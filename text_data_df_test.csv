text_data
"Migration Guides




ESP-IDF 5.x Migration Guide


.. toctree::
    :maxdepth: 1

    release-5.x/5.0/index
    release-5.x/5.1/index
    release-5.x/5.2/index
    release-5.x/5.3/index
"
"Migration from 5.0 to 5.1




.. toctree::
    :maxdepth: 1

    gcc
    :SOC_IEEE802154_SUPPORTED: ieee802154
    peripherals
    storage
    networking
    system
"
"Networking




SNTP


SNTP module now provides thread safe APIs to access lwIP functionality. It is recommended to use :doc:`ESP_NETIF ` API. Please refer to the chapter :ref:`esp_netif-sntp-api` for more details.
"
"GCC
***




GCC Version


The previous GCC version was GCC 11.2.0. This has now been upgraded to GCC 12.2.0 on all targets. Users that need to port their code from GCC 11.2.0 to 12.2.0 should refer to the series of official GCC porting guides listed below:


Warnings


The upgrade to GCC 12.2.0 has resulted in the addition of new warnings, or enhancements to existing warnings. The full details of all GCC warnings can be found in `GCC Warning Options `_. Users are advised to double-check their co"
"de, then fix the warnings if possible. Unfortunately, depending on the warning and the complexity of the user's code, some warnings will be false positives that require non-trivial fixes. In such cases, users can choose to suppress the warning in multiple ways. This section outlines some common warnings that users are likely to encounter and ways to fix them.


``-Wuse-after-free``


Typically, this warning should not produce false-positives for release-level code. But this may appear in test ca"
"ses. There is an example of how it was fixed in ESP-IDF's ``test_realloc.c``.

.. code-block:: c

    void *x = malloc(64);
    void *y = realloc(x, 48);
    TEST_ASSERT_EQUAL_PTR(x, y);

Pointers may be converted to int to avoid warning ``-Wuse-after-free``.

.. code-block:: c

    int x = (int) malloc(64);
    int y = (int) realloc((void *) x, 48);
    TEST_ASSERT_EQUAL_UINT32((uint32_t) x, (uint32_t) y);

``-Waddress``


GCC 12.2.0 introduces an enhanced version of the ``-Waddress`` warning o"
"ption, which is now more eager in detecting the checking of pointers to an array in if-statements.

The following code triggers the warning:

.. code-block:: c

    char array[8];
    ...
    if (array)
        memset(array, 0xff, sizeof(array));


Eliminating unnecessary checks resolves the warning.

.. code-block:: c

    char array[8];
    ...
    memset(array, 0xff, sizeof(array));


RISC-V Builds Outside of ESP-IDF


The RISC-V extensions ``zicsr`` and ``zifencei`` have been separated from "
"the ``I`` extension. GCC 12 reflects this change, and as a result, when building for RISC-V ESP32 chips outside of the ESP-IDF framework, you must include the ``_zicsr_zifencei`` postfix when specifying the -march option in your build system.

Example:

.. code-block:: bash

  riscv32-esp-elf-gcc main.c -march=rv32imac

Now is replaced with:

.. code-block:: bash

  riscv32-esp-elf-gcc main.c -march=rv32imac_zicsr_zifencei
"
"System




FreeRTOS


.. only:: SOC_SPIRAM_SUPPORTED

    Dynamic Memory Allocation
    

     In the past, FreeRTOS commonly utilized the function ``malloc()`` to allocate dynamic memory. As a result, if an application allowed ``malloc()`` to allocate memory from external RAM (by configuring the :ref:`CONFIG_SPIRAM_USE` option as ``CONFIG_SPIRAM_USE_MALLOC``), FreeRTOS had the potential to allocate dynamic memory from external RAM, and the specific location was determined by the heap allocator."
"

    .. note::

        Dynamic memory allocation for tasks (which are likely to consume the most memory) were an exception to the scenario above. FreeRTOS would use a separate memory allocation function to guarantee that dynamic memory allocate for a task was always placed in internal RAM.

    Allowing FreeRTOS objects (such as queues and semaphores) to be placed in external RAM becomes an issue if those objects are accessed while the cache is disabled (such as during SPI flash write operatio"
"ns) and would lead to a cache access errors (see :doc:`Fatal Errors ` for more details).

    Therefore, FreeRTOS has been updated to always use internal memory (i.e., DRAM) for dynamic memory allocation. Calling FreeRTOS creation functions (e.g., :cpp:func:`xTaskCreate`, :cpp:func:`xQueueCreate`) guarantees that the memory allocated for those tasks/objects is from internal memory (see :ref:`freertos-heap` for more details).

    .. warning::

        If you previously relied on :ref:`CONFIG_SPI"
"RAM_USE` to place FreeRTOS objects into external memory, this change will lead to increased usage of internal memory due the FreeRTOS objects now being allocated there.

    To place a FreeRTOS task/object into external memory, it is now necessary to do so explicitly. The following methods can be employed:

    - Allocate the task/object using one of the ``...CreateWithCaps()`` API such as :cpp:func:`xTaskCreateWithCaps` and :cpp:func:`xQueueCreateWithCaps` (see :ref:`freertos-idf-additional-api"
"` for more details).
    - Manually allocate external memory for those objects using :cpp:func:`heap_caps_malloc`, then create the objects from the allocated memory using one of the ``...CreateStatic()`` FreeRTOS functions.

Power Management

"
"Storage




FatFs


``esp_vfs_fat_sdmmc_unmount()`` is now deprecated, and you can use :cpp:func:`esp_vfs_fat_sdcard_unmount()` instead. This API is deprecated in previous ESP-IDF versions, but without a deprecation warning or migration guide. Since ESP-IDF v5.1, calling this ``esp_vfs_fat_sdmmc_unmount()`` API will generate a deprecation warning.


SPI_FLASH


- :cpp:func:`spi_flash_get_counters` is deprecated, please use :cpp:func:`esp_flash_get_counters` instead.
- :cpp:func:`spi_flash_dump_c"
"ounters` is deprecated, please use :cpp:func:`esp_flash_dump_counters` instead.
- :cpp:func:`spi_flash_reset_counters` is deprecated, please use :cpp:func:`esp_flash_reset_counters` instead.
"
"Peripherals




.. only:: SOC_DAC_SUPPORTED

    DAC
    ---

    DAC driver has been redesigned (see :doc:`DAC API Reference `), which aims to unify the interface and extend the usage of DAC peripheral. Although it is recommended to use the new driver APIs, the legacy driver is still available in the previous include path ``driver/dac.h``. However, by default, including ``driver/dac.h`` will bring a build warning like ``The legacy DAC driver is deprecated, please use 'driver/dac_oneshot.h', 'dr"
"iver/dac_cosine.h' or 'driver/dac_continuous.h' instead``. The warning can be suppressed by the Kconfig option :ref:`CONFIG_DAC_SUPPRESS_DEPRECATE_WARN`.

    The major breaking changes in concept and usage are listed as follows:

    Breaking Changes in Concepts
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    - ``dac_channel_t`` which was used to identify the hardware channel are removed from user space. The channel index now starts from ``0``, so please use  `DAC_CHAN_0` and `DAC_CHAN_1` instead. And in"
" the new driver, DAC channels can be selected by using :cpp:type:`dac_channel_mask_t`. And these channels can be allocated in a same channel group which is represented by :cpp:type:`dac_channels_handle_t`.
    - ``dac_cw_scale_t`` is replaced by :cpp:type:`dac_cosine_atten_t` to decouple the legacy driver and the new driver.
    - ``dac_cw_phase_t`` is replaced by :cpp:type:`dac_cosine_phase_t`. The enumerate value is now the phase angle directly.
    - ``dac_cw_config_t`` is replaced by :cpp:ty"
"pe:`dac_cosine_config_t`, but the ``en_ch`` field is removed because it should be specified while allocating the channel group.

    .. only:: esp32s2

        - ``dac_digi_convert_mode_t`` is removed. The driver now can transmit DMA data in different ways by calling :cpp:func:`dac_channels_write_continuously` or :cpp:func:`dac_channels_write_cyclically`.
        - ``dac_digi_config_t`` is replaced by :cpp:type:`dac_continuous_config_t`.

    Breaking Changes in Usage
    ~~~~~~~~~~~~~~~~~~~~~~~"
"~~

    - ``dac_pad_get_io_num`` is removed.
    - ``dac_output_voltage`` is replaced by :cpp:func:`dac_oneshot_output_voltage`.
    - ``dac_output_enable`` is removed. For oneshot mode, it will be enabled after the channel is allocated.
    - ``dac_output_disable`` is removed. For oneshot mode, it will be disabled before the channel is deleted.
    - ``dac_cw_generator_enable`` is replaced by :cpp:func:`dac_cosine_start`.
    - ``dac_cw_generator_disable`` is replaced by :cpp:func:`dac_cosine_s"
"top`.
    - ``dac_cw_generator_config`` is replaced by :cpp:func:`dac_cosine_new_channel`.

    .. only:: esp32

        - ``dac_i2s_enable`` is replaced by :cpp:func:`dac_continuous_enable`, but it needs to allocate the continuous DAC channel first by :cpp:func:`dac_continuous_new_channels`.
        - ``dac_i2s_disable`` is replaced by :cpp:func:`dac_continuous_disable`.

    .. only:: esp32s2

        - ``dac_digi_init`` and ``dac_digi_controller_config`` is merged into :cpp:func:`dac_continuo"
"us_new_channels`.
        - ``dac_digi_deinit`` is replaced by :cpp:func:`dac_continuous_del_channels`.
        - ``dac_digi_start``, ``dac_digi_fifo_reset`` and ``dac_digi_reset`` are merged into :cpp:func:`dac_continuous_enable`.
        - ``dac_digi_stop`` is replaced by :cpp:func:`dac_continuous_disable`.


.. only:: SOC_GPSPI_SUPPORTED

    GPSPI
    

    Following items are deprecated. Since ESP-IDF v5.1, GPSPI clock source is configurable.

    - ``spi_get_actual_clock`` is deprecated, y"
"ou should use :cpp:func:`spi_device_get_actual_freq` instead.

.. only:: SOC_LEDC_SUPPORTED

    LEDC
    

    - :cpp:enumerator:`soc_periph_ledc_clk_src_legacy_t::LEDC_USE_RTC8M_CLK` is deprecated. Please use ``LEDC_USE_RC_FAST_CLK`` instead.
"
"IEEE 802.15.4




Receive Handle Done


.. note::

    It is required since IDF v5.1.3 release.

User must call the function :cpp:func:`esp_ieee802154_receive_handle_done` to notify 802.15.4 driver after the received frame is handled. Otherwise the frame buffer will not be freed for future use.
"
"Migration from 4.4 to 5.0




.. toctree::
    :maxdepth: 1

    :SOC_BT_CLASSIC_SUPPORTED: bluetooth-classic
    :SOC_BLE_SUPPORTED: bluetooth-low-energy
    build-system
    gcc
    networking
    peripherals
    protocols
    provisioning
    removed-components
    storage
    system
    tools
"
"Build System


Migrating from GNU Make Build System


ESP-IDF v5.0 no longer supports GNU make-based projects. Please follow the :ref:`build system ` guide for migration.

Update Fragment File Grammar


The former grammar, supported in ESP-IDF v3.x, was dropped in ESP-IDF v5.0. Here are a few notes on how to migrate properly:


Specify Component Requirements Explicitly


In previous versions of ESP-IDF, some components were always added as public requirements (dependencies) to every component in"
" the build, in addition to the :ref:`common component requirements `:

This means that it was possible to include header files of those components without specifying them as requirements in ``idf_component_register``. This behavior was caused by transitive dependencies of various common components.

In ESP-IDF v5.0, this behavior is fixed and these components are no longer added as public requirements by default.

Every component depending on one of the components which isn't part of common requ"
"irements has to declare this dependency explicitly. This can be done by adding ``REQUIRES `` or ``PRIV_REQUIRES `` in ``idf_component_register`` call inside component's ``CMakeLists.txt``. See :ref:`Component Requirements ` for more information on specifying requirements.

Setting ``COMPONENT_DIRS`` and ``EXTRA_COMPONENT_DIRS`` Variables


.. highlight:: cmake

ESP-IDF v5.0 includes a number of improvements to support building projects with space characters in their paths. To make that possible,"
" there are some changes related to setting ``COMPONENT_DIRS`` and ``EXTRA_COMPONENT_DIRS`` variables in project CMakeLists.txt files.

Adding non-existent directories to ``COMPONENT_DIRS`` or ``EXTRA_COMPONENT_DIRS`` is no longer supported and will result in an error.

Using string concatenation to define ``COMPONENT_DIRS`` or ``EXTRA_COMPONENT_DIRS`` variables is now deprecated. These variables should be defined as CMake lists, instead. For example, use::

    set(EXTRA_COMPONENT_DIRS path1 pat"
"h2)
    list(APPEND EXTRA_COMPONENT_DIRS path3)

instead of::

    set(EXTRA_COMPONENT_DIRS ""path1 path2"")
    set(EXTRA_COMPONENT_DIRS ""${EXTRA_COMPONENT_DIRS} path3"")

Defining these variables as CMake lists is compatible with previous ESP-IDF versions.

Update Usage of ``target_link_libraries`` with ``project_elf``


ESP-IDF v5.0 fixes CMake variable propagation issues for components. This issue caused compiler flags and definitions that were supposed to apply to one component to be applied t"
"o every component in the project.

As a side effect of this, user projects from ESP-IDF v5.0 onwards must use ``target_link_libraries`` with ``project_elf`` explicitly and custom CMake projects must specify ``PRIVATE``, ``PUBLIC``, or ``INTERFACE`` arguments. This is a breaking change and is not backward compatible with previous ESP-IDF versions.

For example::

    target_link_libraries(${project_elf} PRIVATE ""-Wl,--wrap=esp_panic_handler"")

instead of::

    target_link_libraries(${project_elf"
"} ""-Wl,--wrap=esp_panic_handler"")

Update CMake Version


In ESP-IDF v5.0 minimal CMake version was increased to 3.16 and versions lower than 3.16 are not supported anymore.  Run ``tools/idf_tools.py install cmake`` to install a suitable version if your OS version doesn't have one.

This affects ESP-IDF users who use system-provided CMake and custom CMake.

Reorder the Applying of the Target-Specific Config Files


.. highlight:: none

ESP-IDF v5.0 reorders the applying order of target-specific "
"config files and other files listed in SDKCONFIG_DEFAULTS. Now, target-specific files will be applied right after the file brings it in, before all latter files in ``SDKCONFIG_DEFAULTS``.

For example::

    If ``SDKCONFIG_DEFAULTS=""sdkconfig.defaults;sdkconfig_devkit1""``, and there is a file ``sdkconfig.defaults.esp32`` in the same folder, then the files will be applied in the following order: (1) sdkconfig.defaults (2) sdkconfig.defaults.esp32 (3) sdkconfig_devkit1.

If you have a key with dif"
"ferent values in the target-specific files of the former item (e.g., ``sdkconfig.defaults.esp32`` above) and the latter item (e.g., ``sdkconfig_devkit1`` above), please note the latter will override the target-specific file of the former.

If you do want to have some target-specific config values, please put it into the target-specific file of the latter item (e.g., ``sdkconfig_devkit1.esp32``).
"
"Networking




Wi-Fi


Callback Function Type ``esp_now_recv_cb_t``


Previously, the first parameter of ``esp_now_recv_cb_t`` was of type ``const uint8_t *mac_addr``, which only included the address of ESP-NOW peer device.

This now changes. The first parameter is of type ``esp_now_recv_info_t``, which has members ``src_addr``, ``des_addr`` and ``rx_ctrl``. Therefore, the following updates are required:

    - Redefine ESP-NOW receive callback function.

    - ``src_addr`` can be used to replac"
"e original ``mac_addr``.

    - ``des_addr`` is the destination MAC address of ESP-NOW packet, which can be unitcast or broadcast address. With ``des_addr``, the user can distinguish unitcast and broadcast ESP-NOW packets where broadcast ESP-NOW packets can be non-encrypted even when encryption policy is configured for the ESP-NOW.

    - ``rx_ctrl`` is Rx control info of the ESP-NOW packet, which provides more information about the packet.

Please refer to the ESP-NOW example: :example_file:`wi"
"fi/espnow/main/espnow_example_main.c`

Ethernet


``esp_eth_ioctl()`` API


Previously, the :cpp:func:`esp_eth_ioctl` API had the following issues:

    - The third parameter (which is of type ``void *``) would accept an ``int``/``bool`` type arguments (i.e., not pointers) as input in some cases. However, these cases were not documented properly.
    - To pass ``int``/``bool`` type argument as the third parameter, the argument had to be ""unnaturally"" casted to a ``void *`` type, to prevent a com"
"piler warning as demonstrated in the code snippet below. This casting could lead to misuse of the :cpp:func:`esp_eth_ioctl` function.

.. code-block:: c

    esp_eth_ioctl(eth_handle, ETH_CMD_S_FLOW_CTRL, (void *)true);

Therefore, the usage of :cpp:func:`esp_eth_ioctl` is now unified. Arguments to the third parameter must be passed as pointers to a specific data type to/from where data is stored/read by :cpp:func:`esp_eth_ioctl`. The code snippets below demonstrate the usage of :cpp:func:`esp_e"
"th_ioctl`.

Usage example to set Ethernet configuration:

.. code-block:: c

    eth_duplex_t new_duplex_mode = ETH_DUPLEX_HALF;
    esp_eth_ioctl(eth_handle, ETH_CMD_S_DUPLEX_MODE, &new_duplex_mode);

Usage example to get Ethernet configuration:

.. code-block:: c

    eth_duplex_t duplex_mode;
    esp_eth_ioctl(eth_handle, ETH_CMD_G_DUPLEX_MODE, &duplex_mode);

KSZ8041/81 and LAN8720 Driver Update


The KSZ8041/81 and LAN8720 drivers are updated to support more devices (i.e., generations) from"
" their associated product families. The drivers can recognize particular chip numbers and their potential support by the driver.

As a result, the specific ""chip number"" functions calls are replaced by generic ones as follows:


ESP NETIF Glue Event Handlers


``esp_eth_set_default_handlers()`` and ``esp_eth_clear_default_handlers()`` functions are removed. Registration of the default IP layer handlers for Ethernet is now handled automatically. If you have already followed the suggestion to full"
"y initialize the Ethernet driver and network interface before registering their Ethernet/IP event handlers, then no action is required (except for deleting the affected functions). Otherwise, you may start the Ethernet driver right after they register the user event handler.

PHY Address Auto-detect


The Ethernet PHY address auto-detect function ``esp_eth_detect_phy_addr()`` is renamed to :cpp:func:`esp_eth_phy_802_3_detect_phy_addr` and its header declaration is moved to :component_file:`esp_e"
"th/include/esp_eth_phy_802_3.h`.


SPI-Ethernet Module Initialization


The SPI-Ethernet Module initialization is now simplified. Previously, you had to manually allocate an SPI device using :cpp:func:`spi_bus_add_device` before instantiating the SPI-Ethernet MAC.

Now, you no longer need to call :cpp:func:`spi_bus_add_device` as SPI devices are allocated internally. As a result, the :cpp:class:`eth_dm9051_config_t`, :cpp:class:`eth_w5500_config_t`, and :cpp:class:`eth_ksz8851snl_config_t` confi"
"guration structures are updated to include members for SPI device configuration (e.g., to allow fine tuning of SPI timing which may be dependent on PCB design). Likewise, the ``ETH_DM9051_DEFAULT_CONFIG``, ``ETH_W5500_DEFAULT_CONFIG``, and ``ETH_KSZ8851SNL_DEFAULT_CONFIG`` configuration initialization macros are updated to accept new input parameters. Refer to :doc:`Ethernet API Reference Guide ` for an example of SPI-Ethernet Module initialization.

Ethernet Driver


APIs for creating MAC insta"
"nces (`esp_eth_mac_new_*()`) have been reworked to accept two parameters, instead of one common configuration. Now, the configuration includes

This is applicable to internal Ethernet MAC :cpp:func:`esp_eth_mac_new_esp32()` as well as to external MAC devices, such as :cpp:func:`esp_eth_mac_new_ksz8851snl()`, :cpp:func:`esp_eth_mac_new_dm9051()`, and :cpp:func:`esp_eth_mac_new_w5500()`

.. _tcpip-adapter:

TCP/IP Adapter


The TCP/IP Adapter was a network interface abstraction component used in E"
"SP-IDF prior to v4.1. This section outlines migration from ``tcpip_adapter`` API to its successor :doc:`/api-reference/network/esp_netif`.


Updating Network Connection Code



Network Stack Initialization


- You may simply replace ``tcpip_adapter_init()`` with ``esp_netif_init()``. However, please should note that the ``esp_netif_init()`` function now returns standard error codes. See :doc:`/api-reference/network/esp_netif` for more details.
- The ``esp_netif_deinit()`` function is provided to"
" de-initialize the network stack.
- You should also replace ``#include ""tcpip_adapter.h""`` with ``#include ""esp_netif.h""``.


Network Interface Creation


Previously, the TCP/IP Adapter defined the following network interfaces statically:

- WiFi Station
- WiFi Access Point
- Ethernet

This now changes. Network interface instance should be explicitly constructed, so that the :doc:`/api-reference/network/esp_netif` can connect to the TCP/IP stack. For example, after the TCP/IP stack and the event"
" loop are initialized, the initialization code for WiFi must explicitly call ``esp_netif_create_default_wifi_sta();`` or ``esp_netif_create_default_wifi_ap();``.

Please refer to the example initialization code for these three interfaces:

- WiFi Station: :example_file:`wifi/getting_started/station/main/station_example_main.c`
- WiFi Access Point: :example_file:`wifi/getting_started/softAP/main/softap_example_main.c`
- Ethernet: :example_file:`ethernet/basic/main/ethernet_example_main.c`

Other "
"``tcpip_adapter`` API Replacement


All the ``tcpip_adapter`` functions have their ``esp-netif`` counter-part. Please refer to the ``esp_netif.h`` grouped into these sections:

Default Event Handlers


Event handlers are moved from ``tcpip_adapter`` to appropriate driver code. There is no change from application code perspective, as all events should be handled in the same way. Please note that for IP-related event handlers, application code usually receives IP addresses in the form of an ``esp-"
"netif`` specific struct instead of the LwIP structs. However, both structs are binary compatible.


This is the preferred way to print the address:

.. code-block:: c

    ESP_LOGI(TAG, ""got ip:"" IPSTR, IP2STR(&event->ip_info.ip));

Instead of

.. code-block:: c

    ESP_LOGI(TAG, ""got ip:%s"", ip4addr_ntoa(&event->ip_info.ip));

Since ``ip4addr_ntoa()`` is a LwIP API, the esp-netif provides ``esp_ip4addr_ntoa()`` as a replacement. However, the above method using ``IP2STR()`` is generally preferr"
"ed.

IP Addresses


You are advised to use ``esp-netif`` defined IP structures. Please note that with default compatibility enabled, the LwIP structs still work.
"
"GCC
***




GCC Version


The previous GCC version was GCC 8.4.0. This has now been upgraded to GCC 11.2.0 on all targets. Users that need to port their code from GCC 8.4.0 to 11.2.0 should refer to the series of official GCC porting guides listed below:


Warnings


The upgrade to GCC 11.2.0 has resulted in the addition of new warnings, or enhancements to existing warnings. The full details of all GCC warnings can be found in `GCC Warning Options `_. Users are advised to double-check their code"
", then fix the warnings if possible. Unfortunately, depending on the warning and the complexity of the user's code, some warnings will be false positives that require non-trivial fixes. In such cases, users can choose to suppress the warning in multiple ways. This section outlines some common warnings that users are likely to encounter, and ways to suppress them.

.. warning::

    Users are advised to check that a warning is indeed a false positive before attempting to suppress them it.


``-Ws"
"tringop-overflow``, ``-Wstringop-overread``, ``-Wstringop-truncation``, and ``-Warray-bounds``


Users that use memory/string copy/compare functions will run into one of the ``-Wstringop`` warnings if the compiler cannot properly determine the size of the memory/string. The examples below demonstrate code that triggers these warnings and how to suppress them.

.. code-block:: c

    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored ""-Wstringop-overflow""
    #pragma GCC diagnostic ig"
"nored ""-Warray-bounds""
        memset(RTC_SLOW_MEM, 0, CONFIG_ULP_COPROC_RESERVE_MEM); // = 11
    #pragma GCC diagnostic ignored ""-Wstringop-overread"" // ' may result in an unaligned pointer value [-Waddress-of-packed-member]
      105 |     btc_to_bta_uuid(&p_dest->uuid, &p_src->uuid);
          |                     ^~~~~~~~~~~~~


If the warning occurs in multiple places across multiple source files, users can suppress the warning at the CMake level as demonstrated below.

.. code-block:: cm"
"ake

    set_source_files_properties(
        ""host/bluedroid/bta/gatt/bta_gattc_act.c""
        ""host/bluedroid/bta/gatt/bta_gattc_cache.c""
        ""host/bluedroid/btc/profile/std/gatt/btc_gatt_util.c""
        ""host/bluedroid/btc/profile/std/gatt/btc_gatts.c""
        PROPERTIES COMPILE_FLAGS -Wno-address-of-packed-member)

However, if there are only one or two instances, users can suppress the warning directly in the source code itself as demonstrated below.

.. code-block:: c

    #pragma GCC d"
"iagnostic push
    #if     __GNUC__ >= 9
    #pragma GCC diagnostic ignored ""-Waddress-of-packed-member"" ``. When using these fixed-width types (e.g., ``uint32_t``), users will need to replace placeholders such as ``%i`` and ``%x`` with ``PRIi32`` and ``PRIx32`` respectively. Types *not* defined in ```` (e.g., ``int``) do *not* need this special formatting.

In other cases, it should be noted that enums have the ``int`` type.

In common, ``int32_t`` and ``int``, as well as ``uint32_t`` and ``uns"
"igned int``, are different types.

If users do not make the aforementioned updates to format strings in their applications, the following error will be reported during compilation:

.. code-block:: none

    /Users/name/esp/esp-rainmaker/components/esp-insights/components/esp_diagnostics/include/esp_diagnostics.h:238:29: error: format '%u' expects argument of type 'unsigned int', but argument 3 has type 'uint32_t' {aka 'long unsigned int'} [-Werror=format=]
    238 |     esp_diag_log_event(tag, "
"""EV (%u) %s: "" format, esp_log_timestamp(), tag, ##__VA_ARGS__); \
        |                             ^~~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~~~~
        |                                                    |
        |                                                    uint32_t {aka long unsigned int}
                                                  uint32_t {aka long unsigned int}

Removing ``CONFIG_COMPILER_DISABLE_GCC8_WARNINGS`` Build Option


``CONFIG_COMPILER_DISABLE_GCC8_WARNINGS`` opt"
"ion was introduced to allow building of legacy code dating from the rigid GCC 5 toolchain. However, enough time has passed to allow for the warnings to be fixed, thus this option has been removed.

For now in GCC 11, users are advised to review their code and fix the compiler warnings where possible.
"
"Tools




ESP-IDF Monitor


ESP-IDF Monitor makes the following changes regarding baud-rate:

- ESP-IDF monitor now uses the custom console baud-rate (:ref:`CONFIG_ESP_CONSOLE_UART_BAUDRATE`) by default instead of 115200.
- Setting a custom baud from menuconfig is no longer supported.
- A custom baud-rate can be specified from command line with the ``idf.py monitor -b `` command or through setting environment variables.
- Please note that the baud-rate argument has been renamed from ``-B`` to ``"
"-b`` in order to be consistent with the global baud-rate ``idf.py -b ``. Run ``idf.py monitor --help`` for more information.

Deprecated Commands


``idf.py`` sub-commands and ``cmake`` target names have been unified to use hyphens (``-``) instead of underscores (``_``). Using a deprecated sub-command or target name will produce a warning. Users are advised to migrate to using the new sub-commands and target names. The following changes have been made:

.. list-table:: Deprecated Sub-command and"
" Target Names
   :widths: 50 50
   :header-rows: 1
     - New Name
     - efuse-common-table
     - efuse-custom-table
     - erase-flash
     - partition-table
     - partition-table-flash
     - post-debug
     - show-efuse-table
     - erase-otadata
     - read-otadata

Esptool


The ``CONFIG_ESPTOOLPY_FLASHSIZE_DETECT`` option has been renamed to :ref:`CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE` and has been disabled by default. New and existing projects migrated to ESP-IDF v5.0 have to set :r"
"ef:`CONFIG_ESPTOOLPY_FLASHSIZE`. If this is not possible due to an unknown flash size at build time, then :ref:`CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE` can be enabled. However, once enabled, to keep the digest valid, an SHA256 digest is no longer appended to the image when updating the binary header with the flash size during flashing.

Windows Environment


The Msys/Mingw-based Windows environment support got deprecated in ESP-IDF v4.0 and was entirely removed in v5.0. Please use :ref:`get-st"
"arted-windows-tools-installer` to set up a compatible environment. The options include Windows Command Line, Power Shell and the graphical user interface based on Eclipse IDE. In addition, a VS Code-based environment can be set up with the supported plugin: https://github.com/espressif/vscode-esp-idf-extension.
"
"System




Inter-Processor Call


IPC (Inter-Processor Call) feature is no longer a stand-alone component and has been integrated into the ``esp_system`` component.

Thus, any project presenting a ``CMakeLists.txt`` file with the parameters ``PRIV_REQUIRES esp_ipc`` or ``REQUIRES esp_ipc`` should be modified to simply remove these options as the ``esp_system`` component is included by default.

ESP Clock


The ESP Clock API (functions/types/macros prefixed with ``esp_clk``) has been made into a "
"private API. Thus, the previous include paths ``#include ""{IDF_TARGET_NAME}/clk.h""`` and ``#include ""esp_clk.h""`` have been removed. If users still require usage of the ESP Clock API (though this is not recommended), it can be included via  ``#include ""esp_private/esp_clk.h""``.

.. note::

    Private APIs are not stable and no are longer subject to the ESP-IDF versioning scheme's breaking change rules. Thus, it is not recommended for users to continue calling private APIs in their applications."
"

Cache Error Interrupt


The Cache Error Interrupt API (functions/types/macros prefixed with ``esp_cache_err``) has been made into a private API. Thus, the previous include path ``#include ""{IDF_TARGET_NAME}/cache_err_int.h""`` has been removed. If users still require usage of the Cache Error Interrupt API (though this is not recommended), it can be included via  ``#include ""esp_private/cache_err_int.h""``.

``bootloader_support``


Brownout


The Brownout API (functions/types/macros prefixed wit"
"h ``esp_brownout``) has been made into a private API. Thus, the previous include path ``#include ""brownout.h""`` has been removed. If users still require usage of the Brownout API (though this is not recommended), it can be included via  ``#include ""esp_private/brownout.h""``.

Trax


The Trax API (functions/types/macros prefixed with ``trax_``) has been made into a private API. Thus, the previous include path ``#include ""trax.h""`` has been removed. If users still require usage of the Trax API (th"
"ough this is not recommended), it can be included via  ``#include ""esp_private/trax.h""``.

ROM
---

The previously deprecated ROM-related header files located in ``components/esp32/rom/`` (old include path: ``rom/*.h``) have been moved. Please use the new target-specific path from ``components/esp_rom/include/{IDF_TARGET_NAME}/`` (new include path: ``{IDF_TARGET_NAME}/rom/*.h``).

``esp_hw_support``


- The header files ``soc/cpu.h`` have been deleted and deprecated CPU util functions have been "
"removed. ESP-IDF developers should include ``esp_cpu.h`` instead for equivalent functions.
- The header files ``hal/cpu_ll.h``, ``hal/cpu_hal.h``, ``hal/soc_ll.h``, ``hal/soc_hal.h`` and ``interrupt_controller_hal.h`` CPU API functions have been deprecated. ESP-IDF developers should include ``esp_cpu.h`` instead for equivalent functions.
- The header file ``compare_set.h`` have been deleted. ESP-IDF developers should use ``esp_cpu_compare_and_set()`` function provided in ``esp_cpu.h`` instead.
-"
" ``esp_cpu_get_ccount()``, ``esp_cpu_set_ccount()`` and ``esp_cpu_in_ocd_debug_mode()`` were removed from ``esp_cpu.h``. ESP-IDF developers should use respectively ``esp_cpu_get_cycle_count()``, ``esp_cpu_set_cycle_count()`` and ``esp_cpu_dbgr_is_attached()`` instead.
- The header file ``esp_intr.h`` has been deleted. Please include ``esp_intr_alloc.h`` to allocate and manipulate interrupts.
- The Panic API (functions/types/macros prefixed with ``esp_panic``) has been made into a private API. Th"
"us, the previous include path ``#include ""esp_panic.h""`` has been removed. If users still require usage of the Trax API (though this is not recommended), it can be included via  ``#include ""esp_private/panic_reason.h""``. Besides, developers should include ``esp_debug_helpers.h`` instead to use any debug-related helper functions, e.g., print backtrace.
- The header file ``soc_log.h`` is now renamed to ``esp_hw_log.h`` and has been made private. Users are encouraged to use logging APIs provided un"
"der ``esp_log.h`` instead.
- The header files ``spinlock.h``, ``clk_ctrl_os.h``, and ``rtc_wdt.h`` must now be included without the ``soc`` prefix. For example, ``#include ""spinlock.h""``.
- ``esp_chip_info()`` returns the chip version in the format  = 100 * ``major eFuse version`` + ``minor eFuse version``. Thus, the ``revision`` in the ``esp_chip_info_t`` structure is expanded to ``uint16_t`` to fit the new format.

PSRAM


- The target-specific header file ``spiram.h`` and the header file ``es"
"p_spiram.h`` have been removed. A new component ``esp_psram`` is created instead. For PSRAM/SPIRAM-related functions, users now include ``esp_psram.h`` and set the ``esp_psram`` component as a component requirement in their ``CMakeLists.txt`` project files.
- ``esp_spiram_get_chip_size`` and ``esp_spiram_get_size`` have been deleted. You should use ``esp_psram_get_size`` instead.

eFuse


- The parameter type of function ``esp_secure_boot_read_key_digests()`` changed from ``ets_secure_boot_key_d"
"igests_t*`` to ``esp_secure_boot_key_digests_t*``. The new type is the same as the old one, except that the ``allow_key_revoke`` flag has been removed. The latter was always set to ``true`` in current code, not providing additional information.
- Added eFuse wafer revisions: major and minor. The ``esp_efuse_get_chip_ver()`` API is not compatible with these changes, so it was removed. Instead, please use the following APIs: ``efuse_hal_get_major_chip_version()``, ``efuse_hal_get_minor_chip_versio"
"n()`` or ``efuse_hal_chip_revision()``.

``esp_common``


``EXT_RAM_ATTR`` is deprecated. Use the new macro ``EXT_RAM_BSS_ATTR`` to put ``.bss`` on PSRAM.

``esp_system``


- The header files ``esp_random.h``, ``esp_mac.h``, and ``esp_chip_info.h``, which were all previously indirectly included via the header file ``esp_system.h``, must now be included directly. These indirect inclusions from ``esp_system.h`` have been removed.
- The Backtrace Parser API (functions/types/macros prefixed with ``e"
"sp_eh_frame_``) has been made into a private API. Thus, the previous include path ``#include ""eh_frame_parser.h""`` has been removed. If users still require usage of the Backtrace Parser API (though this is not recommended), it can be included via ``#include ""esp_private/eh_frame_parser.h""``.
- The Interrupt Watchdog API (functions/types/macros prefixed with ``esp_int_wdt_``) has been made into a private API. Thus, the previous include path ``#include ""esp_int_wdt.h""`` has been removed. If users "
"still require usage of the Interrupt Watchdog API (though this is not recommended), it can be included via  ``#include ""esp_private/esp_int_wdt.h""``.

SoC Dependency


- Public API headers listed in the Doxyfiles will not expose unstable and unnecessary SoC header files, such as ``soc/soc.h`` and ``soc/rtc.h``. That means the user has to explicitly include them in their code if these ""missing"" header files are still wanted.
- Kconfig option ``LEGACY_INCLUDE_COMMON_HEADERS`` is also removed.
- Th"
"e header file ``soc/soc_memory_types.h`` has been deprecated. Users should use the ``esp_memory_utils.h`` instead. Including ``soc/soc_memory_types.h`` will bring a build warning like ``soc_memory_types.h is deprecated, please migrate to esp_memory_utils.h``

APP Trace


One of the timestamp sources has changed from the legacy timer group driver to the new :doc:`GPTimer `. Kconfig choices like ``APPTRACE_SV_TS_SOURCE_TIMER00`` has been changed to ``APPTRACE_SV_TS_SOURCE_GPTIMER``. User no longer"
" need to choose the group and timer ID.

``esp_timer``


The FRC2-based legacy implementation of ``esp_timer`` available on ESP32 has been removed. The simpler and more efficient implementation based on the LAC timer is now the only option.

ESP Image


The image SPI speed enum definitions have been renamed.

- Enum ``ESP_IMAGE_SPI_SPEED_80M`` has been renamed to ``ESP_IMAGE_SPI_SPEED_DIV_1``.
- Enum ``ESP_IMAGE_SPI_SPEED_40M`` has been renamed to ``ESP_IMAGE_SPI_SPEED_DIV_2``.
- Enum ``ESP_IMAG"
"E_SPI_SPEED_26M`` has been renamed to ``ESP_IMAGE_SPI_SPEED_DIV_3``.
- Enum ``ESP_IMAGE_SPI_SPEED_20M`` has been renamed to ``ESP_IMAGE_SPI_SPEED_DIV_4``.

Task Watchdog Timers


- The API for ``esp_task_wdt_init()`` has changed as follows:

    - Configuration is now passed as a configuration structure.
    - The function will now handle subscribing of the idle tasks if configured to do so.

- The former ``CONFIG_ESP_TASK_WDT`` configuration option has been renamed to :ref:`CONFIG_ESP_TASK_WDT_"
"INIT` and a new :ref:`CONFIG_ESP_TASK_WDT_EN` option has been introduced.

FreeRTOS


Legacy API and Data Types


Previously, the ``configENABLE_BACKWARD_COMPATIBILITY`` option was set by default, thus allowing pre FreeRTOS v8.0.0 function names and data types to be used. The ``configENABLE_BACKWARD_COMPATIBILITY`` is now disabled by default, thus legacy FreeRTOS names/types are no longer supportd by default. Users should do one of the followings:

- Update their code to remove usage of legacy F"
"reeRTOS names/types.
- Enable the :ref:`CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY` to explicitly allow the usage of legacy names/types.

Tasks Snapshot


The header ``task_snapshot.h`` has been removed from ``freertos/task.h``. ESP-IDF developers should include ``freertos/task_snapshot.h`` if they need tasks snapshot API.

The function :cpp:func:`vTaskGetSnapshot` now returns ``BaseType_t``. Return value shall be ``pdTRUE`` on success and ``pdFALSE`` otherwise.

FreeRTOS Asserts


Previously"
", FreeRTOS asserts were configured separately from the rest of the system using the ``FREERTOS_ASSERT`` kconfig option. This option has now been removed and the configuration is now done through ``COMPILER_OPTIMIZATION_ASSERTION_LEVEL``.

Port Macro API


The file ``portmacro_deprecated.h`` which was added to maintain backward compatibility for deprecated APIs is removed. Users are advised to use the alternate functions for the deprecated APIs as listed below:

- ``portENTER_CRITICAL_NESTED()`` "
"is removed. Users should use the ``portSET_INTERRUPT_MASK_FROM_ISR()`` macro instead.
- ``portEXIT_CRITICAL_NESTED()`` is removed. Users should use the ``portCLEAR_INTERRUPT_MASK_FROM_ISR()`` macro instead.
- ``vPortCPUInitializeMutex()`` is removed. Users should use the ``spinlock_initialize()`` function instead.
- ``vPortCPUAcquireMutex()`` is removed. Users should use the ``spinlock_acquire()`` function instead.
- ``vPortCPUAcquireMutexTimeout()`` is removed. Users should use the ``spinlock_a"
"cquire()`` function instead.
- ``vPortCPUReleaseMutex()`` is removed. Users should use the ``spinlock_release()`` function instead.

App Update


- The functions :cpp:func:`esp_ota_get_app_description` and :cpp:func:`esp_ota_get_app_elf_sha256` have been termed as deprecated. Please use the alternative functions :cpp:func:`esp_app_get_description` and :cpp:func:`esp_app_get_elf_sha256` respectively. These functions have now been moved to a new component :component:`esp_app_format`. Please refer "
"to the header file :component_file:`esp_app_desc.h `.

Bootloader Support


- The :cpp:type:`esp_app_desc_t` structure, which used to be declared in :component_file:`esp_app_format.h `, is now declared in :component_file:`esp_app_desc.h `.

- The function :cpp:func:`bootloader_common_get_partition_description` has now been made private. Please use the alternative function :cpp:func:`esp_ota_get_partition_description`. Note that this function takes :cpp:type:`esp_partition_t` as its first argumen"
"t instead of :cpp:type:`esp_partition_pos_t`.

Chip Revision


The bootloader checks the chip revision at the beginning of the application loading. The application can only be loaded if the version is ``>=`` :ref:`CONFIG_{IDF_TARGET_CFG_PREFIX}_REV_MIN` and ``=`` :ref:`CONFIG_{IDF_TARGET_CFG_PREFIX}_REV_MIN` and ``<`` ``CONFIG_{IDF_TARGET_CFG_PREFIX}_REV_MAX_FULL``.
"
"Bluetooth Classic




Bluedroid


    - :component_file:`bt/host/bluedroid/api/include/api/esp_hf_defs.h`

        - In :cpp:enum:`esp_hf_cme_err_t`

            - ``ESP_HF_CME_MEMEORY_FULL`` renamed to ``ESP_HF_CME_MEMORY_FULL``
            - ``ESP_HF_CME_MEMEORY_FAILURE`` renamed to ``ESP_HF_CME_MEMORY_FAILURE``

    - :component_file:`bt/host/bluedroid/api/include/api/esp_hf_ag_api.h`

        - ``esp_bt_hf_init(esp_bd_addr_t remote_addr)`` changes into ``esp_hf_ag_init(void)``

        - ``e"
"sp_bt_hf_deinit(esp_bd_addr_t remote_addr)`` changes into ``esp_hf_ag_deinit(void)``

            Along with this change, the `bt_bdaddr_t init` and  `bt_bdaddr_t deinit` has been removed from `union btc_arg_t`.

        - ``esp_bt_hf_register_callback`` changes into ``esp_hf_ag_register_callback``

        - ``esp_bt_hf_connect`` changes into ``esp_hf_ag_slc_connect``

        - ``esp_bt_hf_disconnect`` changes into ``esp_hf_ag_slc_disconnect``

        - ``esp_bt_hf_connect_audio`` changes int"
"o ``esp_hf_ag_audio_connect``

        - ``esp_bt_hf_disconnect_audio`` changes into ``esp_hf_ag_audio_disconnect``

        - ``esp_bt_hf_vra`` changes into ``esp_hf_ag_vra_control``

        - ``esp_bt_hf_volume_control`` changes into ``esp_hf_ag_volume_control``

        - ``esp_hf_unat_response`` changes into ``esp_hf_ag_unknown_at_send``

        - ``esp_bt_hf_cmee_response`` changes into ``esp_hf_ag_cmee_send``

        - ``esp_bt_hf_indchange_notification`` changes into ``esp_hf_ag_device"
"s_status_indchange``

        - ``esp_bt_hf_cind_response`` changes into ``esp_hf_ag_cind_response``

        - ``esp_bt_hf_cops_response`` changes into ``esp_hf_ag_cops_response``

        - ``esp_bt_hf_clcc_response`` changes into ``esp_hf_ag_clcc_response``

        - ``esp_bt_hf_cnum_response`` changes into ``esp_hf_ag_cnum_response``

        - ``esp_bt_hf_bsir`` changes into ``esp_hf_ag_bsir``

        - ``esp_bt_hf_answer_call`` changes into ``esp_hf_ag_answer_call``

        - ``esp_bt_h"
"f_reject_call`` changes into ``esp_hf_ag_reject_call``

        - ``esp_bt_hf_out_call`` changes into ``esp_hf_ag_out_call``

        - ``esp_bt_hf_end_call`` changes into ``esp_hf_ag_end_call``

        - ``esp_bt_hf_register_data_callback`` changes into ``esp_hf_ag_register_data_callback``

        - ``esp_hf_outgoing_data_ready`` changes into ``esp_hf_ag_outgoing_data_ready``
"
"Removed or Deprecated Components




Components Moved to ESP-IDF Component Registry


Following components are removed from ESP-IDF and moved to `ESP-IDF Component Registry `_:

.. note::

    Please note that http parser functionality which was previously part of ``nghttp`` component is now part of :component:`http_parser ` component.

These components can be installed using ``idf.py add-dependency`` command.

For example, to install libsodium component with the exact version X.Y, run ``idf.py "
"add-dependency libsodium==X.Y``.

To install libsodium component with the latest version compatible to X.Y according to `semver `_ rules, run ``idf.py add-dependency libsodium~X.Y``.

To find out which versions of each component are available, open https://components.espressif.com, search for the component by its name and check the versions listed on the component page.

Deprecated Components


The following components are removed since they were deprecated in ESP-IDF v4.x:

.. note::

    OpenS"
"SL-API component is no longer supported. It is not available in the IDF Component Registry, either. Please use :doc:`ESP-TLS ` or :component:`mbedtls` API directly.

.. note::

    ``esp_adc_cal`` component is no longer supported. New adc calibration driver is in ``esp_adc`` component. Legacy adc calibration driver has been moved into ``esp_adc`` component. To use legacy ``esp_adc_cal`` driver APIs, you should add ``esp_adc`` component to the list of component requirements in CMakeLists.txt. Als"
"o check :doc:`Peripherals Migration Guide ` for more details.

The targets components are no longer necessary after refactoring and have been removed:
"
"Protocols




.. _migration_guide_mbedtls:

Mbed TLS


For ESP-IDF v5.0, `Mbed TLS `_ has been updated from v2.x to v3.1.0.

For more details about Mbed TLS's migration from version 2.x to version 3.0 or greater, please refer to the `official guide `__.

Breaking Changes (Summary)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most Structure Fields Are Now Private


- Direct access to fields of structures (``struct`` types) declared in public headers is no longer supported.
- Appropriate accessor functions (gett"
"er/setter) must be used for the same. A temporary workaround would be to use ``MBEDTLS_PRIVATE`` macro (**not recommended**).
- For more details, refer to the `official guide `__.


SSL
^^^
- Removed support for TLS 1.0, 1.1, and DTLS 1.0
- Removed support for SSL 3.0

Deprecated Functions Were Removed from Cryptography Modules


- The functions ``mbedtls_*_ret()`` (related to MD, SHA, RIPEMD, RNG, HMAC modules) was renamed to replace the corresponding functions without ``_ret`` appended and upd"
"ated return value.
- For more details, refer to the `official guide `__.


Deprecated Config Options


Following are some of the important config options deprecated by this update. The configs related to and/or dependent on these have also been deprecated.

- ``MBEDTLS_SSL_PROTO_SSL3``  : Support for SSL 3.0
- ``MBEDTLS_SSL_PROTO_TLS1``  : Support for TLS 1.0
- ``MBEDTLS_SSL_PROTO_TLS1_1``: Support for TLS 1.1
- ``MBEDTLS_SSL_PROTO_DTLS``  : Support for DTLS 1.1 (Only DTLS 1.2 is supported now)
"
"- ``MBEDTLS_DES_C``           : Support for 3DES ciphersuites
- ``MBEDTLS_RC4_MODE``        : Support for RC4-based ciphersuites

.. note::

  This list includes only major options configurable through ``idf.py menuconfig``. For more details on deprecated options, refer to the `official guide `__.


Miscellaneous


Disabled Diffie-Hellman Key Exchange Modes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Diffie-Hellman Key Exchange modes have now been disabled by default due to security risks (s"
"ee warning text `here `__). Related configs are given below:

- ``MBEDTLS_DHM_C``                 : Support for the Diffie-Hellman-Merkle module
- ``MBEDTLS_KEY_EXCHANGE_DHE_PSK``  : Support for Diffie-Hellman PSK (pre-shared-key) TLS authentication modes
- ``MBEDTLS_KEY_EXCHANGE_DHE_RSA``  : Support for cipher suites with the prefix ``TLS-DHE-RSA-WITH-``

.. note::

  During the initial step of the handshake (i.e., ``client_hello``), the server selects a cipher from the list that the client pub"
"lishes. As the DHE_PSK/DHE_RSA ciphers have now been disabled by the above change, the server would fall back to an alternative cipher; if in a rare case, it does not support any other cipher, the handshake would fail. To retrieve the list of ciphers supported by the server, one must attempt to connect with the server with a specific cipher from the client-side. Few utilities can help do this, e.g., ``sslscan``.

Remove ``certs`` Module from X509 Library
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
"

- The ``mbedtls/certs.h`` header is no longer available in mbedtls 3.1. Most applications can safely remove it from the list of includes.

Breaking Change for ``esp_crt_bundle_set`` API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- The :cpp:func:`esp_crt_bundle_set()` API now requires one additional argument named ``bundle_size``. The return type of the API has also been changed to :cpp:type:`esp_err_t` from ``void``.

Breaking Change for ``esp_ds_rsa_sign`` API
~~~~~~~~~~~~~~~~~~~~~~~~~~~"
"~~~~~~~~~~~~~~~~

- The :cpp:func:`esp_ds_rsa_sign()` API now requires one less argument. The argument ``mode`` is no longer required.

HTTPS Server


Breaking Changes (Summary)
~~~~~~~~~~~~~~~~~~~~~~~~~~

Names of variables holding different certs in :cpp:type:`httpd_ssl_config_t` structure have been updated.

.. list::

The return type of the :cpp:func:`httpd_ssl_stop` API has been changed to :cpp:type:`esp_err_t` from ``void``.

ESP HTTPS OTA


Breaking Changes (Summary)
~~~~~~~~~~~~~~~~~~~~~"
"~~~~~

- The function :cpp:func:`esp_https_ota` now requires pointer to :cpp:type:`esp_https_ota_config_t` as argument instead of pointer to :cpp:type:`esp_http_client_config_t`.


ESP-TLS


Breaking Changes (Summary)
~~~~~~~~~~~~~~~~~~~~~~~~~~

``esp_tls_t`` Structure Is Now Private


The :cpp:type:`esp_tls_t` has now been made completely private. You cannot access its internal structures directly. Any necessary data that needs to be obtained from the ESP-TLS handle can be done through respecti"
"ve getter/setter functions. If there is a requirement of a specific getter/setter function, please raise an `issue `__ on ESP-IDF.


The list of newly added getter/setter function is as as follows:

.. list::

Function Deprecations And Recommended Alternatives


Following table summarizes the deprecated functions removed and their alternatives to be used from ESP-IDF v5.0 onwards.

.. list-table::
   :widths: 50 50
   :header-rows: 1
     - Alternative
     - :cpp:func:`esp_tls_conn_new_sync`
  "
"   - :cpp:func:`esp_tls_conn_destroy`

- The function :cpp:func:`esp_tls_conn_http_new` has now been termed as deprecated. Please use the alternative function :cpp:func:`esp_tls_conn_http_new_sync` (or its asynchronous :cpp:func:`esp_tls_conn_http_new_async`). Note that the alternatives need an additional parameter :cpp:type:`esp_tls_t`, which has to be initialized using the :cpp:func:`esp_tls_init` function.

HTTP Server


Breaking Changes (Summary)
~~~~~~~~~~~~~~~~~~~~~~~~~~

- ``http_server.h"
"`` header is no longer available in ``esp_http_server``. Please use ``esp_http_server.h`` instead.

ESP HTTP Client


Breaking Changes (Summary)
~~~~~~~~~~~~~~~~~~~~~~~~~~

- The functions :cpp:func:`esp_http_client_read` and :cpp:func:`esp_http_client_fetch_headers` now return an additional return value ``-ESP_ERR_HTTP_EAGAIN`` for timeout errors - call timed-out before any data was ready.


TCP Transport


Breaking Changes (Summary)
~~~~~~~~~~~~~~~~~~~~~~~~~~

- The function :cpp:func:`esp_tra"
"nsport_read` now returns ``0`` for a connection timeout and ```__

The ``main`` component folder of the new application shall include the component manager manifest file ``idf_component.yml`` as in the example below:

.. code-block:: text

  dependencies:
    espressif/esp-modbus:
      version: ""^1.0""

The ``esp-modbus`` component can be found in `component manager registry `__. Refer to `component manager documentation `__ for more information on how to set up the component manager.

For appli"
"cations targeting v4.x releases of ESP-IDF that need to use new ``esp-modbus`` component, adding the component manager manifest file ``idf_component.yml`` will be sufficient to pull in the new component. However, users should also exclude the legacy ``freemodbus`` component from the build. This can be achieved using the statement below in the project's ``CMakeLists.txt``:

.. code-block:: cmake

  set(EXCLUDE_COMPONENTS freemodbus)
"
"Storage


New Component for the Partition APIs


Breaking change: all the Partition API code has been moved to a new component :component:`esp_partition`. For the complete list of affected functions and data-types, see header file :component_file:`esp_partition.h `.

These API functions and data-types were previously a part of the :component:`spi_flash` component, and thus possible dependencies on the ``spi_flash`` in existing applications may cause the build failure, in case of direct esp_parti"
"tion_* APIs/data-types use (for instance, ``fatal error: esp_partition.h: No such file or directory`` at lines with ``#include ""esp_partition.h""``). If you encounter such an issue, please update your project's CMakeLists.txt file as follows:

Original dependency setup:

.. code-block:: cmake

   idf_component_register(...
                          REQUIRES spi_flash)

Updated dependency setup:

.. code-block:: cmake

   idf_component_register(...
                          REQUIRES spi_flash esp_"
"partition)

.. note::

   Please update relevant ``REQUIRES`` or ``PRIV_REQUIRES`` section according to your project. The above-presented code snippet is just an example.

If the issue persists, please let us know and we will assist you with your code migration.


SDMMC/SDSPI


SD card frequency on SDMMC/SDSPI interface can be now configured through ``sdmmc_host_t.max_freq_khz`` to a specific value, not only ``SDMMC_FREQ_PROBING`` (400 kHz), ``SDMMC_FREQ_DEFAULT`` (20 MHz), or ``SDMMC_FREQ_HIGHS"
"PEED`` (40 MHz). Previously, in case you have specified a custom frequency other than any of the above-mentioned values, the closest lower-or-equal one was selected anyway.

Now, the underlaying drivers calculate the nearest fitting value, given by available frequency dividers instead of an enumeration item selection. This could cause troubles in communication with your SD card without a change of the existing application code.If you encounter such an issue, please, keep trying different frequen"
"cies around your desired value unless you find the one working well. To check the frequency value calculated and actually applied, use ``void sdmmc_card_print_info(FILE* stream, const sdmmc_card_t* card)`` function.

FatFs


FatFs is now updated to v0.14. As a result, the function signature of ``f_mkfs()`` has changed. The new signature is ``FRESULT f_mkfs (const TCHAR* path, const MKFS_PARM* opt, void* work, UINT len);`` which uses ``MKFS_PARM`` struct as a second argument.

Partition Table


T"
"he partition table generator no longer supports misaligned partitions. When generating a partition table, ``ESP-IDF`` only accepts partitions with offsets that align to 4 KB. This change only affects generating new partition tables. Reading and writing to already existing partitions remains unchanged.


VFS
---

The ``esp_vfs_semihost_register()`` function signature is changed as follows:

- The new signature is ``esp_err_t esp_vfs_semihost_register(const char* base_path);``
- The ``host_path`` "
"parameter of the old signature no longer exists. Instead, the OpenOCD command ``ESP_SEMIHOST_BASEDIR`` should be used to set the full path on the host.

Function Signature Changes


The following functions now return ``esp_err_t`` instead of ``void`` or ``nvs_iterator_t``. Previously, when parameters were invalid or when something goes wrong internally, these functions would ``assert()`` or return a ``nullptr``. With an ``esp_err_t`` returned, you can get better error reporting.

- :cpp:func:`nv"
"s_entry_find`
- :cpp:func:`nvs_entry_next`
- :cpp:func:`nvs_entry_info`

Because the ``esp_err_t`` return type changes, the usage patterns of ``nvs_entry_find()`` and ``nvs_entry_next()`` become different. Both functions now modify iterators via parameters instead of returning an iterator.

The old programming pattern to iterate over an NVS partition was as follows:

.. code-block:: c

    nvs_iterator_t it = nvs_entry_find(, , NVS_TYPE_ANY);
    while (it != NULL) {
            nvs_entry_info_t"
" info;
            nvs_entry_info(it, &info);
            it = nvs_entry_next(it);
            printf(""key '%s', type '%d'"", info.key, info.type);
    };

The new programming pattern to iterate over an NVS partition is now:

.. code-block:: c

    nvs_iterator_t it = nullptr;
    esp_err_t res = nvs_entry_find(, , NVS_TYPE_ANY, &it);
    while(res == ESP_OK) {
        nvs_entry_info_t info;
        nvs_entry_info(it, &info); // Can omit error check if parameters are guaranteed to be non-NULL
   "
"     printf(""key '%s', type '%d'"", info.key, info.type);
        res = nvs_entry_next(&it);
    }
    nvs_release_iterator(it);

Iterator Validity


Note that because the function signature changes, if there is a parameter error, you may get an invalid iterator from ``nvs_entry_find()``. Hence, it is important to initialize the iterator to ``NULL`` before using ``nvs_entry_find()``, so that you can avoid complex error checking before calling ``nvs_release_iterator()``. A good example is the prog"
"ramming pattern above.


Removed SDSPI Deprecated API


Structure ``sdspi_slot_config_t`` and function ``sdspi_host_init_slot()`` are removed, and replaced by structure ``sdspi_device_config_t`` and function ``sdspi_host_init_device()`` respectively.

ROM SPI Flash


In versions before v5.0, ROM SPI flash functions were included via ``esp32**/rom/spi_flash.h``. Thus, code written to support different ESP chips might be filled with ROM headers of different targets. Furthermore, not all of the API"
"s could be used on all ESP chips.

Now, the common APIs are extracted to ``esp_rom_spiflash.h``. Although it is not a breaking change, you are strongly recommended to only use the functions from this header (i.e., prefixed with ``esp_rom_spiflash`` and included by ``esp_rom_spiflash.h``) for better cross-compatibility between ESP chips.

To make ROM SPI flash APIs clearer, the following functions are also renamed:

- ``esp_rom_spiflash_lock()`` to ``esp_rom_spiflash_set_bp()``
- ``esp_rom_spifla"
"sh_unlock()`` to ``esp_rom_spiflash_clear_bp()``

SPI Flash Driver


The ``esp_flash_speed_t`` ``enum`` type is now deprecated. Instead, you may now directly pass the real clock frequency value to the flash configuration structure. The following example demonstrates how to configure a flash frequency of 80MHz:

.. code-block:: c

    esp_flash_spi_device_config_t dev_cfg = {
        // Other members
        .freq_mhz = 80,
        // Other members
    };

Legacy SPI Flash Driver


To make SPI fl"
"ash drivers more stable, the legacy SPI flash driver is removed from v5.0. The legacy SPI flash driver refers to default spi_flash driver since v3.0, and the SPI flash driver with configuration option ``CONFIG_SPI_FLASH_USE_LEGACY_IMPL`` enabled since v4.0. The major breaking change here is that the legacy spi_flash driver is no longer supported from v5.0. Therefore, the legacy driver APIs and the ``CONFIG_SPI_FLASH_USE_LEGACY_IMPL`` configuration option are both removed. Please use the new spi_"
"flash driver's APIs instead.

.. list-table::
    :widths: 50 50
    :header-rows: 1
      - Replacement
      - ``esp_flash_erase_region()``
      - ``esp_flash_erase_region()``
      - ``esp_flash_write()``
      - ``esp_flash_read()``
      - ``esp_flash_write_encrypted()``
      - ``esp_flash_read_encrypted()``

.. note::

    New functions with prefix ``esp_flash`` accept an additional ``esp_flash_t*`` parameter. You can simply set it to NULL. This will make the function to run the main fla"
"sh (``esp_flash_default_chip``).

The ``esp_spi_flash.h`` header is deprecated as system functions are no longer public. To use flash memory mapping APIs, you may include ``spi_flash_mmap.h`` instead.
"
"Peripherals




Peripheral Clock Gating


As usual, peripheral clock gating is still handled by driver itself, users do not need to take care of the peripheral module clock gating.

However, for advanced users who implement their own drivers based on ``hal`` and ``soc`` components, the previous clock gating include path has been changed from ``driver/periph_ctrl.h`` to ``esp_private/periph_ctrl.h``.

RTC Subsystem Control


RTC control APIs have been moved from ``driver/rtc_cntl.h`` to ``esp_pri"
"vate/rtc_ctrl.h``.

ADC
---

ADC Oneshot & Continuous Mode Drivers


The ADC oneshot mode driver has been redesigned.

- The new driver is in ``esp_adc`` component and the include path is ``esp_adc/adc_oneshot.h``.
- The legacy driver is still available in the previous include path ``driver/adc.h``.

The ADC continuous mode driver has been moved from ``driver`` component to ``esp_adc`` component.

- The include path has been changed from ``driver/adc.h`` to ``esp_adc/adc_continuous.h``.

Attempt"
"ing to use the legacy include path ``driver/adc.h`` of either driver triggers the build warning below by default. However, the warning can be suppressed by enabling the :ref:`CONFIG_ADC_SUPPRESS_DEPRECATE_WARN` Kconfig option.

.. code-block:: text

    legacy adc driver is deprecated, please migrate to use esp_adc/adc_oneshot.h and esp_adc/adc_continuous.h for oneshot mode and continuous mode drivers respectively

ADC Calibration Driver


The ADC calibration driver has been redesigned.

- The n"
"ew driver is in ``esp_adc`` component and the include path is ``esp_adc/adc_cali.h`` and ``esp_adc/adc_cali_scheme.h``.

Legacy driver is still available by including ``esp_adc_cal.h``. However, if users still would like to use the include path of the legacy driver, users should add ``esp_adc`` component to the list of component requirements in CMakeLists.txt.

Attempting to use the legacy include path ``esp_adc_cal.h`` triggers the build warning below by default. However, the warning can be sup"
"pressed by enabling the :ref:`CONFIG_ADC_CALI_SUPPRESS_DEPRECATE_WARN` Kconfig option.

.. code-block:: text

    legacy adc calibration driver is deprecated, please migrate to use esp_adc/adc_cali.h and esp_adc/adc_cali_scheme.h

API Changes


- The ADC power management APIs ``adc_power_acquire`` and ``adc_power_release`` have made private and moved to ``esp_private/adc_share_hw_ctrl.h``.

    - The two APIs were previously made public due to a HW errata workaround.
    - Now, ADC power managem"
"ent is completely handled internally by drivers.
    - Users who still require this API can include ``esp_private/adc_share_hw_ctrl.h`` to continue using these functions.

- ``driver/adc2_wifi_private.h`` has been moved to ``esp_private/adc_share_hw_ctrl.h``.
- Enums ``ADC_UNIT_BOTH``, ``ADC_UNIT_ALTER``, and ``ADC_UNIT_MAX`` in ``adc_unit_t`` have been removed.
- The following enumerations have been removed as some of their enumeration values are not supported on all chips. This would lead to t"
"he driver triggering a runtime error if an unsupported value is used.

    - Enum ``ADC_CHANNEL_MAX``
    - Enum ``ADC_ATTEN_MAX``
    - Enum ``ADC_CONV_UNIT_MAX``

- API ``hall_sensor_read`` on ESP32 has been removed. Hall sensor is no longer supported on ESP32.
- API ``adc_set_i2s_data_source`` and ``adc_i2s_mode_init`` have been deprecated. Related enum ``adc_i2s_source_t`` has been deprecated. Please migrate to use ``esp_adc/adc_continuous.h``.
- API ``adc_digi_filter_reset``, ``adc_digi_fil"
"ter_set_config``, ``adc_digi_filter_get_config`` and ``adc_digi_filter_enable`` have been removed. These APIs behaviours are not guaranteed. Enum ``adc_digi_filter_idx_t``, ``adc_digi_filter_mode_t`` and structure ``adc_digi_iir_filter_t`` have been removed as well.
- API ``esp_adc_cal_characterize`` has been deprecated, please migrate to ``adc_cali_create_scheme_curve_fitting`` or ``adc_cali_create_scheme_line_fitting`` instead.
- API ``esp_adc_cal_raw_to_voltage`` has been deprecated, please m"
"igrate to ``adc_cali_raw_to_voltage`` instead.
- API ``esp_adc_cal_get_voltage`` has been deprecated, please migrate to ``adc_oneshot_get_calibrated_result`` instead.

GPIO


- The previous Kconfig option `RTCIO_SUPPORT_RTC_GPIO_DESC` has been removed, thus the ``rtc_gpio_desc`` array is unavailable. Please use ``rtc_io_desc`` array instead.

- The user callback of a GPIO interrupt should no longer read the GPIO interrupt status register to get the GPIO's pin number of triggering the interrupt. "
"You should use the callback argument to determine the GPIO's pin number instead.

    - Previously, when a GPIO interrupt occurs, the GPIO's interrupt status register is cleared after calling the user callbacks. Thus, it was possible for users to read the GPIO's interrupt status register inside the callback to determine which GPIO was used to trigger the interrupt.
    - However, clearing the interrupt status register after calling the user callbacks can potentially cause edge-triggered interrup"
"ts to be lost. For example, if an edge-triggered interrupt is triggered/retriggered while the user callbacks are being called, that interrupt will be cleared without its registered user callback being handled.
    - Now, the GPIO's interrupt status register is cleared **before** invoking the user callbacks. Thus, users can no longer read the GPIO interrupt status register to determine which pin has triggered the interrupt. Instead, users should use the callback argument to pass the pin number.

"
".. only:: SOC_SDM_SUPPORTED

    Sigma-Delta Modulator
    

    The Sigma-Delta Modulator driver has been redesigned into :doc:`SDM `.

    - The new driver implements a factory pattern, where the SDM channels are managed in a pool internally, thus users do not have to fix a SDM channel to a GPIO manually.
    - All SDM channels can be allocated dynamically.

    Although it is recommended to use the new driver APIs, the legacy driver is still available in the previous include path ``driver/sig"
"madelta.h``. However, by default, including ``driver/sigmadelta.h`` triggers the build warning below. The warning can be suppressed by Kconfig option :ref:`CONFIG_SDM_SUPPRESS_DEPRECATE_WARN`.

    .. code-block:: text

        The legacy sigma-delta driver is deprecated, please use driver/sdm.h

    The major breaking changes in concept and usage are listed as follows:

    Breaking Changes in Concepts
    

    - SDM channel representation has changed from ``sigmadelta_channel_t`` to :cpp:type"
":`sdm_channel_handle_t`, which is an opaque pointer.
    - SDM channel configurations are stored in :cpp:type:`sdm_config_t` now, instead the previous ``sigmadelta_config_t``.
    - In the legacy driver, users do not have to set the clock source for SDM channel. But in the new driver, users need to set a proper one in the :cpp:member:`sdm_config_t::clk_src`. The available clock sources are listed in the :cpp:type:`soc_periph_sdm_clk_src_t`.
    - In the legacy driver, users need to set a ``presc"
"ale`` for the channel, which reflects the frequency in which the modulator outputs a pulse. In the new driver, users should use :cpp:member:`sdm_config_t::sample_rate_hz` to set the over sample rate.
    - In the legacy driver, users set ``duty`` to decide the output analog value, it is now renamed to a more appropriate name ``density``.

    Breaking Changes in Usage
    

    - Channel configuration was done by channel allocation, in :cpp:func:`sdm_new_channel`. In the new driver, only the ``d"
"ensity`` can be changed at runtime, by :cpp:func:`sdm_channel_set_pulse_density`. Other parameters like ``gpio number`` and ``prescale`` are only allowed to set during channel allocation.
    - Before further channel operations, users should **enable** the channel in advance, by calling :cpp:func:`sdm_channel_enable`. This function helps to manage some system level services, like **Power Management**.

Timer Group Driver


Timer Group driver has been redesigned into :doc:`GPTimer `, which aims t"
"o unify and simplify the usage of general purpose timer.

Although it is recommended to use the new driver APIs, the legacy driver is still available in the previous include path ``driver/timer.h``. However, by default, including ``driver/timer.h`` triggers the build warning below. The warning can be suppressed by the Kconfig option :ref:`CONFIG_GPTIMER_SUPPRESS_DEPRECATE_WARN`.

.. code-block:: text

    legacy timer group driver is deprecated, please migrate to driver/gptimer.h

The major brea"
"king changes in concept and usage are listed as follows:

Breaking Changes in Concepts


-  ``timer_group_t`` and ``timer_idx_t`` which used to identify the hardware timer are removed from user's code. In the new driver, a timer is represented by :cpp:type:`gptimer_handle_t`.
-  Definition of timer clock source is moved to :cpp:type:`gptimer_clock_source_t`, the previous ``timer_src_clk_t`` is not used.
-  Definition of timer count direction is moved to :cpp:type:`gptimer_count_direction_t`, the"
" previous ``timer_count_dir_t`` is not used.
-  Only level interrupt is supported, ``timer_intr_t`` and ``timer_intr_mode_t`` are not used.
-  Auto-reload is enabled by set the :cpp:member:`gptimer_alarm_config_t::auto_reload_on_alarm` flag. ``timer_autoreload_t`` is not used.

Breaking Changes in Usage


-  Timer initialization is done by creating a timer instance from :cpp:func:`gptimer_new_timer`. Basic configurations like clock source, resolution and direction should be set in :cpp:type:`gpt"
"imer_config_t`. Note that, specific configurations of alarm events are not needed during the installation stage of the driver.
-  Alarm event is configured by :cpp:func:`gptimer_set_alarm_action`, with parameters set in the :cpp:type:`gptimer_alarm_config_t`.
-  Setting and getting count value are done by :cpp:func:`gptimer_get_raw_count` and :cpp:func:`gptimer_set_raw_count`. The driver does not help convert the raw value into UTC time-stamp. Instead, the conversion should be done from user's s"
"ide as the timer resolution is also known to the user.
-  The driver will install the interrupt service as well if :cpp:member:`gptimer_event_callbacks_t::on_alarm` is set to a valid callback function. In the callback, users do not have to deal with the low level registers (like ""clear interrupt status"", ""re-enable alarm event"" and so on). So functions like ``timer_group_get_intr_status_in_isr`` and ``timer_group_get_auto_reload_in_isr`` are not used anymore.
-  To update the alarm configuration"
"s when alarm event happens, one can call :cpp:func:`gptimer_set_alarm_action` in the interrupt callback, then the alarm will be re-enabled again.
-  Alarm will always be re-enabled by the driver if :cpp:member:`gptimer_alarm_config_t::auto_reload_on_alarm` is set to true.

UART


.. list-table::
    :width: 700 px
    :header-rows: 1
      - Replacement
      - Remarks
      - None
      - UART interrupt handling is implemented by driver itself.
      - None
      - UART interrupt handling is im"
"plemented by driver itself.
      - :cpp:member:`uart_config_t::source_clk`
      - Select the clock source.
      - :cpp:func:`uart_enable_pattern_det_baud_intr`
      - Enable pattern detection interrupt.

I2C
---

.. list-table::
    :width: 700 px
    :header-rows: 1
      - Replacement
      - Remarks
      - None
      - I2C interrupt handling is implemented by driver itself.
      - None
      - I2C interrupt handling is implemented by driver itself.
      - None
      - It is not used an"
"ywhere in ESP-IDF.

SPI
---

.. list-table::
    :width: 700 px
    :header-rows: 1
      - Replacement
      - Remarks
      - :cpp:func:`spi_get_actual_clock`
      - Get SPI real working frequency.

- The internal header file ``spi_common_internal.h`` has been moved to ``esp_private/spi_common_internal.h``.

.. only:: SOC_SDMMC_HOST_SUPPORTED

    SDMMC
    

    .. list-table::
        :width: 700 px
        :header-rows: 1
          - Replacement
          - Remarks
          - set ``SDMMC_"
"SLOT_FLAG_INTERNAL_PULLUP`` flag in :cpp:member:`sdmmc_slot_config_t::flags`
          - Enable internal pull up.

LEDC


.. list-table::
    :width: 700 px
    :header-rows: 1
      - Replacement
      - Remarks
      - :cpp:member:`ledc_timer_config_t::duty_resolution`
      - Set resolution of the duty cycle.

.. only:: SOC_PCNT_SUPPORTED

    Pulse Counter Driver
    

    Pulse counter driver has been redesigned (see :doc:`PCNT `), which aims to unify and simplify the usage of PCNT peripher"
"al.

    Although it is recommended to use the new driver APIs, the legacy driver is still available in the previous include path ``driver/pcnt.h``. However, including ``driver/pcnt.h`` triggers the build warning below by default. The warning can be suppressed by the Kconfig option :ref:`CONFIG_PCNT_SUPPRESS_DEPRECATE_WARN`.

    .. code-block:: text

        legacy pcnt driver is deprecated, please migrate to use driver/pulse_cnt.h

    The major breaking changes in concept and usage are listed"
" as follows:

    Breaking Changes in Concepts
    

    - ``pcnt_port_t``, ``pcnt_unit_t`` and ``pcnt_channel_t`` which used to identify the hardware unit and channel are removed from user's code. In the new driver, PCNT unit is represented by :cpp:type:`pcnt_unit_handle_t`, likewise, PCNT channel is represented by :cpp:type:`pcnt_channel_handle_t`. Both of them are opaque pointers.
    - ``pcnt_evt_type_t`` is not used any more, they have been replaced by a universal **Watch Point Event**. In "
"the event callback :cpp:type:`pcnt_watch_cb_t`, it is still possible to distinguish different watch points from :cpp:type:`pcnt_watch_event_data_t`.
    - ``pcnt_count_mode_t`` is replaced by :cpp:type:`pcnt_channel_edge_action_t`, and ``pcnt_ctrl_mode_t`` is replaced by :cpp:type:`pcnt_channel_level_action_t`.

    Breaking Changes in Usage
    

    - Previously, the PCNT unit configuration and channel configuration were combined into a single function: ``pcnt_unit_config``. They are now split"
" into the two factory APIs: :cpp:func:`pcnt_new_unit` and :cpp:func:`pcnt_new_channel` respectively.

        - Only the count range is necessary for initializing a PCNT unit. GPIO number assignment has been moved to :cpp:func:`pcnt_new_channel`.
        - High/Low control mode and positive/negative edge count mode are set by stand-alone functions: :cpp:func:`pcnt_channel_set_edge_action` and :cpp:func:`pcnt_channel_set_level_action`.

    - ``pcnt_get_counter_value`` is replaced by :cpp:func:`p"
"cnt_unit_get_count`.
    - ``pcnt_counter_pause`` is replaced by :cpp:func:`pcnt_unit_stop`.
    - ``pcnt_counter_resume`` is replaced by :cpp:func:`pcnt_unit_start`.
    - ``pcnt_counter_clear`` is replaced by :cpp:func:`pcnt_unit_clear_count`.
    - ``pcnt_intr_enable`` and ``pcnt_intr_disable`` are removed. In the new driver, the interrupt is enabled by registering event callbacks :cpp:func:`pcnt_unit_register_event_callbacks`.
    - ``pcnt_event_enable`` and ``pcnt_event_disable`` are remove"
"d. In the new driver, the PCNT events are enabled/disabled by adding/removing watch points :cpp:func:`pcnt_unit_add_watch_point`, :cpp:func:`pcnt_unit_remove_watch_point`.
    - ``pcnt_set_event_value`` is removed. In the new driver, event value is also set when adding watch point by :cpp:func:`pcnt_unit_add_watch_point`.
    - ``pcnt_get_event_value`` and ``pcnt_get_event_status`` are removed. In the new driver, these information are provided by event callback :cpp:type:`pcnt_watch_cb_t` in the"
" :cpp:type:`pcnt_watch_event_data_t`.
    - ``pcnt_isr_register`` and ``pcnt_isr_unregister`` are removed. Register of the ISR handler from user's code is no longer permitted. Users should register event callbacks instead by calling :cpp:func:`pcnt_unit_register_event_callbacks`.
    - ``pcnt_set_pin`` is removed and the new driver no longer allows the switching of the GPIO at runtime. If users want to change to other GPIOs, please delete the existing PCNT channel by :cpp:func:`pcnt_del_channel`"
" and reinstall with the new GPIO number by :cpp:func:`pcnt_new_channel`.
    - ``pcnt_filter_enable``, ``pcnt_filter_disable`` and ``pcnt_set_filter_value`` are replaced by :cpp:func:`pcnt_unit_set_glitch_filter`. Meanwhile, ``pcnt_get_filter_value`` has been removed.
    - ``pcnt_set_mode`` is replaced by :cpp:func:`pcnt_channel_set_edge_action` and :cpp:func:`pcnt_channel_set_level_action`.
    - ``pcnt_isr_service_install``, ``pcnt_isr_service_uninstall``, ``pcnt_isr_handler_add`` and ``pcnt_"
"isr_handler_remove`` are replaced by :cpp:func:`pcnt_unit_register_event_callbacks`. The default ISR handler is lazy installed in the new driver.

.. only:: SOC_TEMP_SENSOR_SUPPORTED

    Temperature Sensor Driver
    

    The temperature sensor driver has been redesigned and it is recommended to use the new driver. However, the old driver is still available but cannot be used with the new driver simultaneously.

    The new driver can be included via ``driver/temperature_sensor.h``. The old dr"
"iver is still available in the previous include path ``driver/temp_sensor.h``. However, including ``driver/temp_sensor.h`` triggers the build warning below by default. The warning can be suppressed by enabling the menuconfig option :ref:`CONFIG_TEMP_SENSOR_SUPPRESS_DEPRECATE_WARN`.

    .. code-block:: text

        legacy temperature sensor driver is deprecated, please migrate to driver/temperature_sensor.h

    Configuration contents has been changed. In the old version, users need to configur"
"e ``clk_div`` and ``dac_offset``. While in the new version, users only need to choose ``tsens_range``.

    The process of using temperature sensor has been changed. In the old version, users can use ``config->start->read_celsius`` to get value. In the new version, users should install the temperature sensor driver firstly, by ``temperature_sensor_install`` and uninstall it when finished. For more information, please refer to :doc:`Temperature Sensor ` .

.. only:: SOC_RMT_SUPPORTED

    RMT Dri"
"ver
    

    RMT driver has been redesigned (see :doc:`RMT transceiver `), which aims to unify and extend the usage of RMT peripheral.

    Although it is recommended to use the new driver APIs, the legacy driver is still available in the previous include path ``driver/rmt.h``. However, including ``driver/rmt.h`` triggers the build warning below by default. The warning can be suppressed by the Kconfig option :ref:`CONFIG_RMT_SUPPRESS_DEPRECATE_WARN`.

    .. code-block:: text

        The legac"
"y RMT driver is deprecated, please use driver/rmt_tx.h and/or driver/rmt_rx.h

    The major breaking changes in concept and usage are listed as follows:

    Breaking Changes in Concepts
    

    - ``rmt_channel_t`` which used to identify the hardware channel are removed from user space. In the new driver, RMT channel is represented by :cpp:type:`rmt_channel_handle_t`. The channel is dynamically allocated by the driver, instead of designated by user.
    - ``rmt_item32_t`` is replaced by :cpp:"
"type:`rmt_symbol_word_t`, which avoids a nested union inside a struct.
    - ``rmt_mem_t`` is removed, as we do not allow users to access RMT memory block (a.k.an RMTMEM) directly. Direct access to RMTMEM does not make sense but make mistakes, especially when the RMT channel also connected with a DMA channel.
    - ``rmt_mem_owner_t`` is removed, as the ownership is controlled by driver, not by user anymore.
    - ``rmt_source_clk_t`` is replaced by :cpp:type:`rmt_clock_source_t`, and note they "
"are not binary compatible.
    - ``rmt_data_mode_t`` is removed, the RMT memory access mode is configured to always use Non-FIFO and DMA mode.
    - ``rmt_mode_t`` is removed, as the driver has stand alone install functions for TX and RX channels.
    - ``rmt_idle_level_t`` is removed, setting IDLE level for TX channel is available in :cpp:member:`rmt_transmit_config_t::eot_level`.
    - ``rmt_carrier_level_t`` is removed, setting carrier polarity is available in :cpp:member:`rmt_carrier_config_"
"t::polarity_active_low`.
    - ``rmt_channel_status_t`` and ``rmt_channel_status_result_t`` are removed, they are not used anywhere.
    - Transmitting by RMT channel does not expect user to prepare the RMT symbols, instead, user needs to provide an RMT Encoder to tell the driver how to convert user data into RMT symbols.

    Breaking Changes in Usage
    

    - Channel installation has been separated for TX and RX channels into :cpp:func:`rmt_new_tx_channel` and :cpp:func:`rmt_new_rx_channel`"
".
    - ``rmt_set_clk_div`` and ``rmt_get_clk_div`` are removed. Channel clock configuration can only be done during channel installation.
    - ``rmt_set_rx_idle_thresh`` and ``rmt_get_rx_idle_thresh`` are removed. In the new driver, the RX channel IDLE threshold is redesigned into a new concept :cpp:member:`rmt_receive_config_t::signal_range_max_ns`.
    - ``rmt_set_mem_block_num`` and ``rmt_get_mem_block_num`` are removed. In the new driver, the memory block number is determined by :cpp:membe"
"r:`rmt_tx_channel_config_t::mem_block_symbols` and :cpp:member:`rmt_rx_channel_config_t::mem_block_symbols`.
    - ``rmt_set_tx_carrier`` is removed, the new driver uses :cpp:func:`rmt_apply_carrier` to set carrier behavior.
    - ``rmt_set_mem_pd`` and ``rmt_get_mem_pd`` are removed. The memory power is managed by the driver automatically.
    - ``rmt_memory_rw_rst``, ``rmt_tx_memory_reset`` and ``rmt_rx_memory_reset`` are removed. Memory reset is managed by the driver automatically.
    - ``rm"
"t_tx_start`` and ``rmt_rx_start`` are merged into a single function :cpp:func:`rmt_enable`, for both TX and RX channels.
    - ``rmt_tx_stop`` and ``rmt_rx_stop`` are merged into a single function :cpp:func:`rmt_disable`, for both TX and RX channels.
    - ``rmt_set_memory_owner`` and ``rmt_get_memory_owner`` are removed. RMT memory owner guard is added automatically by the driver.
    - ``rmt_set_tx_loop_mode`` and ``rmt_get_tx_loop_mode`` are removed. In the new driver, the loop mode is config"
"ured in :cpp:member:`rmt_transmit_config_t::loop_count`.
    - ``rmt_set_source_clk`` and ``rmt_get_source_clk`` are removed. Configuring clock source is only possible during channel installation by :cpp:member:`rmt_tx_channel_config_t::clk_src` and :cpp:member:`rmt_rx_channel_config_t::clk_src`.
    - ``rmt_set_rx_filter`` is removed. In the new driver, the filter threshold is redesigned into a new concept :cpp:member:`rmt_receive_config_t::signal_range_min_ns`.
    - ``rmt_set_idle_level`` and"
" ``rmt_get_idle_level`` are removed. Setting IDLE level for TX channel is available in :cpp:member:`rmt_transmit_config_t::eot_level`.
    - ``rmt_set_rx_intr_en``, ``rmt_set_err_intr_en``, ``rmt_set_tx_intr_en``, ``rmt_set_tx_thr_intr_en`` and ``rmt_set_rx_thr_intr_en`` are removed. The new driver does not allow user to turn on/off interrupt from user space. Instead, it provides callback functions.
    - ``rmt_set_gpio`` and ``rmt_set_pin`` are removed. The new driver does not support to switch"
" GPIO dynamically at runtime.
    - ``rmt_config`` is removed. In the new driver, basic configuration is done during the channel installation stage.
    - ``rmt_isr_register`` and ``rmt_isr_deregister`` are removed, the interrupt is allocated by the driver itself.
    - ``rmt_driver_install`` is replaced by :cpp:func:`rmt_new_tx_channel` and :cpp:func:`rmt_new_rx_channel`.
    - ``rmt_driver_uninstall`` is replaced by :cpp:func:`rmt_del_channel`.
    - ``rmt_fill_tx_items``, ``rmt_write_items`` "
"and ``rmt_write_sample`` are removed. In the new driver, user needs to provide an encoder to ""translate"" the user data into RMT symbols.
    - ``rmt_get_counter_clock`` is removed, as the channel clock resolution is configured by user from :cpp:member:`rmt_tx_channel_config_t::resolution_hz`.
    - ``rmt_wait_tx_done`` is replaced by :cpp:func:`rmt_tx_wait_all_done`.
    - ``rmt_translator_init``, ``rmt_translator_set_context`` and ``rmt_translator_get_context`` are removed. In the new driver, t"
"he translator has been replaced by the RMT encoder.
    - ``rmt_get_ringbuf_handle`` is removed. The new driver does not use Ringbuffer to save RMT symbols. Instead, the incoming data are saved to the user provided buffer directly. The user buffer can even be mounted to DMA link internally.
    - ``rmt_register_tx_end_callback`` is replaced by :cpp:func:`rmt_tx_register_event_callbacks`, where user can register :cpp:member:`rmt_tx_event_callbacks_t::on_trans_done` event callback.
    - ``rmt_set"
"_intr_enable_mask`` and ``rmt_clr_intr_enable_mask`` are removed, as the interrupt is handled by the driver, user does not need to take care of it.
    - ``rmt_add_channel_to_group`` and ``rmt_remove_channel_from_group`` are replaced by RMT sync manager. Please refer to :cpp:func:`rmt_new_sync_manager`.
    - ``rmt_set_tx_loop_count`` is removed. The loop count in the new driver is configured in :cpp:member:`rmt_transmit_config_t::loop_count`.
    - ``rmt_enable_tx_loop_autostop`` is removed. In"
" the new driver, TX loop auto stop is always enabled if available, it is not configurable anymore.

LCD
---

- The LCD panel initialization flow is slightly changed. Now the :cpp:func:`esp_lcd_panel_init` will not turn on the display automatically. User needs to call :cpp:func:`esp_lcd_panel_disp_on_off` to manually turn on the display. Note, this is different from turning on backlight. With this breaking change, user can flash a predefined pattern to the screen before turning on the screen. Thi"
"s can help avoid random noise on the screen after a power on reset.
- :cpp:func:`esp_lcd_panel_disp_off` is deprecated, please use :cpp:func:`esp_lcd_panel_disp_on_off` instead.
- ``dc_as_cmd_phase`` is removed. The SPI LCD driver currently does not support a 9-bit SPI LCD. Please always use a dedicated GPIO to control the LCD D/C line.
- The way to register RGB panel event callbacks has been moved from the :cpp:type:`esp_lcd_rgb_panel_config_t` into a separate API :cpp:func:`esp_lcd_rgb_panel_r"
"egister_event_callbacks`. However, the event callback signature is not changed.
- Previous ``relax_on_idle`` flag in :cpp:type:`esp_lcd_rgb_panel_config_t` has been renamed into :cpp:member:`esp_lcd_rgb_panel_config_t::refresh_on_demand`, which expresses the same meaning but with a clear name.
- If the RGB LCD is created with the ``refresh_on_demand`` flag enabled, the driver will not start a refresh in the :cpp:func:`esp_lcd_panel_draw_bitmap`. Now users have to call :cpp:func:`esp_lcd_rgb_pane"
"l_refresh` to refresh the screen by themselves.
- :cpp:type:`esp_lcd_color_space_t` is deprecated, please use :cpp:type:`lcd_color_space_t` to describe the color space, and use :cpp:type:`lcd_rgb_element_order_t` to describe the data order of RGB color.

.. only:: SOC_MCPWM_SUPPORTED

    MCPWM
    

    MCPWM driver was redesigned (see :doc:`MCPWM `), meanwhile, the legacy driver is deprecated.

    The new driver's aim is to make each MCPWM submodule independent to each other, and give the fre"
"edom of resource connection back to users.

    Although it is recommended to use the new driver APIs, the legacy driver is still available in the previous include path ``driver/mcpwm.h``. However, using legacy driver triggers the build warning below by default. This warning can be suppressed by the Kconfig option :ref:`CONFIG_MCPWM_SUPPRESS_DEPRECATE_WARN`.

    .. code-block:: text

        legacy MCPWM driver is deprecated, please migrate to the new driver (include driver/mcpwm_prelude.h)

  "
"  The major breaking changes in concept and usage are listed as follows:

    Breaking Changes in Concepts
    

    The new MCPWM driver is object-oriented, where most of the MCPWM submodule has a driver object associated with it. The driver object is created by factory function like :cpp:func:`mcpwm_new_timer`. IO control function always needs an object handle, in the first place.

    The legacy driver has an inappropriate assumption, that is the MCPWM operator should be connected to differen"
"t MCPWM timer. In fact, the hardware does not have such limitation. In the new driver, a MCPWM timer can be connected to multiple operators, so that the operators can achieve the best synchronization performance.

    The legacy driver presets the way to generate a PWM waveform into a so called ``mcpwm_duty_type_t``. However, the duty cycle modes listed there are far from sufficient. Likewise, legacy driver has several preset ``mcpwm_deadtime_type_t``, which also does not cover all the use cases"
". What is more, user usually gets confused by the name of the duty cycle mode and dead-time mode. In the new driver, there are no such limitation, but user has to construct the generator behavior from scratch.

    In the legacy driver, the ways to synchronize the MCPWM timer by GPIO, software and other timer module are not unified. It increased learning costs for users. In the new driver, the synchronization APIs are unified.

    The legacy driver has mixed the concepts of ""Fault detector"" and"
" ""Fault handler"". Which make the APIs very confusing to users. In the new driver, the fault object just represents a failure source, and we introduced a new concept -- **brake** to express the concept of ""Fault handler"". What is more, the new driver supports software fault.

    The legacy drive only provides callback functions for the capture submodule. The new driver provides more useful callbacks for various MCPWM submodules, like timer stop, compare match, fault enter, brake, etc.

    - ``m"
"cpwm_io_signals_t`` and ``mcpwm_pin_config_t`` are not used. GPIO configuration has been moved into submodule's configuration structure.
    - ``mcpwm_timer_t``, ``mcpwm_generator_t`` are not used. Timer and generator are represented by :cpp:type:`mcpwm_timer_handle_t` and :cpp:type:`mcpwm_gen_handle_t`.
    - ``mcpwm_fault_signal_t`` and ``mcpwm_sync_signal_t`` are not used. Fault and sync source are represented by :cpp:type:`mcpwm_fault_handle_t` and :cpp:type:`mcpwm_sync_handle_t`.
    - ``mc"
"pwm_capture_signal_t`` is not used. A capture channel is represented by :cpp:type:`mcpwm_cap_channel_handle_t`.

    Breaking Changes in Usage
    

    - ``mcpwm_gpio_init`` and ``mcpwm_set_pin``: GPIO configurations are moved to submodule's own configuration. e.g., set the PWM GPIO in :cpp:member:`mcpwm_generator_config_t::gen_gpio_num`.
    - ``mcpwm_init``: To get an expected PWM waveform, users need to allocated at least one MCPWM timer and MCPWM operator, then connect them by calling :cpp:"
"func:`mcpwm_operator_connect_timer`. After that, users should set the generator's actions on various events by calling e.g., :cpp:func:`mcpwm_generator_set_actions_on_timer_event`, :cpp:func:`mcpwm_generator_set_actions_on_compare_event`.
    - ``mcpwm_group_set_resolution``: in the new driver, the group resolution is fixed to the maximum, usually it is 80 MHz.
    - ``mcpwm_timer_set_resolution``: MCPWM Timer resolution is set in :cpp:member:`mcpwm_timer_config_t::resolution_hz`.
    - ``mcpwm_"
"set_frequency``: PWM frequency is determined by :cpp:member:`mcpwm_timer_config_t::resolution_hz`, :cpp:member:`mcpwm_timer_config_t::count_mode` and :cpp:member:`mcpwm_timer_config_t::period_ticks`.
    - ``mcpwm_set_duty``: To set the PWM duty cycle, users should call :cpp:func:`mcpwm_comparator_set_compare_value` to change comparator's threshold.
    - ``mcpwm_set_duty_type``: There is no preset duty cycle types. The duty cycle type is configured by setting different generator actions. e.g., "
":cpp:func:`mcpwm_generator_set_actions_on_timer_event`.
    - ``mcpwm_set_signal_high`` and ``mcpwm_set_signal_low`` are replaced by :cpp:func:`mcpwm_generator_set_force_level`. In the new driver, it is implemented by setting force action for the generator, instead of changing the duty cycle to 0% or 100% at the background.
    - ``mcpwm_start`` and ``mcpwm_stop`` are replaced by :cpp:func:`mcpwm_timer_start_stop`. You have more modes to start and stop the MCPWM timer, see :cpp:type:`mcpwm_timer"
"_start_stop_cmd_t`.
    - ``mcpwm_carrier_init`` is replaced by :cpp:func:`mcpwm_operator_apply_carrier`.
    - ``mcpwm_carrier_enable`` and ``mcpwm_carrier_disable``: Enabling and disabling carrier submodule is done automatically by checking whether the carrier configuration structure :cpp:type:`mcpwm_carrier_config_t` is NULL.
    - ``mcpwm_carrier_set_period`` is replaced by :cpp:member:`mcpwm_carrier_config_t::frequency_hz`.
    - ``mcpwm_carrier_set_duty_cycle`` is replaced by :cpp:member:`"
"mcpwm_carrier_config_t::duty_cycle`.
    - ``mcpwm_carrier_oneshot_mode_enable`` is replaced by :cpp:member:`mcpwm_carrier_config_t::first_pulse_duration_us`.
    - ``mcpwm_carrier_oneshot_mode_disable`` is removed. Disabling the first pulse (a.k.a the one-shot pulse) in the carrier is never supported by the hardware.
    - ``mcpwm_carrier_output_invert`` is replaced by :cpp:member:`mcpwm_carrier_config_t::invert_before_modulate` and :cpp:member:`mcpwm_carrier_config_t::invert_after_modulate`.
 "
"   - ``mcpwm_deadtime_enable`` and ``mcpwm_deadtime_disable`` are replaced by :cpp:func:`mcpwm_generator_set_dead_time`.
    - ``mcpwm_fault_init`` is replaced by :cpp:func:`mcpwm_new_gpio_fault`.
    - ``mcpwm_fault_set_oneshot_mode``, ``mcpwm_fault_set_cyc_mode`` are replaced by :cpp:func:`mcpwm_operator_set_brake_on_fault` and :cpp:func:`mcpwm_generator_set_actions_on_brake_event`.
    - ``mcpwm_capture_enable`` is removed. It is duplicated to :cpp:func:`mcpwm_capture_enable_channel`.
    - `"
"`mcpwm_capture_disable`` is removed. It is duplicated to :cpp:func:`mcpwm_capture_capture_disable_channel`.
    - ``mcpwm_capture_enable_channel`` and ``mcpwm_capture_disable_channel`` are replaced by :cpp:func:`mcpwm_capture_channel_enable` and :cpp:func:`mcpwm_capture_channel_disable`.
    - ``mcpwm_capture_signal_get_value`` and ``mcpwm_capture_signal_get_edge``: Capture timer count value and capture edge are provided in the capture event callback, via :cpp:type:`mcpwm_capture_event_data_t`. "
"Capture data are only valuable when capture event happens. Providing single API to fetch capture data is meaningless.
    - ``mcpwm_sync_enable`` is removed. It is duplicated to :cpp:func:`mcpwm_sync_configure`.
    - ``mcpwm_sync_configure`` is replaced by :cpp:func:`mcpwm_timer_set_phase_on_sync`.
    - ``mcpwm_sync_disable`` is equivalent to setting :cpp:member:`mcpwm_timer_sync_phase_config_t::sync_src` to ``NULL``.
    - ``mcpwm_set_timer_sync_output`` is replaced by :cpp:func:`mcpwm_new_ti"
"mer_sync_src`.
    - ``mcpwm_timer_trigger_soft_sync`` is replaced by :cpp:func:`mcpwm_soft_sync_activate`.
    - ``mcpwm_sync_invert_gpio_synchro`` is equivalent to setting :cpp:member:`mcpwm_gpio_sync_src_config_t::active_neg`.
    - ``mcpwm_isr_register`` is removed. You can register various event callbacks instead. For example, to register capture event callback, users can use :cpp:func:`mcpwm_capture_channel_register_event_callbacks`.

.. only:: SOC_DEDICATED_GPIO_SUPPORTED

    Dedicated G"
"PIO Driver
    

    - All of the dedicated GPIO related Low Level (LL) functions in ``cpu_ll.h`` have been moved to ``dedic_gpio_cpu_ll.h`` and renamed.

.. only:: SOC_I2S_SUPPORTED

    I2S Driver
    

    The I2S driver has been redesigned (see :doc:`I2S Driver `), which aims to rectify the shortcomings of the driver that were exposed when supporting all the new features of ESP32-C3 & ESP32-S3. The new driver's APIs are available by including corresponding I2S mode's header files :component_"
"file:`esp_driver_i2s/include/driver/i2s_std.h`, :component_file:`esp_driver_i2s/include/driver/i2s_pdm.h`, or :component_file:`esp_driver_i2s/include/driver/i2s_tdm.h`.

    Meanwhile, the old driver's APIs in :component_file:`driver/deprecated/driver/i2s.h` are still supported for backward compatibility. But there will be warnings if users keep using the old APIs in their projects, these warnings can be suppressed by the Kconfig option :ref:`CONFIG_I2S_SUPPRESS_DEPRECATE_WARN`.

    Here is the"
" general overview of the current I2S files:

    .. figure:: ../../../../_static/diagrams/i2s/i2s_file_structure.png
        :align: center
        :alt: I2S File Structure

    Breaking changes in Concepts
    

    Independent TX/RX channels
    """"""""""""""""""""""""""""""""""""""""""""""""""""

    The minimum control unit in new I2S driver are now individual TX/RX channels instead of an entire I2S controller (that consistes of multiple channels).

    - The TX and RX channels of the same I2S controller can be cont"
"rolled separately, meaning that they are configured such that they can be started or stopped separately.
    - The :cpp:type:`i2s_chan_handle_t` handle type is used to uniquely identify I2S channels. All the APIs require the channel handle and users need to maintain the channel handles by themselves.
    - On the ESP32-C3 and ESP32-S3, TX and RX channels in the same controller can be configured to different clocks or modes.
    - However, on the ESP32 and ESP32-S2, the TX and RX channels of the "
"same controller still share some hardware resources. Thus, configurations may cause one channel to affect another channel in the same controller.
    - The channels can be registered to an available I2S controller automatically by setting :cpp:enumerator:`i2s_port_t::I2S_NUM_AUTO` as I2S port ID which causes the driver to search for the available TX/RX channels. However, the driver also supports registering channels to a specific port.
    - In order to distinguish between TX/RX channels and sou"
"nd channels, the term ""channel"" in the context of the I2S driver only refers to TX/RX channels. Meanwhile, sound channels are referred to as ""slots"".

    I2S Mode Categorization
    """"""""""""""""""""""""""""""""""""""""""""""""

    I2S communication modes are categorized into the following three modes. Note that:

    - **Standard mode**: Standard mode always has two slots, it can support Philips, MSB, and PCM (short frame sync) formats. Please refer to :component_file:`esp_driver_i2s/include/driver/i2s_std.h` for"
" more details.
    - **PDM mode**: PDM mode only supports two slots with 16-bit data width, but the configurations of PDM TX and PDM RX are slightly different. For PDM TX, the sample rate can be set by :cpp:member:`i2s_pdm_tx_clk_config_t::sample_rate`, and its clock frequency depends on the up-sampling configuration. For PDM RX, the sample rate can be set by :cpp:member:`i2s_pdm_rx_clk_config_t::sample_rate`, and its clock frequency depends on the down-sampling configuration. Please refer to :c"
"omponent_file:`esp_driver_i2s/include/driver/i2s_pdm.h` for details.
    - **TDM mode**: TDM mode can support up to 16 slots. It can work in Philips, MSB, PCM (short frame sync), and PCM (long frame sync) formats. Please refer to :component_file:`esp_driver_i2s/include/driver/i2s_tdm.h` for details.

    When allocating a new channel in a specific mode, users should initialize that channel by its corresponding function. It is strongly recommended to use the helper macros to generate the default "
"configurations in case the default values are changed in the future.

    Independent Slot and Clock Configuration
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    The slot configurations and clock configurations can be configured separately.

    - Call :cpp:func:`i2s_channel_init_std_mode`, :cpp:func:`i2s_channel_init_pdm_rx_mode`, :cpp:func:`i2s_channel_init_pdm_tx_mode`, or :cpp:func:`i2s_channel_init_tdm_mode` to initialize the slot/clock/gpio_pin configurations.
    - Calling :cpp:func:`i"
"2s_channel_reconfig_std_slot`, :cpp:func:`i2s_channel_reconfig_pdm_rx_slot`, :cpp:func:`i2s_channel_reconfig_pdm_tx_slot`, or :cpp:func:`i2s_channel_reconfig_tdm_slot` can change the slot configurations after initialization.
    - Calling :cpp:func:`i2s_channel_reconfig_std_clock`, :cpp:func:`i2s_channel_reconfig_pdm_rx_clock`, :cpp:func:`i2s_channel_reconfig_pdm_tx_clock`, or :cpp:func:`i2s_channel_reconfig_tdm_clock` can change the clock configurations after initialization.
    - Calling :cpp:"
"func:`i2s_channel_reconfig_std_gpio`, :cpp:func:`i2s_channel_reconfig_pdm_rx_gpio`, :cpp:func:`i2s_channel_reconfig_pdm_tx_gpio`, or :cpp:func:`i2s_channel_reconfig_tdm_gpio` can change the GPIO configurations after initialization.

    Misc
    """"""""

    - States and state-machine are adopted in the new I2S driver to avoid APIs called in wrong state.
    - ADC and DAC modes are removed. They are only supported in their own drivers and the legacy I2S driver.

    Breaking Changes in Usage
    

"
"    To use the new I2S driver, please follow these steps:

.. only:: SOC_TWAI_SUPPORTED

    TWAI Driver
    

    The deprecated ``CAN`` peripheral driver is removed. Please use ``TWAI`` driver instead (i.e., include ``driver/twai.h`` in your application).

Register Access Macros


Previously, all register access macros could be used as expressions, so the following was allowed::

    uint32_t val = REG_SET_BITS(reg, bits, mask);

In ESP-IDF v5.0, register access macros which write or read-modi"
"fy-write the register can no longer be used as expressions, and can only be used as statements. This applies to the following macros: ``REG_WRITE``, ``REG_SET_BIT``, ``REG_CLR_BIT``, ``REG_SET_BITS``, ``REG_SET_FIELD``, ``WRITE_PERI_REG``, ``CLEAR_PERI_REG_MASK``, ``SET_PERI_REG_MASK``, ``SET_PERI_REG_BITS``.

To store the value which would have been written into the register, split the operation as follows::

    uint32_t new_val = REG_READ(reg) | mask;
    REG_WRITE(reg, new_val);

To get the "
"value of the register after modification (which may be different from the value written), add an explicit read::

    REG_SET_BITS(reg, bits, mask);
    uint32_t new_val = REG_READ(reg);
"
"Provisioning




Protocomm


The ``pop`` field in the :cpp:func:`protocomm_set_security` API is now deprecated. Please use the ``sec_params`` field instead of ``pop``. This parameter should contain the structure (including the security parameters) as required by the protocol version used.

For example, when using security version 2, the ``sec_params`` parameter should contain the pointer to the structure of type :cpp:type:`protocomm_security2_params_t`.

Wi-Fi Provisioning


.. list::

ESP Local"
" Control


The ``pop`` field in the :cpp:type:`esp_local_ctrl_proto_sec_cfg_t` API is now deprecated. Please use the ``sec_params`` field instead of ``pop``. This field should contain the structure (containing the security parameters) as required by the protocol version used.

For example, when using security version 2, the ``sec_params`` field should contain pointer to the structure of type :cpp:type:`esp_local_ctrl_security2_params_t`.
"
"Bluetooth Low Energy




Bluedroid


    The following Bluedroid macros, types, and functions have been renamed:

    - :component_file:`bt/host/bluedroid/api/include/api/esp_gap_ble_api.h`

        - In :cpp:enum:`esp_gap_ble_cb_event_t`:

            - ``ESP_GAP_BLE_SET_PREFERED_DEFAULT_PHY_COMPLETE_EVT`` renamed to ``ESP_GAP_BLE_SET_PREFERRED_DEFAULT_PHY_COMPLETE_EVT``
            - ``ESP_GAP_BLE_SET_PREFERED_PHY_COMPLETE_EVT`` renamed to ``ESP_GAP_BLE_SET_PREFERRED_PHY_COMPLETE_EVT``
       "
"     - ``ESP_GAP_BLE_CHANNEL_SELETE_ALGORITHM_EVT`` renamed to ``ESP_GAP_BLE_CHANNEL_SELECT_ALGORITHM_EVT``

        - ``esp_ble_wl_opration_t`` renamed to :cpp:enum:`esp_ble_wl_operation_t`
        - ``esp_ble_gap_cb_param_t.pkt_data_lenth_cmpl`` renamed to ``pkt_data_length_cmpl``
        - ``esp_ble_gap_cb_param_t.update_whitelist_cmpl.wl_opration`` renamed to ``wl_operation``
        - ``esp_ble_gap_set_prefered_default_phy`` renamed to :cpp:func:`esp_ble_gap_set_preferred_default_phy`
     "
"   - ``esp_ble_gap_set_prefered_phy`` renamed to :cpp:func:`esp_ble_gap_set_preferred_phy`

    - :component_file:`bt/host/bluedroid/api/include/api/esp_gatt_defs.h`

        - In :cpp:enum:`esp_gatt_status_t`:

            - ``ESP_GATT_ENCRYPED_MITM`` renamed to ``ESP_GATT_ENCRYPTED_MITM``
            - ``ESP_GATT_ENCRYPED_NO_MITM`` renamed to ``ESP_GATT_ENCRYPTED_NO_MITM``

Nimble


    The following Nimble APIs have been removed:

    - :component_file:`bt/host/nimble/esp-hci/include/esp_nimb"
"le_hci.h`

        - Remove ``esp_err_t esp_nimble_hci_and_controller_init(void)``

            - Controller initialization, enable and HCI initialization calls have been moved to `nimble_port_init`. This function can be deleted directly.

        - Remove ``esp_err_t esp_nimble_hci_and_controller_deinit(void)``

            - Controller deinitialization, disable and HCI deinitialization calls have been moved to `nimble_port_deinit`. This function can be deleted directly.

ESP-BLE-MESH


    The"
" following ESP-BLE-MESH macro has been renamed:

    - :component_file:`bt/esp_ble_mesh/api/esp_ble_mesh_defs.h`

        - In :cpp:enum:`esp_ble_mesh_prov_cb_event_t`:

            - ``ESP_BLE_MESH_PROVISIONER_DRIECT_ERASE_SETTINGS_COMP_EVT`` renamed to ``ESP_BLE_MESH_PROVISIONER_DIRECT_ERASE_SETTINGS_COMP_EVT``
"
"Migration from 5.1 to 5.2




.. toctree::
    :maxdepth: 1

    bluetooth-classic
    gcc
    :SOC_IEEE802154_SUPPORTED: ieee802154
    peripherals
    protocols
    storage
    system
    :SOC_WIFI_SUPPORTED: wifi
"
"WiFi





WiFi Enterprise Security


APIs defined in `esp_wpa2.h` have been deprecated. Please use newer APIs from `esp_eap_client.h`.


WiFi Disconnect Reason Codes


For the event WIFI_EVENT_STA_DISCONNECTED, the original reason code WIFI_REASON_NO_AP_FOUND has been split as follows:

- REASON_NO_AP_FOUND(original and still used in some scenarios)
- REASON_NO_AP_FOUND_IN_RSSI_THRESHOLD
- REASON_NO_AP_FOUND_IN_AUTHMODE_THRESHOLD
- REASON_NO_AP_FOUND_W_COMPATIBLE_SECURITY

For details, please re"
"fer to :ref:`esp_wifi_reason_code`.
"
"GCC
***




GCC Version


The previous GCC version was GCC 12.2.0. This has now been upgraded to GCC 13.2.0 on all targets. Users that need to port their code from GCC 12.2.0 to 13.2.0 should refer to the series of official GCC porting guides listed below:


Common Porting Problems and Fixes


``stdio.h`` No Longer Includes ``sys/types.h``


Issue


Compilation errors may occur in code that previously worked with the old toolchain. For example:

.. code-block:: c

    #include 
    clock_t var; "
"// error: expected specifier-qualifier-list before 'clock_t'

Solution


To resolve this issue, the correct header must be included. Refactor the code like this:

.. code-block:: c

    #include 
    clock_t var;
"
"System




FreeRTOS


IDF FreeRTOS Upgrade


The IDF FreeRTOS kernel (which is a dual-core SMP implementation of FreeRTOS) has been upgraded to be based on Vanilla FreeRTOS v10.5.1. With this upgrade, the design and implementation of IDF FreeRTOS has also been changed significantly. As a result, users should take not of the following changes to kernel behavior and API:

- When enabling single-core mode via the :ref:`CONFIG_FREERTOS_UNICORE` option, the kernel's behavior will now be identical to "
"Vanilla FreeRTOS (see :ref:`freertos-idf-single-core` for more details).
- For SMP related APIs that were added by IDF FreeRTOS, checks on ``xCoreID`` arguments are now stricter. Providing out of range values for ``xCoreID`` arguments will now trigger an assert.
- The following SMP related APIs are now deprecated and replaced due to naming consistency reasons:

    - ``xTaskGetAffinity()`` is deprecated, call :cpp:func:`xTaskGetCoreID` instead.
    - ``xTaskGetIdleTaskHandleForCPU()`` is depreca"
"ted, call :cpp:func:`xTaskGetIdleTaskHandleForCore` instead.
    - ``xTaskGetCurrentTaskHandleForCPU()`` is deprecated, call :cpp:func:`xTaskGetCurrentTaskHandleForCore` instead.

Task Snapshot


The Task Snapshot API has been made private due to a lack of a practical way for the API to be used from user code (the scheduler must be halted before the API can be called).

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    Xtensa
    

    A number of legacy include paths for Xtensa headers have been dep"
"recated:

    - ``#include ""freertos/xtensa_api.h""`` is deprecated, please use ``#include ""xtensa_api.h""`` instead.
    - ``#include ""freertos/xtensa_context.h""`` is deprecated, please use ``#include ""xtensa_context.h""`` instead.
    - ``#include ""freertos/xtensa_timer.h""`` is deprecated, please use ``#include ""xtensa_timer.h""`` instead.


Panic Handler Behavior


The choice ``CONFIG_ESP_SYSTEM_PANIC_GDBSTUB`` in the configuration option :ref:`CONFIG_ESP_SYSTEM_PANIC` has been made dependent on "
"whether the ``esp_gdbstub`` component is included in the build. When trimming the list of components in the build using ``set(COMPONENTS main)``, ``esp_gdbstub`` component has to be added to this list of components to make the ``CONFIG_ESP_SYSTEM_PANIC_GDBSTUB`` option available.
"
"Bluetooth Classic




Bluedroid


    The following Bluedroid API have been removed:

    - :component_file:`bt/host/bluedroid/api/include/api/esp_bt_main.h`

        - Remove ``esp_err_t esp_bluedroid_init(void)``

            - Bluedroid stack initialization API has been replaced by ``esp_err_t esp_bluedroid_init_with_cfg(esp_bluedroid_config_t *cfg)``. Macro ``BT_BLUEDROID_INIT_CONFIG_DEFAULT()`` provides the default configuration for the initialization. The original function can be deleted d"
"irectly.
"
"Protocols





CoAP


CoAP examples have been moved to `idf-extra-components `__ repository.


HTTP2


http2_request example has been moved to `idf-extra-components `__ repository.
"
"Storage




NVS Encryption


- For SoCs with the HMAC peripheral (``SOC_HMAC_SUPPORTED``), turning on :doc:`../../../security/flash-encryption` will no longer automatically turn on :doc:`../../../api-reference/storage/nvs_encryption`.
- You will need to explicitly turn on NVS encryption and select the required scheme (flash encryption-based or HMAC peripheral-based). You can select the HMAC peripheral-based scheme (:ref:`CONFIG_NVS_SEC_KEY_PROTECTION_SCHEME`), even if flash encryption is not ena"
"bled.
- SoCs without the HMAC peripheral will still automatically turn on NVS encryption when flash encryption is enabled.
"
"Peripherals




.. only:: SOC_UART_SUPPORTED

    UART
    

    - :c:macro:`UART_FIFO_LEN` is deprecated. Please use :c:macro:`UART_HW_FIFO_LEN` instead.

.. only:: SOC_I2C_SUPPORTED

    I2C
    ---

    I2C driver has been redesigned (see :doc:`I2C API Reference `), which aims to unify the interface and extend the usage of I2C peripheral. Although it is recommended to use the new driver APIs, the legacy driver is still available in the previous include path ``driver/i2c.h``.

    The major br"
"eaking changes in concept and usage are listed as follows:

    Major Changes in Concepts
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    - ``i2c_config_t`` which was used to configure the I2C bus, but it doesn't really tell whether to configure master or slave. So in the new design, master and slave initialization are separate, user can call ``i2c_master_bus_config_t`` or ``i2c_slave_config_t``.
    - ``i2c_mode_t`` which was used to tell whether I2C controller works in slave mode or master mode. This enume"
"rator has been deprecated. In the new driver, users don'tneed to manually set the mode anymore since master and slave APIs are different.
    - ``i2c_rw_t`` which was used to tell whether I2C master controller is performing a `write` or a `read` operation. This is now deprecated.
    - ``i2c_addr_mode_t`` was renamed to ``i2c_addr_bit_len_t``.
    -  In the legacy driver, operations needed to be chained with a command list (dynamically or statically created). The new driver now handles this inte"
"rnally, making the operations more size and space efficient.
    -  Capability flags like ``I2C_SCLK_SRC_FLAG_FOR_NOMAL`` are used to select clock source in the legacy driver. In the new driver, users can select clock source directly.

    Major Changes in Usage
    ~~~~~~~~~~~~~~~~~~~~~~

    -  I2C bus initialization is done in two parts: first, initialization of the bus with :cpp:func:`i2c_new_master_bus`, then, initialization of the I2C device with :cpp:func:`i2c_master_bus_add_device`.
    "
"-  ``i2c_reset_tx_fifo`` and ``i2c_reset_rx_fifo`` have been removed, since it is never required to reset the fifo by users. Whole bus can still be reset by calling ``i2c_master_bus_reset``.
    -  ``i2c_cmd_link_xxx`` functions have been removed, user doesn't need to use link to link commands on its own.
    -  ``i2c_master_write_to_device`` has been renamed to ``i2c_master_transmit``.
    -  ``i2c_master_read_from_device`` has been renamed to ``i2c_master_receive``.
    -  ``i2c_master_write_r"
"ead_device`` has been renamed to ``i2c_master_transmit_receive``
    -  ``i2c_slave_write_buffer`` has been renamed to ``i2c_slave_transmit``
    -  ``i2c_slave_read_buffer`` has been renamed to ``i2c_slave_receive``
"
"IEEE 802.15.4




Receive Handle Done


User must call the function :cpp:func:`esp_ieee802154_receive_handle_done` to notify 802.15.4 driver after the received frame is handled. Otherwise the frame buffer will not be freed for future use.
"
"Migration from 5.2 to 5.3




.. toctree::
    :maxdepth: 1

    bluetooth-low-energy
    peripherals
    security
    storage
    system
"
"System




Power Management


Unit Testing


In the past versions of Unity framework, it was possible to omit a semicolon at the end of a ``TEST_ASSERT_*`` macro statement. This is no longer the case in the newer version of Unity, used in IDF v5.3.

For example, the following code:

.. code-block:: c

    TEST_ASSERT(some_func() == ESP_OK)

will now result in a compilation error. To fix this, add a semicolon at the end of the statement:

    TEST_ASSERT(some_func() == ESP_OK);

Partition Table

"
"
Partition Table generation tool has been fixed to ensure that the size of partition of type ``app`` is having flash sector (minimum erase size) aligned size (please see :ref:`partition-offset-and-size`). If the partition does not have aligned size, partition table generator tool will raise an error. This fix ensures that OTA updates for a case where the file size is close or equal to the size of partition works correctly (erase operation does not go beyond the partition size).

In case you have"
" the ``app`` partition size which is not a multiple of the 4 KB then please note that while migrating to ESP-IDF 5.3, you must align this size to its lower 4 KB boundary for the build to succeed. This does not impact the partition table for existing devices as such but ensures that generated firmware size remains within the OTA update capablilty limit.
"
"Storage




VFS
---

The UART implementation of VFS operators has been moved from `vfs` component to `esp_driver_uart` component.

APIs with `esp_vfs_dev_uart_` prefix are all deprecated, replaced with new APIs in `uart_vfs.h` starting with `uart_vfs_dev_` prefix. Specifically,
- ``esp_vfs_dev_uart_register`` has been renamed to ``uart_vfs_dev_register``
- ``esp_vfs_dev_uart_port_set_rx_line_endings`` has been renamed to ``uart_vfs_dev_port_set_rx_line_endings``
- ``esp_vfs_dev_uart_port_set_tx_"
"line_endings`` has been renamed to ``uart_vfs_dev_port_set_tx_line_endings``
- ``esp_vfs_dev_uart_use_nonblocking`` has been renamed to ``uart_vfs_dev_use_nonblocking``
- ``esp_vfs_dev_uart_use_driver`` has been renamed to ``uart_vfs_dev_use_driver``

For compatibility, `vfs` component still registers `esp_driver_uart` as its private dependency. In other words, you do not need to modify the CMake file of an existing project.
"
"Peripherals




Drivers


In order to control the dependence of other components on drivers at a smaller granularity, the original peripheral drivers under the ``driver`` component were split into separate components:

- `esp_driver_gptimer` - Driver for general purpose timers
- `esp_driver_pcnt` - Driver for pulse counter
- `esp_driver_gpio` - Driver for GPIO
- `esp_driver_spi` - Driver for GPSPI
- `esp_driver_mcpwm` - Driver for Motor Control PWM
- `esp_driver_sdmmc` - Driver for SDMMC
- `esp_"
"driver_sdspi` - Driver for SDSPI
- `esp_driver_sdio` - Driver for SDIO
- `esp_driver_ana_cmpr` - Driver for Analog Comparator
- `esp_driver_i2s` - Driver for I2S
- `esp_driver_dac` - Driver for DAC
- `esp_driver_rmt` - Driver for RMT
- `esp_driver_tsens` - Driver for Temperature Sensor
- `esp_driver_sdm` - Driver for Sigma-Delta Modulator
- `esp_driver_i2c` - Driver for I2C
- `esp_driver_uart` - Driver for UART
- `esp_driver_ledc` - Driver for LEDC
- `esp_driver_parlio` - Driver for Parallel IO
"
"- `esp_driver_usb_serial_jtag` - Driver for USB_SERIAL_JTAG

For compatibility, the original ``driver`` component is still treated as an all-in-one component by registering these `esp_driver_xyz` components as its public dependencies. In other words, you do not need to modify the CMake file of an existing project, but you now have a way to specify the specific peripheral driver that your project depends on.

Originally, you may have used **linker.lf** to specify the link location of some driver "
"functions in memory space, but now, because the location of the driver files have been moved, you need to make changes your **linker.lf** file accordingly. For example, a linker.lf file with the following entries:

.. code-block:: none

    [mapping:my_mapping_scheme]
    archive: libdriver.a
    entries:
        gpio (noflash)

Should be changed to:

.. code-block:: none

    [mapping:my_mapping_scheme]
    archive: libesp_driver_gpio.a
    entries:
        gpio (noflash)


Secure Element


The"
" ATECC608A secure element interfacing example has been moved to `ESP Cryptoauthlib Repository `_ on GitHub.

This example is also part of the `esp-cryptoauthlib `_ in the component manager registry.
"
"Bluetooth Low Energy




Bluedroid


    The following Bluedroid APIs have been removed:

    - :component_file:`bt/host/bluedroid/api/include/api/esp_gap_ble_api.h`

        - Remove ``esp_err_t esp_ble_gap_set_device_name(const char *name)``

            - Local device name setting calls have been moved to :cpp:func:`esp_bt_dev_set_device_name`. This function can be deleted directly.

        - Remove ``esp_err_t esp_ble_gap_get_device_name(void)``

            - Local device name getting call"
"s have been moved to :cpp:func:`esp_bt_dev_get_device_name`. This function can be deleted directly.
"
"Security




.. only:: SOC_FLASH_ENC_SUPPORTED

    Platform security features
    

    When flash encryption is enabled, encrypt only the app image that is present partition of type app, instead of encrypting the whole partition. This can help to optimize the encryption time required during the first boot.

    This could be configured using the config ``CONFIG_SECURE_FLASH_ENCRYPT_ONLY_IMAGE_LEN_IN_APP_PART``, which is enabled by default from ESP-IDF v5.3
    and is disabled for all earlier r"
"eleases to avoid any breaking behaviour.
"
"Security Guides




Overview

.. toctree::
   :maxdepth: 1

   security

Features

.. toctree::
   :maxdepth: 1

   flash-encryption
   :esp32: secure-boot-v1
   secure-boot-v2

Workflows

.. toctree::
   :maxdepth: 1

   host-based-security-workflows

"
"Host-Based Security Workflows


{IDF_TARGET_CRYPT_CNT:default=""SPI_BOOT_CRYPT_CNT"",esp32=""FLASH_CRYPT_CNT""}
{IDF_TARGET_CRYPT_CNT_MAX_VAL:default=""7"",esp32=""127""}
{IDF_TARGET_SBV2_DEFAULT_SCHEME:default=""RSA"", esp32c2=""ECDSA (V2)""}

Introduction


It is recommended to have an uninterrupted power supply while enabling security features on ESP32 SoCs. Power failures during the secure manufacturing process could cause issues that are hard to debug and, in some cases, may cause permanent boot-up fai"
"lures.

This guide highlights an approach where security features are enabled with the assistance of an external host machine. Security workflows are broken down into various stages and key material is generated on the host machine; thus, allowing greater recovery chances in case of power or other failures. It also offers better timings for secure manufacturing, e.g., in the case of encryption of firmware on the host machine vs. on the device.


Goals


#. Simplify the traditional workflow with "
"stepwise instructions.
#. Design a more flexible workflow as compared to the traditional firmware-based workflow.
#. Improve reliability by dividing the workflow into small operations.
#. Eliminate dependency on :ref:`second-stage-bootloader` (firmware bootloader).

Pre-requisite


.. code:: bash

   pip install esptool

Scope


Security Workflows


.. _enable-flash-encryption-and-secure-boot-v2-externally:

Enable Flash Encryption and Secure Boot V2 Externally


.. important::

    It is recomm"
"ended to enable both Flash Encryption and Secure Boot V2 for a production use case.

When enabling the Flash Encryption and Secure Boot V2 externally we need to enable them in the following order:

#. Enable the Flash Encryption feature by following the steps listed in :ref:`enable-flash-encryption-externally`.
#. Enable the Secure Boot V2 feature by following the steps listed in :ref:`enable-secure-boot-v2-externally`.

The reason for this order is as follows:

To enable the Secure Boot (SB) V2"
", it is necessary to keep the SB V2 key readable. To protect the key's readability, the write protection for ``RD_DIS`` (``ESP_EFUSE_WR_DIS_RD_DIS``) is applied. However, this action poses a challenge when attempting to enable Flash Encryption, as the Flash Encryption (FE) key needs to remain unreadable. This conflict arises because the ``RD_DIS`` is already write-protected, making it impossible to read protect the FE key.

.. _enable-flash-encryption-externally:

Enable Flash Encryption Externa"
"lly


In this case, all the eFuses related to flash encryption are written with help of the espefuse tool. More details about flash encryption can be found in the :doc:`Flash Encryption Guide `

    See how to check :ref:`flash-encryption-status`.

  In this case, the flash on the chip must be erased and flash encryption must not be enabled. The chip can be erased by running:

  .. code:: bash

     esptool.py --port PORT erase_flash

  A random flash encryption key can be generated by running:
"
"
  .. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

      If :ref:`Size of generated AES-XTS key ` is AES-128 (256-bit key):

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

      else if :ref:`Size of generated AES-XTS key ` is AES-256 (512-bit key):

      .. code-block:: bash

      "
"    espsecure.py generate_flash_encryption_key --keylen 512 my_flash_encryption_key.bin


  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

        If :ref:`Size of generated AES-XTS key ` is AES-128 (256-bit key):

       "
" .. code-block:: bash

            espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

        else if :ref:`Size of generated AES-XTS key ` is AES-128 key derived from 128 bits (SHA256(128 bits)):

        .. code-block:: bash

            espsecure.py generate_flash_encryption_key --keylen 128 my_flash_encryption_key.bin

  This action **cannot be reverted**. It can be done by running:

  .. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

    .. code-block:: bash

        espefuse"
".py --port PORT burn_key flash_encryption my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

    .. code-block:: bash

      espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin KEYPURPOSE

    where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``. And ``KEYPURPOSE`` is either ``XTS_AES_256_KEY_1``, ``XTS_AES_256_KEY_2``, ``XTS_AES_128_KEY``. See `{IDF_TARGET_NAME} Technical Reference Manual `_ for a description of the key purposes.

 "
"   For AES-128 (256-bit key) - ``XTS_AES_128_KEY``:

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_128_KEY

    For AES-256 (512-bit key) - ``XTS_AES_256_KEY_1`` and ``XTS_AES_256_KEY_2``. ``espefuse.py`` supports burning both these two key purposes together with a 512-bit key to two separate key blocks via the virtual key purpose ``XTS_AES_256_KEY``. When this is used ``espefuse.py`` will burn the first 256 bits of the key to the sp"
"ecified ``BLOCK`` and burn the corresponding block key purpose to ``XTS_AES_256_KEY_1``. The last 256 bits of the key will be burned to the first free key block after ``BLOCK`` and the corresponding block key purpose to ``XTS_AES_256_KEY_2``

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_256_KEY

    If you wish to specify exactly which two blocks are used then it is possible to divide the key into two 256-bit keys, and manually burn"
" each half with ``XTS_AES_256_KEY_1`` and ``XTS_AES_256_KEY_2`` as key purposes:

    .. code-block:: bash

      split -b 32 my_flash_encryption_key.bin my_flash_encryption_key.bin
      espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin.aa XTS_AES_256_KEY_1
      espefuse.py --port PORT burn_key BLOCK+1 my_flash_encryption_key.bin.ab XTS_AES_256_KEY_2


  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BL"
"OCK

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_128_KEY

    where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``.

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

    For AES-128 (256-bit key) - ``XTS_AES_128_KEY`` (the ``XTS_KEY_LENGTH_256`` eFuse will be burn to 1):

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK_KEY0 flash_encryption_key256"
".bin XTS_AES_128_KEY

    For AES-128 key derived from 128 bits (SHA256(128 bits)) - ``XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS``. The FE key will be written in the lower part of eFuse BLOCK_KEY0. The upper 128 bits are not used and will remain available for reading by software. Using the special mode of the espefuse tool, shown in the ``For burning both keys together`` section below, the user can write their data to it using any espefuse commands.

    .. code-block:: bash

        espefuse."
"py --port PORT burn_key BLOCK_KEY0 flash_encryption_key128.bin XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS

    For burning both keys together (Secure Boot and Flash Encryption):

    .. code-block:: bash

        espefuse.py --port PORT --chip esp32c2 burn_key_digest secure_boot_signing_key.pem \
                                                  burn_key BLOCK_KEY0 flash_encryption_key128.bin XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS


  .. only:: SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK

      .. "
"warning::

          For the {IDF_TARGET_NAME} BLOCK9 (BLOCK_KEY5) can not be used by XTS_AES keys.

  If you only want to enable flash encryption in **Development** mode and want to keep the ability to disable it in the future, Update the {IDF_TARGET_CRYPT_CNT} value in the below command from {IDF_TARGET_CRYPT_CNT_MAX_VAL} to 0x1 (not recommended for production).

  .. code-block:: bash

      espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse {IDF_TARGET_CRYPT_CNT} {IDF_TARGET_CR"
"YPT_CNT_MAX_VAL}

  .. only:: esp32

      In the case of {IDF_TARGET_NAME}, you also need to burn the ``FLASH_CRYPT_CONFIG``. It can be done by running:

      .. code-block:: bash

          espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse FLASH_CRYPT_CONFIG 0xF

  .. note::

     At this point, the flash encryption on the device has been enabled. You may test the flash encryption process as given in step 5. Please note that the security-related eFuses have not been burned at t"
"his point. It is recommended that they should be burned in production use cases as explained in step 6.

  The bootloader and the application binaries for the project must be built with Flash Encryption Release mode with default configurations.

  Flash encryption Release mode can be set in the menuconfig as follows:

  .. list::

      - :ref:`Enable flash encryption on boot `
      :esp32: - :ref:`Select Release mode ` (Note that once Release mode is selected, the ``DISABLE_DL_ENCRYPT`` and ``"
"DISABLE_DL_DECRYPT`` eFuse bits will be burned to disable flash encryption hardware in ROM Download Mode.)
      :esp32: - :ref:`Select UART ROM download mode (Permanently disabled (recommended)) ` (Note that this option is only available when :ref:`CONFIG_ESP32_REV_MIN` is set to 3 (ESP32 V3).) The default choice is to keep UART ROM download mode enabled, however it is recommended to permanently disable this mode to reduce the options available to an attacker.
      :not esp32: - :ref:`Select R"
"elease mode ` (Note that once Release mode is selected, the ``EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT`` eFuse bit will be burned to disable flash encryption hardware in ROM Download Mode.)
      :not esp32: - :ref:`Select UART ROM download mode (Permanently switch to Secure mode (recommended)) `. This is the default option and is recommended. It is also possible to change this configuration setting to permanently disable UART ROM download mode, if this mode is not needed.
      - :ref:`Select the appr"
"opriate bootloader log verbosity `
      - Save the configuration and exit.


  The binaries can be encrypted on the host machine by running:

  .. only:: esp32

      .. code-block:: bash

         espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x1000 --output bootloader-enc.bin build/bootloader/bootloader.bin

         espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x8000 --output partition-table-enc.bin build/partition_table/pa"
"rtition-table.bin

         espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x10000 --output my-app-enc.bin build/my-app.bin

  .. only:: not esp32

      .. code-block:: bash

         espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x0 --output bootloader-enc.bin build/my-app.bin

         espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x8000 --output partition-table-enc.bin bui"
"ld/partition_table/partition-table.bin

         espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x10000 --output my-app-enc.bin build/my-app.bin

  The above files can then be flashed to their respective offset using ``esptool.py``. To see all of the command line options recommended for ``esptool.py``, see the output printed when ``idf.py build`` succeeds. In the above command the offsets are used for a sample firmware, the actual offset for your firmwa"
"re can be obtained by checking the partition table entry or by running `idf.py partition-table`. When the application contains the following partition: ``otadata``, ``nvs_encryption_keys`` they need to be encrypted as well. Please refer to :ref:`encrypted-partitions` for more details about encrypted partitions.

  .. note::

     If the flashed ciphertext file is not recognized by the {IDF_TARGET_NAME} when it boots, check that the keys match and that the command line arguments match exactly, in"
"cluding the correct offset. It is important to provide the correct offset as the ciphertext changes when the offset changes.

     .. only:: esp32

         If your ESP32 uses non-default :ref:`FLASH_CRYPT_CONFIG value in eFuse ` then you will need to pass the ``--flash_crypt_conf`` argument to ``espsecure.py`` to set the matching value. This will not happen if the device configured flash encryption by itself but may happen when burning eFuses manually to enable flash encryption.

  The command "
"``espsecure.py decrypt_flash_data`` can be used with the same options (and different input/output files), to decrypt ciphertext flash contents or a previously encrypted file.

  A) Burn security eFuses:

    .. important::

      For production use cases, it is highly recommended to burn all the eFuses listed below.

    .. list::

        :esp32: - ``DISABLE_DL_ENCRYPT``: Disable the UART bootloader encryption access.
        :esp32: - ``DISABLE_DL_DECRYPT``: Disable the UART bootloader decrypt"
"ion access.
        :esp32: - ``DISABLE_DL_CACHE``: Disable the UART bootloader flash cache access.
        :esp32: - ``JTAG_DISABLE``: Disable the JTAG
        :SOC_EFUSE_DIS_BOOT_REMAP: - ``DIS_BOOT_REMAP``: Disable capability to Remap ROM to RAM address space
        :SOC_EFUSE_DIS_DOWNLOAD_ICACHE: - ``DIS_DOWNLOAD_ICACHE``: Disable UART cache
        :SOC_EFUSE_DIS_DOWNLOAD_DCACHE: - ``DIS_DOWNLOAD_DCACHE``: Disable UART cache.
        :SOC_EFUSE_HARD_DIS_JTAG: - ``HARD_DIS_JTAG``: Hard disa"
"ble JTAG peripheral
        :SOC_EFUSE_DIS_DIRECT_BOOT:- ``DIS_DIRECT_BOOT``: Disable direct boot (legacy SPI boot mode)
        :SOC_EFUSE_DIS_LEGACY_SPI_BOOT: - ``DIS_LEGACY_SPI_BOOT``: Disable legacy SPI boot mode
        :SOC_EFUSE_DIS_USB_JTAG: - ``DIS_USB_JTAG``: Disable USB switch to JTAG
        :SOC_EFUSE_DIS_PAD_JTAG: - ``DIS_PAD_JTAG``: Disable JTAG permanently
        :not esp32: - ``DIS_DOWNLOAD_MANUAL_ENCRYPT``: Disable UART bootloader encryption access
        :SOC_EFUSE_DIS_DOWNL"
"OAD_MSPI: - ``DIS_DOWNLOAD_MSPI``: Disable the MSPI access in download mode

    The respective eFuses can be burned by running:

    .. code:: bash

        espefuse.py burn_efuse --port PORT EFUSE_NAME 0x1

    .. note::

        Please update the EFUSE_NAME with the eFuse that you need to burn. Multiple eFuses can be burned at the same time by appending them to the above command (e.g., EFUSE_NAME VAL EFUSE_NAME2 VAL2). More documentation about `espefuse.py` can be found `here `_.

  B) Write "
"protect security eFuses:

    After burning the respective eFuses we need to write_protect the security configurations

  .. only:: esp32

      .. code:: bash

          espefuse.py --port PORT write_protect_efuse MAC

      .. note::

          The write disable bit for MAC also write disables DIS_CACHE which is required to prevent accidental burning of this bit.

    C) Disable UART ROM DL mode:

      .. warning::

          Please burn the following bit at the very end. After this bit is bu"
"rned, the espefuse tool can no longer be used to burn additional eFuses.

      .. list::

          - ``UART_DOWNLOAD_DIS`` : Disable the UART ROM Download mode.

          The eFuse can be burned by running:

          .. code:: bash

              espefuse.py --port PORT burn_efuse UART_DOWNLOAD_DIS


  .. only:: not esp32

      .. code:: bash

          espefuse.py --port PORT write_protect_efuse DIS_ICACHE

      .. note::

          The write protection of above eFuse also write protects "
"multiple other eFuses, Please refer to the {IDF_TARGET_NAME} eFuse table for more details.

    C) Enable Security Download mode:

      .. warning::

          Please burn the following bit at the very end. After this bit is burned, the espefuse tool can no longer be used to burn additional eFuses.

      .. list::

          - ``ENABLE_SECURITY_DOWNLOAD``: Enable Secure ROM download mode

          The eFuse can be burned by running:

          .. code:: bash

              espefuse.py --port "
"PORT burn_efuse ENABLE_SECURITY_DOWNLOAD

.. important::

        Once the flash encryption has been enabled for the device, the key **must be deleted immediately**. This ensures that the host cannot produce encrypted binaries for the same device going forward. This step is important to reduce the vulnerability of the flash encryption key.

Flash Encryption Guidelines
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. _enable-secure-boot-v2-externally:

Enable Secure Boot V2 Externally


In this workflow, we shall"
" use ``espsecure`` tool to generate signing keys and use the ``espefuse`` tool to burn the relevant eFuses. The details about the Secure Boot V2 process can be found at :doc:`Secure Boot V2 Guide `

  .. only:: esp32 or SOC_SECURE_BOOT_V2_RSA

     The Secure Boot V2 signing key for the RSA3072 scheme can be generated by running:

     .. code:: bash

         espsecure.py generate_signing_key --version 2 --scheme rsa3072 secure_boot_signing_key.pem

  .. only:: SOC_SECURE_BOOT_V2_ECC

     The "
"Secure Boot V2 signing key for ECDSA scheme can be generated by running:

      .. code:: bash

          espsecure.py generate_signing_key --version 2 --scheme ecdsa256 secure_boot_signing_key.pem

     The scheme in the above command can be changed to ``ecdsa192`` to generate ecdsa192 private key.

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

     A total of 3 keys can be used for Secure Boot V2 at once. These should be computed independently and stored separately. The same command with diff"
"erent key file names can be used to generate multiple Secure Boot V2 signing keys. It is recommended to use multiple keys in order to reduce dependency on a single key.

  The public key digest for the private key generated in the previous step can be generated by running:

  .. code:: bash

      espsecure.py digest_sbv2_public_key --keyfile secure_boot_signing_key.pem --output digest.bin

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

      In case of multiple digests, each digest should be ke"
"pt in a separate file.

  The public key digest can be burned in the eFuse by running:

  .. only:: esp32

      .. code:: bash

          espefuse.py --port PORT --chip esp32 burn_key secure_boot_v2 digest.bin

  .. only:: esp32c2

     .. code:: bash

          espefuse.py --port PORT --chip esp32c2 burn_key KEY_BLOCK0 SECURE_BOOT_DIGEST digest.bin

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

      .. code:: bash

          espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_key BLOC"
"K SECURE_BOOT_DIGEST0 digest.bin

      where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``.

      In case of multiple digests, the other digests can be burned sequentially by changing the key purpose to ``SECURE_BOOT_DIGEST1`` and ``SECURE_BOOT_DIGEST2`` respectively.

  Secure Boot V2 eFuse can be enabled by running:

  .. only:: esp32

     .. code:: bash

          espefuse.py --port PORT --chip esp32 burn_efuse ABS_DONE_1

  .. only:: not esp32

     .. code:: bash"
"

          espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse SECURE_BOOT_EN


  .. note::

     At this stage the secure boot V2 has been enabled for the {IDF_TARGET_NAME}. The ROM bootloader shall now verify the authenticity of the :ref:`second-stage-bootloader` on every bootup. You may test the secure boot process by executing Steps 5 & 6. Please note that security-related eFuses have not been burned at this point. For production use cases, all security-related eFuses must be b"
"urned as given in step 7.

  By default, the ROM bootloader would only verify the :ref:`second-stage-bootloader` (firmware bootloader). The firmware bootloader would verify the app partition only when the :ref:`CONFIG_SECURE_BOOT` option is enabled (and :ref:`CONFIG_SECURE_BOOT_VERSION` is set to ``SECURE_BOOT_V2_ENABLED``) while building the bootloader.

  a) Open the :ref:`project-configuration-menu`, in ""Security features"" set ""Enable hardware Secure Boot in bootloader"" to enable Secure Boot."
"

  .. only:: esp32

      For ESP32, Secure Boot V2 is available only for ESP32 ECO3 onwards. To view the ""Secure Boot V2"" option the chip revision should be changed to revision v3.0 (ECO3). To change the chip revision, set ""Minimum Supported ESP32 Revision"" to ""Rev 3.0 (ECO3)"" in ""Component Config"" -> ""Hardware Settings"" -> ""Chip Revision"".

  .. only:: SOC_SECURE_BOOT_V2_RSA or SOC_SECURE_BOOT_V2_ECC

      The ""Secure Boot V2"" option will be selected and the ""App Signing Scheme"" will be set "
"to {IDF_TARGET_SBV2_DEFAULT_SCHEME} by default.

  b) Disable the option :ref:`CONFIG_SECURE_BOOT_BUILD_SIGNED_BINARIES` for the project in the :ref:`project-configuration-menu`. This shall make sure that all the generated binaries are secure padded and unsigned. This step is done to avoid generating signed binaries as we are going to manually sign the binaries using ``espsecure`` tool.

  After the above configurations, the bootloader and application binaries can be built with ``idf.py build`` "
"command.

  The Secure Boot V2 workflow only verifies the ``bootloader`` and ``application`` binaries, hence only those binaries need to be signed. The other binaries (e.g., ``partition-table.bin``) can be flashed as they are generated in the build stage.

  The ``bootloader.bin`` and ``app.bin`` binaries can be signed by running:

  .. code:: bash

     espsecure.py sign_data --version 2 --keyfile secure_boot_signing_key.pem --output bootloader-signed.bin build/bootloader/bootloader.bin

     e"
"spsecure.py sign_data --version 2 --keyfile secure_boot_signing_key.pem --output my-app-signed.bin build/my-app.bin

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

      If multiple keys secure boot keys are to be used then the same signed binary can be appended with a signature block signed with the new key as follows:

      .. code:: bash

          espsecure.py sign_data --keyfile secure_boot_signing_key2.pem --version 2 --append_signatures -o bootloader-signed2.bin bootloader-signed.bin

  "
"        espsecure.py sign_data --keyfile secure_boot_signing_key2.pem --version 2 --append_signatures -o my-app-signed2.bin my-app-signed.bin

      The same process can be repeated for the third key. Note that the names of the input and output files must not be the same.

  The signatures attached to a binary can be checked by running:

  .. code:: bash

     espsecure.py signature_info_v2 bootloader-signed.bin

  The above files along with other binaries (e.g., partition table) can then be fla"
"shed to their respective offset using ``esptool.py``. To see all of the command line options recommended for ``esptool.py``, see the output printed when ``idf.py build`` succeeds. The flash offset for your firmware can be obtained by checking the partition table entry or by running ``idf.py partition-table``.

  A) Burn security eFuses:

    .. important::

        For production use cases, it is highly recommended to burn all the eFuses listed below.

    .. list::

        :esp32: - ``JTAG_DIS"
"ABLE``: Disable the JTAG
        :SOC_EFUSE_DIS_BOOT_REMAP: - ``DIS_BOOT_REMAP``: Disable capability to Remap ROM to RAM address space
        :SOC_EFUSE_HARD_DIS_JTAG: - ``HARD_DIS_JTAG``: Hard disable JTAG peripheral
        :SOC_EFUSE_SOFT_DIS_JTAG: - ``SOFT_DIS_JTAG``: Disable software access to JTAG peripheral
        :SOC_EFUSE_DIS_DIRECT_BOOT:- ``DIS_DIRECT_BOOT``: Disable direct boot (legacy SPI boot mode)
        :SOC_EFUSE_DIS_LEGACY_SPI_BOOT: - ``DIS_LEGACY_SPI_BOOT``: Disable legacy "
"SPI boot mode
        :SOC_EFUSE_DIS_USB_JTAG: - ``DIS_USB_JTAG``: Disable USB switch to JTAG
        :SOC_EFUSE_DIS_PAD_JTAG: - ``DIS_PAD_JTAG``: Disable JTAG permanently
        :SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: - ``SECURE_BOOT_AGGRESSIVE_REVOKE``: Aggressive revocation of key digests, see :ref:`secure-boot-v2-aggressive-key-revocation` for more details.

    The respective eFuses can be burned by running:

    .. code:: bash

        espefuse.py burn_efuse --port PORT EFUSE_NAME 0x1

    .."
" note::

        Please update the EFUSE_NAME with the eFuse that you need to burn. Multiple eFuses can be burned at the same time by appending them to the above command (e.g., EFUSE_NAME VAL EFUSE_NAME2 VAL2). More documentation about `espefuse.py` can be found `here `_

  B) Secure Boot V2-related eFuses:

    i) Disable the ability for read protection:

    The secure boot digest burned in the eFuse must be kept readable otherwise secure boot operation would result in a failure. To prevent th"
"e accidental enabling of read protection for this key block we need to burn the following eFuse:

    .. code:: bash

        espefuse.py -p $ESPPORT write_protect_efuse RD_DIS

    .. important::

        After this eFuse has been burned, read protection cannot be enabled for any key. E.g., if flash encryption which requires read protection for its key is not enabled at this point then it cannot be enabled afterwards. Please ensure that no eFuse keys are going to need read protection after this"
".


    .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

        ii) Revoke key digests:

        The unused digest slots need to be revoked when we are burning the secure boot key. The respective slots can be revoked by running

        .. code:: bash

            espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse EFUSE_REVOKE_BIT

        The ``EFUSE_REVOKE_BIT`` in the above command can be ``SECURE_BOOT_KEY_REVOKE0`` or ``SECURE_BOOT_KEY_REVOKE1`` or ``SECURE_BOOT_KEY_REVOKE2``. Ple"
"ase note that only the unused key digests must be revoked. Once revoked, the respective digest cannot be used again.

  .. only:: esp32

    C) Disable UART ROM DL mode:

      .. warning::

          Please burn the following bit at the very end. After this bit is burned, the espefuse tool can no longer be used to burn additional eFuses.

      .. list::

          - ``UART_DOWNLOAD_DIS`` : Disable the UART ROM Download mode.

          The eFuse can be burned by running:

          .. code:: b"
"ash

            espefuse.py --port PORT burn_efuse UART_DOWNLOAD_DIS


  .. only:: not esp32

    C) Enable Security Download mode:

      .. warning::

          Please burn the following bit at the very end. After this bit is burned, the espefuse tool can no longer be used to burn additional eFuses.

      .. list::

          - ``ENABLE_SECURITY_DOWNLOAD``: Enable Secure ROM download mode

          The eFuse can be burned by running:

          .. code:: bash

            espefuse.py --port"
" PORT burn_efuse ENABLE_SECURITY_DOWNLOAD

Secure Boot V2 Guidelines
~~~~~~~~~~~~~~~~~~~~~~~~~

.. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS
"
"Secure Boot




.. important::

    All references in this document are related to Secure Boot V1, i.e., the AES-based Secure Boot Scheme. For ESP32 v3.0 onwards, the preferred secure boot scheme is :doc:`secure-boot-v2`.

    Please refer to :doc:`secure-boot-v2` for ESP32 v3.0 or ESP32-S2.

Secure boot is a feature for ensuring only your code can run on the chip. Data loaded from flash is verified on each reset.

Secure boot is separate from the :doc:`flash-encryption` feature, and you can use"
" secure boot without encrypting the flash contents. However, for a secure environment, both should be used simultaneously. See :ref:`secure-boot-and-flash-encr` for more details.

.. important::

    Enabling secure boot limits your options for further updates of your {IDF_TARGET_NAME}. Make sure to read this document thoroughly and understand the implications of enabling secure boot.


Background


- Most data is stored in flash. Flash access does not need to be protected from physical access f"
"or secure boot to function, because critical data is stored in eFuses internal to the chip and is non-software-accessible.

- eFuses are used to store the secure boot information permanently. The secure boot key is stored in eFuse BLOCK2, and also, a single eFuse bit ABS_DONE_0 is burned, or written to 1, to permanently enable secure boot on the chip. For more details on eFuses, see *{IDF_TARGET_NAME} Technical Reference Manual* > *eFuse Controller (EFUSE)* [`PDF `__].

- To understand the secur"
"e boot process, please familiarize yourself with the standard :doc:`../api-guides/startup`.

- Both stages of the boot process, including initial software bootloader load and subsequent partition & app loading, are verified by the secure boot process, in a chain of trust relationship.


Secure Boot Process Overview


This is a high-level overview of the secure boot process. Step-by-step instructions are supplied under :ref:`secure-boot-how-to`. Further in-depth details are supplied under :ref:`s"
"ecure-boot-technical-details`:

   - Hardware secure boot support generates a device-secure bootloader key and a secure digest. The secure bootloader key is generated with the help of the hardware RNG, and then stored in eFuse with read and write protection enabled. The digest is derived from the key, an initialization vector (IV), and the bootloader image contents.
   - The secure digest is flashed at offset 0x0 in the flash.
   - Depending on Secure Boot Configuration, eFuses are burned to dis"
"able JTAG and the ROM BASIC interpreter. It is **strongly recommended** that these options are turned on.
   - Bootloader permanently enables secure boot by burning the ABS_DONE_0 eFuse. The software bootloader then becomes protected. After this point, the chip will only boot a bootloader image if the digest matches.


Keys


The following keys are used by the secure boot process:

- The secure bootloader key is a 256-bit AES key that is stored in eFuse block 2. The bootloader can generate this "
"key itself from the internal hardware random number generator, and you do not need to supply it. It is optionally possible to supply this key, see :ref:`secure-boot-reflashable`. The eFuse holding this key is read and write protected before the secure boot is enabled to prevent further software access of the key.

  - By default, the eFuse Block 2 Coding Scheme is ``None`` and a 256-bit key is stored in this block. On some versions of {IDF_TARGET_NAME}s, the Coding Scheme is set to ``3/4 Encodin"
"g`` with CODING_SCHEME eFuse has value 1, and a 192-bit key must be stored in this block.

  .. only:: esp32

    For more details, see *{IDF_TARGET_NAME} Technical Reference Manual* > *eFuse Controller (EFUSE)* > *System Parameter coding_scheme* [`PDF `__].

  The algorithm operates on a 256-bit key in all cases. 192-bit keys are extended by repeating some bits, see :ref:`secure-bootloader-digest-algorithm`.

- ``secure boot signing key`` is a standard ECDSA public/private key pair in PEM forma"
"t, see :ref:`secure-boot-image-signing-algorithm`.

  - The public key from this key pair is compiled into the software bootloader. It is only used for signature verification purposes and not signature creation. This public key is used to verify the second stage of booting, including the partition table and app image, before booting continues. The public key can be freely distributed; it does not need to be kept secret.

  - The private key from this key pair **must be securely kept private**, a"
"s anyone who has this key can authenticate to any bootloader that is configured with a secure boot and the matching public key.


Bootloader Size


Enabling secure boot and/or flash encryption will increase the size of the bootloader, which might require updating the partition table offset. See :ref:`bootloader-size`.


.. _secure-boot-how-to:

How to Enable Secure Boot


.. important::

   A signing key generated this way will use the best random number source available to the OS and its Python"
" installation, i.e., `/dev/urandom` on OSX/Linux and `CryptGenRandom()` on Windows. If this random number source is weak, then the private key will be weak.

.. important::

   For production environments, we recommend generating the key pair using OpenSSL or another industry-standard encryption program. See :ref:`secure-boot-generate-key` for more details.

.. _secure-boot-resume-normal-flashing:

.. note::

  ``idf.py flash`` does not flash the bootloader if secure boot is enabled.

.. note::
"
"
  The secure boot will not be enabled until after a valid partition table and app image have been flashed. This is to prevent accidents before the system is fully configured.

.. note::

  If {IDF_TARGET_NAME} is reset or powered down during the first boot, it will start the process again on the next boot.


.. _secure-boot-reflashable:

Reflashable Software Bootloader


Configuration ``Secure Boot: One-Time Flash`` is the recommended configuration for production devices. In this mode, each dev"
"ice gets a unique key that is never stored outside the device.

However, an alternative mode :ref:`CONFIG_SECURE_BOOTLOADER_MODE` is also available. This mode allows you to supply a binary key file that is used for the secure bootloader key. As you have the key file, you can generate new bootloader images and secure boot digests for them.

In the ESP-IDF build process, this 256-bit key file is derived from the ECDSA app signing key generated by the user, see the :ref:`secure-boot-generate-key` s"
"tep below. This private key's SHA-256 digest is used as the secure bootloader key in eFuse, as-is for Coding Scheme ``None``, or truncated to 192 bytes for ``3/4 Encoding``. This is a convenience so you only need to generate or protect a single private key.

.. note::

  Although it is possible, we strongly recommend not generating one secure boot key and flashing it to every device in a production environment. The ``One-Time Flash`` option is recommended for production environments.

To enable "
"a reflashable bootloader:


.. _secure-boot-generate-key:

Generating Secure Boot Signing Key


The build system will prompt you with a command to generate a new signing key via ``espsecure.py generate_signing_key``. This uses the python-ecdsa library, which in turn uses Python's ``os.urandom()`` as a random number source.

The strength of the signing key is proportional to the random number source of the system, and the correctness of the algorithm used. For production devices, we recommend gen"
"erating signing keys from a system with a quality entropy source and using the best available EC key generation utilities.

For example, to generate a signing key using the OpenSSL command line:

.. code-block::

  openssl ecparam -name prime256v1 -genkey -noout -out my_secure_boot_signing_key.pem

Remember that the strength of the secure boot system depends on keeping the signing key private.


.. _remote-sign-image:

Remote Signing of Images


For production builds, it can be good practice to "
"use a remote signing server rather than have the signing key on the build machine, which is the default ESP-IDF secure boot configuration. The ``espsecure.py`` command line program can be used to sign app images & partition table data for secure boot, on a remote system.

To use remote signing, disable the option ``Sign binaries during build``. The private signing key does not need to be present on the build system. However, the public signature verification key is required because it is compile"
"d into the bootloader, and can be used to verify image signatures during OTA updates.

To extract the public key from the private key:

.. code-block::

  espsecure.py extract_public_key --keyfile PRIVATE_SIGNING_KEY PUBLIC_VERIFICATION_KEY

The path to the public signature verification key needs to be specified in the menuconfig under ``Secure boot public signature verification key`` in order to build the secure bootloader.

After the app image and partition table are built, the build system wi"
"ll print signing steps using ``espsecure.py``:

.. code-block::

  espsecure.py sign_data --keyfile PRIVATE_SIGNING_KEY BINARY_FILE

The above command appends the image signature to the existing binary. You can use the `--output` argument to write the signed binary to a separate file:

.. code-block::

  espsecure.py sign_data --keyfile PRIVATE_SIGNING_KEY --output SIGNED_BINARY_FILE BINARY_FILE


Secure Boot Best Practices



.. _secure-boot-technical-details:

Technical Details


The following"
" sections contain low-level reference descriptions of various secure boot elements:


.. _secure-boot-hardware-support:

Secure Boot Hardware Support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first stage of secure boot verification, i.e., checking the software bootloader, is done via hardware. The {IDF_TARGET_NAME}'s secure boot support hardware can perform three basic operations:


.. _secure-bootloader-digest-algorithm:

Secure Bootloader Digest Algorithm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting w"
"ith an ""image"" of binary data as input, this algorithm generates a digest as output. The digest is sometimes referred to as an ""abstract"" in hardware documentation.

For a Python version of this algorithm, see the ``espsecure.py`` tool in the :component:`/esptool_py` directory. Specifically, the ``digest_secure_bootloader`` command.

Items marked with (^) are to fulfill hardware restrictions, as opposed to cryptographic restrictions.

   - Reverse the byte order of the plaintext input block. (^)"
"
   - Apply AES256 in ECB mode to the plaintext block.
   - Reverse the byte order of the ciphertext output block. (^)
   - Append to the overall ciphertext output.

Output digest is 192 bytes of data: the 128-byte IV, followed by the 64-byte SHA-512 digest.


.. _secure-boot-image-signing-algorithm:

Image Signing Algorithm
~~~~~~~~~~~~~~~~~~~~~~~

Deterministic ECDSA as specified by `RFC 6979 `_.

- Curve is NIST256p. OpenSSL calls this curve prime256v1, and it is also sometimes called secp256"
"r1.
- The hash function is SHA256.
- The key format used for storage is PEM.

  - In the bootloader, the public key for signature verification is flashed as 64 raw bytes.

- Image signature is 68 bytes: a 4-byte version word (currently zero), followed by 64 bytes of signature data. These 68 bytes are appended to an app image or partition table data.


Manual Commands
~~~~~~~~~~~~~~~

Secure boot is integrated into the ESP-IDF build system, so ``idf.py build`` will automatically sign an app image"
" if secure boot is enabled. ``idf.py bootloader`` will produce a bootloader digest if menuconfig is configured for it.

However, it is possible to use the ``espsecure.py`` tool to make standalone signatures and digests.

To sign a binary image:

.. code-block::

  espsecure.py sign_data --keyfile ./my_signing_key.pem --output ./image_signed.bin image-unsigned.bin

The keyfile is the PEM file containing an ECDSA private signing key.

To generate a bootloader digest:

.. code-block::

  espsecure."
"py digest_secure_bootloader --keyfile ./securebootkey.bin --output ./bootloader-digest.bin build/bootloader/bootloader.bin

The keyfile is the 32-byte raw secure boot key for the device.

The output of the ``espsecure.py digest_secure_bootloader`` command is a single file that contains both the digest and the bootloader appended to it. To flash the combined digest plus bootloader to the device:

.. code-block::

  esptool.py write_flash 0x0 bootloader-digest.bin


.. _secure-boot-and-flash-encr:"
"

Secure Boot & Flash Encryption


If secure boot is used without :doc:`flash-encryption`, it is possible to launch a ``time-of-check to time-of-use`` attack, where flash contents are swapped after the image is verified and running. Therefore, it is recommended to use both features together.


.. _signed-app-verify:

Signed App Verification Without Hardware Secure Boot


The integrity of apps can be checked even without enabling the hardware secure boot option. This option uses the same app sign"
"ature scheme as hardware secure boot, but unlike hardware secure boot, it does not prevent the bootloader from being physically updated. This means that the device can be secured against remote network access, but not physical access. Compared to using hardware secure boot, this option is much simpler to implement. See :ref:`signed-app-verify-how-to` for step-by-step instructions.

An app can be verified on update and, optionally, be verified on boot.

- Verification on update: When enabled, the"
" signature is automatically checked whenever the ``esp_ota_ops.h`` APIs are used for OTA updates. If hardware secure boot is enabled, this option is always enabled and cannot be disabled. If hardware secure boot is not enabled, this option still adds significant security against network-based attackers by preventing spoofing of OTA updates.

- Verification on boot: When enabled, the bootloader will be compiled with code to verify that an app is signed before booting it. If hardware secure boot i"
"s enabled, this option is always enabled and cannot be disabled. If hardware secure boot is not enabled, this option does not add significant security by itself so most users will want to leave it disabled.


.. _signed-app-verify-how-to:

How To Enable Signed App Verification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In this case, the private signing key should be generated by following instructions in :ref:`secure-boot-generate-key`; the public verification key and signed image should be gener"
"ated by following instructions in :ref:`remote-sign-image`.


Advanced Features


JTAG Debugging
~~~~~~~~~~~~~~

By default, when secure boot is enabled, JTAG debugging is disabled via eFuse. The bootloader does this on the first boot, at the same time it enables secure boot.

See :ref:`jtag-debugging-security-features` for more information about using JTAG Debugging with either secure boot or signed app verification enabled.
"
":orphan:

Secure Boot V2


{IDF_TARGET_SBV2_SCHEME:default=""RSA-PSS"", esp32c2=""ECDSA"", esp32c6=""RSA-PSS or ECDSA"", esp32h2=""RSA-PSS or ECDSA"", esp32p4=""RSA-PSS or ECDSA""}

{IDF_TARGET_SBV2_KEY:default=""RSA-3072"", esp32c2=""ECDSA-256 or ECDSA-192"", esp32c6=""RSA-3072, ECDSA-256, or ECDSA-192"", esp32h2=""RSA-3072, ECDSA-256, or ECDSA-192"", esp32p4=""RSA-3072, ECDSA-256, or ECDSA-192""}

{IDF_TARGET_SECURE_BOOT_OPTION_TEXT:default="""", esp32c6=""RSA is recommended because of faster verification time. You "
"can choose between RSA and ECDSA scheme from the menu."", esp32h2=""RSA is recommended because of faster verification time. You can choose between RSA and ECDSA scheme from the menu."", esp32p4=""RSA is recommended because of faster verification time. You can choose between RSA and ECDSA scheme from the menu.""}

{IDF_TARGET_ECO_VERSION:default="""", esp32=""(ECO 3 onwards)"", esp32c3=""(ECO 3 onwards)""}

{IDF_TARGET_RSA_TIME:default="""", esp32c6=""~2.7 ms"", esp32h2=""~4.5 ms""}

{IDF_TARGET_ECDSA_TIME:defaul"
"t="""", esp32c6=""~21.5 ms"", esp32h2=""~36 ms""}

{IDF_TARGET_CPU_FREQ:default="""", esp32c6=""160 MHz"", esp32h2=""96 MHz""}

{IDF_TARGET_SBV2_DEFAULT_SCHEME:default=""RSA"", esp32c2=""ECDSA (V2)""}

.. important::

    This document is about Secure Boot V2, supported on {IDF_TARGET_NAME} {IDF_TARGET_ECO_VERSION}

    .. only:: esp32

        For ESP32 before ECO3, refer to :doc:`secure-boot-v1`. It is recommended that users use Secure Boot V2 if they have a chip version that supports it. Secure Boot V2 is sa"
"fer and more flexible than Secure Boot V1.

    Secure Boot V2 uses {IDF_TARGET_SBV2_SCHEME} based app and bootloader (:ref:`second-stage-bootloader`) verification. This document can also be used as a reference for signing apps using the {IDF_TARGET_SBV2_SCHEME} scheme without signing the bootloader.

.. only:: esp32

    ``Secure Boot V2`` and RSA scheme (``App Signing Scheme``) options are available for ESP32 from ECO3 onwards. To use these options in menuconfig, set :ref:`CONFIG_ESP32_REV_MIN"
"` greater than or equal to `Rev 3`.

.. only:: esp32c3

    ``Secure Boot V2`` is available for ESP32-C3 from ECO3 onwards. To use these options in menuconfig, set :ref:`CONFIG_ESP32C3_REV_MIN` greater than or equal to `Rev 3`.

Background


Secure Boot protects a device from running any unauthorized (i.e., unsigned) code by checking that each piece of software that is being booted is signed. On an {IDF_TARGET_NAME}, these pieces of software include the second stage bootloader and each applicati"
"on binary. Note that the first stage bootloader does not require signing as it is ROM code thus cannot be changed.

.. only:: esp32 or (SOC_SECURE_BOOT_V2_RSA and not SOC_SECURE_BOOT_V2_ECC)

    A RSA based Secure Boot verification scheme (Secure Boot V2) is implemented on {IDF_TARGET_NAME} {IDF_TARGET_ECO_VERSION}.

.. only:: SOC_SECURE_BOOT_V2_ECC and not SOC_SECURE_BOOT_V2_RSA

    A ECC based Secure Boot verification scheme (Secure Boot V2) has been introduce on {IDF_TARGET_NAME}

.. only::"
" SOC_SECURE_BOOT_V2_RSA and SOC_SECURE_BOOT_V2_ECC

    {IDF_TARGET_NAME} has provision to choose between a {IDF_TARGET_SBV2_SCHEME} based secure boot verification scheme.

The Secure Boot process on the {IDF_TARGET_NAME} involves the following steps:

Advantages


- The {IDF_TARGET_SBV2_SCHEME} public key is stored on the device. The corresponding {IDF_TARGET_SBV2_SCHEME} private key is kept at a secret place and is never accessed by the device.

.. only:: esp32 or esp32c2

    - Only one publi"
"c key can be generated and stored in the chip during manufacturing.

.. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

    - Up to three public keys can be generated and stored in the chip during manufacturing.

    - {IDF_TARGET_NAME} provides the facility to permanently revoke individual public keys. This can be configured conservatively or aggressively.

    - Conservatively - The old key is revoked after the bootloader and application have successfully migrated to a new key. Aggressively - The ke"
"y is revoked as soon as verification with this key fails.

- Same image format and signature verification method is applied for applications and software bootloader.

- No secrets are stored on the device. Therefore, it is immune to passive side-channel attacks (timing or power analysis, etc.)


Secure Boot V2 Process


This is an overview of the Secure Boot V2 Process. Instructions how to enable Secure Boot are supplied in section :ref:`secure-boot-v2-howto`.

Secure Boot V2 verifies the bootlo"
"ader image and application binary images using a dedicated *signature block*. Each image has a separately generated signature block which is appended to the end of the image.

.. only:: esp32

  Only one signature block can be appended to the bootloader or application image in ESP32 ECO3.

.. only:: esp32c2

  Only one signature block can be appended to the bootloader or application image in {IDF_TARGET_NAME}

.. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

  Up to 3 signature blocks can be appende"
"d to the bootloader or application image in {IDF_TARGET_NAME}.

Each signature block contains a signature of the preceding image as well as the corresponding {IDF_TARGET_SBV2_KEY} public key. For more details about the format, refer to :ref:`signature-block-format`. A digest of the {IDF_TARGET_SBV2_KEY} public key is stored in the eFuse.

The application image is not only verified on every boot but also on each over the air (OTA) update. If the currently selected OTA app image cannot be verified"
", the bootloader will fall back and look for another correctly signed application image.

The Secure Boot V2 process follows these steps:

.. _signature-block-format:

Signature Block Format


The signature block starts on a 4 KB aligned boundary and has a flash sector of its own. The signature is calculated over all bytes in the image including the padding bytes (:ref:`secure_padding`).

.. only:: SOC_SECURE_BOOT_V2_RSA and SOC_SECURE_BOOT_V2_ECC

    .. note::

        {IDF_TARGET_NAME} has a "
"provision to choose between RSA scheme and ECDSA scheme. Only one scheme can be used per device.

        ECDSA provides similar security strength, compared to RSA, with shorter key lengths. Current estimates are that ECDSA with curve P-256 has an approximate equivalent strength to RSA with 3072-bit keys. However, ECDSA signature verification takes considerably more amount of time as compared to RSA signature verification.

        RSA is recommended for use cases where fast bootup time is requi"
"red whereas ECDSA is recommended for use cases where shorter key length is required.

        .. only:: not esp32p4

            .. list-table:: Comparison between signature verification time
                :widths: 10 10 20
                :header-rows: 1
                  - **Time**
                  - **CPU Frequency**
                  - {IDF_TARGET_RSA_TIME}
                  - {IDF_TARGET_CPU_FREQ}
                  - {IDF_TARGET_ECDSA_TIME}
                  - {IDF_TARGET_CPU_FREQ}

    "
"      The above table compares the time taken to verify a signature in a particular scheme. It does not indicate the bootup time.

The content of each signature block is shown in the following table:

.. only:: esp32 or SOC_SECURE_BOOT_V2_RSA

    .. list-table:: Content of a RSA Signature Block
        :widths: 10 10 40
        :header-rows: 1
          - **Size (bytes)**
          - **Description**
          - 1
          - Magic byte
          - 1
          - Version number byte (currently 0x"
"02), 0x01 is for Secure Boot V1.
          - 2
          - Padding bytes, Reserved. Should be zero.
          - 32
          - SHA-256 hash of only the image content, not including the signature block.
          - 384
          - RSA Public Modulus used for signature verification. (value ‘n’ in RFC8017).
          - 4
          - RSA Public Exponent used for signature verification (value ‘e’ in RFC8017).
          - 384
          - Pre-calculated R, derived from ‘n’.
          - 4
          - Pr"
"e-calculated M’, derived from ‘n’
          - 384
          - RSA-PSS Signature result (section 8.1.1 of RFC8017) of image content, computed using following PSS parameters: SHA256 hash, MGF1 function, salt length 32 bytes, default trailer field (0xBC).
          - 4
          - CRC32 of the preceding 1196 bytes.
          - 16
          - Zero padding to length 1216 bytes.


    .. note::

      R and M' are used for hardware-assisted Montgomery Multiplication.

.. only:: SOC_SECURE_BOOT_V2_ECC
"
"
    .. list-table:: Content of a ECDSA Signature Block
        :widths: 10 10 40
        :header-rows: 1
          - **Size (bytes)**
          - **Description**
          - 1
          - Magic byte.
          - 1
          - Version number byte (currently 0x03).
          - 2
          - Padding bytes, Reserved. Should be zero.
          - 32
          - SHA-256 hash of only the image content, not including the signature block.
          - 1
          - Curve ID (1 for NIST192p curve. 2 for NI"
"ST256p curve).
          - 64
          - ECDSA Public key: 32 byte X coordinate followed by 32 byte Y coordinate.
          - 64
          - ECDSA Signature result (section 5.3.2 of RFC6090) of the image content: 32 byte R component followed by 32 byte S component.
          - 1031
          - Reserved.
          - 4
          - CRC32 of the preceding 1196 bytes.
          - 16
          - Zero padding to length 1216 bytes.

The remainder of the signature sector is erased flash (0xFF) which all"
"ows writing other signature blocks after previous signature block.

.. _secure_padding:

Secure Padding


In Secure Boot V2 scheme, the application image is padded to the flash MMU page size boundary to ensure that only verified contents are mapped in the internal address space. This is known as secure padding. Signature of the image is calculated after padding and then signature block (4KB) gets appended to the image.

.. list::

    - Default flash MMU page size is 64KB
    :SOC_MMU_PAGE_SIZE_"
"CONFIGURABLE: - {IDF_TARGET_NAME} supports configurable flash MMU page size, it (``CONFIG_MMU_PAGE_SIZE``) gets set based on the :ref:`CONFIG_ESPTOOLPY_FLASHSIZE`
    - Secure padding is applied through the option ``--secure-pad-v2`` in the ``elf2image`` conversion using ``esptool.py``

Following table explains the Secure Boot V2 signed image with secure padding and signature block appended:

.. list-table:: Contents of a signed application
        :widths: 20 20 20
        :header-rows: 1
     "
"     - **Size (KB)**
          - **Description**
          - 580
          - Unsigned application size (as an example)
          - 60
          - Secure padding (aligned to next 64KB boundary)
          - 4
          - Signature block

.. note::

    Please note that the application image always starts on the next flash MMU page size boundary (default 64KB) and hence the space left over after the signature block shown above can be utilized to store any other data partitions (e.g., ``nvs``).

.. "
"_verify_signature-block:

Verifying a Signature Block


A signature block is ""valid"" if the first byte is 0xe7 and a valid CRC32 is stored at offset 1196. Otherwise it is invalid.

.. _verify_image:

Verifying an Image


An image is ""verified"" if the public key stored in any signature block is valid for this device, and if the stored signature is valid for the image data read from flash.

.. only:: esp32 or (SOC_SECURE_BOOT_V2_RSA and not SOC_SECURE_BOOT_V2_ECC)

.. only:: SOC_SECURE_BOOT_V2_ECC"
" and not SOC_SECURE_BOOT_V2_RSA

.. only:: SOC_SECURE_BOOT_V2_ECC and SOC_SECURE_BOOT_V2_RSA


Bootloader Size


Enabling Secure boot and/or flash encryption will increase the size of bootloader, which might require updating partition table offset. See :ref:`bootloader-size`.

In the case when :ref:`CONFIG_SECURE_BOOT_BUILD_SIGNED_BINARIES` is disabled, the bootloader is sector padded (4KB) using the ``--pad-to-size`` option in ``elf2image`` command of ``esptool``.

.. _efuse-usage:

eFuse Usage"
"


.. only:: esp32

    ESP32-ECO3:

    - ABS_DONE_1 - Enables Secure Boot protection on boot.

    - BLK2 - Stores the SHA-256 digest of the public key. SHA-256 hash of public key modulus, exponent, pre-calculated R & M' values (represented as 776 bytes – offsets 36 to 812 - as per the :ref:`signature-block-format`) is written to an eFuse key block. The write-protection bit must be set, but the read-protection bit must not.

.. only:: not esp32

    - SECURE_BOOT_EN - Enables Secure Boot prote"
"ction on boot.

.. only:: SOC_EFUSE_KEY_PURPOSE_FIELD

    - KEY_PURPOSE_X - Set the purpose of the key block on {IDF_TARGET_NAME} by programming SECURE_BOOT_DIGESTX (X = 0, 1, 2) into KEY_PURPOSE_X (X = 0, 1, 2, 3, 4, 5). Example: If KEY_PURPOSE_2 is set to SECURE_BOOT_DIGEST1, then BLOCK_KEY2 will have the Secure Boot V2 public key digest. The write-protection bit must be set (this field does not have a read-protection bit).

    - BLOCK_KEYX - The block contains the data corresponding to its "
"purpose programmed in KEY_PURPOSE_X. Stores the SHA-256 digest of the public key. SHA-256 hash of public key modulus, exponent, pre-calculated R & M' values (represented as 776 bytes – offsets 36 to 812 - as per the :ref:`signature-block-format`) is written to an eFuse key block. The write-protection bit must be set, but the read-protection bit must not.

    - KEY_REVOKEX - The revocation bits corresponding to each of the 3 key block. Ex. Setting KEY_REVOKE2 revokes the key block whose key purp"
"ose is SECURE_BOOT_DIGEST2.

    - SECURE_BOOT_AGGRESSIVE_REVOKE - Enables aggressive revocation of keys. The key is revoked as soon as verification with this key fails.

    To ensure no trusted keys can be added later by an attacker, each unused key digest slot should be revoked (KEY_REVOKEX). It will be checked during app startup in :cpp:func:`esp_secure_boot_init_checks` and fixed unless :ref:`CONFIG_SECURE_BOOT_ALLOW_UNUSED_DIGEST_SLOTS` is enabled.

The key(s) must be readable in order to "
"give software access to it. If the key(s) is read-protected then the software reads the key(s) as all zeros and the signature verification process will fail, and the boot process will be aborted.

.. _secure-boot-v2-howto:

How To Enable Secure Boot V2


.. only:: esp32

.. only:: SOC_SECURE_BOOT_V2_RSA or SOC_SECURE_BOOT_V2_ECC

.. important::
   A signing key generated this way will use the best random number source available to the OS and its Python installation (`/dev/urandom` on OSX/Linux a"
"nd `CryptGenRandom()` on Windows). If this random number source is weak, then the private key will be weak.

.. important::
   For production environments, we recommend generating the key pair using openssl or another industry standard encryption program. See :ref:`secure-boot-v2-generate-key` for more details.

.. note::

  ``idf.py flash`` does not flash the bootloader if Secure Boot is enabled.

.. note::

  Secure boot will not be enabled until after a valid partition table and app image hav"
"e been flashed. This is to prevent accidents before the system is fully configured.

.. note::

  If the {IDF_TARGET_NAME} is reset or powered down during the first boot, it will start the process again on the next boot.

Restrictions After Secure Boot Is Enabled


- Any updated bootloader or app will need to be signed with a key matching the digest already stored in eFuse.

- After Secure Boot is enabled, no further eFuses can be read protected. (If :doc:`/security/flash-encryption` is enabled "
"then the bootloader will ensure that any flash encryption key generated on first boot will already be read protected.) If :ref:`CONFIG_SECURE_BOOT_INSECURE` is enabled then this behavior can be disabled, but this is not recommended.

- Please note that enabling Secure Boot or flash encryption disables the USB-OTG USB stack in the ROM, disallowing updates via the serial emulation or Device Firmware Update (DFU) on that port.

.. _secure-boot-v2-generate-key:

Generating Secure Boot Signing Key


"
"The build system will prompt you with a command to generate a new signing key via ``espsecure.py generate_signing_key``.

.. only:: esp32 or SOC_SECURE_BOOT_V2_RSA

   The ``--version 2`` parameter will generate the RSA 3072 private key for Secure Boot V2. Additionally ``--scheme rsa3072`` can be passed as well to generate RSA 3072 private key

.. only:: SOC_SECURE_BOOT_V2_ECC

   Select the ECDSA scheme by passing ``--version 2 --scheme ecdsa256`` or ``--version 2 --scheme ecdsa192`` to generat"
"e corresponding ECDSA private key

The strength of the signing key is proportional to (a) the random number source of the system, and (b) the correctness of the algorithm used. For production devices, we recommend generating signing keys from a system with a quality entropy source, and using the best available {IDF_TARGET_SBV2_SCHEME} key generation utilities.

For example, to generate a signing key using the openssl command line:

.. only:: esp32 or SOC_SECURE_BOOT_V2_RSA

    For RSA 3072

   "
" 

.. only:: SOC_SECURE_BOOT_V2_ECC

    For ECC NIST192p curve

    

    For ECC NIST256p curve

    

Remember that the strength of the Secure Boot system depends on keeping the signing key private.

.. _remote-sign-v2-image:

Remote Signing of Images


Signing Using ``espsecure.py``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For production builds, it can be good practice to use a remote signing server rather than have the signing key on the build machine (which is the default esp-idf Secure Boot config"
"uration). The espsecure.py command line program can be used to sign app images & partition table data for Secure Boot, on a remote system.

To use remote signing, disable the option :ref:`CONFIG_SECURE_BOOT_BUILD_SIGNED_BINARIES` and build the firmware. The private signing key does not need to be present on the build system.

After the app image and partition table are built, the build system will print signing steps using espsecure.py::

  espsecure.py sign_data BINARY_FILE --version 2 --keyfil"
"e PRIVATE_SIGNING_KEY

The above command appends the image signature to the existing binary. You can use the `--output` argument to write the signed binary to a separate file::

  espsecure.py sign_data --version 2 --keyfile PRIVATE_SIGNING_KEY --output SIGNED_BINARY_FILE BINARY_FILE

Signing Using Pre-calculated Signatures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you have valid pre-calculated signatures generated for an image and their corresponding public keys, you can use these signatures "
"to generate a signature sector and append it to the image. Note that the pre-calculated signature should be calculated over all bytes in the image including the secure-padding bytes.

In such cases, the firmware image should be built by disabling the option :ref:`CONFIG_SECURE_BOOT_BUILD_SIGNED_BINARIES`. This image will be secure-padded and to generate a signed binary use the following command::

  espsecure.py sign_data --version 2 --pub-key PUBLIC_SIGNING_KEY --signature SIGNATURE_FILE --outp"
"ut SIGNED_BINARY_FILE BINARY_FILE

The above command verifies the signature, generates a signature block (refer to :ref:`signature-block-format`) and appends it to the binary file.


Signing Using an External Hardware Security Module (HSM)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For security reasons, you might also use an external Hardware Security Module (HSM) to store your private signing key, which cannot be accessed directly but has an interface to generate the signature of"
" a binary file and its corresponding public key.

In such cases, disable the option :ref:`CONFIG_SECURE_BOOT_BUILD_SIGNED_BINARIES` and build the firmware. This secure-padded image then can be used to supply the external HSM for generating a signature. Refer to `Signing using an External HSM `_ to generate a signed image.

.. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

    .. note:: For all the above three remote signing workflows, the signed binary is written to the filename provided to the ``--o"
"utput`` argument and the option ``--append_signatures`` allows us to append multiple signatures (up to 3) the image.

.. only:: not SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

    .. note:: For all the above three remote signing workflows, the signed binary is written to the filename provided to the ``--output`` argument.



Secure Boot Best Practices


.. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

    Key Management
    

    Multiple Keys
    
        espsecure.py sign_data -k secure_boot_signing_key2.p"
"em -v 2 --append_signatures -o signed_bootloader.bin build/bootloader/bootloader.bin
        espsecure.py signature_info_v2 datafile.bin

    Key Revocation
    

    .. note::

        Note that enabling the config :ref:`CONFIG_SECURE_BOOT_ALLOW_UNUSED_DIGEST_SLOTS` only makes sure that the **app** does not revoke the unused digest slots.
        But if you plan to enable secure boot during the fist boot up, the bootloader will intentionally revoke the unused digest slots while enabling secure "
"boot, even if the above config is enabled because keeping the unused key slots un-revoked would a security hazard.
        In case for any development workflow if you need to avoid this revocation, you should enable secure boot externally (:ref:`enable-secure-boot-v2-externally`) rather than enabling it during the boot up, so that the bootloader would not need to enable secure boot and thus you could avoid its revocation strategy.

    Conservative Approach:
    ~~~~~~~~~~~~~~~~~~~~~~

    Assum"
"ing a trusted private key (N-1) has been compromised, to update to new key pair (N).

    .. _secure-boot-v2-aggressive-key-revocation:

    Aggressive Approach:
    ~~~~~~~~~~~~~~~~~~~~

    ROM code has an additional feature of revoking a public key digest if the signature verification fails.

    To enable this feature, you need to burn SECURE_BOOT_AGGRESSIVE_REVOKE efuse or enable :ref:`CONFIG_SECURE_BOOT_ENABLE_AGGRESSIVE_KEY_REVOKE`

    Key revocation is not applicable unless secure boot "
"is successfully enabled. Also, a key is not revoked in case of invalid signature block or invalid image digest, it is only revoked in case the signature verification fails, i.e., revoke key only if failure in step 3 of :ref:`verify_image`

    Once a key is revoked, it can never be used for verfying a signature of an image. This feature provides strong resistance against physical attacks on the device. However, this could also brick the device permanently if all the keys are revoked because of s"
"ignature verification failure.

.. _secure-boot-v2-technical-details:

Technical Details


The following sections contain low-level reference descriptions of various Secure Boot elements:

Manual Commands
~~~~~~~~~~~~~~~

Secure boot is integrated into the esp-idf build system, so ``idf.py build`` will sign an app image and ``idf.py bootloader`` will produce a signed bootloader if secure signed binaries on build is enabled.

However, it is possible to use the ``espsecure.py`` tool to make standa"
"lone signatures and digests.

To sign a binary image::

  espsecure.py sign_data --version 2 --keyfile ./my_signing_key.pem --output ./image_signed.bin image-unsigned.bin

Keyfile is the PEM file containing an {IDF_TARGET_SBV2_KEY} private signing key.

.. _secure-boot-v2-and-flash-encr:

Secure Boot & Flash Encryption


If Secure Boot is used without :doc:`flash-encryption`, it is possible to launch ""time-of-check to time-of-use"" attack, where flash contents are swapped after the image is verif"
"ied and running. Therefore, it is recommended to use both the features together.

.. only:: esp32c2

    .. important::
       {IDF_TARGET_NAME} has only one eFuse key block, which is used for both keys: Secure Boot and Flash Encryption. The eFuse key block can only be burned once. Therefore these keys should be burned together at the same time. Please note that ""Secure Boot"" and ""Flash Encryption"" can not be enabled separately as subsequent writes to eFuse key block shall return an error.

.. _"
"signed-app-verify-v2:

Signed App Verification Without Hardware Secure Boot


The Secure Boot V2 signature of apps can be checked on OTA update, without enabling the hardware Secure Boot option. This option uses the same app signature scheme as Secure Boot V2, but unlike hardware Secure Boot it does not prevent an attacker who can write to flash from bypassing the signature protection.

This may be desirable in cases where the delay of Secure Boot verification on startup is unacceptable, and/or "
"where the threat model does not include physical access or attackers writing to bootloader or app partitions in flash.

In this mode, the public key which is present in the signature block of the currently running app will be used to verify the signature of a newly updated app. (The signature on the running app is not verified during the update process, it is assumed to be valid.) In this way the system creates a chain of trust from the running app to the newly updated app.

For this reason, it "
"is essential that the initial app flashed to the device is also signed. A check is run on app startup and the app will abort if no signatures are found. This is to try and prevent a situation where no update is possible. The app should have only one valid signature block in the first position. Note again that, unlike hardware Secure Boot V2, the signature of the running app is not verified on boot. The system only verifies a signature block in the first position and ignores any other appended si"
"gnatures.

.. only:: not esp32

    Although multiple trusted keys are supported when using hardware Secure Boot, only the first public key in the signature block is used to verify updates if signature checking without Secure Boot is configured. If multiple trusted public keys are required, it is necessary to enable the full Secure Boot feature instead.

.. note::

   In general, it is recommended to use full hardware Secure Boot unless certain that this option is sufficient for application secu"
"rity needs.

.. _signed-app-verify-v2-howto:

How To Enable Signed App Verification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. only:: esp32

.. only:: SOC_SECURE_BOOT_V2_RSA and not SOC_SECURE_BOOT_V2_ECC

.. only:: SOC_SECURE_BOOT_V2_ECC and not SOC_SECURE_BOOT_V2_RSA

.. only:: SOC_SECURE_BOOT_V2_RSA and SOC_SECURE_BOOT_V2_ECC

.. warning::

   It is very important that all apps flashed have been signed, either during the build or after the build.

Advanced Features


JTAG Debugging
~~~~~~~~~~~"
"~~~

By default, when Secure Boot is enabled then JTAG debugging is disabled via eFuse. The bootloader does this on first boot, at the same time it enables Secure Boot.

See :ref:`jtag-debugging-security-features` for more information about using JTAG Debugging with either Secure Boot or signed app verification enabled.
"
"Flash Encryption


{IDF_TARGET_CRYPT_CNT:default=""SPI_BOOT_CRYPT_CNT"",esp32=""FLASH_CRYPT_CNT""}

{IDF_TARGET_ESP32_V3_ONLY:default="""", esp32=""(ESP32 V3 only)""}

{IDF_TARGET_ENCRYPT_COMMAND:default=""espsecure.py encrypt_flash_data --aes_xts"", esp32=""espsecure.py encrypt_flash_data""}



This is a quick start guide to {IDF_TARGET_NAME}'s flash encryption feature. Using application code as an example, it demonstrates how to test and verify flash encryption operations during development and production"
".


Introduction


Flash encryption is intended for encrypting the contents of the {IDF_TARGET_NAME}'s off-chip flash memory. Once this feature is enabled, firmware is flashed as plaintext, and then the data is encrypted in place on the first boot. As a result, physical readout of flash will not be sufficient to recover most flash contents.

.. only:: esp32

    :doc:`Secure Boot ` is a separate feature which can be used together with flash encryption to create an even more secure environment.

"
".. important::

   For production use, flash encryption should be enabled in the ""Release"" mode only.

.. important::

    Enabling flash encryption limits the options for further updates of {IDF_TARGET_NAME}. Before using this feature, read the document and make sure to understand the implications.

.. _encrypted-partitions:

Encrypted Partitions


With flash encryption enabled, the following types of data are encrypted by default:

- :ref:`second-stage-bootloader` (Firmware Bootloader)
- Parti"
"tion Table
- :ref:`nvs_encr_key_partition`
- Otadata
- All ``app`` type partitions

Other types of data can be encrypted conditionally:

- Any partition marked with the ``encrypted`` flag in the partition table. For details, see :ref:`encrypted-partition-flag`.
- Secure Boot bootloader digest if Secure Boot is enabled (see below).

.. _flash-encryption-efuse:

Relevant eFuses


The flash encryption operation is controlled by various eFuses available on {IDF_TARGET_NAME}. The list of eFuses and t"
"heir descriptions is given in the table below. The names in eFuse column are also used by espefuse.py tool. For usage in the eFuse API, modify the name by adding ``ESP_EFUSE_``, for example: esp_efuse_read_field_bit(ESP_EFUSE_DISABLE_DL_ENCRYPT).

.. Comment: As text in cells of list-table header rows does not wrap, it is necessary to make 0 header rows and apply bold typeface to the first row. Otherwise, the table goes beyond the html page limits on the right.

.. only:: not SOC_FLASH_ENCRYPTIO"
"N_XTS_AES

    .. list-table:: eFuses Used in Flash Encryption
       :widths: 25 40 10
       :header-rows: 0
         - **Description**
         - **Bit Depth**
         - Controls actual number of block1 bits used to derive final 256-bit AES key. Possible values: ``0`` for 256 bits, ``1`` for 192 bits, ``2`` for 128 bits. Final AES key is derived based on the ``FLASH_CRYPT_CONFIG`` value.
         - 2
         - AES key storage.
         - 256 bit key block
         - Controls the AES encrypt"
"ion process.
         - 4
         - If set, disables flash encryption operation while running in Firmware Download mode.
         - 1
         - If set, disables flash decryption while running in UART Firmware Download mode.
         - 1
         - A :math:`2^n` number that indicating whether the contents of flash have been encrypted.

           With each successive unencrypted flash update (e.g., flashing a new unencrypted binary) and encryption of the flash (via the :ref:`Enable flash encryp"
"tion on boot ` option), the next MSB of ``{IDF_TARGET_CRYPT_CNT}`` is set.
         - 7


.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

    .. list-table:: eFuses Used in Flash Encryption
       :widths: 25 40 10
       :header-rows: 0
         - **Description**
         - **Bit Depth**
         - AES key storage. N is between 0 and 5.
         - One 256 bit key block for XTS_AES_128, Two 256 bit key blocks for XTS_AES_256 (512 bit total)
         - Controls the purpose of eFuse block ``BLOCK_KEYN"
"``, where N is between 0 and 5. Possible values: ``2`` for ``XTS_AES_256_KEY_1`` , ``3`` for ``XTS_AES_256_KEY_2``, and ``4`` for ``XTS_AES_128_KEY``. Final AES key is derived based on the value of one or two of these purpose eFuses. For a detailed description of the possible combinations, see *{IDF_TARGET_NAME} Technical Reference Manual* > *External Memory Encryption and Decryption (XTS_AES)* [`PDF `__].
         - 4
         - If set, disables flash encryption when in download bootmodes.
    "
"     - 1
         - Enables encryption and decryption, when an SPI boot mode is set. Feature is enabled if 1 or 3 bits are set in the eFuse, disabled otherwise.
         - 3

.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

    .. list-table:: eFuses Used in Flash Encryption
       :widths: 25 40 10
       :header-rows: 0
         - **Description**
         - **Bit Depth**
         - AES key storage. N is between 0 a"
"nd 5.
         - 256 bit key block
         - Control the purpose of eFuse block ``BLOCK_KEYN``, where N is between 0 and 5. For flash encryption, the only valid value is ``4`` for ``XTS_AES_128_KEY``.
         - 4
         - If set, disable flash encryption when in download bootmodes.
         - 1
         - Enable encryption and decryption, when an SPI boot mode is set. Feature is enabled if 1 or 3 bits are set in the eFuse, disabled otherwise.
         - 3

.. only:: SOC_FLASH_ENCRYPTION_XTS_"
"AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

    .. list-table:: eFuses Used in Flash Encryption
       :widths: 25 40 10
       :header-rows: 0
         - **Description**
         - **Bit Depth**
         - Controls actual number of eFuse bits used to derive final 256-bit AES key. Possible values: ``1`` use all 256 bits of the eFuse block for the key, ``0`` use the lower 128 bits of the eFuse block for the key (the higher 128 bits are reserved for Secure Boot key). For 128 bits option, the "
"final AES key is derived as SHA256(EFUSE_KEY0_FE_128BIT).
         - 1
         - AES key storage
         - 256 or 128 key block
         - If set, disable flash encryption when in download bootmodes.
         - 1
         - Enables encryption and decryption, when an SPI boot mode is set. Feature is enabled if 1 or 3 bits are set in the eFuse, disabled otherwise.
         - 3

.. note::

Read and write access to eFuse bits is controlled by appropriate fields in the registers ``WR_DIS`` and ``RD"
"_DIS``. For more information on {IDF_TARGET_NAME} eFuses, see :doc:`eFuse manager `. To change protection bits of eFuse field using espefuse.py, use these two commands: read_protect_efuse and write_protect_efuse. Example ``espefuse.py write_protect_efuse DISABLE_DL_ENCRYPT``.

.. only:: esp32c2

    .. important::

       {IDF_TARGET_NAME} has only one eFuse key block for both keys: Secure Boot and Flash Encryption. As the eFuse key block can only be burned once, these keys should be burned toge"
"ther at the same time. Please note that ""Secure Boot"" and ""Flash Encryption"" can not be enabled separately as subsequent writes to eFuse key block shall return an error.

Flash Encryption Process


Assuming that the eFuse values are in their default states and the firmware bootloader is compiled to support flash encryption, the flash encryption process executes as shown below:

.. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

    .. list::

      :esp32s2: "
"- ``DIS_BOOT_REMAP``
      - ``DIS_DOWNLOAD_ICACHE``
      - ``DIS_DOWNLOAD_DCACHE``
      - ``HARD_DIS_JTAG``
      - ``DIS_LEGACY_SPI_BOOT``

.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

During the development stage, there is a frequent need to program different plaintext flash images and test the flash encryption process. This "
"requires that Firmware Download mode is able to load new plaintext images as many times as it might be needed. However, during manufacturing or production stages, Firmware Download mode should not be allowed to access flash contents for security reasons.

Hence, two different flash encryption configurations were created: for development and for production. For details on these configurations, see Section `Flash Encryption Configuration`_.



Flash Encryption Configuration


The following flash e"
"ncryption modes are available:

- :ref:`flash-enc-development-mode` - recommended for use only during development. In this mode, it is still possible to flash new plaintext firmware to the device, and the bootloader will transparently encrypt this firmware using the key stored in hardware. This allows, indirectly, to read out the plaintext of the firmware in flash.
- :ref:`flash-enc-release-mode` - recommended for manufacturing and production. In this mode, flashing plaintext firmware to the dev"
"ice without knowing the encryption key is no longer possible.

This section provides information on the mentioned flash encryption modes and step by step instructions on how to use them.

.. _flash-enc-development-mode:

Development Mode


During development, you can encrypt flash using either an {IDF_TARGET_NAME} generated key or external host-generated key.


Using {IDF_TARGET_NAME} Generated Key
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Development mode allows you to download multiple plaintext "
"images using Firmware Download mode.

To test flash encryption process, take the following steps:

  See how to check :ref:`flash-encryption-status`.

  .. list::

    - :ref:`Enable flash encryption on boot `.
    - :ref:`Select encryption mode ` (**Development mode** by default).
    :esp32: - :ref:`Select UART ROM download mode ` (**enabled** by default). Note that for the ESP32 target, the choice is only available when :ref:`CONFIG_ESP32_REV_MIN` level is set to 3 (ESP32 V3).
    :not esp32:"
" - :ref:`Select UART ROM download mode ` (**enabled** by default).
    :esp32s2 or esp32s3 or esp32c2: - Set :ref:`Size of generated XTS-AES key `.
    - :ref:`Select the appropriate bootloader log verbosity `.
    - Save the configuration and exit.

Enabling flash encryption will increase the size of bootloader, which might require updating partition table offset. See :ref:`bootloader-size`.

  .. code-block:: bash

      idf.py flash monitor

  .. note::

      This command does not include an"
"y user files which should be written to the partitions on the flash memory. Please write them manually before running this command otherwise the files should be encrypted separately before writing.

  This command will write to flash memory unencrypted images: the firmware bootloader, the partition table and applications. Once the flashing is complete, {IDF_TARGET_NAME} will reset. On the next boot, the firmware bootloader encrypts: the firmware bootloader, application partitions and partitions "
"marked as ``encrypted`` then resets. Encrypting in-place can take time, up to a minute for large partitions. After that, the application is decrypted at runtime and executed.

A sample output of the first {IDF_TARGET_NAME} boot after enabling flash encryption is given below:

.. include:: {IDF_TARGET_PATH_NAME}_log.inc
   :start-after: first_boot_enc
   :end-before: 

A sample output of subsequent {IDF_TARGET_NAME} boots just mentions that flash encryption is already enabled:

.. include:: {IDF_"
"TARGET_PATH_NAME}_log.inc
   :start-after: already_en_enc
   :end-before: 

At this stage, if you need to update and re-flash binaries, see :ref:`encrypt-partitions`.


.. _pregenerated-flash-encryption-key:

Using Host Generated Key
""""""""""""""""""""""""""""""""""""""""""""""""

It is possible to pre-generate a flash encryption key on the host computer and burn it into the eFuse. This allows you to pre-encrypt data on the host and flash already encrypted data without needing a plaintext flash update. This feature c"
"an be used in both :ref:`flash-enc-development-mode` and :ref:`flash-enc-release-mode`. Without a pre-generated key, data is flashed in plaintext and then {IDF_TARGET_NAME} encrypts the data in-place.

.. note::

    This option is not recommended for production, unless a separate key is generated for each individual device.

.. only:: esp32c2

    .. note::

       Note that {IDF_TARGET_NAME} only has one eFuse key block for both Secure Boot and Flash Encryption keys. Therefore, writing the hos"
"t-generated Flash Encryption key must be done with Secure Boot key (if used), otherwise Secure Boot cannot be used.

To use a host generated key, take the following steps:

  See how to check :ref:`flash-encryption-status`.

  .. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

      If :ref:`Size of generated XTS-AES key ` is AES-128 (256-bit key):
"
"
      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

      else if :ref:`Size of generated XTS-AES key ` is AES-256 (512-bit key):

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key --keylen 512 my_flash_encryption_key.bin


  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

      .. code-block:: bash

          espsecure.py gene"
"rate_flash_encryption_key my_flash_encryption_key.bin

.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

      If :ref:`Size of generated XTS-AES key ` is AES-128 (256-bit key):

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

      else if :ref:`Size of generated XTS-AES key ` is AES-128 key derived from 128 bits (SHA256(128 bits)):

      .. code-block:: bash

          espsecure.py generate_flash_e"
"ncryption_key --keylen 128 my_flash_encryption_key.bin

  .. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

    .. code-block:: bash

        espefuse.py --port PORT burn_key flash_encryption my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin KEYPURPOSE

    where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``. And ``KEYPURPOSE`` is either ``AES_256_KEY_1"
"``, ``XTS_AES_256_KEY_2``, ``XTS_AES_128_KEY``. See `{IDF_TARGET_NAME} Technical Reference Manual `_ for a description of the key purposes.

    For AES-128 (256-bit key) - ``XTS_AES_128_KEY``:

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_128_KEY

    For AES-256 (512-bit key) - ``XTS_AES_256_KEY_1`` and ``XTS_AES_256_KEY_2``. ``espefuse.py`` supports burning both these two key purposes together with a 512 bit key to two separate k"
"ey blocks via the virtual key purpose ``XTS_AES_256_KEY``. When this is used ``espefuse.py`` will burn the first 256 bit of the key to the specified ``BLOCK`` and burn the corresponding block key purpose to ``XTS_AES_256_KEY_1``. The last 256 bit of the key will be burned to the first free key block after ``BLOCK`` and the corresponding block key purpose to ``XTS_AES_256_KEY_2``

    .. code-block:: bash

        espefuse.py  --port PORT  burn_key BLOCK my_flash_encryption_key.bin XTS_AES_256_KE"
"Y

    If you wish to specify exactly which two blocks are used then it is possible to divide key into two 256 bit keys, and manually burn each half with ``XTS_AES_256_KEY_1`` and ``XTS_AES_256_KEY_2`` as key purposes:

    .. code-block:: bash

      split -b 32 my_flash_encryption_key.bin my_flash_encryption_key.bin.
      espefuse.py  --port PORT  burn_key BLOCK my_flash_encryption_key.bin.aa XTS_AES_256_KEY_1
      espefuse.py  --port PORT  burn_key BLOCK+1 my_flash_encryption_key.bin.ab XTS"
"_AES_256_KEY_2


  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_128_KEY

    where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``.

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

    For AES-128 (256-bit key) - ``XTS_AES_128_KEY`` (the ``XTS_KE"
"Y_LENGTH_256`` eFuse will be burn to 1):

    .. code-block:: bash

        espefuse.py  --port PORT  burn_key BLOCK_KEY0 flash_encryption_key256.bin XTS_AES_128_KEY

    For AES-128 key derived from 128 bits (SHA256(128 bits)) - ``XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS``. The FE key will be written in the lower part of eFuse BLOCK_KEY0. The upper 128 bits are not used and will remain available for reading by software. Using the special mode of the espefuse tool, shown in the ``For burning "
"both keys together`` section below, the user can write their data to it using any espefuse commands.

    .. code-block:: bash

        espefuse.py  --port PORT  burn_key BLOCK_KEY0 flash_encryption_key128.bin XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS

    For burning both keys together (Secure Boot and Flash Encryption):

    .. code-block:: bash

        espefuse.py --port PORT --chip esp32c2  burn_key_digest secure_boot_signing_key.pem \
                                                burn_"
"key BLOCK_KEY0 flash_encryption_key128.bin XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS

  If the key is not burned and the device is started after enabling flash encryption, the {IDF_TARGET_NAME} will generate a random key that software cannot access or modify.

    - :ref:`Enable flash encryption on boot `
    - :ref:`Select encryption mode ` (**Development mode** by default)
    - :ref:`Select the appropriate bootloader log verbosity `
    - Save the configuration and exit.

Enabling flash enc"
"ryption will increase the size of bootloader, which might require updating partition table offset. See :ref:`bootloader-size`.

  .. code-block:: bash

      idf.py flash monitor

  .. note::

      This command does not include any user files which should be written to the partitions on the flash memory. Please write them manually before running this command otherwise the files should be encrypted separately before writing.

  This command will write to flash memory unencrypted images: the firm"
"ware bootloader, the partition table and applications. Once the flashing is complete, {IDF_TARGET_NAME} will reset. On the next boot, the firmware bootloader encrypts: the firmware bootloader, application partitions and partitions marked as ``encrypted`` then resets. Encrypting in-place can take time, up to a minute for large partitions. After that, the application is decrypted at runtime and executed.

If using Development Mode, then the easiest way to update and re-flash binaries is :ref:`encr"
"ypt-partitions`.

If using Release Mode, then it is possible to pre-encrypt the binaries on the host and then flash them as ciphertext. See :ref:`manual-encryption`.


.. _encrypt-partitions:

Re-flashing Updated Partitions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

If you update your application code (done in plaintext) and want to re-flash it, you will need to encrypt it before flashing. To encrypt the application and flash it in one step, run:

.. code-block:: bash

    idf.py encrypted-app-flash monito"
"r

If all partitions needs to be updated in encrypted format, run:

.. code-block:: bash

    idf.py encrypted-flash monitor


.. _flash-enc-release-mode:

Release Mode


In Release mode, UART bootloader cannot perform flash encryption operations. New plaintext images can ONLY be downloaded using the over-the-air (OTA) scheme which will encrypt the plaintext image before writing to flash.

To use this mode, take the following steps:

  See how to check :ref:`flash-encryption-status`.

  .. list:"
":

    - :ref:`Enable flash encryption on boot `
    :esp32: - :ref:`Select Release mode ` (Note that once Release mode is selected, the ``DISABLE_DL_ENCRYPT`` and ``DISABLE_DL_DECRYPT`` eFuse bits will be burned to disable flash encryption hardware in ROM Download Mode.)
    :esp32: - :ref:`Select UART ROM download mode (Permanently disabled (recommended)) ` (Note that this option is only available when :ref:`CONFIG_ESP32_REV_MIN` is set to 3 (ESP32 V3).) The default choice is to keep UART ROM "
"download mode enabled, however it is recommended to permanently disable this mode to reduce the options available to an attacker.
    :not esp32: - :ref:`Select Release mode ` (Note that once Release mode is selected, the ``EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT`` eFuse bit will be burned to disable flash encryption hardware in ROM Download Mode.)
    :not esp32: - :ref:`Select UART ROM download mode (Permanently switch to Secure mode (recommended)) `. This is the default option, and is recommended. "
"It is also possible to change this configuration setting to permanently disable UART ROM download mode, if this mode is not needed.
    - :ref:`Select the appropriate bootloader log verbosity `
    - Save the configuration and exit.

Enabling flash encryption will increase the size of bootloader, which might require updating partition table offset. See :ref:`bootloader-size`.

  .. code-block:: bash

      idf.py flash monitor


  .. note::

      This command does not include any user files whi"
"ch should be written to the partitions on the flash memory. Please write them manually before running this command otherwise the files should be encrypted separately before writing.

  This command will write to flash memory unencrypted images: the firmware bootloader, the partition table and applications. Once the flashing is complete, {IDF_TARGET_NAME} will reset. On the next boot, the firmware bootloader encrypts: the firmware bootloader, application partitions and partitions marked as ``encr"
"ypted`` then resets. Encrypting in-place can take time, up to a minute for large partitions. After that, the application is decrypted at runtime and executed.

Once the flash encryption is enabled in Release mode, the bootloader will write-protect the ``{IDF_TARGET_CRYPT_CNT}`` eFuse.

For subsequent plaintext field updates, use :ref:`OTA scheme `.

.. note::

    If you have pre-generated the flash encryption key and stored a copy, and the UART download mode is not permanently disabled via :ref"
":`CONFIG_SECURE_UART_ROM_DL_MODE` {IDF_TARGET_ESP32_V3_ONLY}, then it is possible to update the flash locally by pre-encrypting the files and then flashing the ciphertext. See :ref:`manual-encryption`.

.. _flash-encrypt-best-practices:

Best Practices


When using Flash Encryption in production:

.. list::

   - Do not reuse the same flash encryption key between multiple devices. This means that an attacker who copies encrypted data from one device cannot transfer it to a second device.
   :esp"
"32: - When using ESP32 V3, if the UART ROM Download Mode is not needed for a production device then it should be disabled to provide an extra level of protection. Do this by calling :cpp:func:`esp_efuse_disable_rom_download_mode` during application startup. Alternatively, configure the project :ref:`CONFIG_ESP32_REV_MIN` level to 3 (targeting ESP32 V3 only) and select the :ref:`CONFIG_SECURE_UART_ROM_DL_MODE` to ""Permanently disable ROM Download Mode (recommended)"". The ability to disable ROM Do"
"wnload Mode is not available on earlier ESP32 versions.
   :not esp32: - The UART ROM Download Mode should be disabled entirely if it is not needed, or permanently set to ""Secure Download Mode"" otherwise. Secure Download Mode permanently limits the available commands to updating SPI config, changing baud rate, basic flash write, and returning a summary of the currently enabled security features with the `get_security_info` command. The default behaviour is to set Secure Download Mode on first bo"
"ot in Release mode. To disable Download Mode entirely, select :ref:`CONFIG_SECURE_UART_ROM_DL_MODE` to ""Permanently disable ROM Download Mode (recommended)"" or call :cpp:func:`esp_efuse_disable_rom_download_mode` at runtime.
   - Enable :doc:`Secure Boot ` as an extra layer of protection, and to prevent an attacker from selectively corrupting any part of the flash before boot.

Enable Flash Encryption Externally


In the process mentioned above, flash encryption related eFuses which ultimately e"
"nable flash encryption are programmed through the firmware bootloader. Alternatively, all the eFuses can be programmed with the help of ``espefuse`` tool. Please refer :ref:`enable-flash-encryption-externally` for more details.

Possible Failures


Once flash encryption is enabled, the ``{IDF_TARGET_CRYPT_CNT}`` eFuse value will have an odd number of bits set. It means that all the partitions marked with the encryption flag are expected to contain encrypted ciphertext. Below are the three typica"
"l failure cases if the {IDF_TARGET_NAME} is erroneously loaded with plaintext data:

.. only:: esp32

  .. code-block:: bash

      rst:0x3 (SW_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      flash read err, 1000
      ets_main.c 371
      ets Jun  8 2016 00:22:57

      rst:0x7 (TG0WDT_SYS_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      flash read err, 1000
      ets_main.c 371
      ets Jun  8 2016 00:22:57

      rst:0x7 (TG0WDT_SYS_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      flash read err, 1000
"
"      ets_main.c 371
      ets Jun  8 2016 00:22:57

      rst:0x7 (TG0WDT_SYS_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      flash read err, 1000
      ets_main.c 371
      ets Jun  8 2016 00:22:57

      rst:0x7 (TG0WDT_SYS_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      flash read err, 1000
      ets_main.c 371
      ets Jun  8 2016 00:22:57

.. only:: not esp32

  .. code-block:: bash

      rst:0x3 (SW_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      invalid header: 0xb414f76b
      invalid header: "
"0xb414f76b
      invalid header: 0xb414f76b
      invalid header: 0xb414f76b
      invalid header: 0xb414f76b
      invalid header: 0xb414f76b
      invalid header: 0xb414f76b

  .. note::

    The value of invalid header will be different for every application.

.. note::

    This error also appears if the flash contents are erased or corrupted.

  .. code-block:: bash

      rst:0x3 (SW_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      configsip: 0, SPIWP:0xee
      clk_drv:0x00,q_drv:0x00,d_drv:0"
"x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
      mode:DIO, clock div:2
      load:0x3fff0018,len:4
      load:0x3fff001c,len:10464
      ho 0 tail 12 room 4
      load:0x40078000,len:19168
      load:0x40080400,len:6664
      entry 0x40080764
      I (60) boot: ESP-IDF v4.0-dev-763-g2c55fae6c-dirty 2nd stage bootloader
      I (60) boot: compile time 19:15:54
      I (62) boot: Enabling RNG early entropy source...
      I (67) boot: SPI Speed      : 40MHz
      I (72) boot: SPI Mode       : DIO
  "
"    I (76) boot: SPI Flash Size : 4MB
      E (80) flash_parts: partition 0 invalid magic number 0x94f6
      E (86) boot: Failed to verify partition table
      E (91) boot: load partition table error!

  .. code-block:: bash

      rst:0x3 (SW_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
      configsip: 0, SPIWP:0xee
      clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
      mode:DIO, clock div:2
      load:0x3fff0018,len:4
      load:0x3fff001c,len:8452
      load:0x400780"
"00,len:13616
      load:0x40080400,len:6664
      entry 0x40080764
      I (56) boot: ESP-IDF v4.0-dev-850-gc4447462d-dirty 2nd stage bootloader
      I (56) boot: compile time 15:37:14
      I (58) boot: Enabling RNG early entropy source...
      I (64) boot: SPI Speed      : 40MHz
      I (68) boot: SPI Mode       : DIO
      I (72) boot: SPI Flash Size : 4MB
      I (76) boot: Partition Table:
      I (79) boot: ## Label            Usage          Type ST Offset   Length
      I (87) boot:  0 "
"nvs              WiFi data        01 02 0000a000 00006000
      I (94) boot:  1 phy_init         RF data          01 01 00010000 00001000
      I (102) boot:  2 factory          factory app      00 00 00020000 00100000
      I (109) boot: End of partition table
      E (113) esp_image: image at 0x20000 has invalid magic byte
      W (120) esp_image: image at 0x20000 has invalid SPI mode 108
      W (126) esp_image: image at 0x20000 has invalid SPI size 11
      E (132) boot: Factory app partitio"
"n is not bootable
      E (138) boot: No bootable app partitions in the partition table


.. _flash-encryption-status:

{IDF_TARGET_NAME} Flash Encryption Status


To check if flash encryption on your {IDF_TARGET_NAME} device is enabled, do one of the following:

- flash the application example :example:`security/flash_encryption` onto your device. This application prints the ``{IDF_TARGET_CRYPT_CNT}`` eFuse value and if flash encryption is enabled or disabled.

- :doc:`Find the serial port name"
" ` under which your {IDF_TARGET_NAME} device is connected, replace ``PORT`` with your port name in the following command, and run it:

  .. code-block:: bash

      espefuse.py -p PORT summary


.. _reading-writing-content:

Reading and Writing Data in Encrypted Flash


{IDF_TARGET_NAME} application code can check if flash encryption is currently enabled by calling :cpp:func:`esp_flash_encryption_enabled`. Also, a device can identify the flash encryption mode by calling :cpp:func:`esp_get_flash_"
"encryption_mode`.

Once flash encryption is enabled, be more careful with accessing flash contents from code.


Scope of Flash Encryption


Whenever the ``{IDF_TARGET_CRYPT_CNT}`` eFuse is set to a value with an odd number of bits, all flash content accessed via the MMU's flash cache is transparently decrypted. It includes:

- Executable application code in flash (IROM).
- All read-only data stored in flash (DROM).
- Any data accessed via :cpp:func:`spi_flash_mmap`.
- The firmware bootloader ima"
"ge when it is read by the ROM bootloader.

.. important::

    The MMU flash cache unconditionally decrypts all existing data. Data which is stored unencrypted in flash memory will also be ""transparently decrypted"" via the flash cache and will appear to software as random garbage.


Reading from Encrypted Flash


To read data without using a flash cache MMU mapping, you can use the partition read function :cpp:func:`esp_partition_read`. This function will only decrypt data when it is read from a"
"n encrypted partition. Data read from unencrypted partitions will not be decrypted. In this way, software can access encrypted and non-encrypted flash in the same way.

You can also use the following SPI flash API functions:

- :cpp:func:`esp_flash_read` to read raw (encrypted) data which will not be decrypted
- :cpp:func:`esp_flash_read_encrypted` to read and decrypt data

Data stored using the Non-Volatile Storage (NVS) API is always stored and read decrypted from the perspective of flash encr"
"yption. It is up to the library to provide encryption feature if required. Refer to :doc:`../api-reference/storage/nvs_encryption` for more details.


Writing to Encrypted Flash


It is recommended to use the partition write function :cpp:func:`esp_partition_write`. This function will only encrypt data when it is written to an encrypted partition. Data written to unencrypted partitions will not be encrypted. In this way, software can access encrypted and non-encrypted flash in the same way.

You"
" can also pre-encrypt and write data using the function :cpp:func:`esp_flash_write_encrypted`

Also, the following ROM function exist but not supported in esp-idf applications:

- ``esp_rom_spiflash_write_encrypted`` pre-encrypts and writes data to flash
- ``SPIWrite`` writes unencrypted data to flash

Since data is encrypted in blocks, the minimum write size for encrypted data is 16 bytes and the alignment is also 16 bytes.


.. _updating-encrypted-flash:

Updating Encrypted Flash


.. _updatin"
"g-encrypted-flash-ota:

OTA Updates


OTA updates to encrypted partitions will automatically write encrypted data if the function :cpp:func:`esp_partition_write` is used.

Before building the application image for OTA updating of an already encrypted device, enable the option :ref:`Enable flash encryption on boot ` in project configuration menu.

For general information about ESP-IDF OTA updates, please refer to :doc:`OTA `


.. _updating-encrypted-flash-serial:

Updating Encrypted Flash via Ser"
"ial


Flashing an encrypted device via serial bootloader requires that the serial bootloader download interface has not been permanently disabled via eFuse.

In Development Mode, the recommended method is :ref:`encrypt-partitions`.

In Release Mode, if a copy of the same key stored in eFuse is available on the host then it is possible to pre-encrypt files on the host and then flash them. See :ref:`manual-encryption`.

Disabling Flash Encryption


If flash encryption was enabled accidentally, fla"
"shing of plaintext data will soft-brick the {IDF_TARGET_NAME}. The device will reboot continuously, printing the error ``flash read err, 1000`` or ``invalid header: 0xXXXXXX``.

.. only:: esp32

  For flash encryption in Development mode, encryption can be disabled by burning the ``{IDF_TARGET_CRYPT_CNT}`` eFuse. It can only be done three times per chip by taking the following steps:

.. only:: not esp32

  For flash encryption in Development mode, encryption can be disabled by burning the ``{ID"
"F_TARGET_CRYPT_CNT}`` eFuse. It can only be done one time per chip by taking the following steps:

#. In :ref:`project-configuration-menu`, disable :ref:`Enable flash encryption on boot `, then save and exit.
#. Open project configuration menu again and **double-check** that you have disabled this option! If this option is left enabled, the bootloader will immediately re-enable encryption when it boots.
#. With flash encryption disabled, build and flash the new bootloader and application by runn"
"ing ``idf.py flash``.
#. Use ``espefuse.py`` (in ``components/esptool_py/esptool``) to disable the ``{IDF_TARGET_CRYPT_CNT}`` by running:

  .. code-block:: bash

      espefuse.py burn_efuse {IDF_TARGET_CRYPT_CNT}

Reset the {IDF_TARGET_NAME}. Flash encryption will be disabled, and the bootloader will boot as usual.


Key Points About Flash Encryption


.. list::

  :esp32: - Flash memory contents is encrypted using AES-256. The flash encryption key is stored in the ``flash_encryption`` eFuse i"
"nternal to the chip and, by default, is protected from software access.

  :esp32: - The flash encryption algorithm is AES-256, where the key is ""tweaked"" with the offset address of each 32 byte block of flash. This means that every 32-byte block (two consecutive 16 byte AES blocks) is encrypted with a unique key derived from the flash encryption key.

  :SOC_FLASH_ENCRYPTION_XTS_AES_256: - Flash memory contents is encrypted using XTS-AES-128 or XTS-AES-256. The flash encryption key is 256 bits "
"and 512 bits respectively and stored in one or two ``BLOCK_KEYN`` eFuses internal to the chip and, by default, is protected from software access.

  :SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_FLASH_ENCRYPTION_XTS_AES_128_DERIVED: - Flash memory contents is encrypted using XTS-AES-128. The flash encryption key is 256 bits and stored in one ``BLOCK_KEYN`` eFuse internal to the chip and, by default, is protected from software access.

  :SOC_FLASH_ENCRYPT"
"ION_XTS_AES_128_DERIVED: - Flash memory contents is encrypted using XTS-AES-128. The flash encryption key is 256 or 128 bits and stored in ``BLOCK_KEY0`` eFuse internal to the chip and, by default, is protected from software access.

  - Flash access is transparent via the flash cache mapping feature of {IDF_TARGET_NAME} - any flash regions which are mapped to the address space will be transparently decrypted when read.

    Some data partitions might need to remain unencrypted for ease of acces"
"s or might require the use of flash-friendly update algorithms which are ineffective if the data is encrypted. NVS partitions for non-volatile storage cannot be encrypted since the NVS library is not directly compatible with flash encryption. For details, refer to :doc:`NVS Encryption `.

  - If flash encryption might be used in future, the programmer must keep it in mind and take certain precautions when writing code that :ref:`uses encrypted flash `.

  - If secure boot is enabled, re-flashing"
" the bootloader of an encrypted device requires a ""Re-flashable"" secure boot digest (see :ref:`flash-encryption-and-secure-boot`).

Enabling flash encryption will increase the size of bootloader, which might require updating partition table offset. See :ref:`bootloader-size`.

    .. important::

        Do not interrupt power to the {IDF_TARGET_NAME} while the first boot encryption pass is running. If power is interrupted, the flash contents will be corrupted and will require flashing with unen"
"crypted data again. In this case, re-flashing will not count towards the flashing limit.


.. _flash-encryption-limitations:

Limitations of Flash Encryption


Flash encryption protects firmware against unauthorised readout and modification. It is important to understand the limitations of the flash encryption feature:

.. list::

    - Flash encryption is only as strong as the key. For this reason, we recommend keys are generated on the device during first boot (default behaviour). If generatin"
"g keys off-device, ensure proper procedure is followed and do not share the same key between all production devices.
    - Not all data is stored encrypted. If storing data on flash, check if the method you are using (library, API, etc.) supports flash encryption.
    - Flash encryption does not prevent an attacker from understanding the high-level layout of the flash. This is because the same AES key is used for every pair of adjacent 16 byte AES blocks. When these adjacent 16 byte blocks conta"
"in identical content (such as empty or padding areas), these blocks will encrypt to produce matching pairs of encrypted blocks. This may allow an attacker to make high-level comparisons between encrypted devices (i.e., to tell if two devices are probably running the same firmware version).
    :esp32: - For the same reason, an attacker can always tell when a pair of adjacent 16 byte blocks (32 byte aligned) contain two identical 16 byte sequences. Keep this in mind if storing sensitive data on t"
"he flash, design your flash storage so this does not happen (using a counter byte or some other non-identical value every 16 bytes is sufficient). :doc:`NVS Encryption ` deals with this and is suitable for many uses.
    - Flash encryption alone may not prevent an attacker from modifying the firmware of the device. To prevent unauthorised firmware from running on the device, use flash encryption in combination with :doc:`Secure Boot `.

.. _flash-encryption-and-secure-boot:

Flash Encryption and"
" Secure Boot


It is recommended to use flash encryption in combination with Secure Boot. However, if Secure Boot is enabled, additional restrictions apply to device re-flashing:

- :ref:`updating-encrypted-flash-ota` are not restricted, provided that the new app is signed correctly with the Secure Boot signing key.

.. only:: esp32

    - :ref:`Plaintext serial flash updates ` are only possible if the :ref:`Re-flashable ` Secure Boot mode is selected and a Secure Boot key was pre-generated and "
"burned to the {IDF_TARGET_NAME} (refer to :ref:`Secure Boot `). In such configuration, ``idf.py bootloader`` will produce a pre-digested bootloader and secure boot digest file for flashing at offset 0x0. When following the plaintext serial re-flashing steps it is necessary to re-flash this file before flashing other plaintext data.

    - :ref:`Re-flashing via Pregenerated Flash Encryption Key ` is still possible, provided the bootloader is not re-flashed. Re-flashing the bootloader requires the"
" same :ref:`Re-flashable ` option to be enabled in the Secure Boot config.

.. _flash-encryption-advanced-features:

Advanced Features


The following section covers advanced features of flash encryption.

.. _encrypted-partition-flag:

Encrypted Partition Flag


Some partitions are encrypted by default. Other partitions can be marked in the partition table description as requiring encryption by adding the flag ``encrypted`` to the partitions' flag field. As a result, data in these marked partit"
"ions will be treated as encrypted in the same manner as an app partition.

.. code-block:: bash

   # Name,   Type, SubType, Offset,  Size, Flags
   nvs,      data, nvs,     0x9000,  0x6000
   phy_init, data, phy,     0xf000,  0x1000
   factory,  app,  factory, 0x10000, 1M
   secret_data, 0x40, 0x01, 0x20000, 256K, encrypted

For details on partition table description, see :doc:`partition table `.

Further information about encryption of partitions:

- Default partition tables do not include any"
" encrypted data partitions.
- With flash encryption enabled, the ``app`` partition is always treated as encrypted and does not require marking.
- If flash encryption is not enabled, the flag ""encrypted"" has no effect.
- You can also consider protecting ``phy_init`` data from physical access, readout, or modification, by marking the optional ``phy`` partition with the flag ``encrypted``.
- The ``nvs`` partition cannot be encrypted, because the NVS library is not directly compatible with flash enc"
"ryption.


.. _uart-bootloader-encryption:

Enabling UART Bootloader Encryption/Decryption


On the first boot, the flash encryption process burns by default the following eFuses:

.. only:: esp32

  - ``DISABLE_DL_ENCRYPT`` which disables flash encryption operation when running in UART bootloader boot mode.
  - ``DISABLE_DL_DECRYPT`` which disables transparent flash decryption when running in UART bootloader mode, even if the eFuse ``{IDF_TARGET_CRYPT_CNT}`` is set to enable it in normal operat"
"ion.
  - ``DISABLE_DL_CACHE`` which disables the entire MMU flash cache when running in UART bootloader mode.

.. only:: not esp32

  .. list::

    - ``DIS_DOWNLOAD_MANUAL_ENCRYPT`` which disables flash encryption operation when running in UART bootloader boot mode.
    :SOC_EFUSE_DIS_DOWNLOAD_ICACHE and SOC_EFUSE_DIS_DOWNLOAD_DCACHE: - ``DIS_DOWNLOAD_ICACHE`` and ``DIS_DOWNLOAD_DCACHE`` which disables the entire MMU flash cache when running in UART bootloader mode.
    :SOC_EFUSE_DIS_DOWNLOAD_"
"ICACHE and not SOC_EFUSE_DIS_DOWNLOAD_DCACHE: - ``DIS_DOWNLOAD_ICACHE`` which disables the entire MMU flash cache when running in UART bootloader mode.
    :esp32s2: - ``HARD_DIS_JTAG`` which disables JTAG.
    :SOC_EFUSE_DIS_PAD_JTAG and SOC_EFUSE_DIS_USB_JTAG: - ``DIS_PAD_JTAG`` and ``DIS_USB_JTAG`` which disables JTAG.
    :SOC_EFUSE_HARD_DIS_JTAG and SOC_EFUSE_DIS_USB_JTAG: - ``HARD_DIS_JTAG`` and ``DIS_USB_JTAG`` which disables JTAG.
    - ``DIS_DIRECT_BOOT`` (old name ``DIS_LEGACY_SPI_BOOT"
"``)  which disables direct boot mode
    :SOC_EFUSE_DIS_DOWNLOAD_MSPI: - ``DIS_DOWNLOAD_MSPI`` which disables the MSPI access in download mode.

However, before the first boot you can choose to keep any of these features enabled by burning only selected eFuses and write-protect the rest of eFuses with unset value 0. For example:

.. only:: esp32

  .. code-block:: bash

    espefuse.py --port PORT burn_efuse DISABLE_DL_DECRYPT
    espefuse.py --port PORT write_protect_efuse DISABLE_DL_ENCRYPT

."
". only:: not esp32

  .. code-block:: bash

    espefuse.py --port PORT burn_efuse DIS_DOWNLOAD_MANUAL_ENCRYPT
    espefuse.py --port PORT write_protect_efuse DIS_DOWNLOAD_MANUAL_ENCRYPT

  .. note::

      Set all appropriate bits before write-protecting!

      Write protection of all the three eFuses is controlled by one bit. It means that write-protecting one eFuse bit will inevitably write-protect all unset eFuse bits.

  Write protecting these eFuses to keep them unset is not currently ver"
"y useful, as ``esptool.py`` does not support reading encrypted flash.

.. only:: esp32

  .. important::

      Leaving ``DISABLE_DL_DECRYPT`` unset (0) makes flash encryption useless.

      An attacker with physical access to the chip can use UART bootloader mode with custom stub code to read out the flash contents.


.. only:: esp32

  .. _setting-flash-crypt-config:

  Setting FLASH_CRYPT_CONFIG
  

  The eFuse ``FLASH_CRYPT_CONFIG`` determines the number of bits in the flash encryption key "
"which are ""tweaked"" with the block offset. For details, see :ref:`flash-encryption-algorithm`.

  On the first boot of the firmware bootloader, this value is set to the maximum ``0xF``.

  It is possible to burn this eFuse manually and write protect it before the first boot in order to select different tweak values. However, this is not recommended.

  It is strongly recommended to never write-protect ``FLASH_CRYPT_CONFIG`` when it is unset. Otherwise, its value will remain zero permanently, and"
" no bits in the flash encryption key will be tweaked. As a result, the flash encryption algorithm will be equivalent to AES ECB mode.

JTAG Debugging


By default, when Flash Encryption is enabled (in either Development or Release mode) then JTAG debugging is disabled via eFuse. The bootloader does this on first boot, at the same time it enables flash encryption.

See :ref:`jtag-debugging-security-features` for more information about using JTAG Debugging with Flash Encryption.


.. _manual-encry"
"ption:

Manually Encrypting Files


Manually encrypting or decrypting files requires the flash encryption key to be pre-burned in eFuse (see :ref:`pregenerated-flash-encryption-key`) and a copy to be kept on the host. If the flash encryption is configured in Development Mode then it is not necessary to keep a copy of the key or follow these steps, the simpler :ref:`encrypt-partitions` steps can be used.

The key file should be a single raw binary file (example: ``key.bin``).

For example, these "
"are the steps to encrypt the file ``build/my-app.bin`` to flash at offset 0x10000. Run espsecure.py as follows:

.. only:: esp32

    .. code-block:: bash

       espsecure.py encrypt_flash_data --keyfile /path/to/key.bin --address 0x10000 --output my-app-ciphertext.bin build/my-app.bin

.. only:: not esp32

    .. code-block:: bash

       espsecure.py encrypt_flash_data --aes_xts --keyfile /path/to/key.bin --address 0x10000 --output my-app-ciphertext.bin build/my-app.bin

The file ``my-app-cip"
"hertext.bin`` can then be flashed to offset 0x10000 using ``esptool.py``. To see all of the command line options recommended for ``esptool.py``, see the output printed when ``idf.py build`` succeeds.

.. note::

   If the flashed ciphertext file is not recognized by the {IDF_TARGET_NAME} when it boots, check that the keys match and that the command line arguments match exactly, including the correct offset.

   .. only:: esp32

       If your ESP32 uses non-default :ref:`FLASH_CRYPT_CONFIG value"
" in eFuse ` then you will need to pass the ``--flash_crypt_conf`` argument to ``espsecure.py`` to set the matching value. This will not happen if the device configured flash encryption by itself, but may happen if burning eFuses manually to enable flash encryption.

The command ``espsecure.py decrypt_flash_data`` can be used with the same options (and different input/output files), to decrypt ciphertext flash contents or a previously encrypted file.


.. only:: SOC_SPIRAM_SUPPORTED and not esp32"
"

  External RAM
  

  When Flash Encryption is enabled any data read from and written to external SPI RAM through the cache will also be encrypted/decrypted. This happens the same way and with the same key as for Flash Encryption. If Flash Encryption is enabled then encryption for external SPI RAM is also always enabled, it is not possible to separately control this functionality.


Technical Details


The following sections provide some reference information about the operation of flash encryp"
"tion.

.. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

  .. _flash-encryption-algorithm:

  Flash Encryption Algorithm
  

  - AES-256 operates on 16-byte blocks of data. The flash encryption engine encrypts and decrypts data in 32-byte blocks - two AES blocks in series.

  - The main flash encryption key is stored in the ``flash_encryption`` eFuse and, by default, is protected from further writes or software readout.

  - AES-256 key size is 256 bits (32 bytes) read from the ``flash_encryption`` eF"
"use. The hardware AES engine uses the key in reversed byte order as compared to the storage order in ``flash_encryption``.

    - If the ``CODING_SCHEME`` eFuse is set to ``0`` (default, ""None"" Coding Scheme) then the eFuse key block is 256 bits and the key is stored as-is (in reversed byte order).
    - If the ``CODING_SCHEME`` eFuse is set to ``1`` (3/4 Encoding) then the eFuse key block is 192 bits (in reversed byte order), so overall entropy is reduced. The hardware flash encryption still op"
"erates on a 256-bit key, after being read (and un-reversed), the key is extended as ``key = key[0:255] + key[64:127]``.

  - AES algorithm is used inverted in flash encryption, so the flash encryption ""encrypt"" operation is AES decrypt and the ""decrypt"" operation is AES encrypt. This is for performance reasons and does not alter the effeciency of the algorithm.

  - Each 32-byte block (two adjacent 16-byte AES blocks) is encrypted with a unique key. The key is derived from the main flash encrypt"
"ion key in ``flash_encryption``, XORed with the offset of this block in the flash (a ""key tweak"").

  - The specific tweak depends on the ``FLASH_CRYPT_CONFIG`` eFuse setting. This is a 4-bit eFuse where each bit enables XORing of a particular range of the key bits:

    - Bit 1, bits 0-66 of the key are XORed.
    - Bit 2, bits 67-131 of the key are XORed.
    - Bit 3, bits 132-194 of the key are XORed.
    - Bit 4, bits 195-256 of the key are XORed.

    It is recommended that ``FLASH_CRYPT_CO"
"NFIG`` is always left at the default value ``0xF``, so that all key bits are XORed with the block offset. For details, see :ref:`setting-flash-crypt-config`.

  - The high 19 bits of the block offset (bit 5 to bit 23) are XORed with the main flash encryption key. This range is chosen for two reasons: the maximum flash size is 16MB (24 bits), and each block is 32 bytes so the least significant 5 bits are always zero.

  - There is a particular mapping from each of the 19 block offset bits to the "
"256 bits of the flash encryption key to determine which bit is XORed with which. See the variable ``_FLASH_ENCRYPTION_TWEAK_PATTERN`` in the ``espsecure.py`` source code for complete mapping.

  - To see the full flash encryption algorithm implemented in Python, refer to the ``_flash_encryption_operation()`` function in the ``espsecure.py`` source code.

.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

  .. _flash-encryption-algorithm:

  Flash Encryption Algorithm
  

  - {IDF_TARGET_NAME} use the X"
"TS-AES block cipher mode with 256 bit or 512 bit key size for flash encryption.

  - XTS-AES is a block cipher mode specifically designed for disc encryption and addresses the weaknesses other potential modes (e.g., AES-CTR) have for this use case. A detailed description of the XTS-AES algorithm can be found in `IEEE Std 1619-2007 `_.

  - The flash encryption key is stored in one or two ``BLOCK_KEYN`` eFuses and, by default, is protected from further writes or software readout.

  - To see the "
"full flash encryption algorithm implemented in Python, refer to the `_flash_encryption_operation()` function in the ``espsecure.py`` source code.

.. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK


  .. _flash-encryption-algorithm:

  Flash Encryption Algorithm
  

  - {IDF_TARGET_NAME} use the XTS-AES block chiper mode with 256 bit size for flash encryption.

  - XTS-AES is a block chiper mode specifically designed f"
"or disc encryption and addresses the weaknesses other potential modes (e.g., AES-CTR) have for this use case. A detailed description of the XTS-AES algorithm can be found in `IEEE Std 1619-2007 `_.

  - The flash encryption key is stored in one ``BLOCK_KEYN`` eFuse and, by default, is protected from further writes or software readout.

  - To see the full flash encryption algorithm implemented in Python, refer to the `_flash_encryption_operation()` function in the ``espsecure.py`` source code.

"
".. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

  .. _flash-encryption-algorithm:

  Flash Encryption Algorithm
  

  - {IDF_TARGET_NAME} use the XTS-AES block chiper mode with 256 bit size for flash encryption. In case the 128-bit key is stored in the eFuse key block, the final 256-bit AES key is obtained as SHA256(EFUSE_KEY0_FE_128BIT).

  - XTS-AES is a block chiper mode specifically designed for disc encryption and addresses the weaknesses other potential "
"modes (e.g., AES-CTR) have for this use case. A detailed description of the XTS-AES algorithm can be found in `IEEE Std 1619-2007 `_.

  - The flash encryption key is stored in ``BLOCK_KEY0`` eFuse and, by default, is protected from further writes or software readout.

  - To see the full flash encryption algorithm implemented in Python, refer to the `_flash_encryption_operation()` function in the ``espsecure.py`` source code.
"
"Security


{IDF_TARGET_CIPHER_SCHEME:default=""RSA"", esp32h2=""RSA or ECDSA"", esp32p4=""RSA or ECDSA""}

{IDF_TARGET_SIG_PERI:default=""DS"", esp32h2=""DS or ECDSA"", esp32p4=""DS or ECDSA""}



This guide provides an overview of the overall security features available in various Espressif solutions. It is highly recommended to consider this guide while designing the products with the Espressif platform and the ESP-IDF software stack from the **security** perspective.

Goals


High level security goals ar"
"e as follows:

#. Preventing untrustworthy code from being executed
#. Protecting the identity and integrity of the code stored in the off-chip flash memory
#. Securing device identity
#. Secure storage for confidential data
#. Authenticated and encrypted communication from the device

Platform Security


.. _secure_boot-guide:

Secure Boot
~~~~~~~~~~~

The Secure Boot feature ensures that only authenticated software can execute on the device. The Secure Boot process forms a chain of trust by ve"
"rifying all **mutable** software entities involved in the :doc:`../api-guides/startup`. Signature verification happens during both boot-up as well as in OTA updates.

Please refer to :doc:`secure-boot-v2` for detailed documentation about this feature.

.. only:: esp32

    For ESP32 before ECO3, please refer to :doc:`secure-boot-v1`.

.. important::

    It is highly recommended that Secure Boot be enabled on all production devices.

Secure Boot Best Practices



.. _flash_enc-guide:

Flash Encr"
"yption
~~~~~~~~~~~~~~~~

The Flash Encryption feature helps to encrypt the contents on the off-chip flash memory and thus provides the **confidentiality** aspect to the software or data stored in the flash memory.

Please refer to :doc:`flash-encryption` for detailed information about this feature.

.. only:: SOC_SPIRAM_SUPPORTED and not esp32

    If {IDF_TARGET_NAME} is connected to an external SPI RAM, the contents written to or read from the SPI RAM will also be encrypted and decrypted respe"
"ctively (via the MMU's flash cache, provided that FLash Encryption is enabled). This provides an additional safety layer for the data stored in SPI RAM, hence configurations like ``CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC`` can be safely enabled in this case.

Flash Encryption Best Practices



.. only:: SOC_DIG_SIGN_SUPPORTED

    Device Identity
    ~~~~~~~~~~~~~~~

    The Digital Signature peripheral in {IDF_TARGET_NAME} produces hardware-accelerated RSA digital signatures with the assistance of HM"
"AC, without the RSA private key being accessible by software. This allows the private key to be kept secured on the device without anyone other than the device hardware being able to access it.

    .. only:: SOC_ECDSA_SUPPORTED

        {IDF_TARGET_NAME} also supportes ECDSA peripheral for generating hardware-accelerated ECDSA digital signatures. ECDSA private key can be directly programmed in an eFuse block and marked as read protected from the software.

    {IDF_TARGET_SIG_PERI} peripheral c"
"an help to establish the **Secure Device Identity** to the remote endpoint, e.g., in the case of TLS mutual authentication based on the {IDF_TARGET_CIPHER_SCHEME} cipher scheme.

    .. only:: not SOC_ECDSA_SUPPORTED

        Please refer to the :doc:`../api-reference/peripherals/ds` for detailed documentation.

    .. only:: SOC_ECDSA_SUPPORTED

        Please refer to the :doc:`../api-reference/peripherals/ecdsa` and :doc:`../api-reference/peripherals/ds` guides for detailed documentation.

.."
" only:: SOC_MEMPROT_SUPPORTED or SOC_CPU_IDRAM_SPLIT_USING_PMP

    Memory Protection
    ~~~~~~~~~~~~~~~~~

    {IDF_TARGET_NAME} supports the **Memory Protection** scheme, either through architecture or special peripheral like PMS, which provides an ability to enforce and monitor permission attributes to memory and, in some cases, peripherals. ESP-IDF application startup code configures the permissions attributes like Read/Write access on data memories and Read/Execute access on instruction me"
"mories using the relevant peripheral. If there is any attempt made that breaks these permission attributes, e.g., a write operation to instruction memory region, then a violation interrupt is raised, and it results in system panic.

    This feature depends on the config option :ref:`CONFIG_ESP_SYSTEM_MEMPROT_FEATURE` and it is kept enabled by default. Please note that the API for this feature is **private** and used exclusively by ESP-IDF code only.

    .. note::

        This feature can help"
" to prevent the possibility of remote code injection due to the existing vulnerabilities in the software.

.. only:: SOC_CRYPTO_DPA_PROTECTION_SUPPORTED

    DPA (Differential Power Analysis) Protection
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    {IDF_TARGET_NAME} has support for protection mechanisms against the Differential Power Analysis related security attacks. DPA protection dynamically adjusts the clock frequency of the crypto peripherals, thereby blurring the power consumption "
"trajectory during its operation. Based on the configured DPA security level, the clock variation range changes. Please refer to the TRM for more details on this topic.

    :ref:`CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL` can help to select the DPA level. Higher level means better security, but it can also have an associated performance impact. By default, the lowest DPA level is kept enabled but it can be modified based on the security requirement.

    .. note::

        Please note that hardware"
" :doc:`RNG ` must be enabled for DPA protection to work correctly.

Debug Interfaces
~~~~~~~~~~~~~~~~

JTAG


.. list::

    - JTAG interface stays disabled if any of the security features are enabled. Please refer to :ref:`jtag-debugging-security-features` for more information.
    - JTAG interface can also be disabled in the absence of any other security features using :ref:`efuse_API`.
    :SOC_HMAC_SUPPORTED: - {IDF_TARGET_NAME} supports soft disabling the JTAG interface and it can be re-ena"
"bled by programming a secret key through HMAC. (:ref:`hmac_for_enabling_jtag`)

UART Download Mode


.. only:: esp32

    For ESP32 ECO3 case, UART Download mode stays disabled if any of the security features are enabled in their release configuration. Alternatively, it can also be disabled by calling :cpp:func:`esp_efuse_disable_rom_download_mode` at runtime.

    .. important::

        If UART Download mode is disabled then ``esptool.py`` can not work on the device.

.. only:: SOC_SUPPORTS_SE"
"CURE_DL_MODE

    In {IDF_TARGET_NAME}, Secure UART Download mode gets activated if any of the security features are enabled.

    .. important::

        In Secure UART Download mode, ``esptool.py`` can only work with the argument ``--no-stub``.

.. only:: SOC_WIFI_SUPPORTED

    Network Security
    

    Wi-Fi
    ~~~~~

    In addition to the traditional security methods (WEP/WPA-TKIP/WPA2-CCMP), Wi-Fi driver in ESP-IDF also supports additional state-of-the-art security protocols. Please ref"
"er to the :doc:`../api-guides/wifi-security` for detailed documentation.

    TLS (Transport Layer Security)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    It is recommended to use TLS (Transport Layer Security) in all external communications (e.g., cloud communication, OTA updates) from the ESP device. ESP-IDF supports :doc:`../api-reference/protocols/mbedtls` as the official TLS stack.

    TLS is default integrated in :doc:`../api-reference/protocols/esp_http_client`, :doc:`../api-reference/protocol"
"s/esp_https_server` and several other components that ship with ESP-IDF.

    .. note::

        It is recommended to use the ESP-IDF protocol components in their default configuration, which has been ensured to be secure. Disabling of HTTPS and similar security-critical configurations should be avoided.

    ESP-TLS Abstraction
    

    ESP-IDF provides an abstraction layer for the most-used TLS functionalities. Hence, it is recommended that an application uses the API exposed by :doc:`../api-"
"reference/protocols/esp_tls`.

    :ref:`esp_tls_server_verification` section highlights diverse ways in which the identity of server could be established on the device side.

    ESP Certificate Bundle
    

    The :doc:`../api-reference/protocols/esp_crt_bundle` API provides an easy way to include a bundle of custom x509 root certificates for TLS server verification. The certificate bundle is the easiest way to verify the identity of almost all standard TLS servers.

    .. important::

     "
"   It is highly recommended to verify the identity of the server based on X.509 certificates to avoid establishing communication with the **fake** server.


    Managing Root Certificates
    

    Root Certificates embedded inside the application must be managed carefully. Any update to the root certificate list or the :doc:`../api-reference/protocols/esp_crt_bundle` can have an impact on the TLS connection with the remote endpoint. This includes a connection to the OTA update server. In some c"
"ases, the problem shall be visible on the next OTA update and it may leave device unable to perform OTA updates forever.

    Root certificates list update could have following reasons:

    - New firmware has different set of remote endpoint(s).
    - The existing certificate has expired.
    - The certificate has been added or retracted from the upstream certificate bundle.
    - The certificate list changed due to market share statistics (``CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_CMN`` case"
").

    Some guidelines to consider on this topic:

    - Please consider enabling :ref:`OTA rollback ` and then keep the successful connection to the OTA update server as the checkpoint to cancel the rollback process. This ensures that the newly updated firmware can successfully reach till the OTA update server, otherwise rollback process will go back to the previous firmware on the device.
    - If you plan to enable the :ref:`CONFIG_MBEDTLS_HAVE_TIME_DATE` option, then please consider to have"
" the time sync mechanism (SNTP) and sufficient number of trusted certificates in place.

Product Security


.. only:: SOC_WIFI_SUPPORTED

    Secure Provisioning
    ~~~~~~~~~~~~~~~~~~~

    Secure Provisioning refers to a process of secure on-boarding of the ESP device on to the Wi-Fi network. This mechanism also allows provision of additional custom configuration data during the initial provisioning phase from the provisioning entity, e.g., Smartphone.

    ESP-IDF provides various security sc"
"hemes to establish a secure session between ESP and the provisioning entity, they are highlighted at :ref:`provisioning_security_schemes`.

    Please refer to the :doc:`../api-reference/provisioning/wifi_provisioning` documentation for details and the example code for this feature.

    .. note::

        Espressif provides Android and iOS Phone Apps along with their sources, so that it could be easy to further customize them as per the product requirement.

Secure OTA (Over-the-air) Updates
~~"
"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- OTA Updates must happen over secure transport, e.g., HTTPS.
- ESP-IDF provides a simplified abstraction layer :doc:`../api-reference/system/esp_https_ota` for this.
- If :ref:`secure_boot-guide` is enabled, then the server should host the signed application image.
- If :ref:`flash_enc-guide` is enabled, then no additional steps are required on the server side, encryption shall be taken care on the device itself during flash write.
- OTA update :ref:`ota_rollbac"
"k` can help to switch the application as ``active`` only after its functionality has been verified.


Anti-Rollback Protection


Anti-rollback protection feature ensures that device only executes the application that meets the security version criteria as stored in its eFuse. So even though the application is trusted and signed by legitimate key, it may contain some revoked security feature or credential. Hence, device must reject any such application.

ESP-IDF allows this feature for the applic"
"ation only and it is managed through 2nd stage bootloader. The security version is stored in the device eFuse and it is compared against the application image header during both bootup and over-the-air updates.

Please see more information to enable this feature in the :ref:`anti-rollback` guide.

Encrypted Firmware Distribution


Encrypted firmware distribution during over-the-air updates ensures that the application stays encrypted **in transit** from the server to the the device. This can act"
" as an additional layer of protection on top of the TLS communication during OTA updates and protect the identity of the application.

Please see working example for this documented in :ref:`ota_updates_pre-encrypted-firmware` section.

Secure Storage
~~~~~~~~~~~~~~

Secure storage refers to the application-specific data that can be stored in a secure manner on the device, i.e., off-chip flash memory. This is typically a read-write flash partition and holds device specific configuration data, e."
"g., Wi-Fi credentials.

ESP-IDF provides the **NVS (Non-volatile Storage)** management component which allows encrypted data partitions. This feature is tied with the platform :ref:`flash_enc-guide` feature described earlier.

Please refer to the :ref:`nvs_encryption` for detailed documentation on the working and instructions to enable this feature.

.. important::

    By default, ESP-IDF components writes the device specific data into the default NVS partition, including Wi-Fi credentials too,"
" and it is recommended to protect this data using **NVS Encryption** feature.

Secure Device Control
~~~~~~~~~~~~~~~~~~~~~

ESP-IDF provides capability to control an ESP device over ``Wi-Fi + HTTP`` or ``BLE`` in a secure manner using ESP Local Control component.

Please refer to the :doc:`../api-reference/protocols/esp_local_ctrl` for detailed documentation about this feature.

Security Policy


The ESP-IDF GitHub repository has attached `Security Policy Brief`_.

Advisories
~~~~~~~~~~

- Espre"
"ssif publishes critical `Security Advisories`_, which includes security advisories regarding both hardware and software.
- The specific advisories of the ESP-IDF software components are published through the `GitHub repository`_.

Software Updates
~~~~~~~~~~~~~~~~

Critical security issues in the ESP-IDF components, and third-party libraries are fixed as and when we find them or when they are reported to us. Gradually, we make the fixes available in all applicable release branches in ESP-IDF.

A"
"pplicable security issues and CVEs for the ESP-IDF components, third-party libraries are mentioned in the ESP-IDF release notes.

.. important::

    We recommend periodically updating to the latest bugfix version of the ESP-IDF release to have all critical security fixes available.


.. _`Security Policy Brief`: https://github.com/espressif/esp-idf/blob/master/SECURITY.md
.. _`Security Advisories`: https://www.espressif.com/en/support/documents/advisories
.. _`GitHub repository`: https://github"
".com/espressif/esp-idf/security/advisories
"
"
API Reference




.. toctree::
   :maxdepth: 2

   api-conventions
   protocols/index
   :SOC_BT_SUPPORTED: bluetooth/index
   error-codes
   network/index
   peripherals/index
   kconfig
   provisioning/index
   storage/index
   system/index
"
"Error Codes Reference




This section lists various error code constants defined in ESP-IDF.

For general information about error codes in ESP-IDF, see :doc:`Error Handling `.

.. include-build-file:: inc/esp_err_defs.inc
"
"Project Configuration



Introduction


The esp-idf-kconfig_ package that ESP-IDF uses is based on kconfiglib_, which is a Python extension to the Kconfig_ system. Kconfig provides a compile-time project configuration mechanism and offers configuration options of several types (e.g., integers, strings, and boolens). Kconfig files specify dependencies between options, default values of options, the way options are grouped together, etc.

For the full list of available features, please see Kconfig"
"_ and `kconfiglib extentions`_.

.. _project-configuration-menu:

Project Configuration Menu


Application developers can open a terminal-based project configuration menu with the ``idf.py menuconfig`` build target.

After being updated, this configuration is saved in the ``sdkconfig`` file under the project root directory. Based on ``sdkconfig``, application build targets will generate the ``sdkconfig.h`` file under the build directory, and will make the ``sdkconfig`` options available to the p"
"roject build system and source files.

Using ``sdkconfig.defaults``


In some cases, for example, when the ``sdkconfig`` file is under revision control, it may be inconvenient for the build system to change the ``sdkconfig`` file. The build system offers a solution to prevent it from happening, which is to create the ``sdkconfig.defaults`` file. This file is never touched by the build system, and can be created manually or automatically. It contains all the options which matter to the given appl"
"ication and are different from the default ones. The format is the same as that of the ``sdkconfig`` file. ``sdkconfig.defaults`` can be created manually when one remembers all the changed configuration, or it can be generated automatically by running the ``idf.py save-defconfig`` command.

Once ``sdkconfig.defaults`` is created, ``sdkconfig`` can be deleted or added to the ignore list of the revision control system (e.g., the ``.gitignore`` file for ``git``). Project build targets will automati"
"cally create the ``sdkconfig`` file, populate it with the settings from the ``sdkconfig.defaults`` file, and configure the rest of the settings to their default values. Note that during the build process, settings from ``sdkconfig.defaults`` will not override those already in ``sdkconfig``. For more information, see :ref:`custom-sdkconfig-defaults`.

Kconfig Format Rules


Format rules for Kconfig files are as follows:

- Option names in any menus should have consistent prefixes. The prefix curr"
"ently should have at least 3 characters.
- The unit of indentation should be 4 spaces. All sub-items belonging to a parent item are indented by one level deeper. For example, ``menu`` is indented by 0 spaces, ``config``  ``menu`` by 4 spaces, ``help`` in ``config`` by 8 spaces, and the text under ``help`` by 12 spaces.
- No trailing spaces are allowed at the end of the lines.
- The maximum length of options is 50 characters.
- The maximum length of lines is 120 characters.

.. note::

    The ``"
"help`` section of each config in the menu is treated as reStructuredText to generate the reference documentation for each option.

Format Checker


``kconfcheck`` tool in esp-idf-kconfig_ package is provided for checking Kconfig files against the above format rules. The checker checks all Kconfig and ``Kconfig.projbuild`` files given as arguments, and generates a new file with suffix ``.new`` with some suggestions about how to fix issues (if there are any). Please note that the checker cannot co"
"rrect all format issues and the responsibility of the developer is to final check and make corrections in order to pass the tests. For example, indentations will be corrected if there is not any misleading formatting, but it cannot come up with a common prefix for options inside a menu.

The ``esp-idf-kconfig`` package is available in ESP-IDF environments, where the checker tool can be invoked by running command ``python -m kconfcheck ``.

For more information, please refer to `esp-idf-kconfig p"
"ackage documentation `__.

.. _configuration-options-compatibility:

Backward Compatibility of Kconfig Options


The standard Kconfig_ tools ignore unknown options in ``sdkconfig``. So if a developer has custom settings for options which are renamed in newer ESP-IDF releases, then the given setting for the option would be silently ignored. Therefore, several features have been adopted to avoid this:

.. _configuration-options-reference:

Configuration Options Reference


Subsequent sections cont"
"ain the list of available ESP-IDF options automatically generated from Kconfig files. Note that due to dependencies between options, some options listed here may not be visible by default in ``menuconfig``.

By convention, all option names are upper-case letters with underscores. When Kconfig generates ``sdkconfig`` and ``sdkconfig.h`` files, option names are prefixed with ``CONFIG_``. So if an option ``ENABLE_FOO`` is defined in a Kconfig file and selected in ``menuconfig``, then the ``sdkconfi"
"g`` and ``sdkconfig.h`` files will have ``CONFIG_ENABLE_FOO`` defined. In the following sections, option names are also prefixed with ``CONFIG_``, same as in the source code.


.. include-build-file:: inc/kconfig.inc

.. _Kconfig: https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt
.. _esp-idf-kconfig: https://pypi.org/project/esp-idf-kconfig/
.. _kconfiglib: https://github.com/ulfalizer/Kconfiglib
.. _kconfiglib extentions: https://pypi.org/project/kconfiglib/#kconfig-extension"
"s
"
"API Documentation Template




.. note::

    *INSTRUCTIONS*

Overview


.. note::

    *INSTRUCTIONS*

Application Example


.. note::

    *INSTRUCTIONS*

API Reference


.. highlight:: none

.. note::

    *INSTRUCTIONS*

        ##
        ## Wi-Fi - API Reference
        ##
        ../components/esp32/include/esp_wifi.h \
        ../components/esp32/include/esp_smartconfig.h \

       .. include-build-file:: inc/esp_wifi.inc

       For example see :idf_file:`docs/en/api-reference/network/e"
"sp_wifi.rst`

       Below is the list of common ``.. doxygen...::`` directives:

       See `Breathe documentation `_ for additional information.

       To provide a link to header file, use the `link custom role` directive as follows::
"
"API Conventions



.. highlight:: c

This document describes conventions and assumptions common to ESP-IDF Application Programming Interfaces (APIs).

ESP-IDF provides several kinds of programming interfaces:

ESP-IDF is made up of multiple components where these components either contain code specifically written for ESP chips, or contain a third-party library (i.e., a third-party component). In some cases, third-party components contain an ""ESP-IDF specific"" wrapper in order to provide an inte"
"rface that is either simpler or better integrated with the rest of ESP-IDF's features. In other cases, third-party components present the original API of the underlying library directly.

The following sections explain some of the aspects of ESP-IDF APIs and their usage.

Error Handling


Most ESP-IDF APIs return error codes defined with the :cpp:type:`esp_err_t` type. See :doc:`Error Handling ` section for more information about error handling approaches. :doc:`Error Codes Reference ` contains "
"the list of error codes returned by ESP-IDF components.

.. _api_reference_config_structures:

Configuration Structures


.. important:: Correct initialization of configuration structures is an important part of making the application compatible with future versions of ESP-IDF.

Most initialization, configuration, and installation functions in ESP-IDF (typically named ``..._init()``, ``..._config()``, and ``..._install()``) take a configuration structure pointer as an argument. For example::

  "
"  const esp_timer_create_args_t my_timer_args = {
        .callback = &my_timer_callback,
        .arg = callback_arg,
        .name = ""my_timer""
    };
    esp_timer_handle_t my_timer;
    esp_err_t err = esp_timer_create(&my_timer_args, &my_timer);

These functions never store the pointer to the configuration structure, so it is safe to allocate the structure on the stack.

The application must initialize all fields of the structure. The following is incorrect::

    esp_timer_create_args_t my"
"_timer_args;
    my_timer_args.callback = &my_timer_callback;
    /* Incorrect! Fields .arg and .name are not initialized */
    esp_timer_create(&my_timer_args, &my_timer);

Most ESP-IDF examples use C99 `designated initializers`_ for structure initialization since they provide a concise way of setting a subset of fields, and zero-initializing the remaining fields::

    const esp_timer_create_args_t my_timer_args = {
        .callback = &my_timer_callback,
        /* Correct, fields .arg and ."
"name are zero-initialized */
    };

The C++ language supports designated initializer syntax, too, but the initializers must be in the order of declaration. When using ESP-IDF APIs in C++ code, you may consider using the following pattern::

    /* Correct, fields .dispatch_method, .name and .skip_unhandled_events are zero-initialized */
    const esp_timer_create_args_t my_timer_args = {
        .callback = &my_timer_callback,
        .arg = &my_arg,
    };

    ///* Incorrect, .arg is declared"
" after .callback in esp_timer_create_args_t */
    //const esp_timer_create_args_t my_timer_args = {
    //    .arg = &my_arg,
    //    .callback = &my_timer_callback,
    //};

For more information on designated initializers, see :ref:`cplusplus_designated_initializers`. Note that C++ language versions older than C++20, which are not the default in the current version of ESP-IDF, do not support designated initializers. If you have to compile code with an older C++ standard than C++20, you may "
"use GCC extensions to produce the following pattern::

    esp_timer_create_args_t my_timer_args = {};
    /* All the fields are zero-initialized */
    my_timer_args.callback = &my_timer_callback;

Default Initializers


For some configuration structures, ESP-IDF provides macros for setting default values of fields::

    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    /* HTTPD_DEFAULT_CONFIG expands to a designated initializer. Now all fields are set to the default values, and any field ca"
"n still be modified: */
    config.server_port = 8081;
    httpd_handle_t server;
    esp_err_t err = httpd_start(&server, &config);

It is recommended to use default initializer macros whenever they are provided for a particular configuration structure.

.. _api_reference_private_apis:

Private APIs


Certain header files in ESP-IDF contain APIs intended to be used only in ESP-IDF source code rather than by the applications. Such header files often contain ``private`` or ``esp_private`` in thei"
"r name or path. Certain components, such as :doc:`hal ` only contain private APIs.

Private APIs may be removed or changed in an incompatible way between minor or patch releases.

.. _api_reference_example_components:

Components in Example Projects


ESP-IDF examples contain a variety of projects demonstrating the usage of ESP-IDF APIs. In order to reduce code duplication in the examples, a few common helpers are defined inside components that are used by multiple examples. This includes compon"
"ents located in :example:`common_components` directory, as well as some of the components located in the examples themselves. These components are not considered to be part of the ESP-IDF API.

It is not recommended to reference these components directly in custom projects (via ``EXTRA_COMPONENT_DIRS`` build system variable), as they may change significantly between ESP-IDF versions. When starting a new project based on an ESP-IDF example, copy both the project and the common components it depen"
"ds on out of ESP-IDF, and treat the common components as part of the project. Note that the common components are written with examples in mind, and might not include all the error handling required for production applications. Before using, take time to read the code and understand if it is applicable to your use case.

API Stability


ESP-IDF uses `Semantic Versioning `_ as explained in the :ref:`Versioning Scheme `.

Minor and bugfix releases of ESP-IDF guarantee compatibility with previous r"
"eleases. The sections below explain different aspects and limitations to compatibility.

Source-level Compatibility


ESP-IDF guarantees source-level compatibility of C functions, structures, enums, type definitions, and preprocessor macros declared in public header files of ESP-IDF components. Source-level compatibility implies that the application source code can be recompiled with the newer version of ESP-IDF without changes.

The following changes are allowed between minor versions and do no"
"t break source-level compatibility:

Lack of Binary Compatibility


ESP-IDF does not guarantee binary compatibility between releases. This means that if a precompiled library is built with one ESP-IDF version, it is not guaranteed to work the same way with the next minor or bugfix release. The following are the possible changes that keep source-level compatibility but not binary compatibility:

Other Exceptions from Compatibility


While we try to make upgrading to a new ESP-IDF version easy, th"
"ere are parts of ESP-IDF that may change between minor versions in an incompatible way. We appreciate issuing reports about any unintended breaking changes that do not fall into the categories below.

.. _designated initializers: https://en.cppreference.com/w/c/language/struct_initialization
"
"Networking APIs




.. only:: SOC_WIFI_SUPPORTED

   Wi-Fi
   

   .. toctree::
      :maxdepth: 1

      esp_now
      :SOC_WIFI_MESH_SUPPORT: esp-wifi-mesh
      esp_smartconfig
      esp_wifi
      esp_dpp
      :SOC_WIFI_NAN_SUPPORT: esp_nan

   Code examples for the Wi-Fi API are provided in the :example:`wifi` directory of ESP-IDF examples.

.. only:: SOC_WIFI_MESH_SUPPORT

      Code examples for ESP-WIFI-MESH are provided in the :example:`mesh` directory of ESP-IDF examples.



Ethernet
"
"

.. toctree::
   :maxdepth: 1

   esp_eth

Code examples for the Ethernet API are provided in the :example:`ethernet` directory of ESP-IDF examples.

Thread


.. toctree::
   :maxdepth: 1

   esp_openthread

Thread is an IPv6-based mesh networking technology for IoT.

Code examples for the Thread API are provided in the :example:`openthread` directory of ESP-IDF examples.

ESP-NETIF


.. toctree::
   :maxdepth: 1

   esp_netif

IP Network Layer


.. toctree::
    :hidden:

    esp_netif_driver
"
"
Code examples for TCP/IP socket APIs are provided in the :example:`protocols/sockets` directory of ESP-IDF examples.

Application Layer


Documentation for Application layer network protocols (above the IP Network layer) are provided in :doc:`../protocols/index`.
"
"Ethernet


{IDF_TARGET_SOC_REF_CLK_IN_GPIO:default="""", esp32=""GPIO0"", esp32p4=""GPIO32, GPIO44 and GPIO50""}
{IDF_TARGET_SOC_REF_CLK_OUT_GPIO:default="""", esp32=""GPIO0, GPIO16 and GPIO17"", esp32p4=""GPIO23 and GPIO39""}
{IDF_TARGET_SOC_RMII_TX_EN:default="""", esp32=""GPIO21"", esp32p4=""GPIO33, GPIO40 and GPIO49""}
{IDF_TARGET_SOC_RMII_TXD0:default="""", esp32=""GPIO19"", esp32p4=""GPIO34 and GPIO41""}
{IDF_TARGET_SOC_RMII_TXD1:default="""", esp32=""GPIO22"", esp32p4=""GPIO35 and GPIO42""}
{IDF_TARGET_SOC_RMII_CRS_DV"
":default="""", esp32=""GPIO27"", esp32p4=""GPIO28, GPIO45 and GPIO51""}
{IDF_TARGET_SOC_RMII_RXD0:default="""", esp32=""GPIO25"", esp32p4=""GPIO29, GPIO46 and GPIO52""}
{IDF_TARGET_SOC_RMII_RXD1:default="""", esp32=""GPIO26"", esp32p4=""GPIO30, GPIO47 and GPIO53""}




..  Overview 

Overview


.. only:: SOC_EMAC_SUPPORTED

    ESP-IDF provides a set of consistent and flexible APIs to support both internal Ethernet MAC (EMAC) controller and external SPI-Ethernet modules.

.. only:: not SOC_EMAC_SUPPORTED

    ESP"
"-IDF provides a set of consistent and flexible APIs to support external SPI-Ethernet modules.

This programming guide is split into the following sections:

..  Basic Ethernet Concepts 

.. _basic-ethernet-concepts:

Basic Ethernet Concepts


Ethernet is an asynchronous Carrier Sense Multiple Access with Collision Detect (CSMA/CD) protocol/interface. It is generally not well suited for low-power applications. However, with ubiquitous deployment, internet connectivity, high data rates, and limitl"
"ess-range expandability, Ethernet can accommodate nearly all wired communications.

Normal IEEE 802.3 compliant Ethernet frames are between 64 and 1518 bytes in length. They are made up of five or six different fields: a destination MAC address (DA), a source MAC address (SA), a type/length field, a data payload, an optional padding field and a Cyclic Redundancy Check (CRC). Additionally, when transmitted on the Ethernet medium, a 7-byte preamble field and Start-of-Frame (SOF) delimiter byte are"
" appended to the beginning of the Ethernet packet.

Thus the traffic on the twist-pair cabling appears as shown below:

.. rackdiag:: ../../../_static/diagrams/ethernet/data_frame_format.diag
    :caption: Ethernet Data Frame Format
    :align: center

Preamble and Start-of-Frame Delimiter


The preamble contains seven bytes of ``55H``. It allows the receiver to lock onto the stream of data before the actual frame arrives.

The Start-of-Frame Delimiter (SFD) is a binary sequence ``10101011`` (as"
" seen on the physical medium). It is sometimes considered to be part of the preamble.

When transmitting and receiving data, the preamble and SFD bytes will be automatically generated or stripped from the packets.

Destination Address


The destination address field contains a 6-byte length MAC address of the device that the packet is directed to. If the Least Significant bit in the first byte of the MAC address is set, the address is a multicast destination. For example, 01-00-00-00-F0-00 and 3"
"3-45-67-89-AB-CD are multi-cast addresses, while 00-00-00-00-F0-00 and 32-45-67-89-AB-CD are not.

Packets with multi-cast destination addresses are designed to arrive and be important to a selected group of Ethernet nodes. If the destination address field is the reserved multicast address, i.e., FF-FF-FF-FF-FF-FF, the packet is a broadcast packet and it will be directed to everyone sharing the network. If the Least Significant bit in the first byte of the MAC address is clear, the address is a "
"unicast address and will be designed for usage by only the addressed node.

Normally the EMAC controller incorporates receive filters which can be used to discard or accept packets with multi-cast, broadcast and/or unicast destination addresses. When transmitting packets, the host controller is responsible for writing the desired destination address into the transmit buffer.

Source Address


The source address field contains a 6-byte length MAC address of the node which created the Ethernet pac"
"ket. Users of Ethernet must generate a unique MAC address for each controller used. MAC addresses consist of two portions. The first three bytes are known as the Organizationally Unique Identifier (OUI). OUIs are distributed by the IEEE. The last three bytes are address bytes at the discretion of the company that purchased the OUI. For more information about MAC Address used in ESP-IDF, please see :ref:`MAC Address Allocation `.

When transmitting packets, the assigned source MAC address must be"
" written into the transmit buffer by the host controller.

Type/Length


The type/length field is a 2-byte field. If the value in this field is = 1536, it represents the protocol the following packet data belongs to. The followings are the most common type values:

Users implementing proprietary networks may choose to treat this field as a length field, while applications implementing protocols such as the Internet Protocol (IP) or Address Resolution Protocol (ARP), should program this field wit"
"h the appropriate type defined by the protocol's specification when transmitting packets.

Payload


The payload field is a variable length field, anywhere from 0 to 1500 bytes. Larger data packets violates Ethernet standards and will be dropped by most Ethernet nodes.

This field contains the client data, such as an IP datagram.

Padding and FCS


The padding field is a variable length field added to meet the IEEE 802.3 specification requirements when small data payloads are used.

The DA, SA, "
"type, payload, and padding of an Ethernet packet must be no smaller than 60 bytes in total. If the required 4-byte FCS field is added, packets must be no smaller than 64 bytes. If the payload field is less than 46-byte long, a padding field is required.

The FCS field is a 4-byte field that contains an industry-standard 32-bit CRC calculated with the data from the DA, SA, type, payload, and padding fields. Given the complexity of calculating a CRC, the hardware normally automatically generates a"
" valid CRC and transmit it. Otherwise, the host controller must generate the CRC and place it in the transmit buffer.

Normally, the host controller does not need to concern itself with padding and the CRC which the hardware EMAC will also be able to automatically generate when transmitting and verify when receiving. However, the padding and CRC fields will be written into the receive buffer when packets arrive, so they may be evaluated by the host controller if needed.

.. note::
    Besides th"
"e basic data frame described above, there are two other common frame types in 10/100 Mbps Ethernet: control frames and VLAN-tagged frames. They are not supported in ESP-IDF.

..  Driver Operation 

.. _driver-configuration-and-installation:

Configure MAC and PHY


The Ethernet driver is composed of two parts: MAC and PHY.

.. only:: SOC_EMAC_SUPPORTED

    The communication between MAC and PHY can have diverse choices: **MII** (Media Independent Interface), **RMII** (Reduced Media Independent I"
"nterface), etc.

    .. figure:: ../../../_static/rmii-interface.png
        :scale: 80 %
        :alt: Ethernet RMII Interface
        :figclass: align-center

        Ethernet RMII Interface

    One of the obvious differences between MII and RMII is signal consumption. MII usually costs up to 18 signals, while the RMII interface can reduce the consumption to 9.

    .. only:: esp32

        .. note::
            ESP-IDF only supports the RMII interface. Therefore, always set :cpp:member:`eth_"
"esp32_emac_config_t::interface` to :cpp:enumerator:`eth_data_interface_t::EMAC_DATA_INTERFACE_RMII` or always select ``CONFIG_ETH_PHY_INTERFACE_RMII`` in the Kconfig option :ref:`CONFIG_ETH_PHY_INTERFACE`.

    .. only:: not esp32

        .. note::
            ESP-IDF only supports the RMII interface. Therefore, always set :cpp:member:`eth_esp32_emac_config_t::interface` to :cpp:enumerator:`eth_data_interface_t::EMAC_DATA_INTERFACE_RMII`.

    In RMII mode, both the receiver and transmitter sig"
"nals are referenced to the ``REF_CLK``. ``REF_CLK`` **must be stable during any access to PHY and MAC**. Generally, there are three ways to generate the ``REF_CLK`` depending on the PHY device in your design:

    .. only:: esp32

        .. note::
            The ``REF_CLK`` can be also configured via Project Configuration when :cpp:member:`eth_esp32_emac_config_t::clock_config::mode` of :cpp:member:`eth_esp32_emac_config_t::clock_config` is set to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_"
"CLK_DEFAULT`. Choose appropriately ``CONFIG_ETH_RMII_CLK_INPUT`` or ``CONFIG_ETH_RMII_CLK_OUTPUT`` option under :ref:`CONFIG_ETH_RMII_CLK_MODE` configuration based on your design as discussed above.

        .. warning::
            If the RMII clock mode is configured to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_CLK_OUT` (or ``CONFIG_ETH_RMII_CLK_OUTPUT`` is selected), then ``GPIO0`` can be used to output the ``REF_CLK`` signal. See :cpp:enumerator:`emac_rmii_clock_gpio_t::EMAC_APPL_CLK_OUT"
"_GPIO` or :ref:`CONFIG_ETH_RMII_CLK_OUTPUT_GPIO0` for more information.

            What is more, if you are not using PSRAM in your design, GPIO16 and GPIO17 are also available to output the reference clock signal. See :cpp:enumerator:`emac_rmii_clock_gpio_t::EMAC_CLK_OUT_GPIO` and :cpp:enumerator:`emac_rmii_clock_gpio_t::EMAC_CLK_OUT_180_GPIO` or :ref:`CONFIG_ETH_RMII_CLK_OUT_GPIO` for more information.

            If the RMII clock mode is configured to :cpp:enumerator:`emac_rmii_clock_mode"
"_t::EMAC_CLK_EXT_IN` (or ``CONFIG_ETH_RMII_CLK_INPUT`` is selected), then ``GPIO0`` is the only choice to input the ``REF_CLK`` signal. Please note that ``GPIO0`` is also an important strapping GPIO on ESP32. If GPIO0 samples a low level during power-up, ESP32 will go into download mode. The system will get halted until a manually reset. The workaround for this issue is disabling the ``REF_CLK`` in hardware by default so that the strapping pin is not interfered by other signals in the boot stage"
". Then, re-enable the ``REF_CLK`` in the Ethernet driver installation stage.

            The ways to disable the ``REF_CLK`` signal can be:

    .. only:: not esp32

        .. note::
            If the RMII clock mode is configured to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_CLK_OUT`, {IDF_TARGET_SOC_REF_CLK_OUT_GPIO} can be selected as output pin of the ``REF_CLK`` signal via IO_MUX.

            If the RMII clock mode is configured to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_CLK_EX"
"T_IN`, {IDF_TARGET_SOC_REF_CLK_IN_GPIO} can be selected as input pin for the ``REF_CLK`` signal via IO_MUX.

    .. only:: not SOC_EMAC_RMII_CLK_OUT_INTERNAL_LOOPBACK

        .. warning::
            If the RMII clock mode is configured to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_CLK_OUT`, the ``REF_CLK`` output signal must be looped back to the EMAC externally. You have to configure :cpp:member:`eth_mac_clock_config_t::clock_mode` of :cpp:member:`eth_esp32_emac_config_t::clock_config_out_"
"in` to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_CLK_EXT_IN` and select GPIO number associated with ``REF_CLK`` input GPIO's ({IDF_TARGET_SOC_REF_CLK_IN_GPIO}).

            .. only:: esp32p4

                .. figure:: ../../../_static/rmii_ref_clk_esp32p4.png
                    :scale: 95 %
                    :alt: RMII REF_CKL Output Loopback
                    :figclass: align-center

                    RMII REF_CKL Output Loopback

    **No matter which RMII clock mode you select, "
"you really need to take care of the signal integrity of REF_CLK in your hardware design!** Keep the trace as short as possible. Keep it away from RF devices and inductor elements.

    .. only:: not SOC_EMAC_USE_IO_MUX

        .. note::
            Signals used in the data plane are fixed to specific GPIOs via IO_MUX, they can not be modified to other GPIOs. Signals used in the control plane can be routed to any free GPIOs via Matrix. Please refer to :doc:`ESP32-Ethernet-Kit ` for hardware desi"
"gn example.

    .. only:: SOC_EMAC_USE_IO_MUX

        .. note::
            Signals used in the data plane can be configured to predefined set of GPIOs via IO_MUX for the RMII, see below table. The data plane GPIO configuration is performed by the driver based on content of :cpp:member:`eth_esp32_emac_config_t::emac_dataif_gpio`. Signals used in the control plane can be routed to any free GPIOs via GPIO Matrix.

            .. list-table:: {IDF_TARGET_NAME} RMII Data Plane GPIO
               "
" :header-rows: 1
                :widths: 50 50
                :align: center
                  - GPIO Number
                  - {IDF_TARGET_SOC_RMII_TX_EN}
                  - {IDF_TARGET_SOC_RMII_TXD0}
                  - {IDF_TARGET_SOC_RMII_TXD1}
                  - {IDF_TARGET_SOC_RMII_CRS_DV}
                  - {IDF_TARGET_SOC_RMII_RXD0}
                  - {IDF_TARGET_SOC_RMII_RXD1}

You need to set up the necessary parameters for MAC and PHY respectively based on your Ethernet board d"
"esign, and then combine the two together to complete the driver installation.

Configuration for MAC is described in :cpp:class:`eth_mac_config_t`, including:

.. list::

    :SOC_EMAC_SUPPORTED: * :cpp:member:`eth_esp32_emac_config_t::smi_mdc_gpio_num` and :cpp:member:`eth_esp32_emac_config_t::smi_mdio_gpio_num`: the GPIO number used to connect the SMI signals.

    :SOC_EMAC_SUPPORTED: * :cpp:member:`eth_esp32_emac_config_t::interface`: configuration of MAC Data interface to PHY (MII/RMII).

 "
"   :SOC_EMAC_SUPPORTED: * :cpp:member:`eth_esp32_emac_config_t::clock_config`: configuration of EMAC Interface clock (``REF_CLK`` mode and GPIO number in case of RMII).

    :SOC_EMAC_USE_IO_MUX: * :cpp:member:`eth_esp32_emac_config_t::emac_dataif_gpio`: configuration of EMAC MII/RMII data plane GPIO numbers.

    :not SOC_EMAC_RMII_CLK_OUT_INTERNAL_LOOPBACK: * :cpp:member:`eth_esp32_emac_config_t::clock_config_out_in`: configuration of EMAC input interface clock when ``REF_CLK`` signal is gener"
"ated internally and is looped back to the EMAC externally. The mode must be always configured to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_CLK_EXT_IN`. This option is valid only when configuration of :cpp:member:`eth_esp32_emac_config_t::clock_config` is set to :cpp:enumerator:`emac_rmii_clock_mode_t::EMAC_CLK_OUT`.

Configuration for PHY is described in :cpp:class:`eth_phy_config_t`, including:

.. list::

ESP-IDF provides a default configuration for MAC and PHY in macro :c:macro:`ETH_MAC_D"
"EFAULT_CONFIG` and :c:macro:`ETH_PHY_DEFAULT_CONFIG`.


Create MAC and PHY Instance


The Ethernet driver is implemented in an Object-Oriented style. Any operation on MAC and PHY should be based on the instance of the two.

.. only:: SOC_EMAC_SUPPORTED

    Internal EMAC + External PHY
    

    .. highlight:: c

    ::

        eth_mac_config_t mac_config = ETH_MAC_DEFAULT_CONFIG();                      // apply default common MAC configuration
        eth_esp32_emac_config_t esp32_emac_config "
"= ETH_ESP32_EMAC_DEFAULT_CONFIG(); // apply default vendor-specific MAC configuration
        esp32_emac_config.smi_mdc_gpio_num = CONFIG_EXAMPLE_ETH_MDC_GPIO;            // alter the GPIO used for MDC signal
        esp32_emac_config.smi_mdio_gpio_num = CONFIG_EXAMPLE_ETH_MDIO_GPIO;          // alter the GPIO used for MDIO signal
        esp_eth_mac_t *mac = esp_eth_mac_new_esp32(&esp32_emac_config, &mac_config); // create MAC instance

        eth_phy_config_t phy_config = ETH_PHY_DEFAULT_CONF"
"IG();      // apply default PHY configuration
        phy_config.phy_addr = CONFIG_EXAMPLE_ETH_PHY_ADDR;           // alter the PHY address according to your board design
        phy_config.reset_gpio_num = CONFIG_EXAMPLE_ETH_PHY_RST_GPIO; // alter the GPIO used for PHY reset
        esp_eth_phy_t *phy = esp_eth_phy_new_ip101(&phy_config);     // create PHY instance
        // ESP-IDF officially supports several different Ethernet PHY chip driver
        // esp_eth_phy_t *phy = esp_eth_phy_new_r"
"tl8201(&phy_config);
        // esp_eth_phy_t *phy = esp_eth_phy_new_lan8720(&phy_config);
        // esp_eth_phy_t *phy = esp_eth_phy_new_dp83848(&phy_config);

    Optional Runtime MAC Clock Configuration
    

    EMAC ``REF_CLK`` can be optionally configured from the user application code.

    .. highlight:: c

    ::

        eth_esp32_emac_config_t esp32_emac_config = ETH_ESP32_EMAC_DEFAULT_CONFIG(); // apply default vendor-specific MAC configuration

        // ...

        esp32_emac_co"
"nfig.interface = EMAC_DATA_INTERFACE_RMII;                      // alter EMAC Data Interface
        esp32_emac_config.clock_config.rmii.clock_mode = EMAC_CLK_OUT;               // select EMAC REF_CLK mode
        esp32_emac_config.clock_config.rmii.clock_gpio = EMAC_CLK_OUT_GPIO;          // select GPIO number used to input/output EMAC REF_CLK
        esp_eth_mac_t *mac = esp_eth_mac_new_esp32(&esp32_emac_config, &mac_config); // create MAC instance


SPI-Ethernet Module


.. highlight:: c

::
"
"
    eth_mac_config_t mac_config = ETH_MAC_DEFAULT_CONFIG();      // apply default common MAC configuration
    eth_phy_config_t phy_config = ETH_PHY_DEFAULT_CONFIG();      // apply default PHY configuration
    phy_config.phy_addr = CONFIG_EXAMPLE_ETH_PHY_ADDR;           // alter the PHY address according to your board design
    phy_config.reset_gpio_num = CONFIG_EXAMPLE_ETH_PHY_RST_GPIO; // alter the GPIO used for PHY reset
    // Install GPIO interrupt service (as the SPI-Ethernet module is "
"interrupt-driven)
    gpio_install_isr_service(0);
    // SPI bus configuration
    spi_device_handle_t spi_handle = NULL;
    spi_bus_config_t buscfg = {
        .miso_io_num = CONFIG_EXAMPLE_ETH_SPI_MISO_GPIO,
        .mosi_io_num = CONFIG_EXAMPLE_ETH_SPI_MOSI_GPIO,
        .sclk_io_num = CONFIG_EXAMPLE_ETH_SPI_SCLK_GPIO,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
    };
    ESP_ERROR_CHECK(spi_bus_initialize(CONFIG_EXAMPLE_ETH_SPI_HOST, &buscfg, 1));
    // Configure SPI device"
"
    spi_device_interface_config_t spi_devcfg = {
        .mode = 0,
        .clock_speed_hz = CONFIG_EXAMPLE_ETH_SPI_CLOCK_MHZ * 1000 * 1000,
        .spics_io_num = CONFIG_EXAMPLE_ETH_SPI_CS_GPIO,
        .queue_size = 20
    };
    /* dm9051 ethernet driver is based on spi driver */
    eth_dm9051_config_t dm9051_config = ETH_DM9051_DEFAULT_CONFIG(CONFIG_EXAMPLE_ETH_SPI_HOST, &spi_devcfg);
    dm9051_config.int_gpio_num = CONFIG_EXAMPLE_ETH_SPI_INT_GPIO;
    esp_eth_mac_t *mac = esp_eth_mac_n"
"ew_dm9051(&dm9051_config, &mac_config);
    esp_eth_phy_t *phy = esp_eth_phy_new_dm9051(&phy_config);


.. note::


Install Driver


To install the Ethernet driver, we need to combine the instance of MAC and PHY and set some additional high-level configurations (i.e., not specific to either MAC or PHY) in :cpp:class:`esp_eth_config_t`:

ESP-IDF provides a default configuration for driver installation in macro :c:macro:`ETH_DEFAULT_CONFIG`.

.. highlight:: c

::

    esp_eth_config_t config = ETH"
"_DEFAULT_CONFIG(mac, phy); // apply default driver configuration
    esp_eth_handle_t eth_handle = NULL; // after the driver is installed, we will get the handle of the driver
    esp_eth_driver_install(&config, &eth_handle); // install driver

The Ethernet driver also includes an event-driven model, which sends useful and important events to user space. We need to initialize the event loop before installing the Ethernet driver. For more information about event-driven programming, please refer t"
"o :doc:`ESP Event `.

.. highlight:: c

::

    /** Event handler for Ethernet events */
    static void eth_event_handler(void *arg, esp_event_base_t event_base,
                                  int32_t event_id, void *event_data)
    {
        uint8_t mac_addr[6] = {0};
        /* we can get the ethernet driver handle from event data */
        esp_eth_handle_t eth_handle = *(esp_eth_handle_t *)event_data;

        switch (event_id) {
        case ETHERNET_EVENT_CONNECTED:
            esp_eth"
"_ioctl(eth_handle, ETH_CMD_G_MAC_ADDR, mac_addr);
            ESP_LOGI(TAG, ""Ethernet Link Up"");
            ESP_LOGI(TAG, ""Ethernet HW Addr %02x:%02x:%02x:%02x:%02x:%02x"",
                        mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
            break;
        case ETHERNET_EVENT_DISCONNECTED:
            ESP_LOGI(TAG, ""Ethernet Link Down"");
            break;
        case ETHERNET_EVENT_START:
            ESP_LOGI(TAG, ""Ethernet Started"");
            b"
"reak;
        case ETHERNET_EVENT_STOP:
            ESP_LOGI(TAG, ""Ethernet Stopped"");
            break;
        default:
            break;
        }
    }

    esp_event_loop_create_default(); // create a default event loop that runs in the background
    esp_event_handler_register(ETH_EVENT, ESP_EVENT_ANY_ID, &eth_event_handler, NULL); // register Ethernet event handler (to deal with user-specific stuff when events like link up/down happened)

Start Ethernet Driver


After driver installatio"
"n, we can start Ethernet immediately.

.. highlight:: c

::

    esp_eth_start(eth_handle); // start Ethernet driver state machine

.. _connect-driver-to-stack:

Connect Driver to TCP/IP Stack


Up until now, we have installed the Ethernet driver. From the view of OSI (Open System Interconnection), we are still on level 2 (i.e., Data Link Layer). While we can detect link up and down events and gain MAC address in user space, it is infeasible to obtain the IP address, let alone send an HTTP reque"
"st. The TCP/IP stack used in ESP-IDF is called LwIP. For more information about it, please refer to :doc:`LwIP `.

To connect the Ethernet driver to TCP/IP stack, follow these three steps:

For more information about the network interface, please refer to :doc:`Network Interface `.

.. highlight:: c

::

    /** Event handler for IP_EVENT_ETH_GOT_IP */
    static void got_ip_event_handler(void *arg, esp_event_base_t event_base,
                                     int32_t event_id, void *event_d"
"ata)
    {
        ip_event_got_ip_t *event = (ip_event_got_ip_t *) event_data;
        const esp_netif_ip_info_t *ip_info = &event->ip_info;

        ESP_LOGI(TAG, ""Ethernet Got IP Address"");
        ESP_LOGI(TAG, ""~~~~~~~~~~~"");
        ESP_LOGI(TAG, ""ETHIP:"" IPSTR, IP2STR(&ip_info->ip));
        ESP_LOGI(TAG, ""ETHMASK:"" IPSTR, IP2STR(&ip_info->netmask));
        ESP_LOGI(TAG, ""ETHGW:"" IPSTR, IP2STR(&ip_info->gw));
        ESP_LOGI(TAG, ""~~~~~~~~~~~"");
    }

    esp_netif_init()); // Initiali"
"ze TCP/IP network interface (should be called only once in application)
    esp_netif_config_t cfg = ESP_NETIF_DEFAULT_ETH(); // apply default network interface configuration for Ethernet
    esp_netif_t *eth_netif = esp_netif_new(&cfg); // create network interface for Ethernet driver

    esp_netif_attach(eth_netif, esp_eth_new_netif_glue(eth_handle)); // attach Ethernet driver to TCP/IP stack
    esp_event_handler_register(IP_EVENT, IP_EVENT_ETH_GOT_IP, &got_ip_event_handler, NULL); // registe"
"r user defined IP event handlers
    esp_eth_start(eth_handle); // start Ethernet driver state machine

.. warning::
    It is recommended to fully initialize the Ethernet driver and network interface before registering the user's Ethernet/IP event handlers, i.e., register the event handlers as the last thing prior to starting the Ethernet driver. Such an approach ensures that Ethernet/IP events get executed first by the Ethernet driver or network interface so the system is in the expected state"
" when executing the user's handlers.

.. _misc-operation-of-driver:

Misc Control of Ethernet Driver


The following functions should only be invoked after the Ethernet driver has been installed.

.. highlight:: c

::

    /* get MAC address */
    uint8_t mac_addr[6];
    memset(mac_addr, 0, sizeof(mac_addr));
    esp_eth_ioctl(eth_handle, ETH_CMD_G_MAC_ADDR, mac_addr);
    ESP_LOGI(TAG, ""Ethernet MAC Address: %02x:%02x:%02x:%02x:%02x:%02x"",
             mac_addr[0], mac_addr[1], mac_addr[2], m"
"ac_addr[3], mac_addr[4], mac_addr[5]);

    /* get PHY address */
    int phy_addr = -1;
    esp_eth_ioctl(eth_handle, ETH_CMD_G_PHY_ADDR, &phy_addr);
    ESP_LOGI(TAG, ""Ethernet PHY Address: %d"", phy_addr);

.. _flow-control:

Flow Control


Ethernet on MCU usually has a limitation in the number of frames it can handle during network congestion, because of the limitation in RAM size. A sending station might be transmitting data faster than the peer end can accept it. The ethernet flow control m"
"echanism allows the receiving node to signal the sender requesting the suspension of transmissions until the receiver catches up. The magic behind that is the pause frame, which was defined in IEEE 802.3x.

Pause frame is a special Ethernet frame used to carry the pause command, whose EtherType field is ``0x8808``, with the Control opcode set to ``0x0001``. Only stations configured for full-duplex operation may send pause frames. When a station wishes to pause the other end of a link, it sends a"
" pause frame to the 48-bit reserved multicast address of ``01-80-C2-00-00-01``. The pause frame also includes the period of pause time being requested, in the form of a two-byte integer, ranging from ``0`` to ``65535``.

After the Ethernet driver installation, the flow control feature is disabled by default. You can enable it by:

.. highlight:: c

::

    bool flow_ctrl_enable = true;
    esp_eth_ioctl(eth_handle, ETH_CMD_S_FLOW_CTRL, &flow_ctrl_enable);

One thing that should be kept in mind i"
"s that the pause frame ability is advertised to the peer end by PHY during auto-negotiation. The Ethernet driver sends a pause frame only when both sides of the link support it.

..  Examples 

Application Examples


..  Advanced Topics 

.. _advanced-topics:

Advanced Topics


Custom PHY Driver


There are multiple PHY manufacturers with wide portfolios of chips available. The ESP-IDF already supports several PHY chips however one can easily get to a point where none of them satisfies the user'"
"s actual needs due to price, features, stock availability, etc.

Luckily, a management interface between EMAC and PHY is standardized by IEEE 802.3 in Section 22.2.4 Management Functions. It defines provisions of the so-called ""MII Management Interface"" to control the PHY and gather status from the PHY. A set of management registers is defined to control chip behavior, link properties, auto-negotiation configuration, etc. This basic management functionality is addressed by :component_file:`esp_e"
"th/src/esp_eth_phy_802_3.c` in ESP-IDF and so it makes the creation of a new custom PHY chip driver quite a simple task.

.. note::
    Always consult with PHY datasheet since some PHY chips may not comply with IEEE 802.3, Section 22.2.4. It does not mean you are not able to create a custom PHY driver, but it just requires more effort. You will have to define all PHY management functions.

The majority of PHY management functionality required by the ESP-IDF Ethernet driver is covered by the :com"
"ponent_file:`esp_eth/src/esp_eth_phy_802_3.c`. However, the following may require developing chip-specific management functions:

**Steps to create a custom PHY driver:**

Once you finish the new custom PHY driver implementation, consider sharing it among other users via `IDF Component Registry `_.

..  API Reference 

API Reference


.. include-build-file:: inc/eth_types.inc
.. include-build-file:: inc/esp_eth.inc
.. include-build-file:: inc/esp_eth_driver.inc
.. include-build-file:: inc/esp_et"
"h_com.inc
.. include-build-file:: inc/esp_eth_mac.inc
.. include-build-file:: inc/esp_eth_phy.inc
.. include-build-file:: inc/esp_eth_phy_802_3.inc
.. include-build-file:: inc/esp_eth_netif_glue.inc
"
"Wi-Fi Easy Connect\ :sup:`TM` (DPP)




Wi-Fi Easy Connect\ :sup:`TM`, also known as Device Provisioning Protocol (DPP) or Easy Connect, is a provisioning protocol certified by Wi-Fi Alliance. It is a secure and standardized provisioning protocol for configuration of Wi-Fi Devices. With Easy Connect, adding a new device to a network is as simple as scanning a QR Code. This reduces complexity and enhances user experience while onboarding devices without UI like Smart Home and IoT products. Unlike"
" old protocols like Wi-Fi Protected Setup (WPS), Wi-Fi Easy Connect in corporates strong encryption through public key cryptography to ensure networks remain secure as new devices are added.

Easy Connect brings many benefits in the user experience:

  - Simple and intuitive to use; no lengthy instructions to follow for new device setup
  - No need to remember and enter passwords into the device being provisioned
  - Works with electronic or printed QR codes, or human-readable strings
  - Suppor"
"ts both WPA2 and WPA3 networks

Please refer to Wi-Fi Alliance's official page on `Easy Connect `_ for more information.

{IDF_TARGET_NAME} supports Enrollee mode of Easy Connect with QR Code as the provisioning method. A display is required to display this QR Code. Users can scan this QR Code using their capable device and provision the {IDF_TARGET_NAME} to their Wi-Fi network. The provisioning device needs to be connected to the AP which need not support Wi-Fi Easy Connect\ :sup:`TM`.

Easy Co"
"nnect is still an evolving protocol. Of known platforms that support the QR Code method are some Android smartphones with Android 10 or higher. To use Easy Connect, no additional App needs to be installed on the supported smartphone.

Application Example


Example on how to provision {IDF_TARGET_NAME} using a supported smartphone: :example:`wifi/wifi_easy_connect/dpp-enrollee`.

API Reference


.. include-build-file:: inc/esp_dpp.inc
"
"Wi-Fi




Introduction


The Wi-Fi libraries provide support for configuring and monitoring the {IDF_TARGET_NAME} Wi-Fi networking functionality. This includes configuration for:

- Station mode (aka STA mode or Wi-Fi client mode). {IDF_TARGET_NAME} connects to an access point.
- AP mode (aka Soft-AP mode or Access Point mode). Stations connect to the {IDF_TARGET_NAME}.
- Station/AP-coexistence mode ({IDF_TARGET_NAME} is concurrently an access point and a station connected to another access poin"
"t).

- Various security modes for the above (WPA, WPA2, WPA3, etc.)
- Scanning for access points (active & passive scanning).
- Promiscuous mode for monitoring of IEEE802.11 Wi-Fi packets.


Application Examples


Several application examples demonstrating the functionality of Wi-Fi library are provided in :example:`wifi` directory of ESP-IDF repository. Please check the :example_file:`README ` for more details.


API Reference


.. include-build-file:: inc/esp_wifi.inc
.. include-build-file:: i"
"nc/esp_wifi_types.inc
.. include-build-file:: inc/esp_eap_client.inc
.. include-build-file:: inc/esp_wps.inc
.. include-build-file:: inc/esp_rrm.inc
.. include-build-file:: inc/esp_wnm.inc
.. include-build-file:: inc/esp_mbo.inc
"
"ESP-NOW




Overview


ESP-NOW is a kind of connectionless Wi-Fi communication protocol that is defined by Espressif. In ESP-NOW, application data is encapsulated in a vendor-specific action frame and then transmitted from one Wi-Fi device to another without connection.

CTR with CBC-MAC Protocol (CCMP) is used to protect the action frame for security. ESP-NOW is widely used in smart light, remote controlling, sensor, etc.

Frame Format


ESP-NOW uses a vendor-specific action frame to transmit E"
"SP-NOW data. The default ESP-NOW bit rate is 1 Mbps. The format of the vendor-specific action frame is as follows:

.. highlight:: none

::

    
    | MAC Header | Category Code | Organization Identifier | Random Values | Vendor Specific Content |   FCS   |
    
      24 bytes         1 byte              3 bytes               4 bytes             7-257 bytes        4 bytes

- Category Code: The Category Code field is set to the value (127) indicating the vendor-specific category.
- Organization "
"Identifier: The Organization Identifier contains a unique identifier (0x18fe34), which is the first three bytes of MAC address applied by Espressif.
- Random Value: The Random Value filed is used to prevents relay attacks.
- Vendor Specific Content: The Vendor Specific Content contains vendor-specific fields as follows:

.. highlight:: none

::

    
    | Element ID | Length | Organization Identifier | Type | Version |    Body    |
    
        1 byte     1 byte            3 bytes         1 byt"
"e   1 byte   0-250 bytes

- Element ID: The Element ID field is set to the value (221), indicating the vendor-specific element.
- Length: The length is the total length of Organization Identifier, Type, Version and Body.
- Organization Identifier: The Organization Identifier contains a unique identifier (0x18fe34), which is the first three bytes of MAC address applied by Espressif.
- Type: The Type field is set to the value (4) indicating ESP-NOW.
- Version: The Version field is set to the versi"
"on of ESP-NOW.
- Body: The Body contains the ESP-NOW data.

As ESP-NOW is connectionless, the MAC header is a little different from that of standard frames. The FromDS and ToDS bits of FrameControl field are both 0. The first address field is set to the destination address. The second address field is set to the source address. The third address field is set to broadcast address (0xff:0xff:0xff:0xff:0xff:0xff).

Security


ESP-NOW uses the CCMP method, which is described in IEEE Std. 802.11-2012"
", to protect the vendor-specific action frame. The Wi-Fi device maintains a Primary Master Key (PMK) and several Local Master Keys (LMK). The lengths of both PMK and LMk are 16 bytes.

Encrypting multicast vendor-specific action frame is not supported.

Initialization and Deinitialization


Call :cpp:func:`esp_now_init()` to initialize ESP-NOW and :cpp:func:`esp_now_deinit()` to de-initialize ESP-NOW. ESP-NOW data must be transmitted after Wi-Fi is started, so it is recommended to start Wi-Fi be"
"fore initializing ESP-NOW and stop Wi-Fi after de-initializing ESP-NOW.

When :cpp:func:`esp_now_deinit()` is called, all of the information of paired devices are deleted.

Add Paired Device


Call :cpp:func:`esp_now_add_peer()` to add the device to the paired device list before you send data to this device. If security is enabled, the LMK must be set. You can send ESP-NOW data via both the Station and the SoftAP interface. Make sure that the interface is enabled before sending ESP-NOW data.

.."
" only:: esp32c2

    The maximum number of paired devices is 20, and the paired encryption devices are no more than 4, the default is 2. If you want to change the number of paired encryption devices, set :ref:`CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM` in the Wi-Fi component configuration menu.

.. only:: esp32 or esp32s2 or esp32s3 or esp32c3 or esp32c6

    The maximum number of paired devices is 20, and the paired encryption devices are no more than 17, the default is 7. If you want to change th"
"e number of paired encryption devices, set :ref:`CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM` in the Wi-Fi component configuration menu.

A device with a broadcast MAC address must be added before sending broadcast data. The range of the channel of paired devices is from 0 to 14. If the channel is set to 0, data will be sent on the current channel. Otherwise, the channel must be set as the channel that the local device is on.

Send ESP-NOW Data


Call :cpp:func:`esp_now_send()` to send ESP-NOW data a"
"nd :cpp:func:`esp_now_register_send_cb()` to register sending callback function. It will return `ESP_NOW_SEND_SUCCESS` in sending callback function if the data is received successfully on the MAC layer. Otherwise, it will return `ESP_NOW_SEND_FAIL`. Several reasons can lead to ESP-NOW fails to send data. For example, the destination device does not exist; the channels of the devices are not the same; the action frame is lost when transmitting on the air, etc. It is not guaranteed that applicatio"
"n layer can receive the data. If necessary, send back ack data when receiving ESP-NOW data. If receiving ack data timeouts, retransmit the ESP-NOW data. A sequence number can also be assigned to ESP-NOW data to drop the duplicate data.

If there is a lot of ESP-NOW data to send, call :cpp:func:`esp_now_send()` to send less than or equal to 250 bytes of data once a time. Note that too short interval between sending two ESP-NOW data may lead to disorder of sending callback function. So, it is reco"
"mmended that sending the next ESP-NOW data after the sending callback function of the previous sending has returned. The sending callback function runs from a high-priority Wi-Fi task. So, do not do lengthy operations in the callback function. Instead, post the necessary data to a queue and handle it from a lower priority task.

Receiving ESP-NOW Data


Call :cpp:func:`esp_now_register_recv_cb()` to register receiving callback function.  Call the receiving callback function when receiving ESP-NO"
"W. The receiving callback function also runs from the Wi-Fi task. So, do not do lengthy operations in the callback function.
Instead, post the necessary data to a queue and handle it from a lower priority task.

Config ESP-NOW Rate


.. only:: esp32 or esp32s2 or esp32s3 or esp32c2 or esp32c3

    Call :cpp:func:`esp_wifi_config_espnow_rate()` to config ESP-NOW rate of specified interface. Make sure that the interface is enabled before config rate. This API should be called after :cpp:func:`esp_"
"wifi_start()`.

.. only:: esp32c6

    Call :cpp:func:`esp_now_set_peer_rate_config()` to configure ESP-NOW rate of each peer. Make sure that the peer is added before configuring the rate. This API should be called after :cpp:func:`esp_wifi_start()` and :cpp:func:`esp_now_add_peer()`.

    .. note::

        :cpp:func:`esp_wifi_config_espnow_rate()` is deprecated, please use cpp::func:`esp_now_set_peer_rate_config()` instead.

Config ESP-NOW Power-saving Parameter


Sleep is supported only when "
"{IDF_TARGET_NAME} is configured as station.

Call :cpp:func:`esp_now_set_wake_window()` to configure Window for ESP-NOW RX at sleep. The default value is the maximum, which allowing RX all the time.

If Power-saving is needed for ESP-NOW, call :cpp:func:`esp_wifi_connectionless_module_set_wake_interval()` to configure Interval as well.

.. only:: SOC_WIFI_SUPPORTED

    Please refer to :ref:`connectionless module power save ` to get more detail.

Application Examples


API Reference


.. include"
"-build-file:: inc/esp_now.inc
"
"SmartConfig




The SmartConfig\ :sup:`TM` is a provisioning technology developed by TI to connect a new Wi-Fi device to a Wi-Fi network. It uses a mobile application to broadcast the network credentials from a smartphone, or a tablet, to an un-provisioned Wi-Fi device.

The advantage of this technology is that the device does not need to directly know SSID or password of an Access Point (AP). This information is provided using the smartphone. This is particularly important to headless device an"
"d systems, due to their lack of a user interface.

If you are looking for other options to provision your {IDF_TARGET_NAME} devices, check :doc:`../provisioning/index`.


Application Example


Connect {IDF_TARGET_NAME} to the target AP using SmartConfig: :example:`wifi/smart_config`.


API Reference


.. include-build-file:: inc/esp_smartconfig.inc
"
"ESP-WIFI-MESH Programming Guide




This is a programming guide for ESP-WIFI-MESH, including the API reference and coding examples. This guide is split into the following parts:

For documentation regarding the ESP-WIFI-MESH protocol, please see the :doc:`ESP-WIFI-MESH API Guide `. For more information about ESP-WIFI-MESH Development Framework, please see `ESP-WIFI-MESH Development Framework `_.


..  ESP-WIFI-MESH Programming Model 

.. _mesh-programming-model:

ESP-WIFI-MESH Programming Model
"
"

Software Stack


The ESP-WIFI-MESH software stack is built atop the Wi-Fi Driver/FreeRTOS and may use the LwIP Stack in some instances (i.e., the root node). The following diagram illustrates the ESP-WIFI-MESH software stack.

.. _mesh-going-to-software-stack:

.. figure:: ../../../_static/mesh-software-stack.png
    :align: center
    :alt: ESP-WIFI-MESH Software Stack
    :figclass: align-center

    ESP-WIFI-MESH Software Stack

.. _mesh-events:

System Events


An application interfaces wi"
"th ESP-WIFI-MESH via **ESP-WIFI-MESH Events**. Since ESP-WIFI-MESH is built atop the Wi-Fi stack, it is also possible for the application to interface with the Wi-Fi driver via the **Wi-Fi Event Task**. The following diagram illustrates the interfaces for the various System Events in an ESP-WIFI-MESH application.

.. figure:: ../../../_static/mesh-events-delivery.png
    :align: center
    :alt: ESP-WIFI-MESH System Events Delivery
    :figclass: align-center

    ESP-WIFI-MESH System Events Del"
"ivery

The :cpp:type:`mesh_event_id_t` defines all possible ESP-WIFI-MESH events and can indicate events such as the connection/disconnection of parent/child. Before ESP-WIFI-MESH events can be used, the application must register a **Mesh Events handler** via :cpp:func:`esp_event_handler_register` to the default event task. The Mesh Events handler that is registered contain handlers for each ESP-WIFI-MESH event relevant to the application.

Typical use cases of mesh events include using events s"
"uch as :cpp:enumerator:`MESH_EVENT_PARENT_CONNECTED` and :cpp:enumerator:`MESH_EVENT_CHILD_CONNECTED` to indicate when a node can begin transmitting data upstream and downstream respectively. Likewise, :cpp:enumerator:`IP_EVENT_STA_GOT_IP` and :cpp:enumerator:`IP_EVENT_STA_LOST_IP` can be used to indicate when the root node can and cannot transmit data to the external IP network.

.. warning::

    When using ESP-WIFI-MESH under self-organized mode, users must ensure that no calls to Wi-Fi API a"
"re made. This is due to the fact that the self-organizing mode will internally make Wi-Fi API calls to connect/disconnect/scan etc. **Any Wi-Fi calls from the application (including calls from callbacks and handlers of Wi-Fi events) may interfere with ESP-WIFI-MESH's self-organizing behavior**. Therefore, users should not call Wi-Fi APIs after :cpp:func:`esp_mesh_start` is called, and before :cpp:func:`esp_mesh_stop` is called.

LwIP & ESP-WIFI-MESH


The application can access the ESP-WIFI-MESH"
" stack directly without having to go through the LwIP stack. The LwIP stack is only required by the root node to transmit/receive data to/from an external IP network. However, since every node can potentially become the root node (due to automatic root node selection), each node must still initialize the LwIP stack.

**Each node that could become root is required to initialize LwIP by calling** :cpp:func:`esp_netif_init`. In order to prevent non-root node access to LwIP, the application should n"
"ot create or register any network interfaces using esp_netif APIs.


    ESP-WIFI-MESH requires a root node to be connected with a router. Therefore, in the event that a node becomes the root, **the corresponding handler must start the DHCP client service and immediately obtain an IP address**. Doing so will allow other nodes to begin transmitting/receiving packets to/from the external IP network. However, this step is unnecessary if static IP settings are used.


..  Writing a Mesh Application "
"

.. _mesh-writing-mesh-application:

Writing an ESP-WIFI-MESH Application


The prerequisites for starting ESP-WIFI-MESH is to initialize LwIP and Wi-Fi, The following code snippet demonstrates the necessary prerequisite steps before ESP-WIFI-MESH itself can be initialized.

.. code-block:: c

    ESP_ERROR_CHECK(esp_netif_init());

    /*  event initialization */
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    /*  Wi-Fi initialization */
    wifi_init_config_t config = WIFI_INIT_CON"
"FIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&config));
    /*  register IP events handler */
    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL));
    ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH));
    ESP_ERROR_CHECK(esp_wifi_start());

After initializing LwIP and Wi-Fi, the process of getting an ESP-WIFI-MESH network up and running can be summarized into the following three steps:

.. _mesh-initialize-mesh:

Initialize Mesh


"
"The following code snippet demonstrates how to initialize ESP-WIFI-MESH

.. code-block:: c

    /*  mesh initialization */
    ESP_ERROR_CHECK(esp_mesh_init());
    /*  register mesh events handler */
    ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL));

.. _mesh-configuring-mesh:

Configuring an ESP-WIFI-MESH Network


.. todo - Add note about unified configuration

ESP-WIFI-MESH is configured via :cpp:func:`esp_mesh_set_config` which receive"
"s its arguments using the :cpp:type:`mesh_cfg_t` structure. The structure contains the following parameters used to configure ESP-WIFI-MESH:


.. list-table::
   :header-rows: 1
   :widths: 15 25
     - Description
     - Range from 1 to 14
     - ID of ESP-WIFI-MESH Network, see :cpp:type:`mesh_addr_t`
     - Router Configuration, see :cpp:type:`mesh_router_t`
     - Mesh AP Configuration, see :cpp:type:`mesh_ap_cfg_t`
     - Crypto Functions for Mesh IE, see :cpp:type:`mesh_crypto_funcs_t`


T"
"he following code snippet demonstrates how to configure ESP-WIFI-MESH.

.. code-block:: c

    /* Enable the Mesh IE encryption by default */
    mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT();
    /* mesh ID */
    memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6);
    /* channel (must match the router's channel) */
    cfg.channel = CONFIG_MESH_CHANNEL;
    /* router */
    cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID);
    memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.rout"
"er.ssid_len);
    memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD,
           strlen(CONFIG_MESH_ROUTER_PASSWD));
    /* mesh softAP */
    cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS;
    memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD,
           strlen(CONFIG_MESH_AP_PASSWD));
    ESP_ERROR_CHECK(esp_mesh_set_config(&cfg));

.. _mesh-start-mesh:

Start Mesh


The following code snippet demonstrates how to start ESP-WIFI-MESH.

.. code-block:: c

"
"    /* mesh start */
    ESP_ERROR_CHECK(esp_mesh_start());

After starting ESP-WIFI-MESH, the application should check for ESP-WIFI-MESH events to determine when it has connected to the network. After connecting, the application can start transmitting and receiving packets over the ESP-WIFI-MESH network using :cpp:func:`esp_mesh_send` and :cpp:func:`esp_mesh_recv`.


..  ESP-WIFI-MESH Application Examples 

.. _mesh-self-organized-behavior:

Self-Organized Networking


Self-organized networking"
" is a feature of ESP-WIFI-MESH where nodes can autonomously scan/select/connect/reconnect to other nodes and routers. This feature allows an ESP-WIFI-MESH network to operate with high degree of autonomy by making the network robust to dynamic network topologies and conditions. With self-organized networking enabled, nodes in an ESP-WIFI-MESH network are able to carry out the following actions without autonomously:

- Selection or election of the root node (see **Automatic Root Node Selection** i"
"n :ref:`mesh-building-a-network`)
- Selection of a preferred parent node (see **Parent Node Selection** in :ref:`mesh-building-a-network`)
- Automatic reconnection upon detecting a disconnection (see **Intermediate Parent Node Failure** in :ref:`mesh-managing-a-network`)

When self-organized networking is enabled, the ESP-WIFI-MESH stack will internally make calls to Wi-Fi APIs. Therefore, **the application layer should not make any calls to Wi-Fi APIs whilst self-organized networking is enabled"
" as doing so would risk interfering with ESP-WIFI-MESH**.

Toggling Self-Organized Networking


Self-organized networking can be enabled or disabled by the application at runtime by calling the :cpp:func:`esp_mesh_set_self_organized` function. The function has the two following parameters:

- ``bool enable`` specifies whether to enable or disable self-organized networking.

- ``bool select_parent`` specifies whether a new parent node should be selected when enabling self-organized networking. Se"
"lecting a new parent has different effects depending the node type and the node's current state. This parameter is unused when disabling self-organized networking.

Disabling Self-Organized Networking
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
The following code snippet demonstrates how to disable self-organized networking.

.. code-block:: c

    //Disable self-organized networking
    esp_mesh_set_self_organized(false, false);

ESP-WIFI-MESH will attempt to maintain the node's current Wi-Fi state whe"
"n disabling self-organized networking.

- If the node was previously connected to other nodes, it will remain connected.
- If the node was previously disconnected and was scanning for a parent node or router, it will stop scanning.
- If the node was previously attempting to reconnect to a parent node or router, it will stop reconnecting.

Enabling Self-Organized Networking
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

ESP-WIFI-MESH will attempt to maintain the node's current Wi-Fi state when enabling self"
"-organized networking. However, depending on the node type and whether a new parent is selected, the Wi-Fi state of the node can change. The following table shows effects of enabling self-organized networking.

++++
| Select Parent | Is Root Node | Effects                                                                                                          |
++++
| N             | N            | - Nodes already connected to a parent node will remain connected.                                 "
"               |
|               |              | - Nodes previously scanning for a parent nodes will stop scanning. Call :cpp:func:`esp_mesh_connect` to restart. |
|               +++
|               | Y            | - A root node already connected to router will stay connected.                                                   |
|               |              | - A root node disconnected from router will need to call :cpp:func:`esp_mesh_connect` to reconnect.              |
++++
| Y           "
"  | N            | - Nodes without a parent node will automatically select a preferred parent and connect.                          |
|               |              | - Nodes already connected to a parent node will disconnect, reselect a preferred parent node, and connect.       |
|               +++
|               | Y            | - For a root node to connect to a parent node, it must give up it's role as root. Therefore, a root node will    |
|               |              |   disconnect from"
" the router and all child nodes, select a preferred parent node, and connect.                   |
++++

The following code snipping demonstrates how to enable self-organized networking.

.. code-block:: c

    //Enable self-organized networking and select a new parent
    esp_mesh_set_self_organized(true, true);

    ...

    //Enable self-organized networking and manually reconnect
    esp_mesh_set_self_organized(true, false);
    esp_mesh_connect();


Calling Wi-Fi API


There can be instances"
" in which an application may want to directly call Wi-Fi API whilst using ESP-WIFI-MESH. For example, an application may want to manually scan for neighboring APs. However, **self-organized networking must be disabled before the application calls any Wi-Fi APIs**. This will prevent the ESP-WIFI-MESH stack from attempting to call any Wi-Fi APIs and potentially interfering with the application's calls.

Therefore, application calls to Wi-Fi APIs should be placed in between calls of :cpp:func:`esp_"
"mesh_set_self_organized` which disable and enable self-organized networking. The following code snippet demonstrates how an application can safely call :cpp:func:`esp_wifi_scan_start` whilst using ESP-WIFI-MESH.

.. code-block:: c

    //Disable self-organized networking
    esp_mesh_set_self_organized(0, 0);

    //Stop any scans already in progress
    esp_wifi_scan_stop();
    //Manually start scan. Will automatically stop when run to completion
    esp_wifi_scan_start();

    //Process scan "
"results

    ...

    //Re-enable self-organized networking if still connected
    esp_mesh_set_self_organized(1, 0);

    ...

    //Re-enable self-organized networking if non-root and disconnected
    esp_mesh_set_self_organized(1, 1);

    ...

    //Re-enable self-organized networking if root and disconnected
    esp_mesh_set_self_organized(1, 0);  //Do not select new parent
    esp_mesh_connect();                 //Manually reconnect to router


..  ESP-WIFI-MESH Application Examples 

.. _"
"mesh-application-examples:

Application Examples


ESP-IDF contains these ESP-WIFI-MESH example projects:

:example:`The Internal Communication Example ` demonstrates how to set up a ESP-WIFI-MESH network and have the root node send a data packet to every node within the network.

:example:`The Manual Networking Example ` demonstrates how to use ESP-WIFI-MESH without the self-organizing features. This example shows how to program a node to manually scan for a list of potential parent nodes and s"
"elect a parent node based on custom criteria.


..  ESP-WIFI-MESH API Reference 

.. _mesh-api-reference:

API Reference


.. include-build-file:: inc/esp_mesh.inc
"
"Wi-Fi Aware\ :sup:`TM` (NAN)




Wi-Fi Aware\ :sup:`TM` or NAN (Neighbor Awareness Networking) is a protocol that allows Wi-Fi devices to discover services in their proximity. Typically, location-based services are based on querying servers for information about the environment and the location knowledge is based on GPS or other location reckoning techniques. However, NAN does not require real-time connection to servers, GPS or other geo-location, but instead uses direct device-to-device Wi-Fi t"
"o discover and exchange information. NAN scales effectively in dense Wi-Fi environments and complements the connectivity of Wi-Fi by providing information about people and services in the proximity.

Multiple NAN devices which are in the vicinity form a NAN cluster which allows them to communicate with each other. Devices within a NAN cluster can advertise (Publish method) or look for (Subscribe method) services using NAN Service Discovery protocols. Matching of services is done by service name,"
" once a match is found, a device can either send a message or establish an IPv6 Datapath with the peer.

{IDF_TARGET_NAME} supports Wi-Fi Aware in standalone mode with support for both Service Discovery and Datapath. Wi-Fi Aware is still an evolving protocol. Please refer to Wi-Fi Alliance's official page on `Wi-Fi Aware `_ for more information. Many Android smartphones with Android 8 or higher support Wi-Fi Aware. Refer to Android's developer guide on Wi-Fi Aware `Wi-Fi Aware `_ for more inform"
"ation.

Application Example


A pair of examples for a Publisher-Subscriber use case: :example:`wifi/wifi_aware/nan_publisher` and :example:`wifi/wifi_aware/nan_subscriber`. A user interactive console example to explore full functionality of Wi-Fi Aware: :example:`wifi/wifi_aware/nan_console`. Please check the `README` for more details in respective example directories.

API Reference


.. include-build-file:: inc/esp_nan.inc
"
"ESP-NETIF




The purpose of the ESP-NETIF library is twofold:

- It provides an abstraction layer for the application on top of the TCP/IP stack. This allows applications to choose between IP stacks in the future.
- The APIs it provides are thread-safe, even if the underlying TCP/IP stack APIs are not.

ESP-IDF currently implements ESP-NETIF for the lwIP TCP/IP stack only. However, the adapter itself is TCP/IP implementation-agnostic and allows different implementations.

It is also possible to"
" use a custom TCP/IP stack with ESP-IDF, provided it implements BSD API. For more information on building ESP-IDF without lwIP, please refer to :idf_file:`components/esp_netif_stack/README.md`.

Some ESP-NETIF API functions are intended to be called by application code, for example, to get or set interface IP addresses, and configure DHCP. Other functions are intended for internal ESP-IDF use by the network driver layer.

In many cases, applications do not need to call ESP-NETIF APIs directly as"
" they are called by the default network event handlers.


.. _esp-netif structure:

ESP-NETIF Architecture


.. code-block:: text


                         |          (A) USER CODE                 |
                         |                 Apps                   |
        .................| init          settings      events     |
        .                ++
        .                   .                |           *
        .                   .                |           *
    +            +"
"+   *     ++
            |            | new/config   get/set/apps |   *     | init                  |
            |            |                           |...*.....| Apps (DHCP, SNTP)     |
            |            ||   *     |                       |
      init  |            |                           |****     |                       |
      start ||  event handler            ||  DHCP                 |
      stop  |            |                           |         |                       |
 "
"           |            ||         |                       |
            |            |                           |         |    NETIF              |
      +|            |                           |         ++     |
      | glue||---|  esp_netif_receive        |-->| netif_input     |     |
      |     |        |   |                           |         + +     |
      |     |...--|  esp_vfs_l2tap_eth_filter |>---|  read            |
                         |                           |         "
"|                  |
                         |            (E)            |         ++
                         ++
                                                                     USER CODE
                               ESP-NETIF L2 TAP


Data and Event Flow in the Diagram


ESP-NETIF Interaction


A) User Code, Boilerplate


Overall application interaction with a specific IO driver for communication media and configured TCP/IP network stack is abstracted using ESP-NETIF APIs and is outline"
"d as below:

A) Initialization code

  1) Initializes IO driver
  2) Creates a new instance of ESP-NETIF and configure it with

  3) Attaches the IO driver handle to the ESP-NETIF instance created in the above steps
  4) Configures event handlers

B) Interaction with network interfaces using ESP-NETIF API

  1) Gets and sets TCP/IP-related parameters (DHCP, IP, etc)
  2) Receives IP events (connect or disconnect)
  3) Controls application lifecycle (set interface up or down)


B) Communication D"
"river, IO Driver, and Media Driver


Communication driver plays these two important roles in relation to ESP-NETIF:

1) Event handlers: Defines behavior patterns of interaction with ESP-NETIF (e.g., ethernet link-up -> turn netif on)

2) Glue IO layer: Adapts the input or output functions to use ESP-NETIF transmit, receive, and free receive buffer


C) ESP-NETIF


ESP-NETIF serves as an intermediary between an IO driver and a network stack, connecting the packet data path between the two. It pro"
"vides a set of interfaces for attaching a driver to an ESP-NETIF object at runtime and configures a network stack during compiling. Additionally, a set of APIs is provided to control the network interface lifecycle and its TCP/IP properties. As an overview, the ESP-NETIF public interface can be divided into six groups:

1) Initialization APIs (to create and configure ESP-NETIF instance)
2) Input or Output API (for passing data between IO driver and network stack)
3) Event or Action API

4) Sette"
"rs and Getters API for basic network interface properties
5) Network stack abstraction API: enabling user interaction with TCP/IP stack

6) Driver conversion utilities API


D) Network Stack


The network stack has no public interaction with application code with regard to public interfaces and shall be fully abstracted by ESP-NETIF API.


E) ESP-NETIF L2 TAP Interface

The ESP-NETIF L2 TAP interface is a mechanism in ESP-IDF used to access Data Link Layer (L2 per OSI/ISO) for frame reception an"
"d transmission from the user application. Its typical usage in the embedded world might be the implementation of non-IP-related protocols, e.g., PTP, Wake on LAN. Note that only Ethernet (IEEE 802.3) is currently supported.

From a user perspective, the ESP-NETIF L2 TAP interface is accessed using file descriptors of VFS, which provides file-like interfacing (using functions like ``open()``, ``read()``, ``write()``, etc). To learn more, refer to :doc:`/api-reference/storage/vfs`.

There is only "
"one ESP-NETIF L2 TAP interface device (path name) available. However multiple file descriptors with different configurations can be opened at a time since the ESP-NETIF L2 TAP interface can be understood as a generic entry point to the Layer 2 infrastructure. What is important is then the specific configuration of the particular file descriptor. It can be configured to give access to a specific Network Interface identified by ``if_key`` (e.g., `ETH_DEF`) and to filter only specific frames based "
"on their type (e.g., Ethernet type in the case of IEEE 802.3). Filtering only specific frames is crucial since the ESP-NETIF L2 TAP needs to exist along with the IP stack and so the IP-related traffic (IP, ARP, etc.) should not be passed directly to the user application. Even though this option is still configurable, it is not recommended in standard use cases. Filtering is also advantageous from the perspective of the user's application, as it only gets access to the frame types it is intereste"
"d in, and the remaining traffic is either passed to other L2 TAP file descriptors or to the IP stack.

ESP-NETIF L2 TAP Interface Usage Manual


Initialization

To be able to use the ESP-NETIF L2 TAP interface, it needs to be enabled in Kconfig by :ref:`CONFIG_ESP_NETIF_L2_TAP` first and then registered by :cpp:func:`esp_vfs_l2tap_intf_register()` prior usage of any VFS function.

``open()``

Once the ESP-NETIF L2 TAP is registered, it can be opened at path name ""/dev/net/tap"". The same path nam"
"e can be opened multiple times up to :ref:`CONFIG_ESP_NETIF_L2_TAP_MAX_FDS` and multiple file descriptors with a different configuration may access the Data Link Layer frames.

The ESP-NETIF L2 TAP can be opened with the ``O_NONBLOCK`` file status flag to make sure the ``read()`` does not block. Note that the ``write()`` may block in the current implementation when accessing a Network interface since it is a shared resource among multiple ESP-NETIF L2 TAP file descriptors and IP stack, and there"
" is currently no queuing mechanism deployed. The file status flag can be retrieved and modified using ``fcntl()``.

On success, ``open()`` returns the new file descriptor (a nonnegative integer). On error, -1 is returned, and ``errno`` is set to indicate the error.

``ioctl()``

The newly opened ESP-NETIF L2 TAP file descriptor needs to be configured prior to its usage since it is not bounded to any specific Network Interface and no frame type filter is configured. The following configuration op"
"tions are available to do so:

All above-set configuration options have a getter counterpart option to read the current settings.

.. warning::
    The file descriptor needs to be firstly bounded to a specific Network Interface by ``L2TAP_S_INTF_DEVICE`` or ``L2TAP_S_DEVICE_DRV_HNDL`` to make ``L2TAP_S_RCV_FILTER`` option available.

.. note::
    VLAN-tagged frames are currently not recognized. If the user needs to process VLAN-tagged frames, they need a set filter to be equal to the VLAN tag ("
"i.e., 0x8100 or 0x88A8) and process the VLAN-tagged frames in the user application.

.. note::
    ``L2TAP_S_DEVICE_DRV_HNDL`` is particularly useful when the user's application does not require the usage of an IP stack and so ESP-NETIF is not required to be initialized too. As a result, Network Interface cannot be identified by its ``if_key`` and hence it needs to be identified directly by its IO Driver handle.

| On success, ``ioctl()`` returns 0. On error, -1 is returned, and ``errno`` is set"
" to indicate the error.
| * EBADF - not a valid file descriptor.
| * EACCES - options change is denied in this state (e.g., file descriptor has not been bounded to Network interface yet).
| * EINVAL - invalid configuration argument. Ethernet type filter is already used by other file descriptors on that same Network interface.
| * ENODEV - no such Network Interface which is tried to be assigned to the file descriptor exists.
| * ENOSYS - unsupported operation, passed configuration option does not"
" exist.

``fcntl()``

``fcntl()`` is used to manipulate with properties of opened ESP-NETIF L2 TAP file descriptor.

The following commands manipulate the status flags associated with the file descriptor:

| On success, ``ioctl()`` returns 0. On error, -1 is returned, and ``errno`` is set to indicate the error.
| * EBADF - not a valid file descriptor.
| * ENOSYS - unsupported command.

``read()``

Opened and configured ESP-NETIF L2 TAP file descriptor can be accessed by ``read()`` to get inbound"
" frames. The read operation can be either blocking or non-blocking based on the actual state of the ``O_NONBLOCK`` file status flag. When the file status flag is set to blocking, the read operation waits until a frame is received and the context is switched to other tasks. When the file status flag is set to non-blocking, the read operation returns immediately. In such case, either a frame is returned if it was already queued or the function indicates the queue is empty. The number of queued fra"
"mes associated with one file descriptor is limited by :ref:`CONFIG_ESP_NETIF_L2_TAP_RX_QUEUE_SIZE` Kconfig option. Once the number of queued frames reached a configured threshold, the newly arrived frames are dropped until the queue has enough room to accept incoming traffic (Tail Drop queue management).

| On success, ``read()`` returns the number of bytes read. Zero is returned when the size of the destination buffer is 0. On error, -1 is returned, and ``errno`` is set to indicate the error.
|"
" * EBADF - not a valid file descriptor.
| * EAGAIN - the file descriptor has been marked non-blocking (``O_NONBLOCK``), and the read would block.

``write()``

A raw Data Link Layer frame can be sent to Network Interface via opened and configured ESP-NETIF L2 TAP file descriptor. The user's application is responsible to construct the whole frame except for fields which are added automatically by the physical interface device. The following fields need to be constructed by the user's application "
"in case of an Ethernet link: source/destination MAC addresses, Ethernet type, actual protocol header, and user data. The length of these fields is as follows:

.. list-table::
    :header-rows: 1
    :widths: 20 20 20 30
    :align: center
      - Source MAC
      - Type/Length
      - Payload (protocol header/data)
      - 6 B
      - 2 B
      - 0-1486 B

In other words, there is no additional frame processing performed by the ESP-NETIF L2 TAP interface. It only checks the Ethernet type of the"
" frame is the same as the filter configured in the file descriptor. If the Ethernet type is different, an error is returned and the frame is not sent. Note that the ``write()`` may block in the current implementation when accessing a Network interface since it is a shared resource among multiple ESP-NETIF L2 TAP file descriptors and IP stack, and there is currently no queuing mechanism deployed.

| On success, ``write()`` returns the number of bytes written. Zero is returned when the size of the"
" input buffer is 0. On error, -1 is returned, and ``errno`` is set to indicate the error.
| * EBADF - not a valid file descriptor.
| * EBADMSG - The Ethernet type of the frame is different from the file descriptor configured filter.
| * EIO - Network interface not available or busy.

``close()``

Opened ESP-NETIF L2 TAP file descriptor can be closed by the ``close()`` to free its allocated resources. The ESP-NETIF L2 TAP implementation of ``close()`` may block. On the other hand, it is thread-sa"
"fe and can be called from a different task than the file descriptor is actually used. If such a situation occurs and one task is blocked in the I/O operation and another task tries to close the file descriptor, the first task is unblocked. The first's task read operation then ends with an error.

| On success, ``close()`` returns zero. On error, -1 is returned, and ``errno`` is set to indicate the error.
| * EBADF - not a valid file descriptor.

``select()``

Select is used in a standard way, ju"
"st :ref:`CONFIG_VFS_SUPPORT_SELECT` needs to be enabled to make the ``select()`` function available.


.. _esp_netif-sntp-api:

SNTP API


You can find a brief introduction to SNTP in general, its initialization code, and basic modes in Section :ref:`system-time-sntp-sync` in :doc:`System Time `.

This section provides more details about specific use cases of the SNTP service, with statically configured servers, or use the DHCP-provided servers, or both. The workflow is usually very simple:

1) "
"Initialize and configure the service using :cpp:func:`esp_netif_sntp_init()`. This operations can only be called once (unless the SNTP service has been destroyed by :cpp:func:`esp_netif_sntp_deinit()`)
2) Start the service via :cpp:func:`esp_netif_sntp_start()`. This step is not needed if we auto-started the service in the previous step (default). It is useful to start the service explicitly after connecting if we want to use the DHCP-obtained NTP servers. Please note, this option needs to be en"
"abled before connecting, but the SNTP service should be started after.
3) Wait for the system time to synchronize using :cpp:func:`esp_netif_sntp_sync_wait()` (only if needed).
4) Stop and destroy the service using :cpp:func:`esp_netif_sntp_deinit()`.


Basic Mode with Statically Defined Server(s)


Initialize the module with the default configuration after connecting to the network. Note that it is possible to provide multiple NTP servers in the configuration struct:

.. code-block:: c

    esp"
"_sntp_config_t config = ESP_NETIF_SNTP_DEFAULT_CONFIG_MULTIPLE(2,
                               ESP_SNTP_SERVER_LIST(""time.windows.com"", ""pool.ntp.org"" ) );
    esp_netif_sntp_init(&config);

.. note::

    If we want to configure multiple SNTP servers, we have to update the lwIP configuration :ref:`CONFIG_LWIP_SNTP_MAX_SERVERS`.


Use DHCP-Obtained SNTP Server(s)


First of all, we have to enable the lwIP configuration option :ref:`CONFIG_LWIP_DHCP_GET_NTP_SRV`. Then we have to initialize the "
"SNTP module with the DHCP option and without the NTP server:

.. code-block:: c

    esp_sntp_config_t config = ESP_NETIF_SNTP_DEFAULT_CONFIG_MULTIPLE(0, {} );
    config.start = false;                       // start the SNTP service explicitly
    config.server_from_dhcp = true;             // accept the NTP offer from the DHCP server
    esp_netif_sntp_init(&config);

Then, once we are connected, we could start the service using:

.. code-block:: c

    esp_netif_sntp_start();

.. note::

    "
"It is also possible to start the service during initialization (default ``config.start=true``). This would likely to cause the initial SNTP request to fail (since we are not connected yet) and lead to some back-off time for subsequent requests.


Use Both Static and Dynamic Servers


Very similar to the scenario above (DHCP provided SNTP server), but in this configuration, we need to make sure that the static server configuration is refreshed when obtaining NTP servers by DHCP. The underlying lw"
"IP code cleans up the rest of the list of NTP servers when the DHCP-provided information gets accepted. Thus the ESP-NETIF SNTP module saves the statically configured server(s) and reconfigures them after obtaining a DHCP lease.

The typical configuration now looks as per below, providing the specific ``IP_EVENT`` to update the config and index of the first server to reconfigure (for example setting ``config.index_of_first_server=1`` would keep the DHCP provided server at index 0, and the static"
"ally configured server at index 1).

.. code-block:: c

    esp_sntp_config_t config = ESP_NETIF_SNTP_DEFAULT_CONFIG(""pool.ntp.org"");
    config.start = false;                       // start the SNTP service explicitly (after connecting)
    config.server_from_dhcp = true;             // accept the NTP offers from DHCP server
    config.renew_servers_after_new_IP = true;   // let esp-netif update the configured SNTP server(s) after receiving the DHCP lease
    config.index_of_first_server = 1;  "
"         // updates from server num 1, leaving server 0 (from DHCP) intact
    config.ip_event_to_renew = IP_EVENT_STA_GOT_IP;  // IP event on which we refresh the configuration

Then we start the service normally with  :cpp:func:`esp_netif_sntp_start()`.


ESP-NETIF Programmer's Manual


Please refer to the following example to understand the initialization process of the default interface:


.. only:: SOC_WIFI_SUPPORTED

    - Wi-Fi Station: :example_file:`wifi/getting_started/station/main/sta"
"tion_example_main.c`

- Ethernet: :example_file:`ethernet/basic/main/ethernet_example_main.c`

- L2 TAP: :example_file:`protocols/l2tap/main/l2tap_main.c`

.. only:: CONFIG_ESP_WIFI_SOFTAP_SUPPORT

    - Wi-Fi Access Point: :example_file:`wifi/getting_started/softAP/main/softap_example_main.c`

For more specific cases, please consult this guide: :doc:`/api-reference/network/esp_netif_driver`.


.. only:: SOC_WIFI_SUPPORTED

    Wi-Fi Default Initialization
    

    The initialization code as we"
"ll as registering event handlers for default interfaces, such as softAP and station, are provided in separate APIs to facilitate simple startup code for most applications:

    .. only:: CONFIG_ESP_WIFI_SOFTAP_SUPPORT

    Please note that these functions return the ``esp_netif`` handle, i.e., a pointer to a network interface object allocated and configured with default settings, as a consequence, which means that:

    .. only:: CONFIG_ESP_WIFI_SOFTAP_SUPPORT


API Reference


.. include-build-"
"file:: inc/esp_netif.inc
.. include-build-file:: inc/esp_netif_sntp.inc
.. include-build-file:: inc/esp_netif_types.inc
.. include-build-file:: inc/esp_netif_ip_addr.inc
.. include-build-file:: inc/esp_vfs_l2tap.inc


.. only:: SOC_WIFI_SUPPORTED

    Wi-Fi Default API Reference
    

    .. include-build-file:: inc/esp_wifi_default.inc
"
"Thread




Introduction


`Thread `_ is an IP-based mesh networking protocol. It is based on the 802.15.4 physical and MAC layer.

Application Examples


The :example:`openthread` directory of ESP-IDF examples contains the following applications:

- The OpenThread interactive shell :example:`openthread/ot_cli`
- The Thread Border Router :example:`openthread/ot_br`
- The Thread Radio Co-Processor :example:`openthread/ot_rcp`


API Reference


For manipulating the Thread network, the OpenThread AP"
"I shall be used. The OpenThread API docs can be found at the `OpenThread API docs `_.

ESP-IDF provides extra APIs for launching and managing the OpenThread stack, binding to network interfaces and border routing features.

.. include-build-file:: inc/esp_openthread.inc
.. include-build-file:: inc/esp_openthread_types.inc
.. include-build-file:: inc/esp_openthread_lock.inc
.. include-build-file:: inc/esp_openthread_netif_glue.inc
.. include-build-file:: inc/esp_openthread_border_router.inc
"
"ESP-NETIF Custom I/O Driver




This section outlines implementing a new I/O driver with ESP-NETIF connection capabilities.

By convention, the I/O driver has to register itself as an ESP-NETIF driver, and thus holds a dependency on ESP-NETIF component and is responsible for providing data path functions, post-attach callback and in most cases, also default event handlers to define network interface actions based on driver's lifecycle transitions.


Packet Input/Output


According to the diagram"
" shown in the :ref:`esp-netif structure` part, the following three API functions for the packet data path must be defined for connecting with ESP-NETIF:

The first two functions for transmitting and freeing the rx buffer are provided as callbacks, i.e., they get called from ESP-NETIF (and its underlying TCP/IP stack) and I/O driver provides their implementation.

The receiving function on the other hand gets called from the I/O driver, so that the driver's code simply calls :cpp:func:`esp_netif_"
"receive()` on a new data received event.


Post Attach Callback


A final part of the network interface initialization consists of attaching the ESP-NETIF instance to the I/O driver, by means of calling the following API:

.. code:: c

    esp_err_t esp_netif_attach(esp_netif_t *esp_netif, esp_netif_iodriver_handle driver_handle);

It is assumed that the ``esp_netif_iodriver_handle`` is a pointer to driver's object, a struct derived from ``struct esp_netif_driver_base_s``, so that the first memb"
"er of I/O driver structure must be this base structure with pointers to:

As a result, the I/O driver has to create an instance of the struct per below:

.. code:: c

    typedef struct my_netif_driver_s {
            esp_netif_driver_base_t base;           /*!driver_impl
        };
        driver->base.netif = esp_netif;
        ESP_ERROR_CHECK(esp_netif_set_driver_config(esp_netif, &driver_ifconfig));
        my_driver_start(driver->driver_impl);
        return ESP_OK;
    }


Default Handlers"
"


I/O drivers also typically provide default definitions of lifecycle behavior of related network interfaces based on state transitions of I/O drivers. For example *driver start* ``->`` *network start*, etc.

An example of such a default handler is provided below:

.. code:: c

    esp_err_t my_driver_netif_set_default_handlers(my_netif_driver_t *driver, esp_netif_t * esp_netif)
    {
        driver_set_event_handler(driver->driver_impl, esp_netif_action_start, MY_DRV_EVENT_START, esp_netif);
 "
"       driver_set_event_handler(driver->driver_impl, esp_netif_action_stop, MY_DRV_EVENT_STOP, esp_netif);
        return ESP_OK;
    }


Network Stack Connection


The packet data path functions for transmitting and freeing the rx buffer (defined in the I/O driver) are called from the ESP-NETIF, specifically from its TCP/IP stack connecting layer.

Note that ESP-IDF provides several network stack configurations for the most common network interfaces, such as for the Wi-Fi station or Ethernet. T"
"hese configurations are defined in :component_file:`esp_netif/include/esp_netif_defaults.h` and should be sufficient for most network drivers. In rare cases, expert users might want to define custom lwIP based interface layers; it is possible, but an explicit dependency to lwIP needs to be set.

The following API reference outlines these network stack interaction with the ESP-NETIF:

.. include-build-file:: inc/esp_netif_net_stack.inc
"
"Provisioning API




.. toctree::
    :maxdepth: 1

    protocomm
    :SOC_WIFI_SUPPORTED: provisioning
    :SOC_WIFI_SUPPORTED: wifi_provisioning

.. only:: SOC_WIFI_SUPPORTED

    Code examples for above API are provided in the :example:`provisioning` directory of ESP-IDF examples.

    .. toctree::
        :maxdepth: 1

        ../network/esp_smartconfig

    Code example for above API is provided in :example:`wifi/smart_config`.

    .. toctree::
        :maxdepth: 1

        ../network/esp_"
"dpp

    Code example for above API is provided in :example:`wifi/wifi_easy_connect/dpp-enrollee`.
"
"Wi-Fi Provisioning




Overview


This component provides APIs that control the Wi-Fi provisioning service for receiving and configuring Wi-Fi credentials over SoftAP or Bluetooth LE transport via secure :doc:`protocomm` sessions. The set of ``wifi_prov_mgr_`` APIs help quickly implement a provisioning service that has necessary features with minimal amount of code and sufficient flexibility.

.. _wifi-prov-mgr-init:

Initialization


:cpp:func:`wifi_prov_mgr_init()` is called to configure and i"
"nitialize the provisioning manager, and thus must be called prior to invoking any other ``wifi_prov_mgr_`` APIs. Note that the manager relies on other components of ESP-IDF, namely NVS, TCP/IP, Event Loop and Wi-Fi, and optionally mDNS, hence these components must be initialized beforehand. The manager can be de-initialized at any moment by making a call to :cpp:func:`wifi_prov_mgr_deinit()`.

    .. code-block:: c

        wifi_prov_mgr_config_t config = {
            .scheme = wifi_prov_scheme"
"_ble,
            .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM
        };

        ESP_ERROR_CHECK( wifi_prov_mgr_init(config) );


The configuration structure :cpp:type:`wifi_prov_mgr_config_t` has a few fields to specify the desired behavior of the manager:

    .. code-block:: c

        static void event_handler(void* arg, esp_event_base_t event_base,
                                  int event_id, void* event_data)
        {
            if (event_base == WIFI_PROV_EV"
"ENT) {
                switch (event_id) {
                    case WIFI_PROV_START:
                        ESP_LOGI(TAG, ""Provisioning started"");
                        break;
                    case WIFI_PROV_CRED_RECV: {
                        wifi_sta_config_t *wifi_sta_cfg = (wifi_sta_config_t *)event_data;
                        ESP_LOGI(TAG, ""Received Wi-Fi credentials""
                                 ""\n\tSSID     : %s\n\tPassword : %s"",
                                 (const char"
" *) wifi_sta_cfg->ssid,
                                 (const char *) wifi_sta_cfg->password);
                        break;
                    }
                    case WIFI_PROV_CRED_FAIL: {
                        wifi_prov_sta_fail_reason_t *reason = (wifi_prov_sta_fail_reason_t *)event_data;
                        ESP_LOGE(TAG, ""Provisioning failed!\n\tReason : %s""
                                 ""\n\tPlease reset to factory and retry provisioning"",
                                 ("
"*reason == WIFI_PROV_STA_AUTH_ERROR) ?
                                 ""Wi-Fi station authentication failed"" : ""Wi-Fi access-point not found"");
                        break;
                    }
                    case WIFI_PROV_CRED_SUCCESS:
                        ESP_LOGI(TAG, ""Provisioning successful"");
                        break;
                    case WIFI_PROV_END:
                        /* De-initialize manager once provisioning is finished */
                        wifi_prov_"
"mgr_deinit();
                        break;
                    default:
                        break;
                }
            }
        }

The manager can be de-initialized at any moment by making a call to :cpp:func:`wifi_prov_mgr_deinit()`.

.. _wifi-prov-check-state:

Check the Provisioning State


Whether the device is provisioned or not can be checked at runtime by calling :cpp:func:`wifi_prov_mgr_is_provisioned()`. This internally checks if the Wi-Fi credentials are stored in NVS."
"

Note that presently the manager does not have its own NVS namespace for storage of Wi-Fi credentials, instead it relies on the ``esp_wifi_`` APIs to set and get the credentials stored in NVS from the default location.

If the provisioning state needs to be reset, any of the following approaches may be taken:

    .. code-block:: c

        bool provisioned = false;
        ESP_ERROR_CHECK( wifi_prov_mgr_is_provisioned(&provisioned) );


Start the Provisioning Service


At the time of starting "
"provisioning we need to specify a service name and the corresponding key, that is to say:

Also, since internally the manager uses ``protocomm``, we have the option of choosing one of the security features provided by it:

See :doc:`provisioning` for details about the security features.

    .. highlight:: c

    ::

        const char *service_name = ""my_device"";
        const char *service_key  = ""password"";

        wifi_prov_security_t security = WIFI_PROV_SECURITY_1;
        const char *pop"
" = ""abcd1234"";

        ESP_ERROR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) );


The provisioning service automatically finishes only if it receives valid Wi-Fi AP credentials followed by successful connection of device to the AP with IP obtained. Regardless of that, the provisioning service can be stopped at any moment by making a call to :cpp:func:`wifi_prov_mgr_stop_provisioning()`.

.. note::

    If the device fails to connect with the provided creden"
"tials, it does not accept new credentials anymore, but the provisioning service keeps on running, only to convey failure to the client, until the device is restarted. Upon restart, the provisioning state turns out to be true this time, as credentials are found in NVS, but the device does fail again to connect with those same credentials, unless an AP with the matching credentials somehow does become available. This situation can be fixed by resetting the credentials in NVS or force starting the "
"provisioning service. This has been explained above in :ref:`wifi-prov-check-state`.


Waiting for Completion


Typically, the main application waits for the provisioning to finish, then de-initializes the manager to free up resources, and finally starts executing its own logic.

There are two ways for making this possible. The simpler way is to use a blocking call to :cpp:func:`wifi_prov_mgr_wait()`.

    .. code-block:: c

        // Start provisioning service
        ESP_ERROR_CHECK( wifi_pro"
"v_mgr_start_provisioning(security, pop, service_name, service_key) );

        // Wait for service to complete
        wifi_prov_mgr_wait();

        // Finally de-initialize the manager
        wifi_prov_mgr_deinit();


The other way is to use the default event loop handler to catch ``WIFI_PROV_EVENT`` and call :cpp:func:`wifi_prov_mgr_deinit()` when event ID is ``WIFI_PROV_END``:

    .. code-block:: c

        static void event_handler(void* arg, esp_event_base_t event_base,
                 "
"                 int event_id, void* event_data)
        {
            if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) {
                /* De-initialize the manager once the provisioning is finished */
                wifi_prov_mgr_deinit();
            }
        }


User Side Implementation


When the service is started, the device to be provisioned is identified by the advertised service name, which, depending upon the selected transport, is either the Bluetooth LE device name"
" or the SoftAP SSID.

When using SoftAP transport, for allowing service discovery, mDNS must be initialized before starting provisioning. In this case, the host name set by the main application is used, and the service type is internally set to ``_esp_wifi_prov``.

When using Bluetooth LE transport, a custom 128-bit UUID should be set using :cpp:func:`wifi_prov_scheme_ble_set_service_uuid()`. This UUID is to be included in the Bluetooth LE advertisement and corresponds to the primary GATT servic"
"e that provides provisioning endpoints as GATT characteristics. Each GATT characteristic is formed using the primary service UUID as the base, with different auto-assigned 12th and 13th bytes, presumably counting from the 0th byte. Since an endpoint characteristic UUID is auto-assigned, it should not be used to identify the endpoint. Instead, client-side applications should identify the endpoints by reading the User Characteristic Description (``0x2901``) descriptor for each characteristic, whic"
"h contains the endpoint name of the characteristic. For example, if the service UUID is set to ``55cc035e-fb27-4f80-be02-3c60828b7451``, each endpoint characteristic is assigned a UUID like ``55cc____-fb27-4f80-be02-3c60828b7451``, with unique values at the 12th and 13th bytes.

Once connected to the device, the provisioning-related protocomm endpoints can be identified as follows:

.. |br| raw:: html

    

.. list-table:: Endpoints Provided by the Provisioning Service
   :widths: 35 35 30
   :"
"header-rows: 1
     - URI, i.e., SoftAP |br| + HTTP Server + mDNS
     - Description
     - http://.local/prov-session
     - Security endpoint used for session establishment
     - http://wifi-prov.local/prov-scan
     - the endpoint used for starting Wi-Fi scan and receiving scan results
     - http://wifi-prov.local/prov-ctrl
     - the endpoint used for controlling Wi-Fi provisioning state
     - http://.local/prov-config
     - the endpoint used for configuring Wi-Fi credentials on device
 "
"    - http://.local/proto-ver
     - the endpoint for retrieving version info

Immediately after connecting, the client application may fetch the version/capabilities information from the ``proto-ver`` endpoint. All communications to this endpoint are unencrypted, hence necessary information, which may be relevant for deciding compatibility, can be retrieved before establishing a secure session. The response is in JSON format and looks like : ``prov: { ver:  v1.1, cap:  [no_pop] }, my_app: { ver"
":  1.345, cap:  [cloud, local_ctrl] },....``. Here label ``prov`` provides provisioning service version ``ver`` and capabilities ``cap``. For now, only the ``no_pop`` capability is supported, which indicates that the service does not require proof of possession for authentication. Any application-related version or capabilities are given by other labels, e.g., ``my_app`` in this example. These additional fields are set using :cpp:func:`wifi_prov_mgr_set_app_info()`.

User side applications need "
"to implement the signature handshaking required for establishing and authenticating secure protocomm sessions as per the security scheme configured for use, which is not needed when the manager is configured to use protocomm security 0.

See :doc:`provisioning` for more details about the secure handshake and encryption used. Applications must use the ``.proto`` files found under :component:`protocomm/proto`, which define the Protobuf message structures supported by ``prov-session`` endpoint.

On"
"ce a session is established, Wi-Fi credentials are configured using the following set of ``wifi_config`` commands, serialized as Protobuf messages with the corresponding ``.proto`` files that can be found under :component:`wifi_provisioning/proto`:

After session establishment, the client can also request Wi-Fi scan results from the device. The results returned is a list of AP SSIDs, sorted in descending order of signal strength. This allows client applications to display APs nearby to the devic"
"e at the time of provisioning, and users can select one of the SSIDs and provide the password which is then sent using the ``wifi_config`` commands described above. The ``wifi_scan`` endpoint supports the following protobuf commands :

The client can also control the provisioning state of the device using ``wifi_ctrl`` endpoint. The ``wifi_ctrl`` endpoint supports the following protobuf commands:

Additional Endpoints


In case users want to have some additional protocomm endpoints customized to"
" their requirements, this is done in two steps. First is creation of an endpoint with a specific name, and the second step is the registration of a handler for this endpoint. See :doc:`protocomm` for the function signature of an endpoint handler. A custom endpoint must be created after initialization and before starting the provisioning service. Whereas, the protocomm handler is registered for this endpoint only after starting the provisioning service. Note that in the custom endpoint handler fu"
"nction, memory for the response of such protocomm endpoints should be allocated using heap as it gets freed by the protocomm layer once it has been sent by the transport layer.

    .. code-block:: c

        wifi_prov_mgr_init(config);
        wifi_prov_mgr_endpoint_create(""custom-endpoint"");
        wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key);
        wifi_prov_mgr_endpoint_register(""custom-endpoint"", custom_ep_handler, custom_ep_data);


When the provisioning se"
"rvice stops, the endpoint is unregistered automatically.

One can also choose to call :cpp:func:`wifi_prov_mgr_endpoint_unregister()` to manually deactivate an endpoint at runtime. This can also be used to deactivate the internal endpoints used by the provisioning service.

When/How to Stop the Provisioning Service?


The default behavior is that once the device successfully connects using the Wi-Fi credentials set by the ``apply_config`` command, the provisioning service stops, and Bluetooth LE"
" or SoftAP turns off, automatically after responding to the next ``get_status`` command. If ``get_status`` command is not received by the device, the service stops after a 30 s timeout.

On the other hand, if device is not able to connect using the provided Wi-Fi credentials, due to incorrect SSID or passphrase, the service keeps running, and ``get_status`` keeps responding with disconnected status and reason for disconnection. Any further attempts to provide another set of Wi-Fi credentials, ar"
"e to be rejected. These credentials are preserved, unless the provisioning service is force started, or NVS erased.

If this default behavior is not desired, it can be disabled by calling :cpp:func:`wifi_prov_mgr_disable_auto_stop()`. Now the provisioning service stops only after an explicit call to :cpp:func:`wifi_prov_mgr_stop_provisioning()`, which returns immediately after scheduling a task for stopping the service. The service stops after a certain delay and ``WIFI_PROV_END`` event gets emi"
"tted. This delay is specified by the argument to :cpp:func:`wifi_prov_mgr_disable_auto_stop()`.

The customized behavior is useful for applications which want the provisioning service to be stopped some time after the Wi-Fi connection is successfully established. For example, if the application requires the device to connect to some cloud service and obtain another set of credentials, and exchange these credentials over a custom protocomm endpoint, then after successfully doing so, stop the prov"
"isioning service by calling :cpp:func:`wifi_prov_mgr_stop_provisioning()` inside the protocomm handler itself. The right amount of delay ensures that the transport resources are freed only after the response from the protocomm handler reaches the client side application.

Application Examples


For complete example implementation see :example:`provisioning/wifi_prov_mgr`.

Provisioning Tools


Provisioning applications are available for various platforms, along with source code:

The phone appli"
"cations offer simple UI and are thus more user centric, while the command-line application is useful as a debugging tool for developers.


API Reference


.. include-build-file:: inc/manager.inc
.. include-build-file:: inc/scheme_ble.inc
.. include-build-file:: inc/scheme_softap.inc
.. include-build-file:: inc/scheme_console.inc
.. include-build-file:: inc/wifi_config.inc
"
"Protocol Communication




Overview


The Protocol Communication (protocomm) component manages secure sessions and provides the framework for multiple transports. The application can also use the protocomm layer directly to have application-specific extensions for the provisioning or non-provisioning use cases.

Following features are available for provisioning:

Protocomm internally uses protobuf (protocol buffers) for secure session establishment. Users can choose to implement their own securi"
"ty (even without using protobuf). Protocomm can also be used without any security layer.

Protocomm provides the framework for various transports:

.. list::

    :SOC_BLE_SUPPORTED: - Bluetooth LE
    :SOC_WIFI_SUPPORTED: - Wi-Fi (SoftAP + HTTPD)
    - Console, in which case the handler invocation is automatically taken care of on the device side. See Transport Examples below for code snippets.

Note that for protocomm_security1 and protocomm_security2, the client still needs to establish sessi"
"ons by performing the two-way handshake.

.. only:: SOC_WIFI_SUPPORTED

    See :doc:`provisioning` for more details about the secure handshake logic.

.. _enabling-protocomm-security-version:

Enabling Protocomm Security Version


The protocomm component provides a project configuration menu to enable/disable support of respective security versions. The respective configuration options are as follows:

.. note::

    Enabling multiple security versions at once offers the ability to control them"
" dynamically but also increases the firmware size.

.. only:: SOC_WIFI_SUPPORTED

    SoftAP + HTTP Transport Example with Security 2
    

    For sample usage, see :component_file:`wifi_provisioning/src/scheme_softap.c`.

    .. highlight:: c

    ::

        /* The endpoint handler to be registered with protocomm. This simply echoes back the received data. */
        esp_err_t echo_req_handler (uint32_t session_id,
                                    const uint8_t *inbuf, ssize_t inlen,
     "
"                               uint8_t **outbuf, ssize_t *outlen,
                                    void *priv_data)
        {
            /* Session ID may be used for persistence. */
            printf(""Session ID : %d"", session_id);

            /* Echo back the received data. */
            *outlen = inlen;            /* Output the data length updated. */
            *outbuf = malloc(inlen);    /* This is to be deallocated outside. */
            memcpy(*outbuf, inbuf, inlen);

           "
" /* Private data that was passed at the time of endpoint creation. */
            uint32_t *priv = (uint32_t *) priv_data;
            if (priv) {
                printf(""Private data : %d"", *priv);
            }

            return ESP_OK;
        }

        static const char sec2_salt[] = {0xf7, 0x5f, 0xe2, 0xbe, 0xba, 0x7c, 0x81, 0xcd};
        static const char sec2_verifier[] = {0xbf, 0x86, 0xce, 0x63, 0x8a, 0xbb, 0x7e, 0x2f, 0x38, 0xa8, 0x19, 0x1b, 0x35,
            0xc9, 0xe3, 0xbe, 0xc3,"
" 0x2b, 0x45, 0xee, 0x10, 0x74, 0x22, 0x1a, 0x95, 0xbe, 0x62, 0xf7, 0x0c, 0x65, 0x83, 0x50,
            0x08, 0xef, 0xaf, 0xa5, 0x94, 0x4b, 0xcb, 0xe1, 0xce, 0x59, 0x2a, 0xe8, 0x7b, 0x27, 0xc8, 0x72, 0x26, 0x71, 0xde,
            0xb2, 0xf2, 0x80, 0x02, 0xdd, 0x11, 0xf0, 0x38, 0x0e, 0x95, 0x25, 0x00, 0xcf, 0xb3, 0x3f, 0xf0, 0x73, 0x2a, 0x25,
            0x03, 0xe8, 0x51, 0x72, 0xef, 0x6d, 0x3e, 0x14, 0xb9, 0x2e, 0x9f, 0x2a, 0x90, 0x9e, 0x26, 0xb6, 0x3e, 0xc7, 0xe4,
            0x9f, 0xe3, 0x20, 0"
"xce, 0x28, 0x7c, 0xbf, 0x89, 0x50, 0xc9, 0xb6, 0xec, 0xdd, 0x81, 0x18, 0xf1, 0x1a, 0xd9, 0x7a,
            0x21, 0x99, 0xf1, 0xee, 0x71, 0x2f, 0xcc, 0x93, 0x16, 0x34, 0x0c, 0x79, 0x46, 0x23, 0xe4, 0x32, 0xec, 0x2d, 0x9e,
            0x18, 0xa6, 0xb9, 0xbb, 0x0a, 0xcf, 0xc4, 0xa8, 0x32, 0xc0, 0x1c, 0x32, 0xa3, 0x97, 0x66, 0xf8, 0x30, 0xb2, 0xda,
            0xf9, 0x8d, 0xc3, 0x72, 0x72, 0x5f, 0xe5, 0xee, 0xc3, 0x5c, 0x24, 0xc8, 0xdd, 0x54, 0x49, 0xfc, 0x12, 0x91, 0x81,
            0x9c, 0xc3, 0xa"
"c, 0x64, 0x5e, 0xd6, 0x41, 0x88, 0x2f, 0x23, 0x66, 0xc8, 0xac, 0xb0, 0x35, 0x0b, 0xf6, 0x9c, 0x88,
            0x6f, 0xac, 0xe1, 0xf4, 0xca, 0xc9, 0x07, 0x04, 0x11, 0xda, 0x90, 0x42, 0xa9, 0xf1, 0x97, 0x3d, 0x94, 0x65, 0xe4,
            0xfb, 0x52, 0x22, 0x3b, 0x7a, 0x7b, 0x9e, 0xe9, 0xee, 0x1c, 0x44, 0xd0, 0x73, 0x72, 0x2a, 0xca, 0x85, 0x19, 0x4a,
            0x60, 0xce, 0x0a, 0xc8, 0x7d, 0x57, 0xa4, 0xf8, 0x77, 0x22, 0xc1, 0xa5, 0xfa, 0xfb, 0x7b, 0x91, 0x3b, 0xfe, 0x87,
            0x5f, 0xfe,"
" 0x05, 0xd2, 0xd6, 0xd3, 0x74, 0xe5, 0x2e, 0x68, 0x79, 0x34, 0x70, 0x40, 0x12, 0xa8, 0xe1, 0xb4, 0x6c,
            0xaa, 0x46, 0x73, 0xcd, 0x8d, 0x17, 0x72, 0x67, 0x32, 0x42, 0xdc, 0x10, 0xd3, 0x71, 0x7e, 0x8b, 0x00, 0x46, 0x9b,
            0x0a, 0xe9, 0xb4, 0x0f, 0xeb, 0x70, 0x52, 0xdd, 0x0a, 0x1c, 0x7e, 0x2e, 0xb0, 0x61, 0xa6, 0xe1, 0xa3, 0x34, 0x4b,
            0x2a, 0x3c, 0xc4, 0x5d, 0x42, 0x05, 0x58, 0x25, 0xd3, 0xca, 0x96, 0x5c, 0xb9, 0x52, 0xf9, 0xe9, 0x80, 0x75, 0x3d,
            0xc8, 0"
"x9f, 0xc7, 0xb2, 0xaa, 0x95, 0x2e, 0x76, 0xb3, 0xe1, 0x48, 0xc1, 0x0a, 0xa1, 0x0a, 0xe8, 0xaf, 0x41, 0x28,
            0xd2, 0x16, 0xe1, 0xa6, 0xd0, 0x73, 0x51, 0x73, 0x79, 0x98, 0xd9, 0xb9, 0x00, 0x50, 0xa2, 0x4d, 0x99, 0x18, 0x90,
            0x70, 0x27, 0xe7, 0x8d, 0x56, 0x45, 0x34, 0x1f, 0xb9, 0x30, 0xda, 0xec, 0x4a, 0x08, 0x27, 0x9f, 0xfa, 0x59, 0x2e,
            0x36, 0x77, 0x00, 0xe2, 0xb6, 0xeb, 0xd1, 0x56, 0x50, 0x8e};

        /* The example function for launching a protocomm instance "
"over HTTP. */
        protocomm_t *start_pc()
        {
            protocomm_t *pc = protocomm_new();


            /* Config for protocomm_httpd_start(). */
            protocomm_httpd_config_t pc_config = {
                .data = {
                .config = PROTOCOMM_HTTPD_DEFAULT_CONFIG()
                }
            };

            /* Start the protocomm server on top of HTTP. */
            protocomm_httpd_start(pc, &pc_config);

            /* Create Security2 params object from salt an"
"d verifier. It must be valid throughout the scope of protocomm endpoint. This does not need to be static, i.e., could be dynamically allocated and freed at the time of endpoint removal. */
            const static protocomm_security2_params_t sec2_params = {
                .salt = (const uint8_t *) salt,
                .salt_len = sizeof(salt),
                .verifier = (const uint8_t *) verifier,
                .verifier_len = sizeof(verifier),
            };

            /* Set security f"
"or communication at the application level. Just like for request handlers, setting security creates an endpoint and registers the handler provided by protocomm_security1. One can similarly use protocomm_security0. Only one type of security can be set for a protocomm instance at a time. */
            protocomm_set_security(pc, ""security_endpoint"", &protocomm_security2, &sec2_params);

            /* Private data passed to the endpoint must be valid throughout the scope of protocomm endpoint. Thi"
"s need not be static, i.e., could be dynamically allocated and freed at the time of endpoint removal. */
            static uint32_t priv_data = 1234;

            /* Add a new endpoint for the protocomm instance, identified by a unique name, and register a handler function along with the private data to be passed at the time of handler execution. Multiple endpoints can be added as long as they are identified by unique names. */
            protocomm_add_endpoint(pc, ""echo_req_endpoint"",
       "
"                            echo_req_handler, (void *) &priv_data);
            return pc;
        }

        /* The example function for stopping a protocomm instance. */
        void stop_pc(protocomm_t *pc)
        {
            /* Remove the endpoint identified by its unique name. */
            protocomm_remove_endpoint(pc, ""echo_req_endpoint"");

            /* Remove the security endpoint identified by its name. */
            protocomm_unset_security(pc, ""security_endpoint"");

           "
" /* Stop the HTTP server. */
            protocomm_httpd_stop(pc);

            /* Delete, namely deallocate the protocomm instance. */
            protocomm_delete(pc);
        }

    SoftAP + HTTP Transport Example with Security 1
    

    For sample usage, see :component_file:`wifi_provisioning/src/scheme_softap.c`.

    .. highlight:: c

    ::

        /* The endpoint handler to be registered with protocomm. This simply echoes back the received data. */
        esp_err_t echo_req_handler ("
"uint32_t session_id,
                                    const uint8_t *inbuf, ssize_t inlen,
                                    uint8_t **outbuf, ssize_t *outlen,
                                    void *priv_data)
        {
            /* Session ID may be used for persistence. */
            printf(""Session ID : %d"", session_id);

            /* Echo back the received data. */
            *outlen = inlen;            /* Output the data length updated. */
            *outbuf = malloc(inlen); "
"   /* This is to be deallocated outside. */
            memcpy(*outbuf, inbuf, inlen);

            /* Private data that was passed at the time of endpoint creation. */
            uint32_t *priv = (uint32_t *) priv_data;
            if (priv) {
                printf(""Private data : %d"", *priv);
            }

            return ESP_OK;
        }

        /* The example function for launching a protocomm instance over HTTP. */
        protocomm_t *start_pc(const char *pop_string)
        {
    "
"        protocomm_t *pc = protocomm_new();


            /* Config for protocomm_httpd_start(). */
            protocomm_httpd_config_t pc_config = {
                .data = {
                .config = PROTOCOMM_HTTPD_DEFAULT_CONFIG()
                }
            };

            /* Start the protocomm server on top of HTTP. */
            protocomm_httpd_start(pc, &pc_config);

            /* Create security1 params object from pop_string. It must be valid throughout the scope of protocomm endp"
"oint. This need not be static, i.e., could be dynamically allocated and freed at the time of endpoint removal. */
            const static protocomm_security1_params_t sec1_params = {
                .data = (const uint8_t *) strdup(pop_string),
                .len = strlen(pop_string)
            };

            /* Set security for communication at the application level. Just like for request handlers, setting security creates an endpoint and registers the handler provided by protocomm_securit"
"y1. One can similarly use protocomm_security0. Only one type of security can be set for a protocomm instance at a time. */
            protocomm_set_security(pc, ""security_endpoint"", &protocomm_security1, &sec1_params);

            /* Private data passed to the endpoint must be valid throughout the scope of protocomm endpoint. This need not be static, i.e., could be dynamically allocated and freed at the time of endpoint removal. */
            static uint32_t priv_data = 1234;

            /* "
"Add a new endpoint for the protocomm instance identified by a unique name, and register a handler function along with the private data to be passed at the time of handler execution. Multiple endpoints can be added as long as they are identified by unique names. */
            protocomm_add_endpoint(pc, ""echo_req_endpoint"",
                                   echo_req_handler, (void *) &priv_data);
            return pc;
        }

        /* The example function for stopping a protocomm instance."
" */
        void stop_pc(protocomm_t *pc)
        {
            /* Remove the endpoint identified by its unique name. */
            protocomm_remove_endpoint(pc, ""echo_req_endpoint"");

            /* Remove the security endpoint identified by its name. */
            protocomm_unset_security(pc, ""security_endpoint"");

            /* Stop the HTTP server. */
            protocomm_httpd_stop(pc);

            /* Delete, namely deallocate the protocomm instance. */
            protocomm_delete(pc)"
";
        }

.. only:: SOC_BLE_SUPPORTED

    Bluetooth LE Transport Example with Security 0
    

    For sample usage, see :component_file:`wifi_provisioning/src/scheme_ble.c`.

    .. highlight:: c

    ::

        /* The example function for launching a secure protocomm instance over Bluetooth LE. */
        protocomm_t *start_pc()
        {
            protocomm_t *pc = protocomm_new();

            /* Endpoint UUIDs */
            protocomm_ble_name_uuid_t nu_lookup_table[] = {
           "
"     {""security_endpoint"", 0xFF51},
                {""echo_req_endpoint"", 0xFF52}
            };

            /* Config for protocomm_ble_start(). */
            protocomm_ble_config_t config = {
                .service_uuid = {
                    /* LSB  MSB */
                    0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80,
                    0x00, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
                },
                .nu_lookup_count = sizeof(nu_lookup_table)/sizeof(nu_lookup_tabl"
"e[0]),
                .nu_lookup = nu_lookup_table
            };

            /* Start protocomm layer on top of Bluetooth LE. */
            protocomm_ble_start(pc, &config);

            /* For protocomm_security0, Proof of Possession is not used, and can be kept NULL. */
            protocomm_set_security(pc, ""security_endpoint"", &protocomm_security0, NULL);
            protocomm_add_endpoint(pc, ""echo_req_endpoint"", echo_req_handler, NULL);
            return pc;
        }

        /* The "
"example function for stopping a protocomm instance. */
        void stop_pc(protocomm_t *pc)
        {
            protocomm_remove_endpoint(pc, ""echo_req_endpoint"");
            protocomm_unset_security(pc, ""security_endpoint"");

            /* Stop the Bluetooth LE protocomm service. */
            protocomm_ble_stop(pc);

            protocomm_delete(pc);
        }

API Reference


.. include-build-file:: inc/protocomm.inc
.. include-build-file:: inc/protocomm_security.inc
.. include-build-fi"
"le:: inc/protocomm_security0.inc
.. include-build-file:: inc/protocomm_security1.inc
.. include-build-file:: inc/protocomm_security2.inc
.. include-build-file:: inc/esp_srp.inc
.. include-build-file:: inc/protocomm_httpd.inc

.. only:: SOC_BLE_SUPPORTED

    .. include-build-file:: inc/protocomm_ble.inc
"
"Unified Provisioning




Overview
>>>>>>>>

The unified provisioning support in the ESP-IDF provides an extensible mechanism to the developers to configure the device with the Wi-Fi credentials and/or other custom configuration using various transports and different security schemes. Depending on the use case, it provides a complete and ready solution for Wi-Fi network provisioning along with example iOS and Android applications. The developers can choose to extend the device-side and phone-app "
"side implementations to accommodate their requirements for sending additional configuration data. The followings are the important features of this implementation:

The protocol is completely flexible and it offers the ability for the developers to send custom configuration in the provisioning process. The data representation is also left to the application to decide.

The protocol can work on Wi-Fi (SoftAP + HTTP server) or on Bluetooth LE as a transport protocol. The framework provides an abil"
"ity to add support for any other transport easily as long as command-response behavior can be supported on the transport.

It is understood that each use case may require different security scheme to secure the data that is exchanged in the provisioning process. Some applications may work with SoftAP that is WPA2 protected or Bluetooth LE with the ""just-works"" security. Or the applications may consider the transport to be insecure and may want application-level security. The unified provisioning"
" framework allows the application to choose the security as deemed suitable.

The protocol uses `Google Protobufs `_ as a data representation for session setup and Wi-Fi provisioning. They provide a compact data representation and ability to parse the data in multiple programming languages in native format. Please note that this data representation is not forced on application-specific data and the developers may choose the representation of their choice.

Typical Provisioning Process
>>>>>>>>>>"
">>>>>>>>>>>>>>>>>>

.. seqdiag::
    :caption: Typical Provisioning Process
    :align: center

    seqdiag typical-prov-process {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 360;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        CLIENT  [label = ""Client""];
        DEVICE  [label = ""Device""];

        === 1. Transport-specific discovery and connection ===
        DEVICE -> CLIENT [label=""So"
"me form of beaconing""];
        CLIENT -> DEVICE [label=""Client connects""];
        === 2. Session Establishment 
        CLIENT -> DEVICE [label=""Get Version Request""];
        DEVICE -> CLIENT [label=""Get Version Response""];
        CLIENT -> DEVICE [label=""Session Setup Request""];
        DEVICE -> CLIENT [label=""Session Setup Response""];
        CLIENT --> DEVICE;
        ... One or multiple steps as per protocol ...
        DEVICE --> CLIENT
        === 3. Configuration ===
        CLIENT -"
"-> DEVICE [label=""App-specific Set Config (optional)""];
        DEVICE --> CLIENT [label=""Set Config Response (optional)""];
        CLIENT -> DEVICE [label=""Wi-Fi SetConfig(SSID, Passphrase...)""];
        DEVICE -> CLIENT [label=""Wi-Fi SetConfig response""];
        CLIENT -> DEVICE [label=""Wi-Fi ApplyConfig cmd""];
        DEVICE -> CLIENT [label=""Wi-Fi ApplyConfig resp""];
        CLIENT -> DEVICE [label=""Wi-Fi GetStatus cmd (repeated)""];
        DEVICE -> CLIENT [label=""Wi-Fi GetStatus resp (rep"
"eated)""];
        === 4. Close connection ===
        DEVICE -> CLIENT [label=""Close Connection""];
    }

Deciding on Transport
>>>>>>>>>>>>>>>>>>>>>

The unified provisioning subsystem supports Wi-Fi (SoftAP+HTTP server) and Bluetooth LE (GATT based) transport schemes. The following points need to be considered while selecting the best possible transport for provisioning:

    - The device uses the same radio to host the SoftAP and also to connect to the configured AP. Since these could potenti"
"ally be on different channels, it may cause connection status updates not to be reliably received by the phone

    - The phone (client) has to disconnect from its current AP in order to connect to the SoftAP. The original network will get restored only when the provisioning process is complete, and the softAP is taken down.

Deciding on Security
>>>>>>>>>>>>>>>>>>>>

Depending on the transport and other constraints, the security scheme needs to be selected by the application developers. The fol"
"lowing considerations need to be given from the provisioning-security perspective:

There are two levels of security schemes, of which the developer may select one or a combination, depending on requirements.

For SoftAP provisioning, developers may choose WPA2-protected security with unique per-device passphrase. Unique per-device passphrase can also act as a proof-of-possession. For Bluetooth LE, the ""just-works"" security can be used as a transport-level security after assessing its provided l"
"evel of security.

The unified provisioning subsystem provides the application-level security (`Security 1 Scheme`_) that provides data protection and authentication through PoP, if the application does not use the transport-level security, or if the transport-level security is not sufficient for the use case.

Device Discovery
>>>>>>>>>>>>>>>>

The advertisement and device discovery is left to the application and depending on the protocol chosen, the phone apps and device-firmware application c"
"an choose appropriate method for advertisement and discovery.

For the SoftAP+HTTP transport, typically the SSID (network name) of the AP hosted by the device can be used for discovery.

For the Bluetooth LE transport, device name or primary service included in the advertisement or a combination of both can be used for discovery.

Architecture
>>>>>>>>>>>>

The below diagram shows the architecture of unified provisioning:

.. figure:: ../../../_static/unified_provisioning.png
    :align: center
"
"    :alt: Unified Provisioning Architecture

    Unified Provisioning Architecture

It relies on the base layer called :doc:`protocomm` (protocomm) which provides a framework for security schemes and transport mechanisms. The Wi-Fi Provisioning layer uses protocomm to provide simple callbacks to the application for setting the configuration and getting the Wi-Fi status. The application has control over implementation of these callbacks. In addition, the application can directly use protocomm to "
"register custom handlers.

The application creates a protocomm instance which is mapped to a specific transport and specific security scheme. Each transport in the protocomm has a concept of an ""end-point"" which corresponds to the logical channel for communication for specific type of information. For example, security handshake happens on a different endpoint from the Wi-Fi configuration endpoint. Each end-point is identified using a string and depending on the transport internal representation"
" of the end-point changes. In case of the SoftAP+HTTP transport, the end-point corresponds to URI, whereas in case of Bluetooth LE, the end-point corresponds to the GATT characteristic with specific UUID. Developers can create custom end-points and implement handler for the data that is received or sent over the same end-point.

.. _provisioning_security_schemes:

Security Schemes
>>>>>>>>>>>>>>>>

At present, the unified provisioning supports the following security schemes:

No security (No enc"
"ryption).

Curve25519-based key exchange, shared key derivation and AES256-CTR mode encryption of the data. It supports two modes :

    a. Authorized - Proof of Possession (PoP) string used to authorize session and derive shared key.

    b. No Auth (Null PoP) - Shared key derived through key exchange only.

SRP6a-based shared key derivation and AES256-GCM mode encryption of the data.

.. note::

    The respective security schemes need to be enabled through the project configuration menu. Plea"
"se refer to :ref:`enabling-protocomm-security-version` for more details.

Security 1 Scheme
>>>>>>>>>>>>>>>>>

The Security 1 scheme details are shown in the below sequence diagram:

.. seqdiag::
    :caption: Security 1
    :align: center

    seqdiag security1 {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 480;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        CLIENT  [label = ""Client""];
 "
"       DEVICE  [label = ""Device""];

        === Security 1 ===
        CLIENT -> CLIENT [label = ""Generate\nKey Pair"", rightnote = ""{cli_privkey, cli_pubkey} = curve25519_keygen()""];
        CLIENT -> DEVICE [label = ""SessionCmd0(cli_pubkey)""];
        DEVICE -> DEVICE [label = ""Generate\nKey Pair"", leftnote = ""{dev_privkey, dev_pubkey} = curve25519_keygen()""];
        DEVICE -> DEVICE [label = ""Initialization\nVector"", leftnote = ""dev_rand = gen_16byte_random()""];
        DEVICE -> DEVICE [labe"
"l = ""Shared Key"", leftnote = ""shared_key(No PoP) = curve25519(dev_privkey, cli_pubkey) \nshared_key(with PoP) = curve25519(dev_privkey, cli_pubkey) ^ SHA256(pop)""];
        DEVICE -> CLIENT [label = ""SessionResp0(dev_pubkey, dev_rand)""];
        CLIENT -> CLIENT [label = ""Shared Key"", rightnote = ""shared_key(No PoP) = curve25519(cli_privkey, dev_pubkey)\nshared_key(with PoP) = curve25519(cli_privkey, dev_pubkey) ^ SHA256(pop)""];
        CLIENT -> CLIENT [label = ""Verification\nToken"", rightnote "
"= ""cli_verify = aes_ctr_enc(key=shared_key, data=dev_pubkey, nonce=dev_rand)""];
        CLIENT -> DEVICE [label = ""SessionCmd1(cli_verify)""];
        DEVICE -> DEVICE [label = ""Verify Client"", leftnote = ""check (dev_pubkey == aes_ctr_dec(cli_verify...)""];
        DEVICE -> DEVICE [label = ""Verification\nToken"", leftnote = ""dev_verify = aes_ctr_enc(key=shared_key, data=cli_pubkey, nonce=(prev-context))""];
        DEVICE -> CLIENT [label = ""SessionResp1(dev_verify)""];
        CLIENT -> CLIENT [lab"
"el = ""Verify Device"", rightnote = ""check (cli_pubkey == aes_ctr_dec(dev_verify...)""];
    }


Security 2 Scheme
>>>>>>>>>>>>>>>>>

The Security 2 scheme is based on the Secure Remote Password (SRP6a) protocol, see `RFC 5054 `_.

The protocol requires the Salt and Verifier to be generated beforehand with the help of the identifying username ``I`` and the plaintext password ``p``. The Salt and Verifier are then stored on {IDF_TARGET_NAME}.

- The password ``p`` and the username ``I`` are to be pro"
"vided to the Phone App (Provisioning entity) by suitable means, e.g., QR code sticker.

Details about the Security 2 scheme are shown in the below sequence diagram:

.. seqdiag::
    :caption: Security 2
    :align: center

    seqdiag security2 {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 550;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        CLIENT  [label = ""Client\n(PhoneApp)""];
      "
"  DEVICE  [label = ""Device\n(ESP)""];

        === Security 2 ===
        CLIENT -> CLIENT [label = ""Generate\nKey Pair"", rightnote = ""a (cli_privkey) = 256 bit random value,
        A (cli_pubkey) = g^a.
        g - generator, N - large safe prime,
        All arithmetic operations are performed in ring of integers modulo N,
        thus all occurrences like y^z should be read as y^z modulo N.""];
                CLIENT -> DEVICE [label = ""SessionCmd0(cli_pubkey A, username I)""];
                "
"DEVICE -> DEVICE [label = ""Obtain\n Salt and Verifier"", leftnote = ""Obtain salt and verifier stored on esp
        Salt s = 256 bit random value,
        Verifier v  = g^x where x = H(s | I | p)""];
                DEVICE -> DEVICE [label = ""Generate\nKey Pair"", leftnote = ""b (dev_privkey) = 256 bit random value
        B(dev_pubkey) = k*v + g^b where k = H(N, g)""];
                DEVICE -> DEVICE [label = ""Shared Key"", leftnote = ""Shared Key K = H(S) where,
        S = (A * v^u) ^ b
        u ="
" H(A, B)""];
                DEVICE -> CLIENT [label = ""SessionResp0(dev_pubkey B, dev_rand)""];
                CLIENT -> CLIENT [label = ""Shared Key"", rightnote = ""shared_key(K) = H(S) where,
        S = (B - k*v) ^ (a + ux),
        u = H(A, B),
        k = H(N, g),
        v = g^x,
        x = H(s | I | p).

        ""];
                CLIENT -> CLIENT [label = ""Verification\nToken"", rightnote = ""client_proof M =  H[H(N) XOR H(g) | H(I) | s | A | B | K]""];
                CLIENT -> DEVICE [lab"
"el = ""SessionCmd1(client_proof M1)""];
                DEVICE -> DEVICE [label = ""Verify Client"", leftnote = ""device generates M1 =  H[H(N) XOR H(g) | H(I) | s | A | B | K]
        device verifies this M1 with the M1 obtained from Client""];
                DEVICE -> DEVICE [label = ""Verification\nToken"", leftnote = ""
        Device generate device_proof M2 = H(A, M, K)""];
                DEVICE -> DEVICE [label = ""Initialization\nVector"", leftnote = ""dev_rand = gen_16byte_random()
        This ra"
"ndom number is to be used for AES-GCM operation
         for encryption and decryption of the data using the shared secret""];
                DEVICE -> CLIENT [label = ""SessionResp1(device_proof M2, dev_rand)""];
                CLIENT -> CLIENT [label = ""Verify Device"", rightnote = ""Client calculates device proof M2 as M2 = H(A, M, K)
        client verifies this M2 with M2 obtained from device""];
    }

Sample Code
>>>>>>>>>>>

Please refer to :doc:`protocomm` and :doc:`wifi_provisioning` for A"
"PI guides and code snippets on example usage.

Application implementation can be found as an example under :example:`provisioning`.

Provisioning Tools
>>>>>>>>>>>>>>>>>>

Provisioning applications are available for various platforms, along with source code:

The phone applications offer simple UI and are thus more user centric, while the command-line application is useful as a debugging tool for developers.
"
"SD/SDIO/MMC Driver




Overview


The SD/SDIO/MMC driver currently supports SD memory, SDIO cards, and eMMC chips. This is a protocol layer driver (:component_file:`sdmmc/include/sdmmc_cmd.h`) which can be implemented by:

.. list::
    :SOC_SDMMC_HOST_SUPPORTED: - SDMMC host driver (:component_file:`esp_driver_sdmmc/include/driver/sdmmc_host.h`), see :doc:`SDMMC Host API ` for more details.
    - SDSPI host driver (:component_file:`esp_driver_sdspi/include/driver/sdspi_host.h`), see :doc:`SD SP"
"I Host API ` for more details.

Protocol Layer vs Host Layer


The SDMMC protocol layer described in this document handles the specifics of the SD protocol, such as the card initialization flow and variours data transfer command flows. The protocol layer works with the host via the :cpp:class:`sdmmc_host_t` structure. This structure contains pointers to various functions of the host.

Host layer driver(s) implement the protocol layer driver by supporting these functions:

- Sending commands to s"
"lave devices
- Sending and receiving data
- Handling error conditions within the bus

.. blockdiag:: /../_static/diagrams/sd/sd_arch.diag
    :scale: 100%
    :caption: SD Host Side Component Architecture
    :align: center


Application Example


An example which combines the SDMMC driver with the FATFS library is provided in the :example:`storage/sd_card` directory of ESP-IDF examples. This example initializes the card, then writes and reads data from it using POSIX and C library APIs. See REA"
"DME.md file in the example directory for more information.

.. only:: SOC_SDMMC_HOST_SUPPORTED

    Protocol Layer API
    

    The protocol layer is given the :cpp:class:`sdmmc_host_t` structure. This structure describes the SD/MMC host driver, lists its capabilities, and provides pointers to functions for the implementation driver. The protocol layer stores card-specific information in the :cpp:class:`sdmmc_card_t` structure. When sending commands to the SD/MMC host driver, the protocol layer"
" uses the :cpp:class:`sdmmc_command_t` structure to describe the command, arguments, expected return values, and data to transfer if there is any.


    Using API with SD Memory Cards
    


    Using API with eMMC Chips
    

    From the protocol layer's perspective, eMMC memory chips behave exactly like SD memory cards. Even though eMMCs are chips and do not have a card form factor, the terminology for SD cards can still be applied to eMMC due to the similarity of the protocol (`sdmmc_card_t`"
", `sdmmc_card_init`). Note that eMMC chips cannot be used over SPI, which makes them incompatible with the SD SPI host driver.

    To initialize eMMC memory and perform read/write operations, follow the steps listed for SD cards in the previous section.


    Using API with SDIO Cards
    

    Initialization and the probing process are the same as with SD memory cards. The only difference is in data transfer commands in SDIO mode.

    During the card initialization and probing, performed with"
" :cpp:func:`sdmmc_card_init`, the driver only configures the following registers of the IO card:

    In particular, the driver does not set any bits in (1) I/O Enable and Int Enable registers, (2) I/O block sizes, etc. Applications can set them by calling :cpp:func:`sdmmc_io_write_byte`.

    For card configuration and data transfer, choose the pair of functions relevant to your case from the table below.

    .. list-table::
       :widths: 55 25 20
       :header-rows: 1
         - Read Funct"
"ion
         - Write Function
         - :cpp:func:`sdmmc_io_read_byte`
         - :cpp:func:`sdmmc_io_write_byte`
         - :cpp:func:`sdmmc_io_read_bytes`
         - :cpp:func:`sdmmc_io_write_bytes`
         - :cpp:func:`sdmmc_io_read_blocks`
         - :cpp:func:`sdmmc_io_write_blocks`

    SDIO interrupts can be enabled by the application using the function :cpp:func:`sdmmc_io_enable_int`. When using SDIO in 1-line mode, the D1 line also needs to be connected to use SDIO interrupts.

    If"
" you want the application to wait until the SDIO interrupt occurs, use :cpp:func:`sdmmc_io_wait_int`.

    .. only:: esp32

        There is a component ESSL (ESP Serial Slave Link) to use if you are communicating with an ESP32 SDIO slave. See :doc:`/api-reference/protocols/esp_serial_slave_link` and example :example:`peripherals/sdio/host`.

Combo (Memory + IO) Cards


The driver does not support SD combo cards. Combo cards are treated as IO cards.


Thread Safety


Most applications need to us"
"e the protocol layer only in one task. For this reason, the protocol layer does not implement any kind of locking on the :cpp:class:`sdmmc_card_t` structure, or when accessing SDMMC or SD SPI host drivers. Such locking is usually implemented on a higher layer, e.g., in the filesystem driver.


API Reference


.. include-build-file:: inc/sdmmc_cmd.inc

.. include-build-file:: inc/sdmmc_types.inc
"
"Storage API




This section contains reference of the high-level storage APIs. They are based on low-level drivers such as SPI flash, SD/MMC.

- :doc:`Partitions API ` allow block based access to SPI flash according to the :doc:`/api-guides/partition-tables`.
- :doc:`Non-Volatile Storage library (NVS) ` implements a fault-tolerant wear-levelled key-value storage in SPI NOR flash.
- :doc:`Virtual File System (VFS) ` library provides an interface for registration of file system drivers. SPIFFS, F"
"AT and various other file system libraries are based on the VFS.
- :doc:`SPIFFS ` is a wear-levelled file system optimized for SPI NOR flash, well suited for small partition sizes and low throughput
- :doc:`FAT ` is a standard file system which can be used in SPI flash or on SD/MMC cards
- :doc:`Wear Levelling ` library implements a flash translation layer (FTL) suitable for SPI NOR flash. It is used as a container for FAT partitions in flash.

.. note::

    It is suggested to use high-level AP"
"Is (``esp_partition`` or file system) instead of low-level driver APIs to access the SPI NOR flash.

    Due to the restriction of NOR flash and ESP hardware, accessing the main flash will affect the performance of the whole system. See :doc:`/api-reference/peripherals/spi_flash/index` to learn more about the limitations.

.. toctree::
    :maxdepth: 1

    fatfs
    mass_mfg.rst
    nvs_flash
    nvs_encryption
    nvs_partition_gen.rst
    nvs_partition_parse.rst
    sdmmc
    partition
    sp"
"iffs
    vfs
    wear-levelling

Code examples for this API section are provided in the :example:`storage` directory of ESP-IDF examples.
"
"Virtual Filesystem Component




Overview


Virtual filesystem (VFS) component provides a unified interface for drivers which can perform operations on file-like objects. These can be real filesystems (FAT, SPIFFS, etc.) or device drivers which provide a file-like interface.

This component allows C library functions, such as fopen and fprintf, to work with FS drivers. At a high level, each FS driver is associated with some path prefix. When one of C library functions needs to open a file, the V"
"FS component searches for the FS driver associated with the file path and forwards the call to that driver. VFS also forwards read, write, and other calls for the given file to the same FS driver.

For example, one can register a FAT filesystem driver with the ``/fat`` prefix and call ``fopen(""/fat/file.txt"", ""w"")``. Then the VFS component calls the function ``open`` of the FAT driver and pass the argument ``/file.txt`` to it together with appropriate mode flags. All subsequent calls to C librar"
"y functions for the returned ``FILE*`` stream will also be forwarded to the FAT driver.


FS Registration


To register an FS driver, an application needs to define an instance of the :cpp:type:`esp_vfs_t` structure and populate it with function pointers to FS APIs:

.. highlight:: c

::

    esp_vfs_t myfs = {
        .flags = ESP_VFS_FLAG_DEFAULT,
        .write = &myfs_write,
        .open = &myfs_open,
        .fstat = &myfs_fstat,
        .close = &myfs_close,
        .read = &myfs_read,
  "
"  };

    ESP_ERROR_CHECK(esp_vfs_register(""/data"", &myfs, NULL));

Depending on the way how the FS driver declares its API functions, either ``read``, ``write``, etc., or ``read_p``, ``write_p``, etc., should be used.

Case 1: API functions are declared without an extra context pointer (the FS driver is a singleton)::

    ssize_t myfs_write(int fd, const void * data, size_t size);

    // In definition of esp_vfs_t:
        .flags = ESP_VFS_FLAG_DEFAULT,
        .write = &myfs_write,
    // .."
". other members initialized

    // When registering FS, context pointer (third argument) is NULL:
    ESP_ERROR_CHECK(esp_vfs_register(""/data"", &myfs, NULL));

Case 2: API functions are declared with an extra context pointer (the FS driver supports multiple instances)::

    ssize_t myfs_write(myfs_t* fs, int fd, const void * data, size_t size);

    // In definition of esp_vfs_t:
        .flags = ESP_VFS_FLAG_CONTEXT_PTR,
        .write_p = &myfs_write,
    // ... other members initialized

  "
"  // When registering FS, pass the FS context pointer into the third argument
    // (hypothetical myfs_mount function is used for illustrative purposes)
    myfs_t* myfs_inst1 = myfs_mount(partition1->offset, partition1->size);
    ESP_ERROR_CHECK(esp_vfs_register(""/data1"", &myfs, myfs_inst1));

    // Can register another instance:
    myfs_t* myfs_inst2 = myfs_mount(partition2->offset, partition2->size);
    ESP_ERROR_CHECK(esp_vfs_register(""/data2"", &myfs, myfs_inst2));

Synchronous Input/Ou"
"tput Multiplexing


Synchronous input/output multiplexing by :cpp:func:`select` is supported in the VFS component. The implementation works in the following way.

Non-Socket VFS Drivers
""""""""""""""""""""""""""""""""""""""""""""

If you want to use :cpp:func:`select` with a file descriptor belonging to a non-socket VFS driver, then you need to register the driver with functions :cpp:func:`start_select` and :cpp:func:`end_select` similarly to the following example:

.. highlight:: c

::

    // In definition of esp_"
"vfs_t:
        .start_select = &uart_start_select,
        .end_select = &uart_end_select,
    // ... other members initialized

:cpp:func:`start_select` is called for setting up the environment for detection of read/write/error conditions on file descriptors belonging to the given VFS driver.

:cpp:func:`end_select` is called to stop/deinitialize/free the environment which was setup by :cpp:func:`start_select`.

.. note::

    :cpp:func:`end_select` might be called without a previous :cpp:func:"
"`start_select` call in some rare circumstances. :cpp:func:`end_select` should fail gracefully if this is the case (i.e., should not crash but return an error instead).

Please refer to the reference implementation for the UART peripheral in :component_file:`esp_driver_uart/src/uart_vfs.c` and most particularly to the functions :cpp:func:`uart_vfs_dev_register`, :cpp:func:`uart_start_select`, and :cpp:func:`uart_end_select` for more information.

Please check the following examples that demonstra"
"te the use of :cpp:func:`select` with VFS file descriptors:

- :example:`peripherals/uart/uart_select`
- :example:`system/select`


Socket VFS Drivers
""""""""""""""""""""""""""""""""""""

A socket VFS driver is using its own internal implementation of :cpp:func:`select` and non-socket VFS drivers notify it upon read/write/error conditions.

A socket VFS driver needs to be registered with the following functions defined:

.. highlight:: c

::

    // In definition of esp_vfs_t:
        .socket_select = &lwip_sele"
"ct,
        .get_socket_select_semaphore = &lwip_get_socket_select_semaphore,
        .stop_socket_select = &lwip_stop_socket_select,
        .stop_socket_select_isr = &lwip_stop_socket_select_isr,
    // ... other members initialized

:cpp:func:`socket_select` is the internal implementation of :cpp:func:`select` for the socket driver. It works only with file descriptors belonging to the socket VFS.

:cpp:func:`get_socket_select_semaphore` returns the signalization object (semaphore) which is us"
"ed in non-socket drivers to stop the waiting in :cpp:func:`socket_select`.

:cpp:func:`stop_socket_select` call is used to stop the waiting in :cpp:func:`socket_select` by passing the object returned by :cpp:func:`get_socket_select_semaphore`.

:cpp:func:`stop_socket_select_isr` has the same functionality as :cpp:func:`stop_socket_select` but it can be used from ISR.

Please see :component_file:`lwip/port/esp32xx/vfs_lwip.c` for a reference socket driver implementation using LWIP.

.. note::
   "
" If you use :cpp:func:`select` for socket file descriptors only then you can disable the :ref:`CONFIG_VFS_SUPPORT_SELECT` option to reduce the code size and improve performance.
    You should not change the socket driver during an active :cpp:func:`select` call or you might experience some undefined behavior.

Paths


Each registered FS has a path prefix associated with it. This prefix can be considered as a ""mount point"" of this partition.

In case when mount points are nested, the mount point"
" with the longest matching path prefix is used when opening the file. For instance, suppose that the following filesystems are registered in VFS:

- FS 1 on /data
- FS 2 on /data/static

Then:

- FS 1 will be used when opening a file called ``/data/log.txt``
- FS 2 will be used when opening a file called ``/data/static/index.html``
- Even if ``/index.html""`` does not exist in FS 2, FS 1 will **not** be searched for ``/static/index.html``.

As a general rule, mount point names must start with the"
" path separator (``/``) and must contain at least one character after path separator. However, an empty mount point name is also supported and might be used in cases when an application needs to provide a ""fallback"" filesystem or to override VFS functionality altogether. Such filesystem will be used if no prefix matches the path given.

VFS does not handle dots (``.``) in path names in any special way. VFS does not treat ``..`` as a reference to the parent directory. In the above example, using "
"a path ``/data/static/../log.txt`` will not result in a call to FS 1 to open ``/log.txt``. Specific FS drivers (such as FATFS) might handle dots in file names differently.

When opening files, the FS driver receives only relative paths to files. For example:

VFS does not impose any limit on total file path length, but it does limit the FS path prefix to ``ESP_VFS_PATH_MAX`` characters. Individual FS drivers may have their own filename length limitations.


File Descriptors


File descriptors ar"
"e small positive integers from ``0`` to ``FD_SETSIZE - 1``, where ``FD_SETSIZE`` is defined in ``sys/select.h``. The largest file descriptors (configured by ``CONFIG_LWIP_MAX_SOCKETS``) are reserved for sockets. The VFS component contains a lookup-table called ``s_fd_table`` for mapping global file descriptors to VFS driver indexes registered in the ``s_vfs`` array.


Standard IO Streams (``stdin``, ``stdout``, ``stderr``)


If the menuconfig option ``UART for console output`` is not set to ``No"
"ne``, then ``stdin``, ``stdout``, and ``stderr`` are configured to read from, and write to, a UART. It is possible to use UART0 or UART1 for standard IO. By default, UART0 is used with 115200 baud rate; TX pin is GPIO1; RX pin is GPIO3. These parameters can be changed in menuconfig.

Writing to ``stdout`` or ``stderr`` sends characters to the UART transmit FIFO. Reading from ``stdin`` retrieves characters from the UART receive FIFO.

By default, VFS uses simple functions for reading from and wri"
"ting to UART. Writes busy-wait until all data is put into UART FIFO, and reads are non-blocking, returning only the data present in the FIFO. Due to this non-blocking read behavior, higher level C library calls, such as ``fscanf(""%d\n"", &var);``, might not have desired results.

Applications which use the UART driver can instruct VFS to use the driver's interrupt driven, blocking read and write functions instead. This can be done using a call to the :cpp:func:`uart_vfs_dev_use_driver` function. "
"It is also possible to revert to the basic non-blocking functions using a call to :cpp:func:`uart_vfs_dev_use_nonblocking`.

VFS also provides an optional newline conversion feature for input and output. Internally, most applications send and receive lines terminated by the LF (''\n'') character. Different terminal programs may require different line termination, such as CR or CRLF. Applications can configure this separately for input and output either via menuconfig, or by calls to the function"
"s :cpp:func:`uart_vfs_dev_port_set_rx_line_endings` and :cpp:func:`uart_vfs_dev_port_set_tx_line_endings`.


Standard Streams and FreeRTOS Tasks


``FILE`` objects for ``stdin``, ``stdout``, and ``stderr`` are shared between all FreeRTOS tasks, but the pointers to these objects are stored in per-task ``struct _reent``.

The following code is transferred to ``fprintf(__getreent()->_stderr, ""42\n"");`` by the preprocessor:

.. highlight:: c

::

    fprintf(stderr, ""42\n"");


The ``__getreent()`` f"
"unction returns a per-task pointer to ``struct _reent`` in newlib libc. This structure is allocated on the TCB of each task. When a task is initialized, ``_stdin``, ``_stdout``, and ``_stderr`` members of ``struct _reent`` are set to the values of ``_stdin``, ``_stdout``, and ``_stderr`` of ``_GLOBAL_REENT`` (i.e., the structure which is used before FreeRTOS is started).

Such a design has the following consequences:

- It is possible to set ``stdin``, ``stdout``, and ``stderr`` for any given ta"
"sk without affecting other tasks, e.g., by doing ``stdin = fopen(""/dev/uart/1"", ""r"")``.
- Closing default ``stdin``, ``stdout``, or ``stderr`` using ``fclose`` closes the ``FILE`` stream object, which will affect all other tasks.
- To change the default ``stdin``, ``stdout``, ``stderr`` streams for new tasks, modify ``_GLOBAL_REENT->_stdin`` (``_stdout``, ``_stderr``) before creating the task.

``eventfd()``


``eventfd()`` call is a powerful tool to notify a ``select()`` based loop of custom ev"
"ents. The ``eventfd()`` implementation in ESP-IDF is generally the same as described in `man(2) eventfd `_ except for:

- ``esp_vfs_eventfd_register()`` has to be called before calling ``eventfd()``
- Options ``EFD_CLOEXEC``, ``EFD_NONBLOCK`` and ``EFD_SEMAPHORE`` are not supported in flags.
- Option ``EFD_SUPPORT_ISR`` has been added in flags. This flag is required to read and write the eventfd in an interrupt handler.

Note that creating an eventfd with ``EFD_SUPPORT_ISR`` will cause interrupt"
"s to be temporarily disabled when reading, writing the file and during the beginning and the ending of the ``select()`` when this file is set.


API Reference


.. include-build-file:: inc/esp_vfs.inc

.. include-build-file:: inc/esp_vfs_dev.inc

.. include-build-file:: inc/uart_vfs.inc

.. include-build-file:: inc/esp_vfs_eventfd.inc
"
".. include:: /../../components/nvs_flash/nvs_partition_tool/README.rst
"
":orphan:

.. linked from fatfs.rst

Generating and Parsing FATFS on Host




This document is intended mainly for developers of Python tools :component_file:`fatfsgen.py ` and :component_file:`fatfsparse.py `, and people with special interest in these tools and implementation of the FAT file system in ESP-IDF. If you are interested in using these tools, please refer to the user guide at :ref:`fatfs-partition-generator`.

The FAT file system is composed of various logical units. The units are use"
"d to store general information about the file system, allocations, content of files and directories, and file's metadata. The tools ``fatfsgen.py`` and ``fatfsparse.py`` are used to implement the FAT file system while considering all these logical units, and they also provide support for wear levelling.


FAT File System Generator and Parser Design


This section describes particular units of the FAT file system generator and parser design. The implementation aims to create a valid model of the "
"FAT structure with a focus on macro operations, generating and parsing the whole partition without modifying it in the run (mounting).

.. figure:: ../../../_static/classes_fatfsgen.svg
    :align: center
    :alt: Class diagram

    FAT File System Generator and Parser Design Architecture


Class FATFS


This is the most general entity responsible for modeling the FAT file system. It is composed of **FATFSState** (holding metadata and boot sector), **FAT** (holding file allocation table), and *"
"*Directory** (representing the root directory required by FAT12 and FAT16). The class processes all the requirements for the partition, analyses the local folder dedicated to transforming it into a binary image, and generates an internal representation of the local folder. Then, the class can generate a binary image from the internal FAT file system model.

Class WLFATFS


The class extends the functionality of the class **FATFS**. It implements an encapsulation of the file system into the wear "
"levelling, by adding the ""dummy"" sector for balancing the load (a redundant sector, see the section :ref:`fafsgen-wear-levelling`), configuration sector and state sector. This class generates a binary FATFS partition with initialized wear levelling layer. For further analysis, it also provides an option to remove the wear levelling completely. The class is instantiated and invoked by the ``wl_fatfsgen.py`` script.

Class BootSectorState


The instance of this class contains the metadata required"
" for building a boot sector and BPB (BIOS Parameter Block). Boot sector is basically implemented for the cross-platform compatibility, i.e., when ESP chipsets are connected with other platforms, it will always follow all the FAT file system standards. However, during partition generation, chip does not consume the data in this boot sector and all the other data needed, as the data is constant. In other words, changing the fields with the prefix ""BS"" is usually unnecessary and often does not work"
". If you want to add new features, please focus on fields with the prefix ""BPB"". Another critical role of this class is to share access to the metadata and binary image over the whole class system. Because of this, every class in the system can access this singleton.

Class FATFSState


The class **FATFSState** might be obsolete in the future, so developers could transfer its functionality into the **BootSectorState**. The class contains a reference to the **BootSectorState** and extends the dat"
"a with some unknown information when creating a boot sector or unnecessary for the boot sector, such as the information generated when the file system supports long file names.

Class FAT


FAT represents the File Allocation Table. FAT is a sequence of bytes spread over one or more sectors. The number of sectors is determined by the number of clusters and is calculated by the function ``get_fat_sectors_count`` in ``utils.py``. The aim is to have as few sectors for one FAT as possible when you re"
"fer to every physical cluster in the file system. The FAT works as follows: For every physical cluster at ``i * some_constant`` address, FAT contains an entry at the ``i``-th location which represents next address of the clusters in the file chain. Each version of the FAT file system uses a different size for FAT entries. FAT12 uses 12 bits per entry, thus 2 entries span 3 bytes. FAT16 uses 16 bits per entry, thus 1 entry spans 2 bytes. FAT32 uses 32 bits per FAT entry, thus one entry spans 4 by"
"tes. All entries are in little-endian byte order.

All zeros at the ``i``-th entry indicates that corresponding cluster is free, while all ones at the ``i``-th entry indicates that corresponding cluster is occupied and is the last cluster in the file chain. The other number at ``ith``-th entry determines the next cluster's address in the file chain. These clusters are not necessarily stored adjacent to one another in the memory but instead are often fragmented throughout the data region.

For pa"
"rtition generation, the file is divided into several parts to fit the cluster. Notice that the structure allocation of the files is a linked list. Every cluster in the file allocation chain has entry in the FAT which refers to the next cluster or the information about the last cluster in the file chain. As mentioned, FAT12 uses 12 bits per FAT entry, thus it can sets a maximum number of 4096 clusters, as with 12 bits (one and a half bytes), it can enumerate 4096 clusters at most. However, becaus"
"e of other overhead, FAT12 can have 4085 clusters at most. Similarly, FAT16 can have 65525 clusters at most and for FAT32 can have 268435445 clusters at most (as practically only 28 bits out of 32 bits are used to denote each FAT entry). The current implementation doesn't allow forcibly redefining the FAT file system with less than 4085 clusters to FAT16, even though the documentation claims it is possible. Notice that it would be meaningless to define it vice versa, i.e., to FAT12 with more tha"
"n 4085 clusters (which implies clusters on higher addresses being inaccessible).

Class Cluster


The **Cluster** class is responsible for accessing the FAT entries and the corresponding physical cluster. The class **FAT** is an aggregation of a particular number of **Cluster** instances. Every cluster is uniquely defined by the ID, which also determines its position in FAT and corresponding sectors in the data region. When the cluster is allocated, it includes a reference to a file or directory"
". It happens only if the cluster is the first in the allocation chain. The cluster contains information about whether it is empty and the last in the file allocation linked list. If not, it includes a reference to the next cluster in the linked list. In practical usage, the cluster doesn't need to access its file, but the other way around. The **File** or **Directory** accesses its cluster, to retrieve the entire content that might be chained.

.. figure:: ../../../_static/fat_table.svg
   :alig"
"n: center
   :alt: Table diagram


Class Directory


This class represents the file system directory. An instance of **Directory** contains the reference to the corresponding instance of **Cluster**, which has the first cluster in the allocation chain for the directory given. The root directory is a special case with a different count of sectors and a slightly different instantiation process. However, the root directory is still an instance of this class and is the only **Directory** instance as"
"sociated with the class **FATFS** and **WLFATFS** respectively. The class **Directory** (except for the root directory) has one-to-one association with the class **Entry** that defines its entry in the parent directory. It also has an aggregation associated with the class **Entry**, because every directory contains multiple entries that consist of the actual directory's content (for example, aliases, files, and directories).

Class File


Similar to the class **Directory**, **File** represents s"
"ingle file in the file system. This class has one-to-one association with its first cluster in the allocation chain. Through this cluster, the **File** class may access the corresponding physical address and thus modifying its content. Every file also has one-to-one association with **Entry** instance belonging to its parent directory.

Class Entry


**Entry** encapsulates information about the file/directory name in the data region of corresponding parent directory. Every file system entity (Fi"
"le/Directory) has an entry. In case of the symlink, the entity can have multiple entries. The directory uses entries to access its descendant files and sub-directories, and enables traversing the tree structure. Except for that, **Entry** holds the name, extension, size, and information regarding the used file name size (long file names or file names 8.3), etc.

.. figure:: ../../../_static/tree_fatfs.svg
   :align: center
   :alt: Tree diagram


``fatfsgen.py``


:component_file:`fatfsgen.py ` "
"generates FAT file systems on the host.

``fatfsgen.py`` recursively traverses the given folder's directory structure and adds files and/or directories inside the binary partition. Users can set if the script generates the partition with wear levelling support, long file names support, and support for preserving the modification date and time from the original folder on the host.

The ``./fatfsgen.py Espressif`` command generates a simple binary partition with the default settings. Here ``Espres"
"sif`` is the local folder (containing files and/or sub-directories) from which binary image is generated.

There exist two scripts for that purpose, :component_file:`fatfsgen.py ` and :component_file:`wl_fatfsgen.py `. The difference is that ``wl_fatfsgen.py`` firstly uses ``fatfsgen.py`` for generating the partition and then initializes wear leveling.

The script command line arguments are as follows::

    fatfsgen.py [-h] [--output_file OUTPUT_FILE] [--partition_size PARTITION_SIZE] [--sector"
"_size {4096}] [--long_name_support] [--use_default_datetime] input_directory

    --output_file: path to the generated binary partition
    --partition_size: defines the size of the binary partition (decimal, hexa or binary number)
    --sector_size: the size of the sector
    --long_name_support: flag for supporting long file names
    --use_default_datetime: this flag forces using default dates and times (date == 0x2100, time == 0x0000), not using argument to preserve the original file system "
"metadata
    input_directory: required argument, name of the directory being encoded to the binary fat-compatibile partition

``fatfsparse.py``


:component_file:`fatfsparse.py ` translates the binary image into the internal representation and generates the folder with equivalent content on the host. If user requires a parsing partition with initialized wear levelling, the ``fatfsparse.py`` will remove the wear levelling sectors using the function ``remove_wl`` provided by ``wl_fatfsgen.py``. Af"
"ter the sectors are removed, parsing of the partition is the same as with no initial wear levelling.

``./fatfsparse.py fatfs_image.img`` command yields the directory with the equivalent content as the binary data image ``fatfs_image.img``.

The script command line arguments are as follows::

    fatfsparse.py [-h] [--wl-layer {detect,enabled,disabled}] input_image

    --wl-layer: indicates if wear leveling is enabled, disabled or should be detected (detection is ambiguous)
    input_image: pat"
"h to binary image

The long file names can be detected automatically. However, the wear leveling cannot be 100\% detected, because one partition can be valid either with or without wear leveling, according to the user's context. When the script finds wear leveling sectors (cfg and state), it assumes wear leveling is enabled, however it might be a false positive.


Features


FAT12/FAT16


The supported FAT types are FAT12 and FAT16. For smaller partitions, FAT12 is sufficient. The type is detect"
"ed according to the count of clusters, and cannot be changed by the user. If there are less than 4085 clusters, the selected type is FAT12 (FAT's entries have 12 bits). For partitions with 4085 to 65526 clusters (with 4085 and 65526 excluded), the type is FAT16. Currently ``fatfsgen.py`` or ``fatfsparse.py`` cannot process file systems with more than 65525 clusters.

.. _fafsgen-wear-levelling:

Wear Levelling

There are two types of operations related to the wear levelling layer, initializing w"
"ear leveling records and removing wear leveling records during generation and parsing of the FAT file system image.

When a new image with wear leveling support is generated, the script initializes few extra sectors necessary for the wear leveling function.

    - The dummy sector: This is an empty sector placed at the beginning of the partition and it will be ignored when file system is being mounted. The dummy sector copies the content of the next sector and then swaps its position with the ne"
"xt sector (or the first sector in case dummy sector was the last) after particular number of erase cycles. In this way, each FAT file system sector traverses across the whole range of flash partition, and thus the erase cycles corresponding to this sector gets distributed across the entire flash.

    - The state sector: State sector has 64 byte data stored.
        - pos: position of the dummy sector
        - max_pos: number of sectors in the partition (excluding config and state sectors)
    "
"    - move_count: indicates how many times dummy sector traversed through the entire flash
        - access_count: count of sector erase cycles after which dummy sector will swap its position
        - max_count: equal to wl_config_t::updaterate
        - block_size: equal to wl_config_t::page_size
        - version: equal to wl_config_t::version
        - device_id: generated randomly when the state is first initialized
        - reserved: 7 x 32-bit words, set to 0
        - crc32: crc32 of al"
"l the previous fields, including reserved

      Also, the state sector will be appended by 16-byte ``pos update record`` for every value of ``pos``. Thus, this record will help us to determine the position of the dummy sector.

      Since ``erase + write`` operation of the state sector is not atomic, we may lose the data if the power is cut off between ""erase"" and ""write"". However, two copies of the state are maintained to recover the state after the power outage. On each update, both copies a"
"re updated. Thus, after power outage, we can revert the original valid state.

    - The config sector: This sector contains the information about the partition used by the wear leveling layer.
        - start_addr: start address of partition (always 0)
        - full_mem_size: size of the partition, including data, dummy, state x 2, config sectors. Value is in bytes
        - page_size: equal to sector size (generally 4096)
        - sector_size: always 4096 for the types of NOR flash supported"
" by ESP-IDF
        - updaterate: ESP-IDF always sets this to 16. Could be made a config option at some point
        - wr_size: always set to 16
        - version: current version is 2
        - temp_buff_size: always set to 32 (This shouldn't actually have been stored in flash)
        - crc: crc32 of all the previous values
While removing wear leveling records, we have to find the position of the dummy sector, and the original and valid orders of the partition (because traversing the dummy se"
"ctor shuffles the partition). The script can remove other wear leveling sectors from the partition. Steps to remove wear leveling records are given below:

    - Find the ``pos``, position of the dummy sector, which will be determined by the number of ``pos update records`` in the state sector.
    - Create the new image by removing dummy sector and merging remaining sectors before and after dummy sector.
    - Then remove the wear leveling state sectors and config sector which are placed at the"
" end of the partition.
    - Reorder the new image to get its original order. ``move_count`` helps us to find the beginning of the partition. The partition will start at the position ``end_of_partition - move_count``. Thus the beginning of the partition after removing wear leveling sectors will be ``partition[end_of_partition - (move_count*page_size)]``.

File Names Encoding


The protocol FAT supports two types of file names.

Short File Names (SFN)


The SFN is mandatory for the implementation"
" of file names. SFN refer to the 8.3 file name convention, with 8 characters for the file name and 3 characters for the extension. This pattern is case-insensitive, however, all file names are changed to uppercase in the inner representation of the generator. The entry describing the short file names is 32 bytes long and its structure is as follows::

    Offset:   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
    0x000000: 46 49 4C 45 4E 41 4D 45 45 58 54 20 18 00 00 00    FILENAMEEXT.....
  "
"  0x000010: 21 00 21 00 00 00 00 00 21 00 02 00 1E 00 00 00    !.!.....!.......

The entry denotes the file with 8.3 file name (""FILENAME.EXT"") __(0x00/00-0A)__ of size 0x1E = 30 bytes __(0x10/0x0C)__, with default times of modification and creation (0x0021) __(0x10/00,02 and 08)__. The relevant cluster for the file is located at __0x02 (0x10/0A)__. Please notice that a character is encoded using one byte (e.g., __0x46 == 'F'__)

Long File Names (LFN)


The LFN supports 255 characters excluding "
"the trailing ``NULL``. The LFN supports any character as short file names with an additional period ``.`` and the following special characters: ``+ , ; = [ ]``. LFN uses UNICODE, so the character is encoded using 2 bytes.

The structure of one name encoded using LFN is as follows::

    00003000: 42 65 00 2E 00 74 00 78 00 74 00 0F 00 43 FF FF    Be...t.x.t...C..
    00003010: FF FF FF FF FF FF FF FF FF FF 00 00 FF FF FF FF    ................
    00003020: 01 74 00 68 00 69 00 73 00 69 00 0F 00"
" 43 73 00    .t.h.i.s.i...Cs.
    00003030: 6C 00 6F 00 6E 00 67 00 66 00 00 00 69 00 6C 00    l.o.n.g.f...i.l.
    00003040: 54 48 49 53 49 53 7E 31 54 58 54 20 00 00 D6 45    THISIS~1TXT...VE
    00003050: 26 55 26 55 00 00 D6 45 26 55 02 00 1C 00 00 00    &U&U..VE&U......

The above example encodes a file name ``thisislongfile.txt``. The record is composed of multiple entries. The first entry contains metadata and is equivalent to the SFN entry. This entry might be final if the file name conf"
"orms to the 8.3 file name convention. In such scenarios, the SFN pattern is used. Otherwise, the generator adds various entries with the LFN structure above the SFN entry. These entries hold information about the file name and its checksum for consistency. Every LFN record can hold 13 characters (26 bytes). The file name is firstly cut into some amount of 13-character substrings and these are added above the SFN entry.

We add LFN entries in reversed order, so the first entry in the directory is"
" the last part of the file name and the last is SFN entry. In the above example, we can see that the first entry contains text ``e.txt``, while the others contain the beginning of the name ``thisislongfil``. The first byte in LFN entries denotes an order or the sequence number (numbered from 1). To determine the first entry of the LFN, the first byte is masked with 0x40 (``first_byte =| 0x40``). The specification says that the last entry value will be ORed with 0x40 and it is the mark for the la"
"st entry. For example, when the record is the second and also the last in the LFN entry, its first byte is ``0x42``.

The LFN entry is signed at field **DIR_Attr** with value ``ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID`` (see the file ``long_filename_utils.py``). The SFN entry (possibly also within LFN) contains either ``ATTR_DIRECTORY`` or ``ATTR_ARCHIVE`` in this field for directory or file respectively.

The LFN entry is tagged at the field **DIR_NTRes** with the value ``0x0"
"0``. This is a sign of the SFN entry in the LFN record, if the entry is a whole SFN record, the value is ``0x18``. As you can see in the first example, the value at this field is ``0x18``, because the name **""FILENAME.EXT""** fits the SFN. However, the recent example showing **""thisislongfile.txt""** has value ``0x00`` at field **DIR_NTRes** in the last entry, since it is a LFN. The SFN needs to be unique. For that purpose, the ``fatfsgen.py`` uses the first 6 characters from the file name, concat"
"enating with ``~`` and with ID denoting the order of the name with the same prefix. The ID is between 0 to 127, which is the maximal amount of files with the same prefix.

Calculation of the checksum is described and implemented in the ``utils.py`` by function ``lfn_checksum``. The ``fatfsparse.py`` assumes that the LFN entries might not be right next to each other, but it assumes the relative order is preserved. The approach is first to find the SFN belonging to some LFN record (using **DIR_NTR"
"es** field). From then, the script starts to search by moving upwards to the beginning of the respective sector, until it finds the last entry in the LFN record (the one with the first half byte equal to 4). The entries are distinguished by their checksums. When finished, the file name can be composed.

Date and Time in FAT File System


The FAT file system protocol used by ESP-IDF does not preserve the date or time on the chips' media, so all the images extracted from the device have the same d"
"efault timestamp for all the FAT-specified date-time fields (creation and the last modification timestamp as well as creation, last modification and last access dates).

There are a couple of fields in the SFN entry describing time, such as **DIR_CrtTime** and **DIR_WrtTime**. Some fields are ignored by the FAT implementation used by ESP-IDF (see the file ``entry.py``). However, changes in the fields **DIR_WrtTime** and **DIR_WrtDate** are preserved in the chip. Both time and data entry are 16-b"
"it, where the granularity of the time is 2 seconds.
"
".. include:: /../../components/nvs_flash/nvs_partition_generator/README.rst
"
"Partitions API




Overview


The ``esp_partition`` component has higher-level API functions which work with partitions defined in the :doc:`/api-guides/partition-tables`. These APIs are based on lower level API provided by :doc:`/api-reference/peripherals/spi_flash/index`.

.. _flash-partition-apis:

Partition Table API


ESP-IDF projects use a partition table to maintain information about various regions of SPI flash memory (bootloader, various application binaries, data, filesystems). More in"
"formation can be found in :doc:`/api-guides/partition-tables`.

This component provides API functions to enumerate partitions found in the partition table and perform operations on them. These functions are declared in ``esp_partition.h``:

- :cpp:func:`esp_partition_find` checks a partition table for entries with specific type, returns an opaque iterator.
- :cpp:func:`esp_partition_get` returns a structure describing the partition for a given iterator.
- :cpp:func:`esp_partition_next` shifts th"
"e iterator to the next found partition.
- :cpp:func:`esp_partition_iterator_release` releases iterator returned by :cpp:func:`esp_partition_find`.
- :cpp:func:`esp_partition_find_first` is a convenience function which returns the structure describing the first partition found by :cpp:func:`esp_partition_find`.
- :cpp:func:`esp_partition_read`, :cpp:func:`esp_partition_write`, :cpp:func:`esp_partition_erase_range` are equivalent to :cpp:func:`esp_flash_read`, :cpp:func:`esp_flash_write`, :cpp:fun"
"c:`esp_flash_erase_region`, but operate within partition boundaries.


See Also


- :doc:`../../api-guides/partition-tables`
- :doc:`../system/ota` provides high-level API for updating applications stored in flash.
- :doc:`nvs_flash` provides a structured API for storing small pieces of data in SPI flash.


.. _api-reference-partition-table:

API Reference - Partition Table


.. include-build-file:: inc/esp_partition.inc
"
".. include:: /../../tools/mass_mfg/docs/README.rst
"
"Non-Volatile Storage Library




Introduction


Non-volatile storage (NVS) library is designed to store key-value pairs in flash. This section introduces some concepts used by NVS.

Underlying Storage


Currently, NVS uses a portion of main flash memory through the :ref:`esp_partition ` API. The library uses all the partitions with ``data`` type and ``nvs`` subtype.  The application can choose to use the partition with the label ``nvs`` through the :cpp:func:`nvs_open` API function or any other "
"partition by specifying its name using the :cpp:func:`nvs_open_from_partition` API function.

Future versions of this library may have other storage backends to keep data in another flash chip (SPI or I2C), RTC, FRAM, etc.

.. note:: if an NVS partition is truncated (for example, when the partition table layout is changed), its contents should be erased. ESP-IDF build system provides a ``idf.py erase-flash`` target to erase all contents of the flash chip.

.. note:: NVS works best for storing ma"
"ny small values, rather than a few large values of the type 'string' and 'blob'. If you need to store large blobs or strings, consider using the facilities provided by the FAT filesystem on top of the wear levelling library.


Keys and Values


NVS operates on key-value pairs. Keys are ASCII strings; the maximum key length is currently 15 characters. Values can have one of the following types:

-  integer types: ``uint8_t``, ``int8_t``, ``uint16_t``, ``int16_t``, ``uint32_t``, ``int32_t``, ``uin"
"t64_t``, ``int64_t``
-  zero-terminated string
-  variable length binary data (blob)

.. note::

    String values are currently limited to 4000 bytes. This includes the null terminator. Blob values are limited to 508,000 bytes or 97.6% of the partition size - 4000 bytes, whichever is lower.

Additional types, such as ``float`` and ``double`` might be added later.

Keys are required to be unique. Assigning a new value to an existing key replaces the old value and data type with the value and dat"
"a type specified by a write operation.

A data type check is performed when reading a value. An error is returned if the data type expected by read operation does not match the data type of entry found for the key provided.


Namespaces


To mitigate potential conflicts in key names between different components, NVS assigns each key-value pair to one of namespaces. Namespace names follow the same rules as key names, i.e., the maximum length is 15 characters. Furthermore, there can be no more tha"
"n 254 different namespaces in one NVS partition. Namespace name is specified in the :cpp:func:`nvs_open` or :cpp:type:`nvs_open_from_partition` call. This call returns an opaque handle, which is used in subsequent calls to the ``nvs_get_*``, ``nvs_set_*``, and :cpp:func:`nvs_commit` functions. This way, a handle is associated with a namespace, and key names will not collide with same names in other namespaces. Please note that the namespaces with the same name in different NVS partitions are con"
"sidered as separate namespaces.

NVS Iterators


Iterators allow to list key-value pairs stored in NVS, based on specified partition name, namespace, and data type.

There are the following functions available:

- :cpp:func:`nvs_entry_find` creates an opaque handle, which is used in subsequent calls to the :cpp:func:`nvs_entry_next` and :cpp:func:`nvs_entry_info` functions.
- :cpp:func:`nvs_entry_next` advances an iterator to the next key-value pair.
- :cpp:func:`nvs_entry_info` returns informat"
"ion about each key-value pair

In general, all iterators obtained via :cpp:func:`nvs_entry_find` have to be released using :cpp:func:`nvs_release_iterator`, which also tolerates ``NULL`` iterators.

:cpp:func:`nvs_entry_find` and :cpp:func:`nvs_entry_next` set the given iterator to ``NULL`` or a valid iterator in all cases except a parameter error occured (i.e., return ``ESP_ERR_NVS_NOT_FOUND``). In case of a parameter error, the given iterator will not be modified. Hence, it is best practice to"
" initialize the iterator to ``NULL`` before calling :cpp:func:`nvs_entry_find` to avoid complicated error checking before releasing the iterator.


Security, Tampering, and Robustness


.. only:: not SOC_HMAC_SUPPORTED

    NVS is not directly compatible with the {IDF_TARGET_NAME} flash encryption system. However, data can still be stored in encrypted form if NVS encryption is used together with {IDF_TARGET_NAME} flash encryption. Please refer to :doc:`nvs_encryption` for more details.

.. only:"
": SOC_HMAC_SUPPORTED

    NVS is not directly compatible with the {IDF_TARGET_NAME} flash encryption system. However, data can still be stored in encrypted form if NVS encryption is used together with {IDF_TARGET_NAME} flash encryption or with the help of the HMAC peripheral. Please refer to :doc:`nvs_encryption` for more details.

If NVS encryption is not used, it is possible for anyone with physical access to the flash chip to alter, erase, or add key-value pairs. With NVS encryption enabled, "
"it is not possible to alter or add a key-value pair and get recognized as a valid pair without knowing corresponding NVS encryption keys. However, there is no tamper-resistance against the erase operation.

The library does try to recover from conditions when flash memory is in an inconsistent state. In particular, one should be able to power off the device at any point and time and then power it back on. This should not result in loss of data, except for the new key-value pair if it was being w"
"ritten at the moment of powering off. The library should also be able to initialize properly with any random data present in flash memory.


.. _nvs_encryption:

NVS Encryption


Please refer to the :doc:`nvs_encryption` guide for more details.

NVS Partition Generator Utility


This utility helps generate NVS partition binary files which can be flashed separately on a dedicated partition via a flashing utility. Key-value pairs to be flashed onto the partition can be provided via a CSV file. For"
" more details, please refer to :doc:`nvs_partition_gen`.

Instead of calling the ``nvs_partition_gen.py`` tool manually, the creation of the partition binary files can also be done directly from CMake using the function ``nvs_create_partition_image``::

    nvs_create_partition_image(  [FLASH_IN_PROJECT] [DEPENDS  dep dep dep ...])

**Positional Arguments**:

.. list-table::
    :header-rows: 1
      - Description
      - Name of the NVS parition
      - Path to CSV file to parse


**Optional Ar"
"guments**:

.. list-table::
   :header-rows: 1
     - Description
     - Name of the NVS parition
     - Specify files on which the command depends


If ``FLASH_IN_PROJECT`` is not specified, the image will still be generated, but you will have to flash it manually using ``idf.py -flash`` (e.g., if your parition name is ``nvs``, then use ``idf.py nvs-flash``).

``nvs_create_partition_image`` must be called from one of the component ``CMakeLists.txt`` files. Currently, only non-encrypted partitio"
"ns are supported.

Application Example


You can find code examples in the :example:`storage` directory of ESP-IDF examples:

:example:`storage/nvs_rw_value`

  Demonstrates how to read a single integer value from, and write it to NVS.

  The value checked in this example holds the number of the {IDF_TARGET_NAME} module restarts. The value's function as a counter is only possible due to its storing in NVS.

  The example also shows how to check if a read/write operation was successful, or if a c"
"ertain value has not been initialized in NVS. The diagnostic procedure is provided in plain text to help you track the program flow and capture any issues on the way.

:example:`storage/nvs_rw_blob`

  Demonstrates how to read a single integer value and a blob (binary large object), and write them to NVS to preserve this value between {IDF_TARGET_NAME} module restarts.

  The example also shows how to implement the diagnostic procedure to check if the read/write operation was successful.

:examp"
"le:`storage/nvs_rw_value_cxx`

  This example does exactly the same as :example:`storage/nvs_rw_value`, except that it uses the C++ NVS handle class.

Internals


Log of Key-Value Pairs


NVS stores key-value pairs sequentially, with new key-value pairs being added at the end. When a value of any given key has to be updated, a new key-value pair is added at the end of the log and the old key-value pair is marked as erased.

Pages and Entries


NVS library uses two main entities in its operation:"
" pages and entries. Page is a logical structure which stores a portion of the overall log. Logical page corresponds to one physical sector of flash memory. Pages which are in use have a *sequence number* associated with them. Sequence numbers impose an ordering on pages. Higher sequence numbers correspond to pages which were created later. Each page can be in one of the following states:

Empty/uninitialized
    Flash storage for the page is empty (all bytes are ``0xff``). Page is not used to st"
"ore any data at this point and does not have a sequence number.

Active
    Flash storage is initialized, page header has been written to flash, page has a valid sequence number. Page has some empty entries and data can be written there. No more than one page can be in this state at any given moment.

Full
    Flash storage is in a consistent state and is filled with key-value pairs.
    Writing new key-value pairs into this page is not possible. It is still possible to mark some key-value pairs"
" as erased.

Erasing
    Non-erased key-value pairs are being moved into another page so that the current page can be erased. This is a transient state, i.e., page should never stay in this state at the time when any API call returns. In case of a sudden power off, the move-and-erase process will be completed upon the next power-on.

Corrupted
    Page header contains invalid data, and further parsing of page data was canceled. Any items previously written into this page will not be accessible. "
"The corresponding flash sector will not be erased immediately and will be kept along with sectors in **uninitialized** state for later use. This may be useful for debugging.

Mapping from flash sectors to logical pages does not have any particular order. The library will inspect sequence numbers of pages found in each flash sector and organize pages in a list based on these numbers.

::

    ++     ++     ++     ++
    | Page 1 |     | Page 2 |     | Page 3 |     | Page 4 |
    | Full   +---> | "
"Full   +---> | Active |     | Empty  |     |     Data (8)                   |
                                            | Types     ++
                       +-> Fixed length --
                       |                    |           +++++
                       |                    +>  | Size(4) | ChunkCount(1)| ChunkStart(1) | Rsv(2)|
        Data format ---+                    Blob Index  +++++
                       |
                       |                             ++++
              "
"         +->   Variable length   -->   | Size (2) | Rsv (2) | CRC32 (4) |
                            (Strings, Blob Data)     ++++


Individual fields in entry structure have the following meanings:

NS
    Namespace index for this entry. For more information on this value, see the section on namespaces implementation.

Type
    One byte indicating the value data type. See the :cpp:type:`ItemType` enumeration in :component_file:`nvs_flash/include/nvs_handle.hpp` for possible values.

Span
    N"
"umber of entries used by this key-value pair. For integer types, this is equal to 1. For strings and blobs, this depends on value length.

ChunkIndex
    Used to store the index of a blob-data chunk for blob types. For other types, this should be ``0xff``.

CRC32
    Checksum calculated over all the bytes in this entry, except for the CRC32 field itself.

Key
    Zero-terminated ASCII string containing a key name. Maximum string length is 15 bytes, excluding a zero terminator.

Data
    For inte"
"ger types, this field contains the value itself. If the value itself is shorter than 8 bytes, it is padded to the right, with unused bytes filled with ``0xff``.

    For ""blob index"" entry, these 8 bytes hold the following information about data-chunks:

    - Size
        (Only for blob index.) Size, in bytes, of complete blob data.

    - ChunkCount
        (Only for blob index.) Total number of blob-data chunks into which the blob was divided during storage.

    - ChunkStart
        (Only fo"
"r blob index.) ChunkIndex of the first blob-data chunk of this blob. Subsequent chunks have chunkIndex incrementally allocated (step of 1).

    For string and blob data chunks, these 8 bytes hold additional data about the value, which are described below:

    - Size
        (Only for strings and blobs.) Size, in bytes, of actual data. For strings, this includes zero terminators.

    - CRC32
        (Only for strings and blobs.) Checksum calculated over all bytes of data.

Variable length valu"
"es (strings and blobs) are written into subsequent entries, 32 bytes per entry. The ``Span`` field of the first entry indicates how many entries are used.


Namespaces


As mentioned above, each key-value pair belongs to one of the namespaces. Namespace identifiers (strings) are stored as keys of key-value pairs in namespace with index 0. Values corresponding to these keys are indexes of these namespaces.

::

    ++
    | NS=0 Type=uint8_t Key=""wifi"" Value=1      |   Entry describing namespace "
"""wifi""
    ++
    | NS=1 Type=uint32_t Key=""channel"" Value=6  |   Key ""channel"" in namespace ""wifi""
    ++
    | NS=0 Type=uint8_t Key=""pwm"" Value=2       |   Entry describing namespace ""pwm""
    ++
    | NS=2 Type=uint16_t Key=""channel"" Value=20 |   Key ""channel"" in namespace ""pwm""
    ++


Item Hash List


To reduce the number of reads from flash memory, each member of the Page class maintains a list of pairs: item index; item hash. This list makes searches much quicker. Instead of iterating o"
"ver all entries, reading them from flash one at a time, `Page::findItem` first performs a search for the item hash in the hash list. This gives the item index within the page if such an item exists. Due to a hash collision, it is possible that a different item is found. This is handled by falling back to iteration over items in flash.

Each node in the hash list contains a 24-bit hash and 8-bit item index. Hash is calculated based on item namespace, key name, and ChunkIndex. CRC32 is used for ca"
"lculation; the result is truncated to 24 bits. To reduce the overhead for storing 32-bit entries in a linked list, the list is implemented as a double-linked list of arrays. Each array holds 29 entries, for the total size of 128 bytes, together with linked list pointers and a 32-bit count field. The minimum amount of extra RAM usage per page is therefore 128 bytes; maximum is 640 bytes.

API Reference


.. include-build-file:: inc/nvs_flash.inc

.. include-build-file:: inc/nvs.inc
"
"FAT Filesystem Support




ESP-IDF uses the `FatFs `_ library to work with FAT filesystems. FatFs resides in the ``fatfs`` component. Although the library can be used directly, many of its features can be accessed via VFS using the C standard library and POSIX API functions.

Additionally, FatFs has been modified to support the runtime pluggable disk I/O layer. This allows mapping of FatFs drives to physical disks at runtime.


Using FatFs with VFS


The header file :component_file:`fatfs/vfs/es"
"p_vfs_fat.h` defines the functions for connecting FatFs and VFS.

The function :cpp:func:`esp_vfs_fat_register` allocates a ``FATFS`` structure and registers a given path prefix in VFS. Subsequent operations on files starting with this prefix are forwarded to FatFs APIs.

The function :cpp:func:`esp_vfs_fat_unregister_path` deletes the registration with VFS, and frees the ``FATFS`` structure.

Most applications use the following workflow when working with ``esp_vfs_fat_`` functions:

#. Call :cp"
"p:func:`esp_vfs_fat_register` to specify:
    - Path prefix where to mount the filesystem (e.g., ``""/sdcard""``, ``""/spiflash""``)
    - FatFs drive number
    - A variable which receives the pointer to the ``FATFS`` structure

#. Call :cpp:func:`ff_diskio_register` to register the disk I/O driver for the drive number used in Step 1.

#. To mount the filesystem using the same drive number which was passed to :cpp:func:`esp_vfs_fat_register`, call the FatFs function :cpp:func:`f_mount`. If the file"
"system is not present on the target logical drive, :cpp:func:`f_mount` will fail with the ``FR_NO_FILESYSTEM`` error. In such case, call :cpp:func:`f_mkfs` to create a fresh FatFS structure on the drive first, and then call :cpp:func:`f_mount` again. Note that SD cards need to be partitioned with :cpp:func:`f_fdisk` prior to previously described steps. For more information, see `FatFs documentation `_.

#. Call the C standard library and POSIX API functions to perform such actions on files as op"
"en, read, write, erase, copy, etc. Use paths starting with the path prefix passed to :cpp:func:`esp_vfs_register` (for example, ``""/sdcard/hello.txt""``). The filesystem uses `8.3 filenames `_ format (SFN) by default. If you need to use long filenames (LFN), enable the :ref:`CONFIG_FATFS_LONG_FILENAMES` option. Please refer to `FatFs filenames `_ for more details.

#. Optionally, call the FatFs library functions directly. In this case, use paths without a VFS prefix, for example, ``""/hello.txt""``"
".

#. Close all open files.

#. Call the FatFs function :cpp:func:`f_mount` for the same drive number with NULL ``FATFS*`` argument to unmount the filesystem.

#. Call the FatFs function :cpp:func:`ff_diskio_register` with NULL ``ff_diskio_impl_t*`` argument and the same drive number to unregister the disk I/O driver.

#. Call :cpp:func:`esp_vfs_fat_unregister_path` with the path where the file system is mounted to remove FatFs from VFS, and free the ``FATFS`` structure allocated in Step 1.

The"
" convenience functions :cpp:func:`esp_vfs_fat_sdmmc_mount`, :cpp:func:`esp_vfs_fat_sdspi_mount`, and :cpp:func:`esp_vfs_fat_sdcard_unmount` wrap the steps described above and also handle SD card initialization. These functions are described in the next section.

.. note::

   Because FAT filesystem does not support hardlinks, :cpp:func:`link` copies contents of the file instead. (This only applies to files on FatFs volumes.)


Using FatFs with VFS and SD Cards


The header file :component_file:`"
"fatfs/vfs/esp_vfs_fat.h` defines convenience functions :cpp:func:`esp_vfs_fat_sdmmc_mount`, :cpp:func:`esp_vfs_fat_sdspi_mount`, and :cpp:func:`esp_vfs_fat_sdcard_unmount`. These functions perform Steps 1–3 and 7–9 respectively and handle SD card initialization, but provide only limited error handling. Developers are encouraged to check its source code and incorporate more advanced features into production applications.

The convenience function :cpp:func:`esp_vfs_fat_sdmmc_unmount` unmounts the"
" filesystem and releases the resources acquired by :cpp:func:`esp_vfs_fat_sdmmc_mount`.


Using FatFs with VFS in Read-Only Mode


The header file :component_file:`fatfs/vfs/esp_vfs_fat.h` also defines the convenience functions :cpp:func:`esp_vfs_fat_spiflash_mount_ro` and :cpp:func:`esp_vfs_fat_spiflash_unmount_ro`. These functions perform Steps 1-3 and 7-9 respectively for read-only FAT partitions. These are particularly helpful for data partitions written only once during factory provisioning"
", which will not be changed by production application throughout the lifetime of the hardware.

Configuration options


The following configuration options are available for the FatFs component:


FatFS Disk IO Layer


FatFs has been extended with API functions that register the disk I/O driver at runtime.

These APIs provide implementation of disk I/O functions for SD/MMC cards and can be registered for the given FatFs drive number using the function :cpp:func:`ff_diskio_register_sdmmc`.

.. do"
"xygenfunction:: ff_diskio_register
.. doxygenstruct:: ff_diskio_impl_t
    :members:
.. doxygenfunction:: ff_diskio_register_sdmmc
.. doxygenfunction:: ff_diskio_register_wl_partition
.. doxygenfunction:: ff_diskio_register_raw_partition


.. _fatfs-partition-generator:

FatFs Partition Generator


We provide a partition generator for FatFs (:component_file:`wl_fatfsgen.py `) which is integrated into the build system and could be easily used in the user project.

The tool is used to create files"
"ystem images on a host and populate it with content of the specified host folder.

The script is based on the partition generator (:component_file:`fatfsgen.py `). Apart from generating partition, it can also initialize wear levelling.

The latest version supports both short and long file names, FAT12 and FAT16. The long file names are limited to 255 characters and can contain multiple periods (``.``) characters within the filename and additional characters ``+``, ``,``, ``;``, ``=``, ``[`` and "
"``]``.

An in-depth description of the FatFs partition generator and analyzer can be found at :doc:`Generating and parsing FAT partition on host `.

Build System Integration with FatFs Partition Generator


It is possible to invoke FatFs generator directly from the CMake build system by calling ``fatfs_create_spiflash_image``::

    fatfs_create_spiflash_image(  [FLASH_IN_PROJECT])

If you prefer generating partition without wear levelling support, you can use ``fatfs_create_rawflash_image``::

"
"    fatfs_create_rawflash_image(  [FLASH_IN_PROJECT])

``fatfs_create_spiflash_image`` respectively ``fatfs_create_rawflash_image`` must be called from project's CMakeLists.txt.

If you decide for any reason to use ``fatfs_create_rawflash_image`` (without wear levelling support), beware that it supports mounting only in read-only mode in the device.


The arguments of the function are as follows:

#. partition - the name of the partition as defined in the partition table (e.g., :example_file:`st"
"orage/fatfsgen/partitions_example.csv`).

#. base_dir - the directory that will be encoded to FatFs partition and optionally flashed into the device. Beware that you have to specify the suitable size of the partition in the partition table.

#. flag ``FLASH_IN_PROJECT`` - optionally, users can have the image automatically flashed together with the app binaries, partition tables, etc. on ``idf.py flash -p `` by specifying ``FLASH_IN_PROJECT``.

#. flag ``PRESERVE_TIME`` - optionally, users can fo"
"rce preserving the timestamps from the source folder to the target image. Without preserving the time, every timestamp will be set to the FATFS default initial time (1st January 1980).

#. flag ``ONE_FAT`` - optionally, users can still choose to generate a FATFS volume with a single FAT (file allocation table) instead of two. This makes the free space in the FATFS volume a bit larger (by ``number of sectors used by FAT * sector size``) but also more prone to corruption.

For example::

    fatfs"
"_create_spiflash_image(my_fatfs_partition my_folder FLASH_IN_PROJECT)

If FLASH_IN_PROJECT is not specified, the image will still be generated, but you will have to flash it manually using ``esptool.py`` or a custom build system target.

For an example, see :example:`storage/fatfsgen`.


FatFs Partition Analyzer


(:component_file:`fatfsparse.py `) is a partition analyzing tool for FatFs.

It is a reverse tool of (:component_file:`fatfsgen.py `), i.e., it can generate the folder structure on the"
" host based on the FatFs image.

Usage::

    ./fatfsparse.py [-h] [--wl-layer {detect,enabled,disabled}] [--verbose] fatfs_image.img

Parameter --verbose prints detailed information from boot sector of the FatFs image to the terminal before folder structure is generated.

High-level API Reference


.. include-build-file:: inc/esp_vfs_fat.inc
"
"SPIFFS Filesystem




Overview


SPIFFS is a file system intended for SPI NOR flash devices on embedded targets. It supports wear levelling, file system consistency checks, and more.

Notes


 - Currently, SPIFFS does not support directories, it produces a flat structure. If SPIFFS is mounted under ``/spiffs``, then creating a file with the path ``/spiffs/tmp/myfile.txt`` will create a file called ``/tmp/myfile.txt`` in SPIFFS, instead of ``myfile.txt`` in the directory ``/spiffs/tmp``.
 - It is"
" not a real-time stack. One write operation might take much longer than another.
 - For now, it does not detect or handle bad blocks.
 - SPIFFS is able to reliably utilize only around 75% of assigned partition space.
 - When the filesystem is running out of space, the garbage collector is trying to find free space by scanning the filesystem multiple times, which can take up to several seconds per write function call, depending on required space. This is caused by the SPIFFS design and the issue "
"has been reported multiple times (e.g., `here `_) and in the official `SPIFFS github repository `_. The issue can be partially mitigated by the `SPIFFS configuration `_.
 - When garbage collector is attempting to reclaim space by scanning the entire filesystem multiple times (usually 10 times by default), during each scan, the garbage collector frees up one block if available. Therefore, if the maximum number of runs set for the garbage collector is 'n' (SPIFFS_GC_MAX_RUNS: locate this configura"
"tion option in `SPIFFS configuration `_), then n times the block size will become available for data writing. If you attempt to write data exceeding n times the block size, the write operation may fail and return an error.
 - When the chip experiences a power loss during a file system operation it could result in SPIFFS corruption. However the file system still might be recovered via ``esp_spiffs_check`` function. More details in the official SPIFFS `FAQ `_.

Tools


``spiffsgen.py``


:componen"
"t_file:`spiffsgen.py` is a write-only Python SPIFFS implementation used to create filesystem images from the contents of a host folder. To use ``spiffsgen.py``, open Terminal and run::

    python spiffsgen.py   

The required arguments are as follows:

- **image_size**: size of the partition onto which the created SPIFFS image will be flashed.
- **base_dir**: directory for which the SPIFFS image needs to be created.
- **output_file**: SPIFFS image output file.

There are also other arguments th"
"at control image generation. Documentation on these arguments can be found in the tool's help::

    python spiffsgen.py --help

These optional arguments correspond to a possible SPIFFS build configuration. To generate the right image, please make sure that you use the same arguments/configuration as were used to build SPIFFS. As a guide, the help output indicates the SPIFFS build configuration to which the argument corresponds. In cases when these arguments are not specified, the default values"
" shown in the help output will be used.

When the image is created, it can be flashed using ``esptool.py`` or ``parttool.py``.

Aside from invoking the ``spiffsgen.py`` standalone by manually running it from the command line or a script, it is also possible to invoke ``spiffsgen.py`` directly from the build system by calling ``spiffs_create_partition_image``::

    spiffs_create_partition_image(  [FLASH_IN_PROJECT] [DEPENDS dep dep dep...])

This is more convenient as the build configuration is "
"automatically passed to the tool, ensuring that the generated image is valid for that build. An example of this is while the **image_size** is required for the standalone invocation, only the **partition** name is required when using ``spiffs_create_partition_image`` -- the image size is automatically obtained from the project's partition table.

``spiffs_create_partition_image`` must be called from one of the component ``CMakeLists.txt`` files.

Optionally, users can opt to have the image autom"
"atically flashed together with the app binaries, partition tables, etc. on ``idf.py flash`` by specifying ``FLASH_IN_PROJECT``.  For example::

    spiffs_create_partition_image(my_spiffs_partition my_folder FLASH_IN_PROJECT)

If FLASH_IN_PROJECT/SPIFFS_IMAGE_FLASH_IN_PROJECT is not specified, the image will still be generated, but you will have to flash it manually using ``esptool.py``, ``parttool.py``, or a custom build system target.

There are cases where the contents of the base directory i"
"tself is generated at build time. Users can use DEPENDS/SPIFFS_IMAGE_DEPENDS to specify targets that should be executed before generating the image::

    add_custom_target(dep COMMAND ...)

    spiffs_create_partition_image(my_spiffs_partition my_folder DEPENDS dep)

For an example, see :example:`storage/spiffsgen`.

``mkspiffs``


Another tool for creating SPIFFS partition images is `mkspiffs `_. Similar to ``spiffsgen.py``, it can be used to create an image from a given folder and then flash "
"that image using ``esptool.py``

For that, you need to obtain the following parameters:

- **Block Size**: 4096 (standard for SPI Flash)
- **Page Size**: 256 (standard for SPI Flash)
- **Image Size**: Size of the partition in bytes (can be obtained from a partition table)
- **Partition Offset**: Starting address of the partition (can be obtained from a partition table)

To pack a folder into a 1-Megabyte image, run::

    mkspiffs -c [src_folder] -b 4096 -p 256 -s 0x100000 spiffs.bin

To flash t"
"he image onto {IDF_TARGET_NAME} at offset 0x110000, run::

    python esptool.py --chip {IDF_TARGET_PATH_NAME} --port [port] --baud [baud] write_flash -z 0x110000 spiffs.bin

Notes on Which SPIFFS Tool to Use
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The two tools presented above offer very similar functionality. However, there are reasons to prefer one over the other, depending on the use case.

Use ``spiffsgen.py`` in the following cases:

Use ``mkspiffs`` in the following cases:

See Also


- :doc:`"
"Partition Table documentation `


Application Example


An example of using SPIFFS is provided in the :example:`storage/spiffs` directory. This example initializes and mounts a SPIFFS partition, then writes and reads data from it using POSIX and C library APIs. See the README.md file in the example directory for more information.

High-level API Reference


.. include-build-file:: inc/esp_spiffs.inc
"
"NVS Encryption




Overview


This guide provides an overview of the NVS encryption feature. NVS encryption helps to achieve secure storage on the device flash memory.

Data stored in NVS partitions can be encrypted using XTS-AES in the manner similar to the one mentioned in disk encryption standard IEEE P1619. For the purpose of encryption, each entry is treated as one ``sector`` and relative address of the entry (w.r.t., partition-start) is fed to the encryption algorithm as ``sector-number``."
"

.. only:: SOC_HMAC_SUPPORTED

    NVS encryption can be facilitated by enabling :ref:`CONFIG_NVS_ENCRYPTION` and :ref:`CONFIG_NVS_SEC_KEY_PROTECTION_SCHEME` > ``CONFIG_NVS_SEC_KEY_PROTECT_USING_FLASH_ENC`` or ``CONFIG_NVS_SEC_KEY_PROTECT_USING_HMAC`` depending on the scheme to be used.


NVS Encryption: Flash Encryption-Based Scheme


In this scheme, the keys required for NVS encryption are stored in yet another partition, which is protected using :doc:`Flash Encryption `. Therefore, enabling "
":doc:`Flash Encryption ` becomes a prerequisite for NVS encryption here.

.. only:: SOC_HMAC_SUPPORTED

    NVS encryption should be enabled when :doc:`../../security/flash-encryption` is enabled because the Wi-Fi driver stores credentials (like SSID and passphrase) in the default NVS partition. It is important to encrypt them if platform-level encryption is already enabled.

.. only:: not SOC_HMAC_SUPPORTED

    NVS encryption is enabled by default when :doc:`../../security/flash-encryption` is"
" enabled. This is done because Wi-Fi driver stores credentials (like SSID and passphrase) in the default NVS partition. It is important to encrypt them as default choice if platform-level encryption is already enabled.

For using NVS encryption using this scheme, the partition table must contain the :ref:`nvs_encr_key_partition`. Two partition tables containing the :ref:`nvs_encr_key_partition` are provided for NVS encryption under the partition table option (``menuconfig`` > ``Partition Table``"
"). They can be selected with the project configuration menu (``idf.py menuconfig``). Please refer to the example :example:`security/flash_encryption` for how to configure and use the NVS encryption feature.

.. _nvs_encr_key_partition:

NVS Key Partition


An application requiring NVS encryption support (using the Flash Encryption-based scheme) needs to be compiled with a key-partition of the type ``data`` and subtype ``key``. This partition should be marked as ``encrypted`` and its size should "
"be the minimum partition size (4 KB). Refer to :doc:`../../api-guides/partition-tables` for more details. Two additional partition tables which contain the :ref:`nvs_encr_key_partition` are provided under the partition table option (``menuconfig`` > ``Partition Table``). They can be directly used for NVS encryption. The structure of these partitions is depicted below:

.. highlight:: none

::

    +++++
    |              XTS encryption key (32)        |
    ++
    |              XTS tweak key ("
"32)             |
    ++
    |                  CRC32 (4)                  |
    ++

The XTS encryption keys in the :ref:`nvs_encr_key_partition` can be generated in one of the following two ways.

**Generate the keys on {IDF_TARGET_NAME} chip itself**

    .. note::

        Please note that ``nvs_keys`` partition must be completely erased before you start the application in this approach. Otherwise the application may generate the :c:macro:`ESP_ERR_NVS_CORRUPT_KEY_PART` error code assuming tha"
"t ``nvs_keys`` partition is not empty and contains malformatted data. You can use the following command for this:
        ::

            parttool.py --port PORT --partition-table-file=PARTITION_TABLE_FILE --partition-table-offset PARTITION_TABLE_OFFSET erase_partition --partition-type=data --partition-subtype=nvs_keys

**Use a pre-generated NVS key partition**

    This option will be required by the user when keys in the :ref:`nvs_encr_key_partition` are not generated by the application. The :"
"ref:`nvs_encr_key_partition` containing the XTS encryption keys can be generated with the help of :doc:`NVS Partition Generator Utility `. Then the user can store the pre-generated key partition on the flash with help of the following two commands:
    ::

        idf.py partition-table partition-table-flash
    ::

        parttool.py --port PORT --partition-table-offset PARTITION_TABLE_OFFSET write_partition --partition-name=""name of nvs_key partition"" --input NVS_KEY_PARTITION_FILE

    .. no"
"te::
        If the device is encrypted in flash encryption development mode and you want to renew the NVS key partition, you need to tell :component_file:`parttool.py` to encrypt the NVS key partition and you also need to give it a pointer to the unencrypted partition table in your build directory (build/partition_table) since the partition table on the device is encrypted, too. You can use the following command:
        ::

            parttool.py --esptool-write-args encrypt --port PORT --par"
"tition-table-file=PARTITION_TABLE_FILE --partition-table-offset PARTITION_TABLE_OFFSET write_partition --partition-name=""name of nvs_key partition"" --input NVS_KEY_PARTITION_FILE

Since the key partition is marked as ``encrypted`` and :doc:`Flash Encryption ` is enabled, the bootloader will encrypt this partition using flash encryption key on the first boot.

It is possible for an application to use different keys for different NVS partitions and thereby have multiple key-partitions. However, it"
" is a responsibility of the application to provide the correct key-partition and keys for encryption or decryption.

.. only:: SOC_HMAC_SUPPORTED

    NVS Encryption: HMAC Peripheral-Based Scheme
    

    In this scheme, the XTS keys required for NVS encryption are derived from an HMAC key programmed in eFuse with the purpose :cpp:enumerator:`esp_efuse_purpose_t::ESP_EFUSE_KEY_PURPOSE_HMAC_UP`. Since the encryption keys are derived at runtime, they are not stored anywhere in the flash. Thus, th"
"is feature does not require a separate :ref:`nvs_encr_key_partition`.

    .. note::

        This scheme enables us to achieve secure storage on {IDF_TARGET_NAME} **without enabling flash encryption**.

    .. important::

        Please take note that this scheme uses one eFuse block for storing the HMAC key required for deriving the encryption keys.

    - When NVS encryption is enabled, the :cpp:func:`nvs_flash_init` API function can be used to initialize the encrypted default NVS partition."
" The API function first checks whether an HMAC key is present at :ref:`CONFIG_NVS_SEC_HMAC_EFUSE_KEY_ID`.

    .. note::

        The valid range for the config :ref:`CONFIG_NVS_SEC_HMAC_EFUSE_KEY_ID` is from ``0`` (:cpp:enumerator:`hmac_key_id_t::HMAC_KEY0`) to ``5`` (:cpp:enumerator:`hmac_key_id_t::HMAC_KEY5`). By default, the config is set to ``6`` (:cpp:enumerator:`hmac_key_id_t::HMAC_KEY_MAX`), which have to be configured before building the user application.

    - If no key is found, a ke"
"y is generated internally and stored at the eFuse block specified at :ref:`CONFIG_NVS_SEC_HMAC_EFUSE_KEY_ID`.
    - If a key is found with the purpose :cpp:enumerator:`esp_efuse_purpose_t::ESP_EFUSE_KEY_PURPOSE_HMAC_UP`, the same is used for the derivation of the XTS encryption keys.
    - If the specified eFuse block is found to be occupied with a key with a purpose other than :cpp:enumerator:`esp_efuse_purpose_t::ESP_EFUSE_KEY_PURPOSE_HMAC_UP`, an error is thrown.

    - The API :cpp:func:`nvs"
"_flash_init` then automatically generates the NVS keys on demand by using the :cpp:func:`nvs_flash_generate_keys_v2` API function provided by the :component_file:`nvs_flash/include/nvs_flash.h`. The same keys can also be used to read the security configurations (see :cpp:func:`nvs_flash_read_security_cfg_v2`) for initializing a custom encrypted NVS partition with help of :cpp:func:`nvs_flash_secure_init_partition`.

    - The API functions :cpp:func:`nvs_flash_secure_init` and :cpp:func:`nvs_fla"
"sh_secure_init_partition` do not generate the keys internally. When these API functions are used for initializing encrypted NVS partitions, the keys can be generated after startup using the :cpp:func:`nvs_flash_generate_keys_v2` API function or take and populate the NVS security configuration structure :cpp:type:`nvs_sec_cfg_t` with :cpp:func:`nvs_flash_read_security_cfg_v2` and feed them into the above APIs.

    .. note:: Users can program their own HMAC key in eFuse block beforehand by using "
"the following command:
        ::

            espefuse.py -p PORT burn_key   HMAC_UP

Encrypted Read/Write


The same NVS API functions ``nvs_get_*`` or ``nvs_set_*`` can be used for reading of, and writing to an encrypted NVS partition as well.

**Encrypt the default NVS partition**

- To enable encryption for the default NVS partition, no additional step is necessary. When :ref:`CONFIG_NVS_ENCRYPTION` is enabled, the :cpp:func:`nvs_flash_init` API function internally performs some additional "
"steps to enable encryption for the default NVS partition depending on the scheme being used (set by :ref:`CONFIG_NVS_SEC_KEY_PROTECTION_SCHEME`).

- For the flash encryption-based scheme, the first :ref:`nvs_encr_key_partition` found is used to generate the encryption keys while for the HMAC one, keys are generated using the HMAC key burnt in eFuse at :ref:`CONFIG_NVS_SEC_HMAC_EFUSE_KEY_ID` (refer to the API documentation for more details).

Alternatively, :cpp:func:`nvs_flash_secure_init` API f"
"unction can also be used to enable encryption for the default NVS partition.

**Encrypt a custom NVS partition**

- To enable encryption for a custom NVS partition, :cpp:func:`nvs_flash_secure_init_partition` API function is used instead of :cpp:func:`nvs_flash_init_partition`.

- When :cpp:func:`nvs_flash_secure_init` and :cpp:func:`nvs_flash_secure_init_partition` API functions are used, the applications are expected to follow the steps below in order to perform NVS read/write operations with "
"encryption enabled:

            - Find key partition and NVS data partition using ``esp_partition_find*`` API functions.
            - Populate the :cpp:type:`nvs_sec_cfg_t` struct using the :cpp:func:`nvs_flash_read_security_cfg` or :cpp:func:`nvs_flash_generate_keys` API functions.

        .. only:: SOC_HMAC_SUPPORTED

                - Set the scheme-specific config data with :cpp:type:`nvs_sec_config_hmac_t` and register the HMAC-based scheme with the API :cpp:func:`nvs_sec_provider_regist"
"er_hmac` which will also populate the scheme-specific handle (see :cpp:type:`nvs_sec_scheme_t`).
                - Populate the :cpp:type:`nvs_sec_cfg_t` struct using the :cpp:func:`nvs_flash_read_security_cfg_v2` or :cpp:func:`nvs_flash_generate_keys_v2` API functions.

            .. code-block:: c

                    nvs_sec_cfg_t cfg = {};
                    nvs_sec_scheme_t *sec_scheme_handle = NULL;

                    nvs_sec_config_hmac_t sec_scheme_cfg = {};
                    hmac_"
"key_id_t hmac_key = HMAC_KEY0;
                    sec_scheme_cfg.hmac_key_id = hmac_key;

                    ret = nvs_sec_provider_register_hmac(&sec_scheme_cfg, &sec_scheme_handle);
                    if (ret != ESP_OK) {
                        return ret;
                    }

                    ret = nvs_flash_read_security_cfg_v2(sec_scheme_handle, &cfg);
                    if (ret != ESP_OK) {
                        if (ret == ESP_ERR_NVS_SEC_HMAC_KEY_NOT_FOUND) {
                 "
"           ret = nvs_flash_generate_keys_v2(&sec_scheme_handle, &cfg);
                            if (ret != ESP_OK) {
                                ESP_LOGE(TAG, ""Failed to generate NVS encr-keys!"");
                                return ret;
                            }
                        }
                        ESP_LOGE(TAG, ""Failed to read NVS security cfg!"");
                        return ret;
                    }

.. only:: SOC_HMAC_SUPPORTED

    .. note::
        While usin"
"g the HMAC-based scheme, the above workflow can be used without enabling any of the config options for NVS encryption - :ref:`CONFIG_NVS_ENCRYPTION`, :ref:`CONFIG_NVS_SEC_KEY_PROTECTION_SCHEME` -> ``CONFIG_NVS_SEC_KEY_PROTECT_USING_HMAC`` and :ref:`CONFIG_NVS_SEC_HMAC_EFUSE_KEY_ID` to encrypt the default as well as custom NVS partitions with :cpp:func:`nvs_flash_secure_init` API.


NVS Security Provider


The component :component:`nvs_sec_provider` stores all the implementation-specific code for"
" the NVS encryption schemes and would also accomodate any future schemes. This component acts as an interface to the :component:`nvs_flash` component for the handling of encryption keys. :component:`nvs_sec_provider` has a configuration menu of its own, based on which the selected security scheme and the corresponding settings are registered for the :component:`nvs_flash` component.

.. only:: SOC_HMAC_SUPPORTED

    This component offers factory functions with which a particular security scheme"
" can be registered without having to worry about the APIs to generate and read the encryption keys (e.g., :cpp:func:`nvs_sec_provider_register_hmac`). Refer to the :example:`security/nvs_encryption_hmac` example for API usage.


API Reference


.. include-build-file:: inc/nvs_sec_provider.inc
"
".. include:: ../../../../components/wear_levelling/README.rst

See Also


- :doc:`./fatfs`
- :doc:`../../api-guides/partition-tables`

Application Example


An example that combines the wear levelling driver with the FATFS library is provided in the :example:`storage/wear_levelling` directory. This example initializes the wear levelling driver, mounts FatFs partition, as well as writes and reads data from it using POSIX and C library APIs. See :example_file:`storage/wear_levelling/README.md` for"
" more information.

High-level API Reference


Header Files


High-level wear levelling functions :cpp:func:`esp_vfs_fat_spiflash_mount_rw_wl`, :cpp:func:`esp_vfs_fat_spiflash_unmount_rw_wl` and struct :cpp:class:`esp_vfs_fat_mount_config_t` are described in :doc:`./fatfs`.

Mid-level API Reference


.. include-build-file:: inc/wear_levelling.inc
"
"FreeRTOS Overview




Overview


FreeRTOS is an open source RTOS (real-time operating system) kernel that is integrated into ESP-IDF as a component. Thus, all ESP-IDF applications and many ESP-IDF components are written based on FreeRTOS. The FreeRTOS kernel is ported to all architectures (i.e., Xtensa and RISC-V) available of ESP chips.

Furthermore, ESP-IDF provides different implementations of FreeRTOS in order to support SMP (Symmetric Multiprocessing) on multi-core ESP chips. This document "
"provides an overview of the FreeRTOS component, the different FreeRTOS implementations offered by ESP-IDF, and the common aspects across all implementations.

Implementations


The `official FreeRTOS `_ (henceforth referred to as Vanilla FreeRTOS) is a single-core RTOS. In order to support the various multi-core ESP targets, ESP-IDF supports different FreeRTOS implementations as listed below:

ESP-IDF FreeRTOS


ESP-IDF FreeRTOS is a FreeRTOS implementation based on Vanilla FreeRTOS v10.5.1, but"
" contains significant modifications to support SMP. ESP-IDF FreeRTOS only supports two cores at most (i.e., dual core SMP), but is more optimized for this scenario by design. For more details regarding ESP-IDF FreeRTOS and its modifications, please refer to the :doc:`freertos_idf` document.

.. note::

    ESP-IDF FreeRTOS is currently the default FreeRTOS implementation for ESP-IDF.

.. only:: not esp32p4

    .. _amazon_smp_freertos:

    Amazon SMP FreeRTOS
    

    Amazon SMP FreeRTOS is an"
" SMP implementation of FreeRTOS that is officially supported by Amazon. Amazon SMP FreeRTOS is able to support N-cores (i.e., more than two cores). Amazon SMP FreeRTOS can be enabled via the :ref:`CONFIG_FREERTOS_SMP` option. For more details regarding Amazon SMP FreeRTOS, please refer to the `official Amazon SMP FreeRTOS documentation `_.

    .. warning::

        The Amazon SMP FreeRTOS implementation (and its port in ESP-IDF) are currently in experimental/beta state. Therefore, significant b"
"ehavioral changes and breaking API changes can occur.

Configuration


Kernel Configuration


Vanilla FreeRTOS requires that ports and applications configure the kernel by adding various ``#define config...`` macro definitions to the ``FreeRTOSConfig.h`` header file. Vanilla FreeRTOS supports a list of kernel configuration options which allow various kernel behaviors and features to be enabled or disabled.

**However, for all FreeRTOS ports in ESP-IDF, the FreeRTOSConfig.h header file is conside"
"red private and must not be modified by users**. A large number of kernel configuration options in ``FreeRTOSConfig.h`` are hard-coded as they are either required/not supported by ESP-IDF. All kernel configuration options that are configurable by the user are exposed via menuconfig under ``Component Config/FreeRTOS/Kernel``.

For the full list of user configurable kernel options, see :doc:`/api-reference/kconfig`. The list below highlights some commonly used kernel configuration options:

- :ref"
":`CONFIG_FREERTOS_UNICORE` runs FreeRTOS only on Core 0. Note that this is **not equivalent to running Vanilla FreeRTOS**. Furthermore, this option may affect behavior of components other than :component:`freertos`. For more details regarding the effects of running FreeRTOS on a single core, refer to :ref:`freertos-idf-single-core` (if using ESP-IDF FreeRTOS) or the official Amazon SMP FreeRTOS documentation. Alternatively, users can also search for occurrences of ``CONFIG_FREERTOS_UNICORE`` in "
"the ESP-IDF components.

.. only:: not SOC_HP_CPU_HAS_MULTIPLE_CORES

    .. note::
        As {IDF_TARGET_NAME} is a single core SoC, the :ref:`CONFIG_FREERTOS_UNICORE` configuration is always set.

- :ref:`CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY` enables backward compatibility with some FreeRTOS macros/types/functions that were deprecated from v8.0 onwards.

Port Configuration


All other FreeRTOS related configuration options that are not part of the kernel configuration are exposed via"
" menuconfig under ``Component Config/FreeRTOS/Port``. These options configure aspects such as:

- The FreeRTOS ports themselves (e.g., tick timer selection, ISR stack size)
- Additional features added to the FreeRTOS implementation or ports

Using FreeRTOS


Application Entry Point


Unlike Vanilla FreeRTOS, users of FreeRTOS in ESP-IDF **must never call** :cpp:func:`vTaskStartScheduler` and :cpp:func:`vTaskEndScheduler`. Instead, ESP-IDF starts FreeRTOS automatically. Users must define a ``void"
" app_main(void)`` function which acts as the entry point for user's application and is automatically invoked on ESP-IDF startup.

- Typically, users would spawn the rest of their application's task from ``app_main``.
- The ``app_main`` function is allowed to return at any point (i.e., before the application terminates).
- The ``app_main`` function is called from the ``main`` task.

.. _freertos_system_tasks:

Background Tasks


During startup, ESP-IDF and the FreeRTOS kernel automatically create"
" multiple tasks that run in the background (listed in the the table below).

.. list-table:: List of Tasks Created During Startup
    :widths: 10 75 5 5 5
    :header-rows: 1
      - Description
      - Stack Size
      - Affinity
      - Priority
      - An idle task (``IDLEx``) is created for (and pinned to) each core, where ``x`` is the core's number. ``x`` is dropped when single-core configuration is enabled.
      - :ref:`CONFIG_FREERTOS_IDLE_TASK_STACKSIZE`
      - Core x
      - ``0``
   "
"   - FreeRTOS will create the Timer Service/Daemon Task if any FreeRTOS Timer APIs are called by the application
      - :ref:`CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH`
      - Core 0
      - :ref:`CONFIG_FREERTOS_TIMER_TASK_PRIORITY`
      - Task that simply calls ``app_main``. This task will self delete when ``app_main`` returns
      - :ref:`CONFIG_ESP_MAIN_TASK_STACK_SIZE`
      - :ref:`CONFIG_ESP_MAIN_TASK_AFFINITY`
      - ``1``
      - When :ref:`CONFIG_FREERTOS_UNICORE` is false, an IPC ta"
"sk (``ipcx``) is created for (and pinned to) each core. IPC tasks are used to implement the Inter-processor Call (IPC) feature.
      - :ref:`CONFIG_ESP_IPC_TASK_STACK_SIZE`
      - Core x
      - ``24``
      - ESP-IDF creates the ESP Timer Task used to process ESP Timer callbacks
      - :ref:`CONFIG_ESP_TIMER_TASK_STACK_SIZE`
      - Core 0
      - ``22``

.. note::
    Note that if an application uses other ESP-IDF features (e.g., Wi-Fi or Bluetooth), those features may create their own back"
"ground tasks in addition to the tasks listed in the table above.

FreeRTOS Additions


ESP-IDF provides some supplemental features to FreeRTOS such as Ring Buffers, ESP-IDF style Tick and Idle Hooks, and TLSP deletion callbacks. See :doc:`freertos_additions` for more details.

.. _freertos-heap:

FreeRTOS Heap


Vanilla FreeRTOS provides its own `selection of heap implementations `_. However, ESP-IDF already implements its own heap (see :doc:`/api-reference/system/mem_alloc`), thus ESP-IDF does "
"not make use of the heap implementations provided by Vanilla FreeRTOS. All FreeRTOS ports in ESP-IDF map FreeRTOS memory allocation or free calls (e.g., ``pvPortMalloc()`` and ``pvPortFree()``) to ESP-IDF heap API (i.e., :cpp:func:`heap_caps_malloc` and :cpp:func:`heap_caps_free`). However, the FreeRTOS ports ensure that all dynamic memory allocated by FreeRTOS is placed in internal memory.

.. note::
    If users wish to place FreeRTOS tasks/objects in external memory, users can use the followi"
"ng methods:

    - Allocate the task or object using one of the ``...CreateWithCaps()`` API, such as :cpp:func:`xTaskCreateWithCaps` and :cpp:func:`xQueueCreateWithCaps` (see :ref:`freertos-idf-additional-api` for more details).
    - Manually allocate external memory for those objects using :cpp:func:`heap_caps_malloc`, then create the objects from the allocated memory using on of the ``...CreateStatic()`` FreeRTOS functions.
"
"Miscellaneous System APIs




{IDF_TARGET_BASE_MAC_BLOCK: default=""BLK1"", esp32=""BLK0""}
{IDF_TARGET_CPU_RESET_DES: default=""the CPU is reset"", esp32=""both CPUs are reset"", esp32s3=""both CPUs are reset"", esp32p4=""both CPUs are reset""}

Software Reset


To perform software reset of the chip, the :cpp:func:`esp_restart` function is provided. When the function is called, execution of the program stops, {IDF_TARGET_CPU_RESET_DES}, the application is loaded by the bootloader and starts execution again"
".

Additionally, the :cpp:func:`esp_register_shutdown_handler` function can register a routine that will be automatically called before a restart (that is triggered by :cpp:func:`esp_restart`) occurs. This is similar to the functionality of ``atexit`` POSIX function.

Reset Reason


ESP-IDF applications can be started or restarted due to a variety of reasons. To get the last reset reason, call :cpp:func:`esp_reset_reason` function. See description of :cpp:type:`esp_reset_reason_t` for the list o"
"f possible reset reasons.

Heap Memory


Two heap-memory-related functions are provided:

Note that ESP-IDF supports multiple heaps with different capabilities. The functions mentioned in this section return the size of heap memory that can be allocated using the ``malloc`` family of functions. For further information about heap memory, see :doc:`Heap Memory Allocation `.

.. _MAC-Address-Allocation:

MAC Address


These APIs allow querying and customizing MAC addresses for different supported n"
"etwork interfaces (e.g., Wi-Fi, Bluetooth, Ethernet).

To fetch the MAC address for a specific network interface (e.g., Wi-Fi, Bluetooth, Ethernet), call the function :cpp:func:`esp_read_mac`.

In ESP-IDF, the MAC addresses for the various network interfaces are calculated from a single **base MAC address**. By default, the Espressif base MAC address is used. This base MAC address is pre-programmed into the {IDF_TARGET_NAME} eFuse in the factory during production.

.. only:: not esp32s2

    .. "
"list-table::
        :widths: 20 40 40
        :header-rows: 1
          - MAC Address (4 universally administered, default)
          - MAC Address (2 universally administered)
          - base_mac
          - base_mac
          - base_mac, +1 to the last octet
          - :ref:`Local MAC ` (derived from Wi-Fi Station MAC)
          - base_mac, +2 to the last octet
          - base_mac, +1 to the last octet
          - base_mac, +3 to the last octet
          - :ref:`Local MAC ` (derived from B"
"luetooth MAC)

    .. note::

        The :ref:`configuration ` configures the number of universally administered MAC addresses that are provided by Espressif.

.. only:: esp32s2

    .. list-table::
        :widths: 20 40 40
        :header-rows: 1
          - MAC Address (2 universally administered, default)
          - MAC Address (1 universally administered)
          - base_mac
          - base_mac
          - base_mac, +1 to the last octet
          - :ref:`Local MAC ` (derived from Wi-Fi "
"Station MAC)
          - :ref:`Local MAC ` (derived from Wi-Fi SoftAP MAC)
          - :ref:`Local MAC ` (derived from base_mac with +1 to last octet. Not recommended.)

    .. note::

        The :ref:`configuration ` configures the number of universally administered MAC addresses that are provided by Espressif.

.. only:: not SOC_EMAC_SUPPORTED

    .. note::

      Although {IDF_TARGET_NAME} has no integrated Ethernet MAC, it is still possible to calculate an Ethernet MAC address. However, th"
"is MAC address can only be used with an external ethernet interface such as an SPI-Ethernet device. See :doc:`/api-reference/network/esp_eth`.

Custom Interface MAC


Sometimes you may need to define custom MAC addresses that are not generated from the base MAC address. To set a custom interface MAC address, use the :cpp:func:`esp_iface_mac_addr_set` function. This function allows you to overwrite the MAC addresses of interfaces set (or not yet set) by the base MAC address. Once a MAC address ha"
"s been set for a particular interface, it will not be affected when the base MAC address is changed.

Custom Base MAC


The default base MAC is pre-programmed by Espressif in eFuse {IDF_TARGET_BASE_MAC_BLOCK}. To set a custom base MAC instead, call the function :cpp:func:`esp_iface_mac_addr_set` with the ``ESP_MAC_BASE`` argument (or :cpp:func:`esp_base_mac_addr_set`) before initializing any network interfaces or calling the :cpp:func:`esp_read_mac` function. The custom MAC address can be stored"
" in any supported storage device (e.g., flash, NVS).

The custom base MAC addresses should be allocated such that derived MAC addresses will not overlap. Based on the table above, users can configure the option :ref:`CONFIG_{IDF_TARGET_CFG_PREFIX}_UNIVERSAL_MAC_ADDRESSES` to set the number of valid universal MAC addresses that can be derived from the custom base MAC.

.. note::

    It is also possible to call the function :cpp:func:`esp_netif_set_mac` to set the specific MAC used by a network i"
"nterface after network initialization. But it is recommended to use the base MAC approach documented here to avoid the possibility of the original MAC address briefly appearing on the network before being changed.


Custom MAC Address in eFuse
@@@@@@@@@@@@@@@@@@@@@@@@@@@

When reading custom MAC addresses from eFuse, ESP-IDF provides a helper function :cpp:func:`esp_efuse_mac_get_custom`. Users can also use :cpp:func:`esp_read_mac` with the ``ESP_MAC_EFUSE_CUSTOM`` argument. This loads the MAC a"
"ddress from eFuse BLK3. The :cpp:func:`esp_efuse_mac_get_custom` function assumes that the custom base MAC address is stored in the following format:

.. only:: esp32

    .. list-table::
        :widths: 20 15 20 45
        :header-rows: 1
          - # of bits
          - Range of bits
          - Notes
          - 8
          - 191:184
          - 0: invalid, others — valid
          - 128
          - 183:56
          -
          - 48
          - 55:8
          -
          - 8
          - 7:0"
"
          - CRC-8-CCITT, polynomial 0x07

    .. note::

        If the 3/4 coding scheme is enabled, all eFuse fields in this block must be burnt at the same time.

.. only:: not esp32

    .. list-table::
        :widths: 30 30 30
        :header-rows: 1
          - # of bits
          - Range of bits
          - 48
          - 200:248

    .. note::

        The eFuse BLK3 uses RS-coding during burning, which means that all eFuse fields in this block must be burnt at the same time.

Once cus"
"tom eFuse MAC address has been obtained (using :cpp:func:`esp_efuse_mac_get_custom` or :cpp:func:`esp_read_mac`), you need to set it as the base MAC address. There are two ways to do it:


.. _local-mac-addresses:

Local Versus Universal MAC Addresses


{IDF_TARGET_NAME} comes pre-programmed with enough valid Espressif universally administered MAC addresses for all internal interfaces. The table above shows how to calculate and derive the MAC address for a specific interface according to the bas"
"e MAC address.

When using a custom MAC address scheme, it is possible that not all interfaces can be assigned with a universally administered MAC address. In these cases, a locally administered MAC address is assigned. Note that these addresses are intended for use on a single local network only.

See `this article `_ for the definition of locally and universally administered MAC addresses.

Function :cpp:func:`esp_derive_local_mac` is called internally to derive a local MAC address from a univ"
"ersal MAC address. The process is as follows:

Chip Version


:cpp:func:`esp_chip_info` function fills :cpp:class:`esp_chip_info_t` structure with information about the chip. This includes the chip revision, number of CPU cores, and a bit mask of features enabled in the chip.

.. _idf-version-h:

SDK Version


:cpp:func:`esp_get_idf_version` returns a string describing the ESP-IDF version which is used to compile the application. This is the same value as the one available through ``IDF_VER`` va"
"riable of the build system. The version string generally has the format of ``git describe`` output.

To get the version at build time, additional version macros are provided. They can be used to enable or disable parts of the program depending on the ESP-IDF version.

  .. code-block:: c

      #include ""esp_idf_version.h""

      #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
          // enable functionality present in ESP-IDF v4.0
      #endif


.. _app-version:

App Version


The applica"
"tion version is stored in :cpp:class:`esp_app_desc_t` structure. It is located in DROM sector and has a fixed offset from the beginning of the binary file. The structure is located after :cpp:class:`esp_image_header_t` and :cpp:class:`esp_image_segment_header_t` structures. The type of the field version is string and it has a maximum length of 32 chars.

To set the version in your project manually, you need to set the ``PROJECT_VER`` variable in the ``CMakeLists.txt`` of your project. In applica"
"tion ``CMakeLists.txt``, put ``set(PROJECT_VER ""0.1.0.1"")`` before including ``project.cmake``.

If the :ref:`CONFIG_APP_PROJECT_VER_FROM_CONFIG` option is set, the value of :ref:`CONFIG_APP_PROJECT_VER` will be used. Otherwise, if the ``PROJECT_VER`` variable is not set in the project, it will be retrieved either from the ``$(PROJECT_PATH)/version.txt`` file (if present) or using git command ``git describe``. If neither is available, ``PROJECT_VER`` will be set to ""1"". Application can make use "
"of this by calling :cpp:func:`esp_app_get_description` or :cpp:func:`esp_ota_get_partition_description` functions.

API Reference


.. include-build-file:: inc/esp_system.inc
.. include-build-file:: inc/esp_idf_version.inc
.. include-build-file:: inc/esp_mac.inc
.. include-build-file:: inc/esp_chip_info.inc
.. include-build-file:: inc/esp_cpu.inc
.. include-build-file:: inc/esp_app_desc.inc
"
"ULP Coprocessor Programming




The Ultra Low Power (ULP) coprocessor is a simple finite state machine (FSM) which is designed to perform measurements using the ADC, temperature sensor, and external I2C sensors, while the main processors are in Deep-sleep mode. The ULP coprocessor can access the ``RTC_SLOW_MEM`` memory region, and registers in the ``RTC_CNTL``, ``RTC_IO``, and ``SARADC`` peripherals. The ULP coprocessor uses fixed-width 32-bit instructions, 32-bit memory addressing, and has 4 ge"
"neral-purpose 16-bit registers. This coprocessor is referred to as ``ULP FSM`` in ESP-IDF.

.. only:: esp32s2 or esp32s3

    {IDF_TARGET_NAME} provides a second type of ULP coprocessor which is based on a RISC-V instruction set architecture. For details regarding `ULP RISC-V` refer :doc:`ULP-RISC-V Coprocessor `.

Installing the Toolchain


The ULP FSM coprocessor code is written in assembly and compiled using the `binutils-esp32ulp toolchain`_.

If you have already set up ESP-IDF with CMake bu"
"ild system according to the :doc:`Getting Started Guide `, then the ULP FSM toolchain will already be installed.

Programming ULP FSM


The ULP FSM can be programmed using the supported instruction set. Alternatively, the ULP FSM coprocessor can also be programmed using C Macros on the main CPU. Theses two methods are described in the following section:

.. toctree::
   :maxdepth: 1

   Instruction set reference for {IDF_TARGET_NAME} ULP 
   Programming using macros (legacy) 

Compiling the ULP "
"Code


To compile the ULP FSM code as part of the component, the following steps must be taken:

.. note::

    When registering the component (via ``idf_component_register``), this directory should not be added to the ``SRC_DIRS`` argument. The logic behind this is that the ESP-IDF build system will compile files found in ``SRC_DIRS`` based on their extensions. For ``.S`` files, ``{IDF_TARGET_TOOLCHAIN_PREFIX}-as`` assembler is used. This is not desirable for ULP FSM assembly files, so the easi"
"est way to achieve the distinction is by placing ULP FSM assembly files into a separate directory. The ULP FSM assembly source files should also **not** be added to ``SRCS`` for the same reason. See the steps below for how to properly add ULP FSM assembly source files.

    ...
    idf_component_register()

    set(ulp_app_name ulp_${COMPONENT_NAME})
    set(ulp_s_sources ulp/ulp_assembly_source_file.S)
    set(ulp_exp_dep_srcs ""ulp_c_source_file.c"")

    ulp_embed_binary(${ulp_app_name} ""${ulp_"
"s_sources}"" ""${ulp_exp_dep_srcs}"")

The first argument to ``ulp_embed_binary`` specifies the ULP FSM binary name. The name specified here will also be used by other generated artifacts such as the ELF file, map file, header file and linker export file. The second argument specifies the ULP FSM assembly source files. Finally, the third argument specifies the list of component source files which include the header file to be generated. This list is needed to build the dependencies correctly and en"
"sure that the generated header file will be created before any of these files are compiled. See the section below for the concept of generated header files for ULP applications.

   Inside, the build system will take the following steps to build ULP FSM program:

Accessing the ULP FSM Program Variables


Global symbols defined in the ULP FSM program may be used inside the main program.

For example, the ULP FSM program may define a variable ``measurement_count`` which will define the number of A"
"DC measurements the program needs to make before waking up the chip from Deep-sleep::

                            .global measurement_count
    measurement_count:      .long 0

                            // later, use measurement_count
                            move r3, measurement_count
                            ld r3, r3, 0

The main program needs to initialize this variable before the ULP program is started. The build system makes this possible by generating the ``${ULP_APP_NAME}.h`` an"
"d ``${ULP_APP_NAME}.ld`` files which define the global symbols present in the ULP program. Each global symbol defined in the ULP program is included in these files and are prefixed with ``ulp_``.

The header file contains the declaration of the symbol::

    extern uint32_t ulp_measurement_count;

Note that all symbols (variables, arrays, functions) are declared as ``uint32_t``. For functions and arrays, take the address of the symbol and cast it to the appropriate type.

The generated linker sc"
"ript file defines the locations of symbols in RTC_SLOW_MEM::

    PROVIDE ( ulp_measurement_count = 0x50000060 );

To access the ULP program variables from the main program, the generated header file should be included using an ``include`` statement. This will allow the ULP program variables to be accessed as regular variables::

    #include ""ulp_app_name.h""

    // later
    void init_ulp_vars() {
        ulp_measurement_count = 64;
    }

.. only:: esp32

    Note that the ULP FSM program can"
" only use the lower 16 bits of each 32-bit word in RTC memory, because the registers are 16-bit, and there is no instruction to load from the high part of the word. Likewise, the ULP store instruction writes register values into the lower 16 bits of the 32-bit word in RTC memory. The upper 16 bits are written with a value which depends on the address of the store instruction, thus when reading variables written by the ULP coprocessor, the main application needs to mask the upper 16 bits, e.g.,::"
"

        printf(""Last measurement value: %d\n"", ulp_last_measurement & UINT16_MAX);

Starting the ULP FSM Program


To run a ULP FSM program, the main application needs to load the ULP program into RTC memory using the :cpp:func:`ulp_load_binary` function, and then start it using the :cpp:func:`ulp_run` function.

Note that the ``Enable Ultra Low Power (ULP) Coprocessor`` option must be enabled in menuconfig to work with ULP. To select the type of ULP to be used, the ``ULP Co-processor type`` o"
"ption must be set. To reserve memory for the ULP, the ``RTC slow memory reserved for coprocessor`` option must be set to a value big enough to store ULP code and data. If the application components contain multiple ULP programs, then the size of the RTC memory must be sufficient to hold the largest one.

Each ULP program is embedded into the ESP-IDF application as a binary blob. The application can reference this blob and load it in the following way (suppose ULP_APP_NAME was defined to ``ulp_ap"
"p_name``)::

    extern const uint8_t bin_start[] asm(""_binary_ulp_app_name_bin_start"");
    extern const uint8_t bin_end[]   asm(""_binary_ulp_app_name_bin_end"");

    void start_ulp_program() {
        ESP_ERROR_CHECK( ulp_load_binary(
            0 // load address, set to 0 when using default linker scripts
            bin_start,
            (bin_end - bin_start) / sizeof(uint32_t)) );
    }

Once the program is loaded into RTC memory, the application can start it by passing the address of the"
" entry point to the ``ulp_run`` function::

    ESP_ERROR_CHECK( ulp_run(&ulp_entry - RTC_SLOW_MEM) );

Declaration of the entry point symbol comes from the generated header file mentioned above, ``${ULP_APP_NAME}.h``. In the assembly source of the ULP FSM application, this symbol must be marked as ``.global``::


            .global entry
    entry:
            // code starts here

.. only:: esp32

    ESP32 ULP Program Flow
    

    ESP32 ULP coprocessor is started by a timer. The timer is st"
"arted once :cpp:func:`ulp_run` is called. The timer counts a number of RTC_SLOW_CLK ticks (by default, produced by an internal 150 kHz RC oscillator). The number of ticks is set using ``SENS_ULP_CP_SLEEP_CYCx_REG`` registers (x = 0..4). When starting the ULP for the first time, ``SENS_ULP_CP_SLEEP_CYC0_REG`` will be used to set the number of timer ticks. Later the ULP program can select another ``SENS_ULP_CP_SLEEP_CYCx_REG`` register using ``sleep`` instruction.

    The application can set ULP "
"timer period values (SENS_ULP_CP_SLEEP_CYCx_REG, x = 0..4) using ``ulp_set_wakeup_period`` function.

    Once the timer counts the number of ticks set in the selected ``SENS_ULP_CP_SLEEP_CYCx_REG`` register, ULP coprocessor powers up and starts running the program from the entry point set in the call to :cpp:func:`ulp_run`.

    The program runs until it encounters a ``halt`` instruction or an illegal instruction. Once the program halts the ULP coprocessor powers down and the timer is started a"
"gain.

    To disable the timer (effectively preventing the ULP program from running again), clear the ``RTC_CNTL_ULP_CP_SLP_TIMER_EN`` bit in the ``RTC_CNTL_STATE0_REG`` register. This can be done both from ULP code and from the main program.


.. only:: esp32s2 or esp32s3

    {IDF_TARGET_NAME} ULP Program Flow
    

    {IDF_TARGET_NAME} ULP coprocessor is started by a timer. The timer is started once :cpp:func:`ulp_run` is called. The timer counts a number of RTC_SLOW_CLK ticks (by default, "
"produced by an internal 90 kHz RC oscillator). The number of ticks is set using ``RTC_CNTL_ULP_CP_TIMER_1_REG`` register.

    The application can set ULP timer period values by :cpp:func:`ulp_set_wakeup_period` function.

    Once the timer counts the number of ticks set in the selected ``RTC_CNTL_ULP_CP_TIMER_1_REG`` register, ULP coprocessor powers up and starts running the program from the entry point set in the call to :cpp:func:`ulp_run`.

    The program runs until it encounters a ``halt`"
"` instruction or an illegal instruction. Once the program halts, ULP coprocessor powers down, and the timer is started again.

    To disable the timer (effectively preventing the ULP program from running again), clear the ``RTC_CNTL_ULP_CP_SLP_TIMER_EN`` bit in the ``RTC_CNTL_ULP_CP_TIMER_REG`` register. This can be done both from ULP code and from the main program.

Application Examples


API Reference


.. include-build-file:: inc/ulp_fsm_common.inc
.. include-build-file:: inc/ulp_common.inc
"
".. include-build-file:: inc/ulp_common_defs.inc

.. _binutils-esp32ulp toolchain: https://github.com/espressif/binutils-gdb
"
"System API




.. toctree::
    :maxdepth: 1

    app_image_format
    bootloader_image_format
    app_trace
    esp_function_with_shared_stack
    chip_revision
    console
    efuse
    esp_err
    esp_https_ota
    esp_event
    freertos
    freertos_idf
    freertos_additions
    mem_alloc
    mm
    :SOC_PSRAM_DMA_CAPABLE or SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE: mm_sync
    heap_debug
    esp_timer
    internal-unstable
    :SOC_HP_CPU_HAS_MULTIPLE_CORES: ipc
    intr_alloc
    log
    misc_s"
"ystem_api
    ota
    :CONFIG_IDF_TARGET_ARCH_XTENSA: perfmon
    power_management
    pthread
    random
    sleep_modes
    soc_caps
    system_time
    :SOC_ASYNC_MEMCPY_SUPPORTED: async_memcpy
    :esp32: himem
    :SOC_ULP_FSM_SUPPORTED: ulp
    :SOC_RISCV_COPROC_SUPPORTED: ulp-risc-v
    :SOC_LP_CORE_SUPPORTED: ulp-lp-core
    wdts


Code examples for this API section are provided in the :example:`system` directory of ESP-IDF examples.
"
"Heap Memory Debugging




Overview


ESP-IDF integrates tools for requesting :ref:`heap information `, :ref:`heap corruption detection `, and :ref:`heap tracing `. These can help track down memory-related bugs.

For general information about the heap memory allocator, see :doc:`Heap Memory Allocation `.

.. _heap-information:

Heap Information


To obtain information about the state of the heap, call the following functions:

- :cpp:func:`heap_caps_get_free_size` can be used to return the curren"
"t free memory for different memory capabilities.
- :cpp:func:`heap_caps_get_largest_free_block` can be used to return the largest free block in the heap, which is also the largest single allocation currently possible. Tracking this value and comparing it to the total free heap allows you to detect heap fragmentation.
- :cpp:func:`heap_caps_get_minimum_free_size` can be used to track the heap ""low watermark"" since boot.
- :cpp:func:`heap_caps_get_info` returns a :cpp:class:`multi_heap_info_t` str"
"ucture, which contains the information from the above functions, plus some additional heap-specific data (number of allocations, etc.).
- :cpp:func:`heap_caps_print_heap_info` prints a summary of the information returned by :cpp:func:`heap_caps_get_info` to stdout.
- :cpp:func:`heap_caps_dump` and :cpp:func:`heap_caps_dump_all` output detailed information about the structure of each block in the heap. Note that this can be a large amount of output.


.. _heap-allocation-free:

Heap Allocation an"
"d Free Function Hooks


Heap allocation and free detection hooks allow you to be notified of every successful allocation and free operation:

- Providing a definition of :cpp:func:`esp_heap_trace_alloc_hook` allows you to be notified of every successful memory allocation operation
- Providing a definition of :cpp:func:`esp_heap_trace_free_hook` allows you to be notified of every successful memory-free operations

This feature can be enabled by setting the :ref:`CONFIG_HEAP_USE_HOOKS` option. :cp"
"p:func:`esp_heap_trace_alloc_hook` and :cpp:func:`esp_heap_trace_free_hook` have weak declarations (e.g., ``__attribute__((weak))``), thus it is not necessary to provide declarations for both hooks. Given that it is technically possible to allocate and free memory from an ISR (**though strongly discouraged from doing so**), the :cpp:func:`esp_heap_trace_alloc_hook` and :cpp:func:`esp_heap_trace_free_hook` can potentially be called from an ISR.

It is not recommended to perform (or call API funct"
"ions to perform) blocking operations or memory allocation/free operations in the hook functions. In general, the best practice is to keep the implementation concise and leave the heavy computation outside of the hook functions.

The example below shows how to define the allocation and free function hooks:

.. code-block:: c

  #include ""esp_heap_caps.h""

  void esp_heap_trace_alloc_hook(void* ptr, size_t size, uint32_t caps)
  {
    ...
  }
  void esp_heap_trace_free_hook(void* ptr)
  {
    ...
"
"  }

  void app_main()
  {
      ...
  }

.. _heap-corruption:

Heap Corruption Detection


Heap corruption detection allows you to detect various types of heap memory errors:

- Out-of-bound writes & buffer overflows
- Writes to freed memory
- Reads from freed or uninitialized memory

Assertions


The heap implementation (:component_file:`heap/multi_heap.c`, etc.) includes numerous assertions that will fail if the heap memory is corrupted. To detect heap corruption most effectively, ensure that"
" assertions are enabled in the project configuration via the :ref:`CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL` option.

If a heap integrity assertion fails, a line will be printed like ``CORRUPT HEAP: multi_heap.c:225 detected at 0x3ffbb71c``. The memory address printed is the address of the heap structure that has corrupt content.

It is also possible to manually check heap integrity by calling :cpp:func:`heap_caps_check_integrity_all` or related functions. This function checks all of the req"
"uested heap memory for integrity and can be used even if assertions are disabled. If the integrity checks detects an error, it will print the error along with the address(es) of corrupt heap structures.

Memory Allocation Failed Hook


Users can use :cpp:func:`heap_caps_register_failed_alloc_callback` to register a callback that is invoked every time an allocation operation fails.

Additionally, users can enable the :ref:`CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS`, which will automatically trigger"
" a system abort if any allocation operation fails.

The example below shows how to register an allocation failure callback:

.. code-block:: c

  #include ""esp_heap_caps.h""

  void heap_caps_alloc_failed_hook(size_t requested_size, uint32_t caps, const char *function_name)
  {
    printf(""%s was called but failed to allocate %d bytes with 0x%X capabilities. \n"",function_name, requested_size, caps);
  }

  void app_main()
  {
      ...
      esp_err_t error = heap_caps_register_failed_alloc_callb"
"ack(heap_caps_alloc_failed_hook);
      ...
      void *ptr = heap_caps_malloc(allocation_size, MALLOC_CAP_DEFAULT);
      ...
  }

Finding Heap Corruption


Memory corruption can be one of the hardest classes of bugs to find and fix, as the source of the corruption could be completely unrelated to the symptoms of the corruption. Here are some tips:

- A crash with a ``CORRUPT HEAP:`` message usually includes a stack trace, but this stack trace is rarely useful. The crash is the symptom of memor"
"y corruption when the system realizes the heap is corrupt. But usually, the corruption happens elsewhere and earlier in time.
- Increasing the heap memory debugging `Configuration`_ level to ""Light impact"" or ""Comprehensive"" gives you a more accurate message with the first corrupt memory address.
- Adding regular calls to :cpp:func:`heap_caps_check_integrity_all` or :cpp:func:`heap_caps_check_integrity_addr` in your code helps you pin down the exact time that the corruption happened. You can mov"
"e these checks around to ""close in on"" the section of code that corrupted the heap.
- Based on the memory address that has been corrupted, you can use :ref:`JTAG debugging ` to set a watchpoint on this address and have the CPU halt when it is written to.
- If you do not have JTAG, but you do know roughly when the corruption happens, set a watchpoint in software just beforehand via :cpp:func:`esp_cpu_set_watchpoint`. A fatal exception will occur when the watchpoint triggers. The following is an e"
"xample of how to use the function - ``esp_cpu_set_watchpoint(0, (void *)addr, 4, ESP_WATCHPOINT_STORE)``. Note that watchpoints are per-CPU and are set on the current running CPU only. So if you do not know which CPU is corrupting memory, call this function on both CPUs.
- For buffer overflows, `heap tracing`_ in ``HEAP_TRACE_ALL`` mode tells which callers are allocating which addresses from the heap. See `Heap Tracing To Find Heap Corruption`_ for more details. You can try to find the function "
"that allocates memory with an address immediately before the corrupted address, since it is probably the function that overflows the buffer.
- Calling :cpp:func:`heap_caps_dump` or :cpp:func:`heap_caps_dump_all` can give an indication of what heap blocks are surrounding the corrupted region and may have overflowed or underflowed, etc.

Configuration


Temporarily increasing the heap corruption detection level can give more detailed information about heap corruption errors.

In the project config"
"uration menu, under ``Component config``, there is a menu ``Heap memory debugging``. The option :ref:`CONFIG_HEAP_CORRUPTION_DETECTION` can be set to one of the following three levels:

Basic (No Poisoning)
++++++++++++++++++++

This is the default level. By default, no special heap corruption features are enabled, but the provided assertions are enabled. A heap corruption error will be printed if any of the heap's internal data structures appear overwritten or corrupted. This usually indicates "
"a buffer overrun or out-of-bounds write.

If assertions are enabled, an assertion will also trigger if a double-free occurs (the same memory is freed twice).

Calling :cpp:func:`heap_caps_check_integrity` in Basic mode checks the integrity of all heap structures, and print errors if any appear to be corrupted.

Light Impact
++++++++++++

At this level, heap memory is additionally ""poisoned"" with head and tail ""canary bytes"" before and after each block that is allocated. If an application writes "
"outside the bounds of allocated buffers, the canary bytes will be corrupted, and the integrity check will fail.

The head canary word is ``0xABBA1234`` (``3412BAAB`` in byte order), and the tail canary word is ``0xBAAD5678`` (``7856ADBA`` in byte order).

With basic heap corruption checks, most out-of-bound writes can be detected and the number of overrun bytes before a failure is detected depends on the properties of the heap. However, the Light Impact mode is more precise as even a single-byte"
" overrun can be detected.

Enabling light-impact checking increases the memory usage. Each individual allocation uses 9 to 12 additional bytes of memory depending on alignment.

Each time :cpp:func:`heap_caps_free` is called in Light Impact mode, the head and tail canary bytes of the buffer being freed are checked against the expected values.

When :cpp:func:`heap_caps_check_integrity` is called, all allocated blocks of heap memory have their canary bytes checked against the expected values.

In"
" both cases, the functions involve checking that the first 4 bytes of an allocated block (before the buffer is returned to the user) should be the word ``0xABBA1234``, and the last 4 bytes of the allocated block (after the buffer is returned to the user) should be the word ``0xBAAD5678``.

Different values usually indicate buffer underrun or overrun. Overrun indicates that when writing to memory, the data written exceeds the size of the allocated memory, resulting in writing to an unallocated me"
"mory area; underrun indicates that when reading memory, the data read exceeds the allocated memory and reads data from an unallocated memory area.

Comprehensive
+++++++++++++

This level incorporates the ""light impact"" detection features plus additional checks for uninitialized-access and use-after-free bugs. In this mode, all freshly allocated memory is filled with the pattern ``0xCE``, and all freed memory is filled with the pattern ``0xFE``.

Enabling Comprehensive mode has a substantial imp"
"act on runtime performance, as all memory needs to be set to the allocation patterns each time a :cpp:func:`heap_caps_malloc` or :cpp:func:`heap_caps_free` completes, and the memory also needs to be checked each time. However, this mode allows easier detection of memory corruption bugs which are much more subtle to find otherwise. It is recommended to only enable this mode when debugging, not in production.

Crashes in Comprehensive Mode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If an application crashes w"
"hen reading or writing an address related to ``0xCECECECE`` in Comprehensive mode, it indicates that it has read uninitialized memory. The application should be changed to either use :cpp:func:`heap_caps_calloc` (which zeroes memory), or initialize the memory before using it. The value ``0xCECECECE`` may also be seen in stack-allocated automatic variables, because, in ESP-IDF, most task stacks are originally allocated from the heap, and in C, stack memory is uninitialized by default.

If an appl"
"ication crashes, and the exception register dump indicates that some addresses or values were ``0xFEFEFEFE``, this indicates that it is reading heap memory after it has been freed, i.e., a ""use-after-free bug"". The application should be changed to not access heap memory after it has been freed.

If a call to :cpp:func:`heap_caps_malloc` or :cpp:func:`heap_caps_realloc` causes a crash because it was expected to find the pattern ``0xFEFEFEFE`` in free memory and a different pattern was found, it i"
"ndicates that the app has a use-after-free bug where it is writing to memory that has already been freed.

Manual Heap Checks in Comprehensive Mode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Calls to :cpp:func:`heap_caps_check_integrity` may print errors relating to ``0xFEFEFEFE``, ``0xABBA1234``, or ``0xBAAD5678``. In each case the checker is expected to find a given pattern, and will error out if not found:

- For free heap blocks, the checker expects to find all bytes set to ``0xFE``. Any othe"
"r values indicate a use-after-free bug where free memory has been incorrectly overwritten.
- For allocated heap blocks, the behavior is the same as for the Light Impact mode. The canary bytes ``0xABBA1234`` and ``0xBAAD5678`` are checked at the head and tail of each allocated buffer, and any variation indicates a buffer overrun or underrun.

.. _heap-task-tracking:

Heap Task Tracking


Heap Task Tracking can be used to get per-task info for heap memory allocation. The application has to specify"
" the heap capabilities for which the heap allocation is to be tracked.

Example code is provided in :example:`system/heap_task_tracking`.

.. _heap-tracing:

Heap Tracing


Heap Tracing allows the tracing of code which allocates or frees memory. Two tracing modes are supported:

- Standalone. In this mode, traced data are kept on-board, so the size of the gathered information is limited by the buffer assigned for that purpose, and the analysis is done by the on-board code. There are a couple of "
"APIs available for accessing and dumping collected info.
- Host-based. This mode does not have the limitation of the standalone mode, because traced data are sent to the host over JTAG connection using app_trace library. Later on, they can be analyzed using special tools.

Heap tracing can perform two functions:

- Leak checking: find memory that is allocated and never freed.
- Heap use analysis: show all functions that are allocating or freeing memory while the trace is running.

How to Diagnos"
"e Memory Leaks


If you suspect a memory leak, the first step is to figure out which part of the program is leaking memory. Use the :cpp:func:`heap_caps_get_free_size` or related functions in :ref:`heap information ` to track memory use over the life of the application. Try to narrow the leak down to a single function or sequence of functions where free memory always decreases and never recovers.


Standalone Mode
+++++++++++++++

Once you have identified the code which you think is leaking:

- "
"Enable the :ref:`CONFIG_HEAP_TRACING_DEST` option.
- Call the function :cpp:func:`heap_trace_init_standalone` early in the program, to register a buffer that can be used to record the memory trace.
- Call the function :cpp:func:`heap_trace_start` to begin recording all mallocs or frees in the system. Call this immediately before the piece of code which you suspect is leaking memory.
- Call the function :cpp:func:`heap_trace_stop` to stop the trace once the suspect piece of code has finished exec"
"uting.
- Call the function :cpp:func:`heap_trace_dump` to dump the results of the heap trace.

The following code snippet demonstrates how application code would typically initialize, start, and stop heap tracing:

.. code-block:: c

  #include ""esp_heap_trace.h""

  #define NUM_RECORDS 100
  static heap_trace_record_t trace_record[NUM_RECORDS]; // This buffer must be in internal RAM

  ...

  void app_main()
  {
      ...
      ESP_ERROR_CHECK( heap_trace_init_standalone(trace_record, NUM_RECORD"
"S) );
      ...
  }

  void some_function()
  {
      ESP_ERROR_CHECK( heap_trace_start(HEAP_TRACE_LEAKS) );

      do_something_you_suspect_is_leaking();

      ESP_ERROR_CHECK( heap_trace_stop() );
      heap_trace_dump();
      ...
  }

The output from the heap trace has a similar format to the following example:

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    .. code-block:: none

        2 allocations trace (100 entry buffer)
        32 bytes (@ 0x3ffaf214) allocated CPU 0 ccount 0x2e9b7384 c"
"aller 0x400d276d:0x400d27c1
        0x400d276d: leak_some_memory at /path/to/idf/examples/get-started/blink/main/./blink.c:27

        0x400d27c1: blink_task at /path/to/idf/examples/get-started/blink/main/./blink.c:52

        8 bytes (@ 0x3ffaf804) allocated CPU 0 ccount 0x2e9b79c0 caller 0x400d2776:0x400d27c1
        0x400d2776: leak_some_memory at /path/to/idf/examples/get-started/blink/main/./blink.c:29

        0x400d27c1: blink_task at /path/to/idf/examples/get-started/blink/main/./blink."
"c:52

        40 bytes 'leaked' in trace (2 allocations)
        total allocations 2 total frees 0

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

    .. code-block:: none

        2 allocations trace (100 entry buffer)
        32 bytes (@ 0x3ffaf214) allocated CPU 0 ccount 0x2e9b7384 caller
        8 bytes (@ 0x3ffaf804) allocated CPU 0 ccount 0x2e9b79c0 caller
        40 bytes 'leaked' in trace (2 allocations)
        total allocations 2 total frees 0

.. note::

    The above example output uses :do"
"c:`IDF Monitor ` to automatically decode PC addresses to their source files and line numbers.

The first line indicates how many allocation entries are in the buffer, compared to its total size.

In ``HEAP_TRACE_LEAKS`` mode, for each traced memory allocation that has not already been freed, a line is printed with:

.. list::

    - ``XX bytes`` is the number of bytes allocated.
    - ``@ 0x...`` is the heap address returned from :cpp:func:`heap_caps_malloc` or :cpp:func:`heap_caps_calloc` .
   "
" - ``Internal`` or ``PSRAM`` is the general location of the allocated memory.
    - ``CPU x`` is the CPU (0 or 1) running when the allocation was made.
    - ``ccount 0x...`` is the CCOUNT (CPU cycle count) register value the allocation was made. The value is different for CPU 0 vs CPU 1.
    :CONFIG_IDF_TARGET_ARCH_XTENSA: - ``caller 0x...`` gives the call stack of the call to :cpp:func:`heap_caps_malloc` or :cpp:func:`heap_caps_free` , as a list of PC addresses. These can be decoded to source "
"files and line numbers, as shown above.

.. only:: not CONFIG_IDF_TARGET_ARCH_RISCV

    The depth of the call stack recorded for each trace entry can be configured in the project configuration menu, under ``Heap Memory Debugging`` > ``Enable heap tracing`` > :ref:`CONFIG_HEAP_TRACING_STACK_DEPTH`. Up to 32 stack frames can be recorded for each allocation (the default is 2). Each additional stack frame increases the memory usage of each ``heap_trace_record_t`` record by eight bytes.

Finally, th"
"e total number of the 'leaked' bytes (bytes allocated but not freed while the trace is running) is printed together with the total number of allocations it represents.

A warning will be printed if the trace buffer was not large enough to hold all the allocations happened. If you see this warning, consider either shortening the tracing period or increasing the number of records in the trace buffer.


Host-Based Mode
+++++++++++++++

Once you have identified the code which you think is leaking:

"
"- In the project configuration menu, navigate to ``Component settings`` > ``Heap Memory Debugging`` > :ref:`CONFIG_HEAP_TRACING_DEST` and select ``Host-Based``.
- In the project configuration menu, navigate to ``Component settings`` > ``Application Level Tracing`` > :ref:`CONFIG_APPTRACE_DESTINATION1` and select ``Trace memory``.
- In the project configuration menu, navigate to ``Component settings`` > ``Application Level Tracing`` > ``FreeRTOS SystemView Tracing`` and enable :ref:`CONFIG_APPTRA"
"CE_SV_ENABLE`.
- Call the function :cpp:func:`heap_trace_init_tohost` early in the program, to initialize the JTAG heap tracing module.
- Call the function :cpp:func:`heap_trace_start` to begin recording all memory allocation and free calls in the system. Call this immediately before the piece of code which you suspect is leaking memory.

  In host-based mode, the argument to this function is ignored, and the heap tracing module behaves like ``HEAP_TRACE_ALL`` is passed, i.e., all allocations an"
"d deallocations are sent to the host.

- Call the function :cpp:func:`heap_trace_stop` to stop the trace once the suspect piece of code has finished executing.

The following code snippet demonstrates how application code would typically initialize, start, and stop host-based mode heap tracing:

.. code-block:: c

  #include ""esp_heap_trace.h""

  ...

  void app_main()
  {
      ...
      ESP_ERROR_CHECK( heap_trace_init_tohost() );
      ...
  }

  void some_function()
  {
      ESP_ERROR_CHECK"
"( heap_trace_start(HEAP_TRACE_LEAKS) );

      do_something_you_suspect_is_leaking();

      ESP_ERROR_CHECK( heap_trace_stop() );
      ...
  }

To gather and analyze heap trace, do the following on the host:

.. note::

    In order to use this feature, you need OpenOCD version ``v0.10.0-esp32-20181105`` or later.

.. code-block:: c

    target remote :3333

    mon reset halt
    maintenance flush register-cache

    tb heap_trace_start
    commands
    mon esp sysview start file:///tmp/heap."
"svdat
    c
    end

    tb heap_trace_stop
    commands
    mon esp sysview stop
    end

    c

Using this file GDB can connect to the target, reset it, and start tracing when the program hits breakpoint at :cpp:func:`heap_trace_start`. Tracing will be stopped when the program hits breakpoint at :cpp:func:`heap_trace_stop`. Traced data will be saved to ``/tmp/heap_log.svdat``.

The output from the heap trace has a similar format to the following example:

.. code-block::

  Parse trace from '/"
"tmp/heap.svdat'...
  Stop parsing trace. (Timeout 0.000000 sec while reading 1 bytes!)
  Process events from '['/tmp/heap.svdat']'...
  [0.002244575] HEAP: Allocated 1 bytes @ 0x3ffaffd8 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.002258425] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task ""alloc"" on core 0 by:
  /home/us"
"er/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.002563725] HEAP: Freed bytes @ 0x3ffaffe0 from task ""free"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.002782950] HEAP: Freed bytes @ 0x3ffb"
"40b8 from task ""main"" on core 0 by:
  /home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590
  /home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590

  [0.002798700] HEAP: Freed bytes @ 0x3ffb50bc from task ""main"" on core 0 by:
  /home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590
  /home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590

  [0.102436025] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-i"
"df/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.102449800] HEAP: Allocated 4 bytes @ 0x3ffaffe8 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.102666150] HEAP: Freed bytes @ 0x3ffaffe8 from task ""free"" on core 0 "
"by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.202436200] HEAP: Allocated 3 bytes @ 0x3ffaffe8 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.202451725] HEAP:"
" Allocated 6 bytes @ 0x3ffafff0 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.202667075] HEAP: Freed bytes @ 0x3ffafff0 from task ""free"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
  /home/user/projects/esp/esp-idf/components/freerto"
"s/port.c:355 (discriminator 1)

  [0.302436000] HEAP: Allocated 4 bytes @ 0x3ffafff0 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.302451475] HEAP: Allocated 8 bytes @ 0x3ffb40b8 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
  /home/us"
"er/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.302667500] HEAP: Freed bytes @ 0x3ffb40b8 from task ""free"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  Processing completed.

  Processed 1019 events

   HEAP TRACE REPORT 

  Processed 14 heap events.

  [0.002244575] HEAP: Allocated 1 bytes @ "
"0x3ffaffd8 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.102436025] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

"
"  [0.202436200] HEAP: Allocated 3 bytes @ 0x3ffaffe8 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

  [0.302436000] HEAP: Allocated 4 bytes @ 0x3ffafff0 from task ""alloc"" on core 0 by:
  /home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
  /home/user/projects/esp/esp-idf/componen"
"ts/freertos/port.c:355 (discriminator 1)

  Found 10 leaked bytes in 4 blocks.

Heap Tracing To Find Heap Corruption


Heap tracing can also be used to help track down heap corruption. When a region in the heap is corrupted, it may be from some other part of the program that allocated memory at a nearby address.

If you have an approximate idea of when the corruption occurred, enabling heap tracing in ``HEAP_TRACE_ALL`` mode allows you to record all the memory allocation functions used and the c"
"orresponding allocation addresses.

Using heap tracing in this way is very similar to memory leak detection as described above. For memories that are allocated and not freed, the output is the same. However, records will also be shown for memory that has been freed.

Performance Impact


Enabling heap tracing in menuconfig increases the code size of your program, and has a very small negative impact on the performance of heap allocation or free operations even when heap tracing is not running.

"
"When heap tracing is running, heap allocation or free operations are substantially slower than when heap tracing is stopped. Increasing the depth of stack frames recorded for each allocation (see above) also increases this performance impact.

To mitigate the performance loss when the heap tracing is enabled and active, enable :ref:`CONFIG_HEAP_TRACE_HASH_MAP`. With this configuration enabled, a hash map mechanism will be used to handle the heap trace records, thus considerably decreasing the he"
"ap allocation or free execution time. The size of the hash map can be modified by setting the value of :ref:`CONFIG_HEAP_TRACE_HASH_MAP_SIZE`.

.. only:: SOC_SPIRAM_SUPPORTED

  By default, the hash map is placed into internal RAM. It can also be placed into external RAM if :ref:`CONFIG_HEAP_TRACE_HASH_MAP_IN_EXT_RAM` is enabled. In order to enable this configuration, make sure to enable :ref:`CONFIG_SPIRAM` and :ref:`CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY`.

False-Positive Memory Leaks


N"
"ot everything printed by :cpp:func:`heap_trace_dump` is necessarily a memory leak. The following cases may also be printed:

- Any memory that is allocated after :cpp:func:`heap_trace_start` but freed after :cpp:func:`heap_trace_stop` appears in the leaked dump.
- Allocations may be made by other tasks in the system. Depending on the timing of these tasks, it is quite possible that this memory is freed after :cpp:func:`heap_trace_stop` is called.
- The first time a task uses stdio - e.g., when i"
"t calls :cpp:func:`heap_caps_printf` - a lock, i.e., RTOS mutex semaphore, is allocated by the libc. This allocation lasts until the task is deleted.
- Certain uses of :cpp:func:`heap_caps_printf`, such as printing floating point numbers and allocating some memory from the heap on demand. These allocations last until the task is deleted.
- The Bluetooth, Wi-Fi, and TCP/IP libraries allocate heap memory buffers to handle incoming or outgoing data. These memory buffers are usually short-lived, but"
" some may be shown in the heap leak trace if the data has been received or transmitted by the lower levels of the network during the heap tracing.
- TCP connections retain some memory even after they are closed due to the ``TIME_WAIT`` state. Once the ``TIME_WAIT`` period is completed, this memory will be freed.

One way to differentiate between ""real"" and ""false positive"" memory leaks is to call the suspect code multiple times while tracing is running, and look for patterns (multiple matching a"
"llocations) in the heap trace output.

API Reference - Heap Tracing


.. include-build-file:: inc/esp_heap_trace.inc
"
"Watchdogs




Overview


ESP-IDF supports multiple types of watchdogs:

.. list::

    - Hardware Watchdog Timers
    - Interrupt Watchdog Timer (IWDT)
    - Task Watchdog Timer (TWDT)
    :SOC_XT_WDT_SUPPORTED: - XTAL32K Watchdog Timer (Crystal 32K Watchdog Timer, i.e., XTWDT)

The Interrupt Watchdog is responsible for ensuring that ISRs (Interrupt Service Routines) are not blocked for a prolonged period of time. The TWDT is responsible for detecting instances of tasks running without yielding "
"for a prolonged period.

The various watchdog timers can be enabled using the :ref:`project-configuration-menu`. However, the TWDT can also be enabled during runtime.

.. _app-hardware-watchdog-timers:

Hardware Watchdog Timers


The chips have two groups of watchdog timers:

.. list::

    :not esp32c2: - Main System Watchdog Timer (MWDT_WDT) - used by Interrupt Watchdog Timer (IWDT) and Task Watchdog Timer (TWDT).
    :esp32c2: - Main System Watchdog Timer (MWDT_WDT) - used by Interrupt Watchd"
"og Timer (IWDT).
    - RTC Watchdog Timer (RTC_WDT) - used to track the boot time from power-up until the user's main function (by default RTC Watchdog is disabled immediately before the user's main function).

Refer to the :ref:`bootloader-watchdog` section to understand how watchdogs are utilized in the bootloader.

The app's behaviour can be adjusted so the RTC Watchdog remains enabled after app startup. The Watchdog would need to be explicitly reset (i.e., fed) or disabled by the app to avoi"
"d the chip reset. To do this, set the :ref:`CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE` option, modify the app as needed, and then recompile the app. In this case, the following APIs should be used:

.. list::

    - :cpp:func:`wdt_hal_disable`: see :ref:`hw-abstraction-hal-layer-disable-rtc-wdt`
    - :cpp:func:`wdt_hal_feed`: see :ref:`hw-abstraction-hal-layer-feed-rtc-wdt`
    :esp32 or esp32s2: - :cpp:func:`rtc_wdt_feed`
    :esp32 or esp32s2: - :cpp:func:`rtc_wdt_disable`

If RTC_WDT is not"
" reset/disabled in time, the chip will be automatically reset. See :ref:`RTC-Watchdog-Timeout` for more information.

Interrupt Watchdog Timer (IWDT)


{IDF_TARGET_IWDT_TIMER_GROUP:default=""Timer Group 1"", esp32c2=""Timer Group 0""}

The purpose of the IWDT is to ensure that interrupt service routines (ISRs) are not blocked from running for a prolonged period of time (i.e., the IWDT timeout period). Preventing ISRs from running in a timely manner is undesirable as it can increase ISR latency, and "
"also prevent task switching (as task switching is executed form an ISR). The things that can block ISRs from running include:

- Disabling interrupts
- Critical Sections (also disables interrupts)
- Other same/higher priority ISRs which block same/lower priority ISRs from running

The IWDT utilizes the MWDT_WDT watchdog timer in {IDF_TARGET_IWDT_TIMER_GROUP} as its underlying hardware timer and leverages the FreeRTOS tick interrupt on each CPU to feed the watchdog timer. If the tick interrupt on"
" a particular CPU is not run at within the IWDT timeout period, it is indicative that something is blocking ISRs from being run on that CPU (see the list of reasons above).

When the IWDT times out, the default action is to invoke the panic handler and display the panic reason as ``Interrupt wdt timeout on CPU0`` or ``Interrupt wdt timeout on CPU1`` (as applicable). Depending on the panic handler's configured behavior (see :ref:`CONFIG_ESP_SYSTEM_PANIC`), users can then debug the source of the I"
"WDT timeout (via the backtrace, OpenOCD, gdbstub etc) or simply reset the chip (which may be preferred in a production environment).

If for whatever reason the panic handler is unable to run after an IWDT timeout, the IWDT has a second stage timeout that will hard-reset the chip (i.e., a system reset).

Configuration


- The IWDT is enabled by default via the :ref:`CONFIG_ESP_INT_WDT` option.
- The IWDT's timeout is configured by setting the :ref:`CONFIG_ESP_INT_WDT_TIMEOUT_MS` option.

    - N"
"ote that the default timeout is higher if PSRAM support is enabled, as a critical section or interrupt routine that accesses a large amount of PSRAM takes longer to complete in some circumstances.
    - The timeout should always at least twice longer than the period between FreeRTOS ticks (see :ref:`CONFIG_FREERTOS_HZ`).

Tuning


If you find the IWDT timeout is triggered because an interrupt or critical section is running longer than the timeout period, consider rewriting the code:

- Critical "
"sections should be made as short as possible. Any non-critical code/computation should be placed outside the critical section.
- Interrupt handlers should also perform the minimum possible amount of computation. Users can consider deferring any computation to a task by having the ISR push data to a task using queues.

Neither critical sections or interrupt handlers should ever block waiting for another event to occur. If changing the code to reduce the processing time is not possible or desirabl"
"e, it is possible to increase the :ref:`CONFIG_ESP_INT_WDT_TIMEOUT_MS` setting instead.

.. _task-watchdog-timer:

Task Watchdog Timer (TWDT)


The Task Watchdog Timer (TWDT) is used to monitor particular tasks, ensuring that they are able to execute within a given timeout period. The TWDT primarily watches the Idle Tasks of each CPU, however any task can subscribe to be watched by the TWDT. By watching the Idle Tasks of each CPU, the TWDT can detect instances of tasks running for a prolonged pe"
"riod of time without yielding. This can be an indicator of poorly written code that spinloops on a peripheral, or a task that is stuck in an infinite loop.

.. only:: not esp32c2

    The TWDT is built around the MWDT_WDT watchdog timer in Timer Group 0. When a timeout occurs, an interrupt is triggered.

.. only:: esp32c2

    The {IDF_TARGET_NAME} has only a single Timer Group, used by Interrupt Watchdog (IWDT). Thus, the Task Watchdog is built around the ``esp_timer`` component in order to imp"
"lement a software timer. When a timeout occurs, an interrupt is triggered, notifying the ``esp_timer``'s main task. The latter then executes the TWDT callback previously registered.

Users can define the function ``esp_task_wdt_isr_user_handler`` in the user code, in order to receive the timeout event and extend the default behavior.


Usage


The following functions can be used to watch tasks using the TWDT:

- :cpp:func:`esp_task_wdt_init` to initialize the TWDT and subscribe the idle tasks.
-"
" :cpp:func:`esp_task_wdt_add` subscribes other tasks to the TWDT.
- Once subscribed, :cpp:func:`esp_task_wdt_reset` should be called from the task to feed the TWDT.
- :cpp:func:`esp_task_wdt_delete()` unsubscribes a previously subscribed task.
- :cpp:func:`esp_task_wdt_deinit()` unsubscribes the idle tasks and deinitializes the TWDT.


In the case where applications need to watch at a more granular level (i.e., ensure that a particular functions/stub/code-path is called), the TWDT allows subscri"
"ption of ``users``.

- :cpp:func:`esp_task_wdt_add_user` to subscribe an arbitrary user of the TWDT. This function returns a user handle to the added user.
- :cpp:func:`esp_task_wdt_reset_user` must be called using the user handle in order to prevent a TWDT timeout.
- :cpp:func:`esp_task_wdt_delete_user` unsubscribes an arbitrary user of the TWDT.

Configuration


The default timeout period for the TWDT is set using config item :ref:`CONFIG_ESP_TASK_WDT_TIMEOUT_S`. This should be set to at least"
" as long as you expect any single task needs to monopolize the CPU (for example, if you expect the app will do a long intensive calculation and should not yield to other tasks). It is also possible to change this timeout at runtime by calling :cpp:func:`esp_task_wdt_init`.

.. note::

    Erasing large flash areas can be time consuming and can cause a task to run continuously, thus triggering a TWDT timeout. The following two methods can be used to avoid this:

    - Increase :ref:`CONFIG_ESP_TA"
"SK_WDT_TIMEOUT_S` in menuconfig for a larger watchdog timeout period.
    - You can also call :cpp:func:`esp_task_wdt_init` to increase the watchdog timeout period before erasing a large flash area.

    For more information, you can refer to :doc:`../peripherals/spi_flash/index`.

The following config options control TWDT configuration. They are all enabled by default:

{IDF_TARGET_IDLE_TASK:default=""Idle task"", esp32=""CPU0 Idle task"", esp32s3=""CPU0 Idle task"", esp32p4=""CPU0 Idle task""}

.. lis"
"t::

    - :ref:`CONFIG_ESP_TASK_WDT_EN` - enables TWDT feature. If this option is disabled, TWDT cannot be used, even if initialized at runtime.
    - :ref:`CONFIG_ESP_TASK_WDT_INIT` - the TWDT is initialized automatically during startup. If this option is disabled, it is still possible to initialize the Task WDT at runtime by calling :cpp:func:`esp_task_wdt_init`.
    - :ref:`CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0` - {IDF_TARGET_IDLE_TASK} is subscribed to the TWDT during startup. If this op"
"tion is disabled, it is still possible to subscribe the idle task by calling :cpp:func:`esp_task_wdt_init` again.
    :SOC_HP_CPU_HAS_MULTIPLE_CORES: - :ref:`CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1` - CPU1 Idle task is subscribed to the TWDT during startup.


.. note::

    On a TWDT timeout the default behaviour is to simply print a warning and a backtrace before continuing running the app. If you want a timeout to cause a panic and a system reset then this can be configured through :ref:`CONF"
"IG_ESP_TASK_WDT_PANIC`.


.. only:: SOC_XT_WDT_SUPPORTED

    XTAL32K Watchdog Timer (XTWDT)
    

    One of the optional clock inputs to the {IDF_TARGET_NAME} is an external 32 kHz crystal oscillator (XTAL32K) that is used as a clock source (``XTAL32K_CLK``) to various subsystems (such as the RTC).

    The XTWDT is a dedicated watchdog timer used to ensure that the XTAL32K is functioning correctly. When ``XTAL32K_CLK`` works as the clock source of ``RTC_SLOW_CLK`` and stops oscillating, the X"
"TWDT will detect this and generate an interrupt. It also provides functionality for automatically switching over to the internal, but less accurate oscillator as the ``RTC_SLOW_CLK`` source.

    Since the switch to the backup clock is done in hardware it can also happen during Deep Sleep. This means that even if ``XTAL32K_CLK`` stops functioning while the chip is in Deep Sleep, waiting for a timer to expire, it is still able to wake-up as planned.

    If the ``XTAL32K_CLK`` starts functioning "
"normally again, you can call ``esp_xt_wdt_restore_clk`` to switch back to this clock source and re-enable the watchdog timer.

    Configuration
    """"""""""""""""""""""""""

    - When the external 32 KHz crystal or oscillator is selected (:ref:`CONFIG_RTC_CLK_SRC`) the XTWDT can be enabled via the :ref:`CONFIG_ESP_XT_WDT` configuration option.
    - The timeout is configured by setting the :ref:`CONFIG_ESP_XT_WDT_TIMEOUT` option.
    - The automatic backup clock functionality is enabled via the ref:`CONF"
"IG_ESP_XT_WDT_BACKUP_CLK_ENABLE` configuration option.


JTAG & Watchdogs


While debugging using OpenOCD, the CPUs are halted every time a breakpoint is reached. However if the watchdog timers continue to run when a breakpoint is encountered, they will eventually trigger a reset making it very difficult to debug code. Therefore OpenOCD will disable the hardware timers of both the interrupt and task watchdogs at every breakpoint. Moreover, OpenOCD will not reenable them upon leaving the breakpoi"
"nt. This means that interrupt watchdog and task watchdog functionality will essentially be disabled. No warnings or panics from either watchdogs will be generated when the {IDF_TARGET_NAME} is connected to OpenOCD via JTAG.


API Reference


Task Watchdog


A full example using the Task Watchdog is available in esp-idf: :example:`system/task_watchdog`

.. include-build-file:: inc/esp_task_wdt.inc
"
"ESP Timer (High Resolution Timer)




{IDF_TARGET_HR_TIMER:default = ""SYSTIMER"", esp32 = ""LAC timer""}

{IDF_TARGET_HR_TIMER_Resolution:default = ""Not updated"", esp32 = ""64"", esp32s2 = ""64"", esp32c3 = ""52"", esp32s3 = ""52"", esp32c2 = ""52"", esp32c6 = ""52"", esp32h2 = ""52"", esp32p4 = ""52""}

.. only:: html

    This document covers the ESP-IDF feature called ESP Timer. The contents are as follows:

    .. contents::
        :local:
        :depth: 2


Overview


The ESP Timer feature allows for creati"
"ng software timers and invoking their callback functions (dispatching callbacks) on timeout. ESP Timer is useful when user software needs to perform delayed or periodic actions, such as delayed device start/stop or periodic sampling of sensor data.

ESP Timer hides the complexity associated with managing multiple timers, dispatching callbacks, accounting for clock frequency changes (if dynamic frequency scaling is enabled), and maintaining correct time after light sleep.

For application scenari"
"os that require better real-time performance (such as generating waveforms) or configurable timer resolution, it is recommended that :doc:`GPTimer ` be used instead. Also, GPTimer has features not available in ESP Timer, such as event capture.

Finally, FreeRTOS has its own software timers. As explained in :ref:`FreeRTOS Timers`, they have much lower resolution compared to ESP Timer, but FreeRTOS timers are portable (non-dependent on ESP-IDF) which might be an advantage in some cases.


Features"
" and Concepts


The ESP Timer API provides:

- One-shot and periodic timers
- Multiple callback dispatch methods
- Handling overdue callbacks
- Bit range: {IDF_TARGET_HR_TIMER_Resolution} bits
- Time resolution: 1 microsecond


One-Shot and Periodic Timers


A one-shot timer invokes its callback function only once upon expiration and then stops operation. One-shot timers are useful for single delayed actions, such as turning off a device or reading a sensor after a specified time interval.

A pe"
"riodic timer invokes its callback function upon expiration and restarts itself automatically, resulting in the callback function being invoked at a defined interval until the periodic timer is manually stopped. Periodic timers are useful for repeated actions, such as sampling sensor data, updating display information, or generating a waveform.


.. _Callback Methods:

Callback Dispatch Methods


Timer callbacks can be dispatched using the following methods:

- Task Dispatch method (default):

  "
"  - Dispatches timer callbacks from a single high-priority ESP Timer task (esp_timer task (notified by ISR) > callback)
    - Suitable for handling timer callbacks that are not time-critical

- Interrupt Dispatch method (:cpp:enumerator:`ESP_TIMER_ISR `):

    - Dispatches timer callbacks directly from an interrupt handler (ISR > callback)
    - Suitable for simple, low-latency timer callbacks which take a few microseconds to run
    - Ensures shorter delay between the event and the callback exe"
"cution
    - Not affected by other active tasks


Task Dispatch Specifics
~~~~~~~~~~~~~~~~~~~~~~~

The execution of callbacks in the ESP Timer task is serialized. Thus, when multiple timeouts occur simultaneously, the execution time of one callback will delay the execution of subsequent callbacks. For this reason, it is recommended to keep the callbacks short. If the callback needs to perform more work, the work should be deferred to a lower-priority task using FreeRTOS primitives, such as queue"
"s and semaphores.

If other FreeRTOS tasks with higher priority are running, such as an SPI Flash operation, callback dispatching will be delayed until the ESP Timer task has a chance to run.

To maintain predictable and timely execution of tasks, callbacks should never attempt block (waiting for resources) or yield (give up control) operations, because such operations disrupt the serialized execution of callbacks.


Interrupt Dispatch Specifics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Timers using the Int"
"errupt Dispatch method have their callbacks executed from an interrupt handler. As interrupts can preempt all tasks, the Interrupt Dispatch method offers lower latency. Interrupt dispatched timer callbacks should never attempt to block and should not attempt to trigger a context switch via ``portYIELD_FROM_ISR()``. Instead, the function :cpp:func:`esp_timer_isr_dispatch_need_yield` should be used. The context switch will happen after all ISR dispatch timers are processed.

While using interrupt "
"dispatched timers, the standard logging or debugging methods, such as ``printf`` should be avoided. To debug an application or display certain information in the console, the ESP-IDF logging macros should be used, such as :c:macro:`ESP_DRAM_LOGI`, :c:macro:`ESP_EARLY_LOGI`, etc. These macros are specifically designed to work in various contexts, including interrupt service routines.


Obtaining Current Time


The time passed since the initialization of ESP Timer can be obtained using the conveni"
"ence function :cpp:func:`esp_timer_get_time`. The initialization happens shortly before the ``app_main`` function is called. This function is fast and has no locking mechanisms that could potentially introduce delays or conflicts. As a result, it can be useful for fine-grained timing, with the accuracy of 1 us, in tasks as well as in ISR routines.

Unlike the ``gettimeofday()`` function, :cpp:func:`esp_timer_get_time` has the following specifics:

- Upon wakeup from deep sleep, the initializatio"
"n timer restarts from zero
- The returned value has no timezone settings or daylight saving time adjustments


System Integration


This section mainly covers some aspects of how to optimize the operation of ESP Timer and integrate it with other ESP-IDF features.


Timeout Value Limits


As callback dispatching can never be instantaneous, the one-shot and periodic timers created with ESP Timer also have timeout value limits. These limits cannot be estimated precisely, because they depend on mult"
"iple factors.

For reference, the ESP32 running at 240 MHz and using the Task Dispatch method has the approximate minimum timeout values as follows:

The lower the CPU frequency, the higher the minimum timeout values will be. The general guideline is if the required timeout values are in the order of tens of microseconds, the user application needs to undergo thorough testing to ensure stable operation.

If the minimum timeout values slightly exceed the requirements, the Interrupt Dispatch metho"
"d might offer an improvement.

.. only:: not SOC_PARLIO_SUPPORTED and SOC_RMT_SUPPORTED

    For even smaller timeout values, for example, to generate or receive waveforms or do bit banging, the resolution of ESP Timer may be insufficient. In this case, it is recommended to use dedicated peripherals, such as :doc:`GPTimer ` or :doc:`RMT `, and their DMA features if available.

.. only:: SOC_PARLIO_SUPPORTED

    For even smaller timeout values, for example, to generate or receive waveforms or do"
" bit banging, the resolution of ESP Timer may be insufficient. In this case, it is recommended to use dedicated peripherals, such as :doc:`Parallel IO `, and their DMA features if available.


Sleep Mode Considerations


If a timer is started, and there are no other tasks being executed during the wait time, the chip can be put into sleep to optimize power consumption.

Sleep can be induced in the following ways:

For manually induced sleep, the following sleep modes exist:

  The user applicati"
"on restarts from scratch upon wakeup from deep sleep. This makes deep sleep unsuitable for continuous ESP Timer operation. However, deep sleep can be used if the running timers are not expected to persist across wakeups.

  While in light sleep, ESP Timer counter and callbacks are suspended. Timekeeping is done by the RTC timer. Once the chip is woken up, the counter of ESP Timer is automatically advanced by the amount of time spent in sleep, then timekeeping and callback execution is resumed.

"
"  At this point, ESP Timer will attempt to dispatch all unhandled callbacks if there are any. It can potentially lead to the overflow of ESP Timer callback execution queue. This behavior may be undesirable for certain applications, and the ways to avoid it are covered in :ref:`Handling Callbacks in Light Sleep`.


.. _FreeRTOS Timers:

FreeRTOS Timers


Although FreeRTOS provides `software timers `_, they have limitations:

- FreeRTOS timer resolution is bound by the `tick frequency `_, which is"
" typically in the range of 100 to 1000 Hz.
- Timer callbacks are dispatched from a low-priority timer task that can be preempted by other tasks, leading to decreased timer precision and accuracy.

However, FreeRTOS timers are portable (non-dependent on ESP-IDF) and are written to be deterministic as they do not dispatch callbacks from ISRs.


.. only:: SOC_ETM_SUPPORTED and SOC_SYSTIMER_SUPPORT_ETM

    ETM Events
    

    ESP Timer has connection to the :doc:`Event Task Matrix ` (ETM) module. "
"This module allows notifying a number of peripherals about events without involving CPU interrupts. Direct notifications reduce latency and decrease CPU workload. The function :cpp:func:`esp_timer_new_etm_alarm_event` can be called to get the corresponding ETM event handle.


Usage


While setting up your ESP-IDF project, make sure to:

- Add required component dependencies to your ``CMakeLists.txt``.
- Include required header files in your ``.c`` files.
- (Optional) Set Kconfig options. For thi"
"s, see :ref:`Kconfig Options ` > *ESP Timer (High Resolution Timer)*


.. _General Procedure:

General Procedure


The general procedure to create, start, stop, and delete a timer is as follows:

    - Define a timer handle using the type :cpp:type:`esp_timer_handle_t`
    - Set the timer configuration parameters by defining the structure :cpp:struct:`esp_timer_create_args_t` which also includes the callback function

      .. note::

          It is recommended to keep callbacks as short as pos"
"sible to avoid delaying other callbacks.

    - To create a timer, call the function :cpp:func:`esp_timer_create`

    - To start the timer in one-shot mode, call :cpp:func:`esp_timer_start_once`
    - To start the timer in periodic mode, call :cpp:func:`esp_timer_start_periodic`; the timer will continue running until you explicitly stop it using :cpp:func:`esp_timer_stop`

    .. note:: When executing a start function, ensure that the timer is not running. If a timer is running, either call :cp"
"p:func:`esp_timer_restart` or stop it first using :cpp:func:`esp_timer_stop` and then call one of the start functions.

    - To stop the running timer, call the function :cpp:func:`esp_timer_stop`

    - When the timer is no longer needed, delete it to free up memory using the function :cpp:func:`esp_timer_delete`


.. _Using ESP_TIMER_ISR Callback Method:

Using the Interrupt Dispatch Method


Out of the available :ref:`callback methods `, if you choose the Interrupt Dispatch method, follow th"
"ese steps:

    - Enable :ref:`CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD`

    - Set the timer configuration parameters by defining the structure :cpp:struct:`esp_timer_create_args_t`

      .. code-block:: c

          const esp_timer_create_args_t timer = {
            ... ,
            .dispatch_method = ESP_TIMER_ISR,
            ...
          };
    - To create a timer, call the function :cpp:func:`esp_timer_create`

For further steps, refer to :ref:`General Procedure`.


.. _Handling C"
"allbacks in Light Sleep:

Handling Callbacks in Light-sleep Mode


Light sleep allows you to save power while maintaining the ability to quickly wake up for specific actions. To use ESP Timer in conjunction with Light-sleep mode, see :doc:`Sleep Mode APIs `.

During light sleep, to keep unhandled callbacks under control and avoid potential overflow of ESP Timer callback execution queue on wakeup, do one of the following:

- Prevent the invocation of callbacks in the first place: stop the timer b"
"efore entering light sleep by using :cpp:func:`esp_timer_stop`.
- If calling the stop function is not desirable for any reason, use the option :cpp:member:`esp_timer_create_args_t::skip_unhandled_events`. In this case, if a periodic timer expires one or more times during light sleep, then only one callback is executed on wakeup.


Debugging Timers


The function :cpp:func:`esp_timer_dump` allows dumping information about either all or only running timers: the parameters for timers, the number of"
" times the timers were started, triggered, skipped, and time taken by timer callbacks to execute. This information can be helpful in debugging.

To debug timers, use the following procedure:

    - Enable :ref:`CONFIG_ESP_TIMER_PROFILING`

    Note that enabling this option increases code size and heap memory usage.


Troubleshooting


Unstable Callback Dispatch Time


While dispatching the same callback function repeatedly, if the response time varies considerably, try to stabilize it by doing "
"the following:

.. list::

    - Use the :ref:`ESP_TIMER_ISR callback method `
    :SOC_HP_CPU_HAS_MULTIPLE_CORES: - Use the Kconfig option :ref:`CONFIG_ESP_TIMER_TASK_AFFINITY` to run the ESP Timer task on both cores


Significant Delays Dispatching Callbacks


If dispatching a callback function takes a considerable amount of time, the problem can lie in the callback function itself. More precisely, as all callback functions are processed one by one in a single esp_timer task, the delays might "
"be caused by other callback functions earlier in the queue.

For this reason, make sure that all callback functions in your application can execute on their own quickly and without any blocking operations.


Repeated Callback Dispatches After Sleep


If the callback functions are executed repeatedly upon wakeup from sleep, see :ref:`Handling Callbacks in Light Sleep`.


Stack Overflow While Dispatching Callbacks


If you see a stack overflow error when executing a callback function, consider red"
"ucing the stack usage within your callback function. Alternatively, try increasing the size of the ESP Timer task stack by adjusting :ref:`CONFIG_ESP_TIMER_TASK_STACK_SIZE`.


Application Examples



API Reference


.. include-build-file:: inc/esp_timer.inc
"
"System Time




{IDF_TARGET_RTC_CLK_FRE:default=""Not updated"", esp32=""150 kHz"", esp32s2=""90 kHz"", esp32s3=""136 kHz"", esp32c3=""136 kHz"", esp32c2=""136 kHz"", esp32c6=""150 kHz"", esp32h2=""150 kHz"", esp32p4=""150 kHz""}
{IDF_TARGET_INT_OSC_FRE:default=""Not updated"", esp32=""8.5 MHz"", esp32s2=""8.5 MHz"", esp32s3=""17.5 MHz"", esp32c3=""17.5 MHz"", esp32c2=""17.5 MHz""}
{IDF_TARGET_INT_OSC_FRE_DIVIDED:default=""Not updated"", esp32=""about 33 kHz"", esp32s2=""about 33 kHz"", esp32s3=""about 68 kHz"", esp32c3=""about 68 kH"
"z"", esp32c2=""about 68 kHz""}
{IDF_TARGET_EXT_CRYSTAL_PIN:default=""Not updated"", esp32=""32K_XP and 32K_XN"", esp32s2=""XTAL_32K_P and XTAL_32K_N"", esp32s3=""XTAL_32K_P and XTAL_32K_N"", esp32c3=""XTAL_32K_P and XTAL_32K_N"", esp32c6=""XTAL_32K_P and XTAL_32K_N"", esp32h2=""XTAL_32K_P and XTAL_32K_N"", esp32p4=""XTAL_32K_P and XTAL_32K_N""}
{IDF_TARGET_EXT_OSC_PIN:default=""Not updated"", esp32=""32K_XN"", esp32s2=""XTAL_32K_P"", esp32s3=""XTAL_32K_P"", esp32c3=""XTAL_32K_P"", esp32c2=""GPIO0"", esp32c6=""XTAL_32K_P"", esp3"
"2h2=""XTAL_32K_P"", esp32p4=""XTAL_32K_P""}
{IDF_TARGET_HARDWARE_DESIGN_URL:default=""Not updated"",esp32=""`ESP32 Hardware Design Guidelines `_"", esp32s2=""`ESP32-S2 Hardware Design Guidelines `_"", esp32s3=""`ESP32-S3 Hardware Design Guidelines `_"", esp32c3=""`ESP32-C3 Hardware Design Guidelines `_"", esp32c6=""`ESP32-C6 Hardware Design Guidelines `_"", esp32c2=""`ESP8684 Hardware Design Guidelines `_"", esp32h2=""`ESP32-H2 Hardware Design Guidelines `_"", esp32p4=""`ESP32-P4 Hardware Design Guidelines `_""}


Ov"
"erview


{IDF_TARGET_NAME} uses two hardware timers for the purpose of keeping system time. System time can be kept by using either one or both of the hardware timers depending on the application's purpose and accuracy requirements for system time. The two hardware timers are:

- **RTC timer**: This timer allows time keeping in various sleep modes, and can also persist time keeping across any resets (with the exception of power-on resets which reset the RTC timer). The frequency deviation depend"
"s on the `RTC Timer Clock Sources`_ and affects the accuracy only in sleep modes, in which case the time will be measured at 6.6667 μs resolution.

- **High-resolution timer**: This timer is not available in sleep modes and will not persist over a reset, but has greater accuracy. The timer uses the APB_CLK clock source (typically 80 MHz), which has a frequency deviation of less than ±10 ppm. Time will be measured at 1 μs resolution.

The possible combinations of hardware timers used to keep syst"
"em time are listed below:

- RTC and high-resolution timer (default)
- RTC
- High-resolution timer
- None

It is recommended that users stick to the default option as it provides the highest accuracy. However, users can also select a different setting via the :ref:`CONFIG_NEWLIB_TIME_SYSCALL` configuration option.


.. _rtc-clock-source-choice:

RTC Timer Clock Sources


The RTC timer has the following clock sources:

.. list::

    - ``Internal {IDF_TARGET_RTC_CLK_FRE} RC oscillator`` (default)"
": Features the lowest Deep-sleep current consumption and no dependence on any external components. However, the frequency stability of this clock source is affected by temperature fluctuations, so time may drift in both Deep-sleep and Light-sleep modes.

    :not esp32c2: - ``External 32 kHz crystal``: Requires a 32 kHz crystal to be connected to the {IDF_TARGET_EXT_CRYSTAL_PIN} pins. This source provides a better frequency stability at the expense of a slightly higher (by 1 μA) Deep-sleep curre"
"nt consumption.

    - ``External 32 kHz oscillator at {IDF_TARGET_EXT_OSC_PIN} pin``: Allows using 32 kHz clock generated by an external circuit. The external clock signal must be connected to the {IDF_TARGET_EXT_OSC_PIN} pin. The amplitude should be less than 1.2 V for sine wave signal and less than 1 V for square wave signal. Common mode voltage should be in the range of 0.1 ` when interacting with SNTP module.

To initialize a particular SNTP server and also start the SNTP service, simply cr"
"eate a default SNTP server configuration with a particular server name, then call :cpp:func:`esp_netif_sntp_init()` to register that server and start the SNTP service.

.. code-block:: c

    esp_sntp_config_t config = ESP_NETIF_SNTP_DEFAULT_CONFIG(""pool.ntp.org"");
    esp_netif_sntp_init(&config);

This code automatically performs time synchronization once a reply from the SNTP server is received. Sometimes it is useful to wait until the time gets synchronized, :cpp:func:`esp_netif_sntp_sync_wa"
"it()` can be used for this purpose:

.. code-block:: c

    if (esp_netif_sntp_sync_wait(pdMS_TO_TICKS(10000)) != ESP_OK) {
        printf(""Failed to update system time within 10s timeout"");
    }

To configure multiple NTP servers (or use more advanced settings, such as DHCP provided NTP servers), please refer to the detailed description of :ref:`esp_netif-sntp-api` in :doc:`esp_netif ` documentation.

The lwIP SNTP library could work in one of the following sync modes:

- :cpp:enumerator:`SNTP"
"_SYNC_MODE_IMMED` (default): Updates system time immediately upon receiving a response from the SNTP server after using ``settimeofday()``.
- :cpp:enumerator:`SNTP_SYNC_MODE_SMOOTH`: Updates time smoothly by gradually reducing time error using the function ``adjtime()``. If the difference between the SNTP response time and system time is more than 35 minutes, update system time immediately by using ``settimeofday()``.

If you want to choose the :cpp:enumerator:`SNTP_SYNC_MODE_SMOOTH` mode, pleas"
"e set the :cpp:member:`esp_sntp_config::smooth` to ``true`` in the SNTP configuration struct. Otherwise (and by default) the :cpp:enumerator:`SNTP_SYNC_MODE_IMMED` mode will be used.

For setting a callback function that is called when time gets synchronized, use the :cpp:member:`esp_sntp_config::sync_cb` field in the configuration struct.

An application with this initialization code periodically synchronizes the time. The time synchronization period is determined by :ref:`CONFIG_LWIP_SNTP_UPDA"
"TE_DELAY` (the default value is one hour). To modify the variable, set :ref:`CONFIG_LWIP_SNTP_UPDATE_DELAY` in project configuration.

A code example that demonstrates the implementation of time synchronization based on the lwIP SNTP library is provided in the :example:`protocols/sntp` directory.

Note that it is also possible to use lwIP API directly, but care must be taken to thread safety. Here we list the thread-safe APIs:

- :cpp:func:`sntp_set_time_sync_notification_cb` can be used to set "
"a callback function that notifies of the time synchronization process.
- :cpp:func:`sntp_get_sync_status` and :cpp:func:`sntp_set_sync_status` can be used to get/set time synchronization status.
- :cpp:func:`sntp_set_sync_mode` can be used to set the synchronization mode.
- :cpp:func:`esp_sntp_setoperatingmode` sets the preferred operating mode.:cpp:enumerator:`ESP_SNTP_OPMODE_POLL` and :cpp:func:`esp_sntp_init` initializes SNTP module.
- :cpp:func:`esp_sntp_setservername` configures one SNTP se"
"rver.


Timezones


To set the local timezone, use the following POSIX functions:

Once these steps are completed, call the standard C library function ``localtime()``, and it returns the correct local time taking into account the timezone offset and daylight saving time.


Year 2036 and 2038 Overflow Issues


SNTP/NTP 2036 Overflow


SNTP/NTP timestamps are represented as 64-bit unsigned fixed point numbers, where the first 32 bits represent the integer part, and the last 32 bits represent the "
"fractional part. The 64-bit unsigned fixed point number represents the number of seconds since 00:00 on 1st of January 1900, thus SNTP/NTP times will overflow in the year 2036.

To address this issue, lifetime of the SNTP/NTP timestamps has been extended by convention by using the MSB (bit 0 by convention) of the integer part to indicate time ranges between years 1968 to 2104 (see `RFC2030 `_ for more details). This convention is implemented in lwIP library SNTP module. Therefore SNTP-related fu"
"nctions in ESP-IDF are future-proof until year 2104.


Unix Time 2038 Overflow


Unix time (type ``time_t``) was previously represented as a 32-bit signed integer, leading to an overflow in year 2038 (i.e., `Y2K38 issue `_). To address the Y2K38 issue, ESP-IDF uses a 64-bit signed integer to represent ``time_t`` starting from release v5.0, thus deferring ``time_t`` overflow for another 292 billion years.


API Reference


.. include-build-file:: inc/esp_sntp.inc
"
"Asynchronous Memory Copy




Overview


{IDF_TARGET_NAME} has a DMA engine which can help to offload internal memory copy operations from the CPU in an asynchronous way.

The async memcpy API wraps all DMA configurations and operations. The signature of :cpp:func:`esp_async_memcpy` is almost the same as the standard libc ``memcpy`` function.

The DMA allows multiple memory copy requests to be queued up before the first one is completed, which allows overlap of computation and memory copy. Moreov"
"er, it is still possible to know the exact time when a memory copy request is completed by registering an event callback.

.. only:: SOC_AHB_GDMA_SUPPORT_PSRAM

    If the async memcpy is constructed upon the AHB GDMA, it is also possible to copy data from/to PSRAM with a proper alignment.

.. only:: SOC_AXI_GDMA_SUPPORT_PSRAM

    If the async memcpy is constructed upon the AXI GDMA, it is also possible to copy data from/to PSRAM with a proper alignment.


Configure and Install Driver


There a"
"re several ways to install the async memcpy driver, depending on the underlying DMA engine:

.. list::

    :SOC_CP_DMA_SUPPORTED: - :cpp:func:`esp_async_memcpy_install_cpdma` is used to install the async memcpy driver based on the CP DMA engine.
    :SOC_AHB_GDMA_SUPPORTED: - :cpp:func:`esp_async_memcpy_install_gdma_ahb` is used to install the async memcpy driver based on the AHB GDMA engine.
    :SOC_AXI_GDMA_SUPPORTED: - :cpp:func:`esp_async_memcpy_install_gdma_axi` is used to install the asy"
"nc memcpy driver based on the AXI GDMA engine.
    - :cpp:func:`esp_async_memcpy_install` is a generic API to install the async memcpy driver with a default DMA engine. If the SoC has the CP DMA engine, the default DMA engine is CP DMA. Otherwise, the default DMA engine is AHB GDMA.

Driver configuration is described in :cpp:type:`async_memcpy_config_t`:

.. code-block:: c

    async_memcpy_config_t config = ASYNC_MEMCPY_DEFAULT_CONFIG();
    // update the maximum data stream supported by underl"
"ying DMA engine
    config.backlog = 8;
    async_memcpy_handle_t driver = NULL;
    ESP_ERROR_CHECK(esp_async_memcpy_install(&config, &driver)); // install driver with default DMA engine

Send Memory Copy Request


:cpp:func:`esp_async_memcpy` is the API to send memory copy request to DMA engine. It must be called after driver is installed successfully. This API is thread safe, so it can be called from different tasks.

Different from the libc version of ``memcpy``, you can optionally pass a ca"
"llback to :cpp:func:`esp_async_memcpy`, so that you can be notified when the memory copy is finished. Note that the callback is executed in the ISR context, please make sure you will not call any blocking functions in the callback.

The prototype of the callback function is :cpp:type:`async_memcpy_isr_cb_t`. The callback function should only return true if it wakes up a high priority task by RTOS APIs like :cpp:func:`xSemaphoreGiveFromISR`.

.. code-block:: c

    // Callback implementation, run"
"ning in ISR context
    static bool my_async_memcpy_cb(async_memcpy_handle_t mcp_hdl, async_memcpy_event_t *event, void *cb_args)
    {
        SemaphoreHandle_t sem = (SemaphoreHandle_t)cb_args;
        BaseType_t high_task_wakeup = pdFALSE;
        xSemaphoreGiveFromISR(semphr, &high_task_wakeup); // high_task_wakeup set to pdTRUE if some high priority task unblocked
        return high_task_wakeup == pdTRUE;
    }

    // Create a semaphore used to report the completion of async memcpy
    Se"
"maphoreHandle_t semphr = xSemaphoreCreateBinary();

    // Called from user's context
    ESP_ERROR_CHECK(esp_async_memcpy(driver_handle, to, from, copy_len, my_async_memcpy_cb, my_semaphore));
    // Do something else here
    xSemaphoreTake(my_semaphore, portMAX_DELAY); // Wait until the buffer copy is done


Uninstall Driver


:cpp:func:`esp_async_memcpy_uninstall` is used to uninstall asynchronous memcpy driver. It is not necessary to uninstall the driver after each memcpy operation. If you "
"know your application will not use this driver anymore, then this API can recycle the memory and other hardware resources for you.

.. only:: SOC_ETM_SUPPORTED and SOC_GDMA_SUPPORT_ETM

    ETM Event
    

    Async memory copy is able to generate an event when one async memcpy operation is done. This event can be used to interact with the :doc:`ETM ` module. You can call :cpp:func:`esp_async_memcpy_new_etm_event` to get the ETM event handle.

    For how to connect the event to an ETM channel, "
"please refer to the :doc:`ETM ` documentation.

API Reference


.. include-build-file:: inc/esp_async_memcpy.inc
"
"Power Management




Overview


Power management algorithm included in ESP-IDF can adjust the advanced peripheral bus (APB) frequency, CPU frequency, and put the chip into Light-sleep mode to run an application at smallest possible power consumption, given the requirements of application components.

Application components can express their requirements by creating and acquiring power management locks.

For example:

- Driver for a peripheral clocked from APB can request the APB frequency to be "
"set to 80 MHz while the peripheral is used.
- RTOS can request the CPU to run at the highest configured frequency while there are tasks ready to run.
- A peripheral driver may need interrupts to be enabled, which means it has to request disabling Light-sleep.

Since requesting higher APB or CPU frequencies or disabling Light-sleep causes higher current consumption, please keep the usage of power management locks by components to a minimum.

Configuration


Power management can be enabled at comp"
"ile time, using the option :ref:`CONFIG_PM_ENABLE`.

Enabling power management features comes at the cost of increased interrupt latency. Extra latency depends on a number of factors, such as the CPU frequency, single/dual core mode, whether or not frequency switch needs to be done. Minimum extra latency is 0.2 us (when the CPU frequency is 240 MHz and frequency scaling is not enabled). Maximum extra latency is 40 us (when frequency scaling is enabled, and a switch from 40 MHz to 80 MHz is perfo"
"rmed on interrupt entry).

Dynamic frequency scaling (DFS) and automatic Light-sleep can be enabled in an application by calling the function :cpp:func:`esp_pm_configure`. Its argument is a structure defining the frequency scaling settings, :cpp:class:`esp_pm_config_t`. In this structure, three fields need to be initialized:

.. list::

    - ``max_freq_mhz``: Maximum CPU frequency in MHz, i.e., the frequency used when the ``ESP_PM_CPU_FREQ_MAX`` lock is acquired. This field is usually set to th"
"e default CPU frequency.

    :esp32 or esp32s2: - ``min_freq_mhz``: Minimum CPU frequency in MHz, indicating the frequency used when not holding the power management lock. Note that 10 MHz is the minimum frequency required for generating a 1 MHz REF_TICK default clock.

    :not esp32 and not esp32s2: - ``min_freq_mhz``: Minimum CPU frequency in MHz, indicating the frequency used when not holding the power management lock.

    - ``light_sleep_enable``: Whether the system should automatically e"
"nter Light-sleep when no locks are acquired (``true``/``false``).


  Alternatively, if you enable the option :ref:`CONFIG_PM_DFS_INIT_AUTO` in menuconfig, the maximum CPU frequency will be determined by the :ref:`CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ` setting, and the minimum CPU frequency will be locked to the XTAL frequency.

.. note::

  Automatic Light-sleep is based on FreeRTOS Tickless Idle functionality. If automatic Light-sleep is requested while the option :ref:`CONFIG_FREERTOS_USE_TICKLESS_"
"IDLE` is not enabled in menuconfig, :cpp:func:`esp_pm_configure` will return the error `ESP_ERR_NOT_SUPPORTED`.

.. note::

  In Light-sleep, peripherals are clock gated, and interrupts (from GPIOs and internal peripherals) will not be generated. A wakeup source described in the :doc:`sleep_modes` documentation can be used to trigger wakeup from the Light-sleep state.

.. only:: SOC_PM_SUPPORT_EXT0_WAKEUP or SOC_PM_SUPPORT_EXT1_WAKEUP

  For example, the EXT0 and EXT1 wakeup sources can be used "
"to wake up the chip via a GPIO.


Power Management Locks

{IDF_TARGET_MAX_CPU_FREQ: default=""Not updated yet"", esp32=""80 MHz, 160 MHz, or 240 MHz"", esp32s2=""80 MHz, 160 MHz, or 240 MHz"", esp32s3=""80 MHz, 160 MHz, or 240 MHz"", esp32c2=""80 MHz or 120 MHz"", esp32c3=""80 MHz or 160 MHz"", esp32c6=""80 MHz or 160 MHz""}

Applications have the ability to acquire/release locks in order to control the power management algorithm. When an application acquires a lock, the power management algorithm operation i"
"s restricted in a way described below. When the lock is released, such restrictions are removed.

Power management locks have acquire/release counters. If the lock has been acquired a number of times, it needs to be released the same number of times to remove associated restrictions.

{IDF_TARGET_NAME} supports three types of locks described in the table below.

.. list-table::
  :header-rows: 1
  :widths: 25 60
    - Description
    - Requests CPU frequency to be at the maximum value set with :"
"cpp:func:`esp_pm_configure`. For {IDF_TARGET_NAME}, this value can be set to {IDF_TARGET_MAX_CPU_FREQ}.
    - Requests the APB frequency to be at the maximum supported value. For {IDF_TARGET_NAME}, this is 80 MHz.
    - Disables automatic switching to Light-sleep.

{IDF_TARGET_NAME} Power Management Algorithm


The table below shows how CPU and APB frequencies will be switched if dynamic frequency scaling is enabled. You can specify the maximum CPU frequency with either :cpp:func:`esp_pm_configu"
"re` or :ref:`CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ`.

.. include:: inc/power_management_{IDF_TARGET_PATH_NAME}.rst

If none of the locks are acquired, and Light-sleep is enabled in a call to :cpp:func:`esp_pm_configure`, the system will go into Light-sleep mode. The duration of Light-sleep will be determined by:

- FreeRTOS tasks blocked with finite timeouts
- Timers registered with :doc:`High resolution timer ` APIs

Light-sleep duration is chosen to wake up the chip before the nearest event (task be"
"ing unblocked, or timer elapses).

To skip unnecessary wake-up, you can consider initializing an ``esp_timer`` with the ``skip_unhandled_events`` option as ``true``. Timers with this flag will not wake up the system and it helps to reduce consumption.


Dynamic Frequency Scaling and Peripheral Drivers


When DFS is enabled, the APB frequency can be changed multiple times within a single RTOS tick. The APB frequency change does not affect the operation of some peripherals, while other peripherals"
" may have issues. For example, Timer Group peripheral timers keeps counting, however, the speed at which they count changes proportionally to the APB frequency.

Peripheral clock sources such as ``REF_TICK``, ``XTAL``, ``RC_FAST`` (i.e., ``RTC_8M``), their frequencies will not be inflenced by APB frequency. And therefore, to ensure the peripheral behaves consistently during DFS, it is recommanded to select one of these clocks as the peripheral clock source. For more specific guidelines, please r"
"efer to the ""Power Management"" section of each peripheral's ""API Reference > Peripherals API"" page.

Currently, the following peripheral drivers are aware of DFS and use the ``ESP_PM_APB_FREQ_MAX`` lock for the duration of the transaction:

- SPI master
- I2C
- I2S (If the APLL clock is used, then it will use the ``ESP_PM_NO_LIGHT_SLEEP`` lock)
- SDMMC

The following drivers hold the ``ESP_PM_APB_FREQ_MAX`` lock while the driver is enabled:

.. list::

    - **SPI slave**: between calls to :cpp:"
"func:`spi_slave_initialize` and :cpp:func:`spi_slave_free`.
    - **GPTimer**: between calls to :cpp:func:`gptimer_enable` and :cpp:func:`gptimer_disable`.
    - **Ethernet**: between calls to :cpp:func:`esp_eth_driver_install` and :cpp:func:`esp_eth_driver_uninstall`.
    - **WiFi**: between calls to :cpp:func:`esp_wifi_start` and :cpp:func:`esp_wifi_stop`. If modem sleep is enabled, the lock will be released for the periods of time when radio is disabled.
    :SOC_TWAI_SUPPORTED: - **TWAI**: b"
"etween calls to :cpp:func:`twai_driver_install` and :cpp:func:`twai_driver_uninstall` (only when the clock source is set to :cpp:enumerator:`TWAI_CLK_SRC_APB`).
    :SOC_BT_SUPPORTED and esp32: - **Bluetooth**: between calls to :cpp:func:`esp_bt_controller_enable` and :cpp:func:`esp_bt_controller_disable`. If Bluetooth Modem-sleep is enabled, the ``ESP_PM_APB_FREQ_MAX`` lock will be released for the periods of time when radio is disabled. However the ``ESP_PM_NO_LIGHT_SLEEP`` lock will still be "
"held, unless :ref:`CONFIG_BTDM_CTRL_LOW_POWER_CLOCK` option is set to ""External 32kHz crystal"".
    :SOC_BT_SUPPORTED and not esp32: - **Bluetooth**: between calls to :cpp:func:`esp_bt_controller_enable` and :cpp:func:`esp_bt_controller_disable`. If Bluetooth Modem-sleep is enabled, the ``ESP_PM_APB_FREQ_MAX`` lock will be released for the periods of time when radio is disabled. However the ``ESP_PM_NO_LIGHT_SLEEP`` lock will still be held.

The following peripheral drivers are not aware of DFS "
"yet. Applications need to acquire/release locks themselves, when necessary:

.. list::

    - PCNT
    - Sigma-delta
    - The legacy timer group driver
    :SOC_MCPWM_SUPPORTED: - MCPWM


Light-sleep Peripheral Power Down


.. only:: esp32c6 or esp32h2

    {IDF_TARGET_NAME} supports power-down peripherals during Light-sleep.

    If :ref:`CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP` is enabled, when the driver initializes the peripheral, the driver will register the working register context"
" of the peripheral to the sleep retention link. Before entering sleep, the ``REG_DMA`` peripheral reads the configuration in the sleep retention link, and back up the register context to memory according to the configuration. ``REG_DMA`` also restores context from memory to peripheral registers on wakeup.

    Currently ESP-IDF supports Light-sleep context retention for the following peripherals:
    - INT_MTX
    - TEE/APM
    - IO_MUX / GPIO
    - UART0
    - TIMG0
    - SPI0/1
    - SYSTIMER
"
"
    The following peripherals are not yet supported:
    - ETM
    - TIMG1
    - ASSIST_DEBUG
    - Trace
    - Crypto: AES/ECC/HMAC/RSA/SHA/DS/XTA_AES/ECDSA
    - SPI2
    - I2S
    - PCNT
    - USB-Serial-JTAG
    - TWAI
    - LEDC
    - MCPWM
    - RMT
    - SARADC
    - SDIO
    - PARL_IO
    - UART1

    For peripherals that do not support Light-sleep context retention, if the Power management is enabled, the ``ESP_PM_NO_LIGHT_SLEEP`` lock should be held when the peripheral is working to a"
"void losing the working context of the peripheral when entering sleep.

    .. note::

        When the peripheral power domain is powered down during sleep, both the IO_MUX and GPIO modules are inactive, meaning the chip pins' state is not maintained by these modules. To preserve the state of an IO during sleep, it's essential to call :cpp:func:`gpio_hold_dis` and :cpp:func:`gpio_hold_en` before and after configuring the GPIO state. This action ensures that the IO configuration is latched and p"
"revents the IO from becoming floating while in sleep mode.


API Reference


.. include-build-file:: inc/esp_pm.inc
"
"Programming ULP FSM Coprocessor Using C Macros (Legacy)


In addition to the existing binutils port for the {IDF_TARGET_NAME} ULP coprocessor, it is possible to generate programs for the ULP FSM coprocessor by embedding assembly-like macros into an {IDF_TARGET_NAME} application. Here is an example how this can be done::

    const ulp_insn_t program[] = {
        I_MOVI(R3, 16),         // R3  RTC_SLOW_MEM[R2 + 2]
        I_HALT()
    };
    size_t load_addr = 0;
    size_t size = sizeof(program"
")/sizeof(ulp_insn_t);
    ulp_process_macros_and_load(load_addr, program, &size);
    ulp_run(load_addr);

The ``program`` array is an array of ``ulp_insn_t``, i.e., ULP coprocessor instructions. Each ``I_XXX`` preprocessor define translates into a single 32-bit instruction. Arguments of these preprocessor defines can be register numbers (``R0 — R3``) and literal constants. See the API reference section at the end of this guide for descriptions of instructions and arguments they take.

.. note::"
"

    Because some of the instruction macros expand to inline function calls, defining such array in global scope will cause the compiler to produce an ""initializer element is not constant"" error. To fix this error, move the definition of instructions array into local scope.

.. note::

    Load, store and move instructions use **addresses expressed in 32-bit words**. Address 0 corresponds to the first word of ``RTC_SLOW_MEM``.
    This is different to how address arguments are handled in assemb"
"ly code of the same instructions. See the section :ref:`ulp-fsm-addressing` for more details for reference.

To generate branch instructions, special ``M_`` preprocessor defines are used. ``M_LABEL`` define can be used to define a branch target. Label identifier is a 16-bit integer. ``M_Bxxx`` defines can be used to generate branch instructions with target set to a particular label.

Implementation note: these ``M_`` preprocessor defines will be translated into two ulp_insn_t values: one is a to"
"ken value which contains label number, and the other is the actual instruction. ``ulp_process_macros_and_load`` function resolves the label number to the address, modifies the branch instruction to use the correct address, and removes the extra ``ulp_insn_t`` token which contains the label numer.

Here is an example of using labels and branches::

    const ulp_insn_t program[] = {
        I_MOVI(R0, 34),         // R0  RTC_SLOW_MEM[R0 + 0]
        I_ADDI(R0, R0, 1),      // R0++
        M_BL(1,"
" 64),            // if (R0 < 64) goto label_1
        I_HALT(),
    };
    RTC_SLOW_MEM[32] = 42;
    RTC_SLOW_MEM[33] = 18;
    size_t load_addr = 0;
    size_t size = sizeof(program)/sizeof(ulp_insn_t);
    ulp_process_macros_and_load(load_addr, program, &size);
    ulp_run(load_addr);

API Reference


.. include-build-file:: inc/ulp.inc
"
"Performance Monitor




The Performance Monitor component provides APIs to use {IDF_TARGET_NAME} internal performance counters to profile functions and applications.

Application Example


An example which combines performance monitor is provided in ``examples/system/perfmon`` directory. This example initializes the performance monitor structure and execute them with printing the statistics.

High-Level API Reference


Header Files


API Reference


.. include-build-file:: inc/xtensa_perfmon_acc"
"ess.inc
.. include-build-file:: inc/xtensa_perfmon_apis.inc
"
"SoC Capabilities




This section lists the macro definitions of the {IDF_TARGET_NAME}'s SoC hardware capabilities. These macros are commonly used by conditional-compilation directives (e.g., ``#if``) in ESP-IDF to determine which hardware-dependent features are supported, thus control what portions of code are compiled.

.. warning::

    These macro definitions are currently not considered to be part of the public API, and may be changed in a breaking manner (see :doc:`../../../versions` for m"
"ore details).


API Reference


.. include-build-file:: inc/soc_caps.inc
"
"Over The Air Updates (OTA)




OTA Process Overview


The OTA update mechanism allows a device to update itself based on data received while the normal firmware is running (for example, over Wi-Fi, Bluetooth or Ethernet).

OTA requires configuring the :doc:`../../api-guides/partition-tables` of the device with at least two OTA app slot partitions (i.e., ``ota_0`` and ``ota_1``) and an OTA Data Partition.

The OTA operation functions write a new app firmware image to whichever OTA app slot that i"
"s currently not selected for booting. Once the image is verified, the OTA Data partition is updated to specify that this image should be used for the next boot.

.. _ota_data_partition:

OTA Data Partition


An OTA data partition (type ``data``, subtype ``ota``) must be included in the :doc:`../../api-guides/partition-tables` of any project which uses the OTA functions.

For factory boot settings, the OTA data partition should contain no data (all bytes erased to 0xFF). In this case, the ESP-IDF"
" software bootloader will boot the factory app if it is present in the partition table. If no factory app is included in the partition table, the first available OTA slot (usually ``ota_0``) is booted.

After the first OTA update, the OTA data partition is updated to specify which OTA app slot partition should be booted next.

The OTA data partition is two flash sectors (0x2000 bytes) in size, to prevent problems if there is a power failure while it is being written. Sectors are independently er"
"ased and written with matching data, and if they disagree a counter field is used to determine which sector was written more recently.

.. _app_rollback:

App Rollback


The main purpose of the application rollback is to keep the device working after the update. This feature allows you to roll back to the previous working application in case a new application has critical errors. When the rollback process is enabled and an OTA update provides a new version of the app, one of three things can hap"
"pen:

.. note::

  The state is not written to the binary image of the application but rather to the ``otadata`` partition. The partition contains a ``ota_seq`` counter, which is a pointer to the slot (``ota_0``, ``ota_1``, ...) from which the application will be selected for boot.

App OTA State


States control the process of selecting a boot app:

 
            States            Restriction of selecting a boot app in bootloader
 
 ESP_OTA_IMG_VALID            None restriction. Will be selecte"
"d.
 ESP_OTA_IMG_UNDEFINED        None restriction. Will be selected.
 ESP_OTA_IMG_INVALID          Will not be selected.
 ESP_OTA_IMG_ABORTED          Will not be selected.
 ESP_OTA_IMG_NEW              If :ref:`CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE` option is set it will
                              be selected only once. In bootloader the state immediately changes to
                              ``ESP_OTA_IMG_PENDING_VERIFY``.
 ESP_OTA_IMG_PENDING_VERIFY   If :ref:`CONFIG_BOOTLOADER_APP_ROLL"
"BACK_ENABLE` option is set it will
                              not be selected, and the state will change to ``ESP_OTA_IMG_ABORTED``.
 

If :ref:`CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE` option is not enabled (by default), then the use of the following functions :cpp:func:`esp_ota_mark_app_valid_cancel_rollback` and :cpp:func:`esp_ota_mark_app_invalid_rollback_and_reboot` are optional, and ``ESP_OTA_IMG_NEW`` and ``ESP_OTA_IMG_PENDING_VERIFY`` states are not used.

An option in Kconfig :ref:`CON"
"FIG_BOOTLOADER_APP_ROLLBACK_ENABLE` allows you to track the first boot of a new application. In this case, the application must confirm its operability by calling :cpp:func:`esp_ota_mark_app_valid_cancel_rollback` function, otherwise the application will be rolled back upon reboot. It allows you to control the operability of the application during the boot phase. Thus, a new application has only one attempt to boot successfully.

.. _ota_rollback:

Rollback Process


The description of the rollb"
"ack process when :ref:`CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE` option is enabled:

Unexpected Reset


If a power loss or an unexpected crash occurs at the time of the first boot of a new application, it will roll back the application.

Recommendation: Perform the self-test procedure as quickly as possible, to prevent rollback due to power loss.

Only ``OTA`` partitions can be rolled back. Factory partition is not rolled back.

Booting Invalid/aborted Apps


Booting an application which was previo"
"usly set to ``ESP_OTA_IMG_INVALID`` or ``ESP_OTA_IMG_ABORTED`` is possible:

To determine if self-tests should be run during startup of an application, call the :cpp:func:`esp_ota_get_state_partition` function. If result is ``ESP_OTA_IMG_PENDING_VERIFY`` then self-testing and subsequent confirmation of operability is required.

Where the States Are Set


A brief description of where the states are set:

.. _anti-rollback:

Anti-rollback


Anti-rollback prevents rollback to application with secur"
"ity version lower than one programmed in eFuse of chip.

This function works if set :ref:`CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK` option. In the bootloader, when selecting a bootable application, an additional security version check is added which is on the chip and in the application image. The version in the bootable firmware must be greater than or equal to the version in the chip.

:ref:`CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK` and :ref:`CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE` options are used toget"
"her. In this case, rollback is possible only on the security version which is equal or higher than the version in the chip.


A Typical Anti-rollback Scheme Is


- New firmware released with the elimination of vulnerabilities with the previous version of security.
- After the developer makes sure that this firmware is working. He can increase the security version and release a new firmware.
- Download new application.
- To make it bootable, run the function :cpp:func:`esp_ota_set_boot_partition`"
". If the security version of the new application is smaller than the version in the chip, the new application will be erased. Update to new firmware is not possible.
- Reboot.
- In the bootloader, an application with a security version greater than or equal to the version in the chip will be selected. If otadata is in the initial state, and one firmware was loaded via a serial channel, whose secure version is higher than the chip, then the secure version of efuse will be immediately updated in t"
"he bootloader.
- New application booted. Then the application should perform diagnostics of the operation and if it is completed successfully, you should call :cpp:func:`esp_ota_mark_app_valid_cancel_rollback` function to mark the running application with the ``ESP_OTA_IMG_VALID`` state and update the secure version on chip. Note that if was called :cpp:func:`esp_ota_mark_app_invalid_rollback_and_reboot` function a rollback may not happen as the device may not have any bootable apps. It will the"
"n return ``ESP_ERR_OTA_ROLLBACK_FAILED`` error and stay in the ``ESP_OTA_IMG_PENDING_VERIFY`` state.
- The next update of app is possible if a running app is in the ``ESP_OTA_IMG_VALID`` state.

Recommendation:

If you want to avoid the download/erase overhead in case of the app from the server has security version lower than the running app, you have to get ``new_app_info.secure_version`` from the first package of an image and compare it with the secure version of efuse. Use ``esp_efuse_check_s"
"ecure_version(new_app_info.secure_version)`` function if it is true then continue downloading otherwise abort.

.. code-block:: c

    ....
    bool image_header_was_checked = false;
    while (1) {
        int data_read = esp_http_client_read(client, ota_write_data, BUFFSIZE);
        ...
        if (data_read > 0) {
            if (image_header_was_checked == false) {
                esp_app_desc_t new_app_info;
                if (data_read > sizeof(esp_image_header_t) + sizeof(esp_image_segm"
"ent_header_t) + sizeof(esp_app_desc_t)) {
                    // check current version with downloading
                    if (esp_efuse_check_secure_version(new_app_info.secure_version) == false) {
                      ESP_LOGE(TAG, ""This a new app can not be downloaded due to a secure version is lower than stored in efuse."");
                      http_cleanup(client);
                      task_fatal_error();
                    }

                    image_header_was_checked = true;

     "
"               esp_ota_begin(update_partition, OTA_SIZE_UNKNOWN, &update_handle);
                }
            }
            esp_ota_write( update_handle, (const void *)ota_write_data, data_read);
        }
    }
    ...

Restrictions:

.. list::

    :esp32: - The number of bits in the ``secure_version`` field is limited to 32 bits. This means that only 32 times you can do an anti-rollback. You can reduce the length of this efuse field using :ref:`CONFIG_BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD"
"` option.
    :not esp32: - The number of bits in the ``secure_version`` field is limited to 16 bits. This means that only 16 times you can do an anti-rollback. You can reduce the length of this efuse field using :ref:`CONFIG_BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD` option.
    :esp32: - Anti-rollback works only if the encoding scheme for efuse is set to ``NONE``.
    - Factory and Test partitions are not supported in anti rollback scheme and hence partition table should not have partition with "
"SubType set to ``factory`` or ``test``.

``security_version``:

- In application image it is stored in ``esp_app_desc`` structure. The number is set :ref:`CONFIG_BOOTLOADER_APP_SECURE_VERSION`.

.. only:: esp32

  - In ESP32 it is stored in efuse ``EFUSE_BLK3_RDATA4_REG``. (when a eFuse bit is programmed to 1, it can never be reverted to 0). The number of bits set in this register is the ``security_version`` from app.


.. _secure-ota-updates:

Secure OTA Updates Without Secure Boot


The verifi"
"cation of signed OTA updates can be performed even without enabling hardware secure boot. This can be achieved by setting :ref:`CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT` and :ref:`CONFIG_SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT`

.. only:: esp32

  For more information refer to :ref:`signed-app-verify`


OTA Tool ``otatool.py``


The component ``app_update`` provides a tool :component_file:`app_update/otatool.py` for performing OTA partition-related operations on a target device. The following ope"
"rations can be performed using the tool:

  - read contents of otadata partition (read_otadata)
  - erase otadata partition, effectively resetting device to factory app (erase_otadata)
  - switch OTA partitions (switch_ota_partition)
  - erasing OTA partition (erase_ota_partition)
  - write to OTA partition (write_ota_partition)
  - read contents of OTA partition (read_ota_partition)

The tool can either be imported and used from another Python script or invoked from shell script for users wanti"
"ng to perform operation programmatically. This is facilitated by the tool's Python API and command-line interface, respectively.

Python API


Before anything else, make sure that the ``otatool`` module is imported.

.. code-block:: python

  import sys
  import os

  idf_path = os.environ[""IDF_PATH""]  # get value of IDF_PATH from environment
  otatool_dir = os.path.join(idf_path, ""components"", ""app_update"")  # otatool.py lives in $IDF_PATH/components/app_update

  sys.path.append(otatool_dir)  "
"# this enables Python to find otatool module
  from otatool import *  # import all names inside otatool module

The starting point for using the tool's Python API to do is create a ``OtatoolTarget`` object:

.. code-block:: python

  # Create a parttool.py target device connected on serial port /dev/ttyUSB1
  target = OtatoolTarget(""/dev/ttyUSB1"")

The created object can now be used to perform operations on the target device:

.. code-block:: python

  # Erase otadata, reseting the device to fac"
"tory app
  target.erase_otadata()

  # Erase contents of OTA app slot 0
  target.erase_ota_partition(0)

  # Switch boot partition to that of app slot 1
  target.switch_ota_partition(1)

  # Read OTA partition 'ota_3' and save contents to a file named 'ota_3.bin'
  target.read_ota_partition(""ota_3"", ""ota_3.bin"")

The OTA partition to operate on is specified using either the app slot number or the partition name.

More information on the Python API is available in the docstrings for the tool.

Co"
"mmand-line Interface


The command-line interface of ``otatool.py`` has the following structure:

.. code-block:: bash

  otatool.py [command-args] [subcommand] [subcommand-args]

  - command-args - these are arguments that are needed for executing the main command (parttool.py), mostly pertaining to the target device
  - subcommand - this is the operation to be performed
  - subcommand-args - these are arguments that are specific to the chosen operation

.. code-block:: bash

  # Erase otadata,"
" resetting the device to factory app
  otatool.py --port ""/dev/ttyUSB1"" erase_otadata

  # Erase contents of OTA app slot 0
  otatool.py --port ""/dev/ttyUSB1"" erase_ota_partition --slot 0

  # Switch boot partition to that of app slot 1
  otatool.py --port ""/dev/ttyUSB1"" switch_ota_partition --slot 1

  # Read OTA partition 'ota_3' and save contents to a file named 'ota_3.bin'
  otatool.py --port ""/dev/ttyUSB1"" read_ota_partition --name=ota_3 --output=ota_3.bin


More information can be obtained"
" by specifying ``--help`` as argument:

.. code-block:: bash

  # Display possible subcommands and show main command argument descriptions
  otatool.py --help

  # Show descriptions for specific subcommand arguments
  otatool.py [subcommand] --help


See Also


Application Example


End-to-end example of OTA firmware update workflow: :example:`system/ota`.

API Reference


.. include-build-file:: inc/esp_ota_ops.inc

Debugging OTA Failure


.. figure:: ../../../_static/how-to-debug-when-OTA-fail"
"s-en.png
    :align: center
    :scale: 100%
    :alt: How to Debug When OTA Fails (click to enlarge)
    :figclass: align-center

    How to Debug When OTA Fails (click to enlarge)
"
"Himem




Overview


For external memories that are = 4 MiB in size. However, the memory on these chips needs to be accessed using a bank switching scheme. ESP-IDF provides the **Himem API** to control this bank switching. More specifically, the Himem API allows particular 32 K banks within 4 MiB address switch mappings at run time, thus allowing access to more than 4 MiB of external memory.

Usage


In order to use the Himem API, you have to enable it in the menuconfig using :ref:`CONFIG_SPIRAM"
"_BANKSWITCH_ENABLE`, as well as set the amount of banks reserved for this in :ref:`CONFIG_SPIRAM_BANKSWITCH_RESERVE`. This decreases the amount of external memory allocated by functions like ``malloc()``, but it allows you to use the Himem API to map any of the remaining memory into the reserved banks.

The Himem API is more-or-less an abstraction of the bank switching scheme: it allows you to claim one or more banks of address space (called 'regions' in the API) as well as one or more of banks "
"of memory to map into the ranges.

Example


An example doing a simple memory test of the high memory range is available in ESP-IDF: :example:`system/himem`


API Reference


.. include-build-file:: inc/himem.inc
"
"App Image Format




.. _app-image-structures:

Application Image Structures


An application image consists of the following:

The count of each segment is defined in the ``segment_count`` field that is stored in :cpp:type:`esp_image_header_t`. The count cannot be more than :c:macro:`ESP_IMAGE_MAX_SEGMENTS`.

To get the list of your image segments, please run the following command:

.. code-block::

    esptool.py --chip {IDF_TARGET_PATH_NAME} image_info build/app.bin

.. code-block::

    espt"
"ool.py v2.3.1
    Image version: 1
    Entry point: 40080ea4
    13 segments

    Segment 1: len 0x13ce0 load 0x3f400020 file_offs 0x00000018 SOC_DROM
    Segment 2: len 0x00000 load 0x3ff80000 file_offs 0x00013d00 SOC_RTC_DRAM
    Segment 3: len 0x00000 load 0x3ff80000 file_offs 0x00013d08 SOC_RTC_DRAM
    Segment 4: len 0x028e0 load 0x3ffb0000 file_offs 0x00013d10 DRAM
    Segment 5: len 0x00000 load 0x3ffb28e0 file_offs 0x000165f8 DRAM
    Segment 6: len 0x00400 load 0x40080000 file_offs 0x00"
"016600 SOC_IRAM
    Segment 7: len 0x09600 load 0x40080400 file_offs 0x00016a08 SOC_IRAM
    Segment 8: len 0x62e4c load 0x400d0018 file_offs 0x00020010 SOC_IROM
    Segment 9: len 0x06cec load 0x40089a00 file_offs 0x00082e64 SOC_IROM
    Segment 10: len 0x00000 load 0x400c0000 file_offs 0x00089b58 SOC_RTC_IRAM
    Segment 11: len 0x00004 load 0x50000000 file_offs 0x00089b60 SOC_RTC_DATA
    Segment 12: len 0x00000 load 0x50000004 file_offs 0x00089b6c SOC_RTC_DATA
    Segment 13: len 0x00000 loa"
"d 0x50000004 file_offs 0x00089b74 SOC_RTC_DATA
    Checksum: e8 (valid)
    Validation Hash: 407089ca0eae2bbf83b4120979d3354b1c938a49cb7a0c997f240474ef2ec76b (valid)

You can also see the information on segments in the ESP-IDF logs while your application is booting:

.. code-block::

    I (443) esp_image: segment 0: paddr=0x00020020 vaddr=0x3f400020 size=0x13ce0 ( 81120) map
    I (489) esp_image: segment 1: paddr=0x00033d08 vaddr=0x3ff80000 size=0x00000 ( 0) load
    I (530) esp_image: segment"
" 2: paddr=0x00033d10 vaddr=0x3ff80000 size=0x00000 ( 0) load
    I (571) esp_image: segment 3: paddr=0x00033d18 vaddr=0x3ffb0000 size=0x028e0 ( 10464) load
    I (612) esp_image: segment 4: paddr=0x00036600 vaddr=0x3ffb28e0 size=0x00000 ( 0) load
    I (654) esp_image: segment 5: paddr=0x00036608 vaddr=0x40080000 size=0x00400 ( 1024) load
    I (695) esp_image: segment 6: paddr=0x00036a10 vaddr=0x40080400 size=0x09600 ( 38400) load
    I (737) esp_image: segment 7: paddr=0x00040018 vaddr=0x400d0"
"018 size=0x62e4c (405068) map
    I (847) esp_image: segment 8: paddr=0x000a2e6c vaddr=0x40089a00 size=0x06cec ( 27884) load
    I (888) esp_image: segment 9: paddr=0x000a9b60 vaddr=0x400c0000 size=0x00000 ( 0) load
    I (929) esp_image: segment 10: paddr=0x000a9b68 vaddr=0x50000000 size=0x00004 ( 4) load
    I (971) esp_image: segment 11: paddr=0x000a9b74 vaddr=0x50000004 size=0x00000 ( 0) load
    I (1012) esp_image: segment 12: paddr=0x000a9b7c vaddr=0x50000004 size=0x00000 ( 0) load

.. onl"
"y:: esp32

    For more details on the type of memory segments and their address ranges, see **{IDF_TARGET_NAME} Technical Reference Manual** > **System and Memory** > **Embedded Memory** [`PDF `__].

.. only:: not esp32

    For more details on the type of memory segments and their address ranges, see **{IDF_TARGET_NAME} Technical Reference Manual** > **System and Memory** > **Internal Memory** [`PDF `__].

.. _app-image-format-application-description:

Application Description


The ``DROM`` se"
"gment of the application binary starts with the :cpp:type:`esp_app_desc_t` structure which carries specific fields describing the application:

.. [#f1] The maximum length is 32 characters, including null-termination character. For example, if the length of ``PROJECT_NAME`` exceeds 31 characters, the excess characters will be disregarded.

This structure is useful for identification of images uploaded via Over-the-Air (OTA) updates because it has a fixed offset = sizeof(:cpp:type:`esp_image_head"
"er_t`) + sizeof(:cpp:type:`esp_image_segment_header_t`). As soon as a device receives the first fragment containing this structure, it has all the information to determine whether the update should be continued with or not.

To obtain the :cpp:type:`esp_app_desc_t` structure for the currently running application, use :cpp:func:`esp_app_get_description`.

To obtain the :cpp:type:`esp_app_desc_t` structure for another OTA partition, use :cpp:func:`esp_ota_get_partition_description`.


Adding a Cus"
"tom Structure to an Application


Users also have the opportunity to have similar structure with a fixed offset relative to the beginning of the image.

The following pattern can be used to add a custom structure to your image:

.. code-block:: c

    const __attribute__((section("".rodata_custom_desc""))) esp_custom_app_desc_t custom_app_desc = { ... }

Offset for custom structure is sizeof(:cpp:type:`esp_image_header_t`) + sizeof(:cpp:type:`esp_image_segment_header_t`) + sizeof(:cpp:type:`esp_ap"
"p_desc_t`).

To guarantee that the custom structure is located in the image even if it is not used, you need to add ``target_link_libraries(${COMPONENT_TARGET} ""-u custom_app_desc"")`` into ``CMakeLists.txt``.

API Reference


.. include-build-file:: inc/esp_app_format.inc
"
"Application Level Tracing




Overview


ESP-IDF provides a useful feature for application behavior analysis called **Application Level Tracing**. The feature can be enabled in menuconfig and allows transfer of arbitrary data between the host and {IDF_TARGET_NAME} via JTAG interface with minimal overhead on program execution.

Developers can use this library to send application specific state of execution to the host, and receive commands or other types of information in the opposite direction a"
"t runtime. The main use cases of this library are:

API Reference


.. include-build-file:: inc/esp_app_trace.inc
.. include-build-file:: inc/esp_sysview_trace.inc
"
"Chip Revision




Overview


{IDF_TARGET_NAME} may have different revisions. These revisions mainly fix some issues, and sometimes also bring new features to the chip. :ref:`versioning scheme` describes the versioning of these chip revisions, and the APIs to read the versions at runtime.

There are some considerations of compatibility among application, ESP-IDF version, and chip revisions:

- Applications may depend on some fixes/features provided by a chip revision.
- When using updated version"
" of hardware, the hardware may be incompatible with earlier versions of ESP-IDF.

:ref:`revision_limitation` describes how the application can specify its chip revision requirements, and the way ESP-IDF checks the compatibility. After that, there is troubleshooting information for this mechanism.

.. _versioning scheme:

Versioning Scheme


A chip's revision number is typically expressed as ``vX.Y``, where:

- ``X`` means a **Major** wafer version. If it is changed, it means that the current sof"
"tware version is not compatible with this released chip and the software must be updated to use this chip.

- ``Y`` means a **Minor** wafer version. If it is changed that means the current software version is compatible with the released chip, and there is no need to update the software.

If a newly released chip does not contain breaking changes, the chip can run the same software as the previous chip. As such, the new chip's revision number will only increment the minor version while keeping t"
"he major version the same (e.g., ``v1.1`` to ``v1.2``).

Conversely, if a newly released chip contains breaking changes, the chip **cannot** run the same software as the previous chip. As such, the new chip's revision number will increment the major version and set the minor version to 0 (e.g., ``v1.1`` to ``v2.0``).

This versioning scheme was selected to indicate the derivation relationship of chip revisions, and clearly distinguish changes in chips between breaking changes and non-breaking ch"
"anges.

ESP-IDF is designed to execute seamlessly on future chip minor revisions with the same logic as the chip's nearest previous minor revision. Thus，users can directly port their compiled binaries to newer MINOR chip revisions without upgrading their ESP-IDF version and re-compile the whole project.

When a binary is executed on a chip revision of unexpected MAJOR revision, the software is also able to report issues according to the MAJOR revision. The major and minor versioning scheme also "
"allows hardware changes to be branchable.

.. note::

    The current chip revision scheme using major and minor versions was introduced from ESP-IDF v5.0 onwards. Thus bootloaders built using earlier versions of ESP-IDF will still use the legacy chip revision scheme of wafer versions.

EFuse Bits for Chip Revisions


Chips have several eFuse version fields:

- Major wafer version (``WAFER_VERSION_MAJOR`` eFuse)
- Minor wafer version (``WAFER_VERSION_MINOR`` eFuse)
- Ignore maximum revision (``D"
"ISABLE_WAFER_VERSION_MAJOR`` eFuse). See :ref:`revision_limitation` on how this is used.

.. note::

    The previous versioning logic was based on a single eFuse version field (``WAFER_VERSION``). This approach makes it impossible to mark chips as breaking or non-breaking changes, and the versioning logic becomes linear.


Chip Revision APIs


These APIs helps to get chip revision from eFuses:

- :cpp:func:`efuse_hal_chip_revision`. It returns revision in the ``major * 100 + minor`` format.
- :"
"cpp:func:`efuse_hal_get_major_chip_version`. It returns Major revision.
- :cpp:func:`efuse_hal_get_minor_chip_version`. It returns Minor revision.

The following Kconfig definitions (in ``major * 100 + minor`` format) that can help add the chip revision dependency to the code:

- ``CONFIG_{IDF_TARGET_CFG_PREFIX}_REV_MIN_FULL``
- ``CONFIG_ESP_REV_MIN_FULL``
- ``CONFIG_{IDF_TARGET_CFG_PREFIX}_REV_MAX_FULL``
- ``CONFIG_ESP_REV_MAX_FULL``


.. _revision_limitation:

Compatibility Checks of ESP-IDF

"
"
When building an application that needs to support multiple revisions of a particular chip, the minimum and maximum chip revision numbers supported by the build are specified via Kconfig.

The minimum chip revision can be configured via the :ref:`CONFIG_{IDF_TARGET_CFG_PREFIX}_REV_MIN` option. Specifying the minimum chip revision will limit the software to only run on a chip revisions that are high enough to support some features or bugfixes.

The maximum chip revision cannot be configured and "
"is automatically determined by the current ESP-IDF version being used. ESP-IDF will refuse to boot any chip revision exceeding the maximum chip revision. Given that it is impossible for a particular ESP-IDF version to foresee all future chip revisions, the maximum chip revision is usually set to ``maximum supported MAJOR version + 99``. The ""Ignore Maximum Revision"" eFuse can be set to bypass the maximum revision limitation. However, the software is not guaranteed to work if the maximum revision"
" is ignored.

Below is the information about troubleshooting when the chip revision fails the compatibility check. Then there are technical details of the checking and software behavior on earlier version of ESP-IDF.

Troubleshooting


.. code-block:: none

    Image requires chip rev >= v3.0, but chip is v1.0

To resolve this issue,

- Use a chip with the required minimum revision or higher.
- Lower the :ref:`CONFIG_{IDF_TARGET_CFG_PREFIX}_REV_MIN` value and rebuild the image so that it is comp"
"atible with the chip revision being used.

.. code-block:: none

    Image requires chip rev `_
- `Compatibility Between ESP-IDF Releases and Revisions of Espressif SoCs `_
- `SoC Errata `_
- :doc:`/versions`

API Reference


.. include-build-file:: inc/efuse_hal.inc
"
"{IDF_TARGET_NAME} ULP Coprocessor Instruction Set




This document provides details about the instructions used by {IDF_TARGET_NAME} ULP FSM coprocessor assembler.

ULP FSM coprocessor has 4 16-bit general purpose registers, labeled R0, R1, R2, R3. It also has an 8-bit counter register (``stage_cnt``) which can be used to implement loops. Stage count register is accessed using special instructions.

ULP coprocessor can access 8 K bytes of RTC_SLOW_MEM memory region. Memory is addressed in 32-bi"
"t word units. It can also access peripheral registers in ``RTC_CNTL``, ``RTC_IO``, and ``SENS`` peripherals.

All instructions are 32-bit. Jump instructions, ALU instructions, peripheral register and memory access instructions are executed in 1 cycle. Instructions which work with peripherals (TSENS, ADC, I2C) take variable number of cycles, depending on peripheral operation.

The instruction syntax is case insensitive. Upper and lower case letters can be used and intermixed arbitrarily. This is "
"true both for register names and instruction names.

.. _ulp-fsm-addressing:

Note About Addressing


{IDF_TARGET_NAME} ULP FSM coprocessor's ``JUMP``, ``ST``, ``LD`` family of instructions expect the address argument to be expressed in the following way depending on the type of address argument used:

- When the address argument is presented as a label then the instruction expects the address to be expressed as 32-bit words.

  Consider the following example program::

    entry:
            NO"
"P
            NOP
            NOP
            NOP
    loop:
            MOVE R1, loop
            JUMP R1

  When this program is assembled and linked, address of label ``loop`` will be equal to 16 (expressed in bytes). However ``JUMP`` instruction expects the address stored in register ``R1`` to be expressed in 32-bit words. To account for this common use case, the assembler will convert the address of label ``loop`` from bytes to words when generating the ``MOVE`` instruction. Hence, the code "
"generated code will be equivalent to::

    0000    NOP
    0004    NOP
    0008    NOP
    000c    NOP
    0010    MOVE R1, 4
    0014    JUMP R1

- The other case is when the argument of ``MOVE`` instruction is not a label but a constant. In this case, assembler will **use the value as is**, without any conversion::

            .set        val, 0x10
            MOVE        R1, val

  In this case, value loaded into ``R1`` will be ``0x10``.

  However, when an immediate value is used as an off"
"set in ``LD`` and ``ST`` instructions, the assembler considers the address argument in bytes and converts it to 32-bit words before executing the instruction::

            ST R1, R2, 4        // offset = 4 bytes; Mem[R2 + 4 / 4] = R1

  In this case, the value in R1 is stored at the memory location pointed by [R2 + offset / 4].

  Consider the following code::

            .global array
    array:  .long 0
            .long 0
            .long 0
            .long 0

            MOVE R1, array
 "
"           MOVE R2, 0x1234
            ST R2, R1, 0      // write value of R2 into the first array element,
                              // i.e., array[0]

            ST R2, R1, 4      // write value of R2 into the second array element,
                              // (4 byte offset), i.e., array[1]

            ADD R1, R1, 2     // this increments address by 2 words (8 bytes)
            ST R2, R1, 0      // write value of R2 into the third array element,
                              // i.e"
"., array[2]

Note About Instruction Execution Time


ULP coprocessor is clocked from ``RTC_FAST_CLK``, which is normally derived from the internal 8 MHz oscillator. Applications which need to know exact ULP clock frequency can calibrate it against the main XTAL clock::

    #include ""soc/rtc.h""

    // calibrate 8M/256 clock against XTAL, get 8M/256 clock period
    uint32_t rtc_8md256_period = rtc_clk_cal(RTC_CAL_8MD256, 100);
    uint32_t rtc_fast_freq_hz = 1000000ULL * (1 > R3

  2:        RS"
"H R1, R2, 0x03            // R1 = R2 >> 0x03

  3:        .set value1, 0x03           // constant value1=0x03
            RSH R1, R2, value1          // R1 = R2 >> value1

  4:        .global label               // declaration of variable label
            RSH R1, R2, label           // R1 = R2 >> label
    label:  nop                         // definition of variable label


**MOVE** – Move to Register


**Syntax**

  **MOVE**     **Rdst, Rsrc**

  **MOVE**     **Rdst, imm**

**Operands**

  - "
"**Rdst** – Register R[0..3]
  - **Rsrc** – Register R[0..3]
  - **Imm**  – 16-bit signed value

**Cycles**

  2 cycles to execute, 4 cycles to fetch next instruction

**Description**

   The instruction moves the value from the source register or a 16-bit signed value to the destination register.

.. note::

    Note that when a label is used as an immediate, the address of the label will be converted from bytes to words. This is because ``LD``, ``ST``, and ``JUMP`` instructions expect the addre"
"ss register value to be expressed in words rather than bytes. See the section :ref:`ulp-fsm-addressing` for more details.


**Examples**::

  1:        MOVE       R1, R2            // R1 = R2

  2:        MOVE       R1, 0x03          // R1 = 0x03

  3:        .set       value1, 0x03      // constant value1=0x03
            MOVE       R1, value1        // R1 = value1

  4:        .global     label            // declaration of label
            MOVE        R1, label        // R1 = address_of(label"
") / 4
            ...
    label:  nop                          // definition of label


**ST** – Store Data to the Memory


**Syntax**

  **ST**     **Rsrc, Rdst, offset**

**Operands**

  - **Rsrc** – Register R[0..3], holds the 16-bit value to store
  - **Rdst** – Register R[0..3], address of the destination, in 32-bit words
  - **Offset** – 13-bit signed value, offset in bytes

**Cycles**

  4 cycles to execute, 4 cycles to fetch next instruction

**Description**

  The instruction stores the"
" 16-bit value of Rsrc to the lower half-word of memory with address Rdst + offset. The upper half-word is written with the current program counter (PC) (expressed in words, shifted left by 5 bits) OR'd with Rdst (0..3)::

    Mem[Rdst + offset / 4]{31:0} = {PC[10:0], 3'b0, Rdst, Rsrc[15:0]}

  The application can use the higher 16 bits to determine which instruction in the ULP program has written any particular word into memory.

.. note::

    Note that the offset specified in bytes is converte"
"d to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing` for more details.

**Examples**::

  1:        ST  R1, R2, 0x12        // MEM[R2 + 0x12 / 4] = R1

  2:        .data                   // Data section definition
    Addr1:  .word     123           // Define label Addr1 16 bit
            .set      offs, 0x00    // Define constant offs
            .text                   // Text section definition
            MOVE      R1, 1         // R1 = 1
            MOVE  "
"    R2, Addr1     // R2 = Addr1
            ST        R1, R2, offs  // MEM[R2 +  0 / 4] = R1
                                    // MEM[Addr1 + 0] will be 32'h600001

.. only:: esp32s2 or esp32s3

    **STL** – Store Data to the Lower 16 Bits of 32-bit Memory
    

    **Syntax**

      **STL**    **Rsrc, Rdst, offset, Label**

    **Operands**

      - **Rsrc** – Register R[0..3], holds the 16-bit value to store
      - **Rdst** – Register R[0..3], address of the destination, in 32-bit words
  "
"    - **Offset** – 11-bit signed value, offset in bytes
      - **Label** – 2-bit user defined unsigned value

    **Cycles**

      4 cycles to execute, 4 cycles to fetch next instruction

    **Description**

      The instruction stores the 16-bit value of Rsrc to the lower half-word of the memory with address [Rdst + offset / 4]::

        Mem[Rdst + offset / 4]{15:0} = {Rsrc[15:0]}
        Mem[Rdst + offset / 4]{15:0} = {Label[1:0],Rsrc[13:0]}

      The ``ST`` and the ``STL`` commands can "
"be used interchangeably and have been provided to maintain backward compatibility with previous versions of the ULP core.

    .. note::

        Note that the offset specified in bytes is converted to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing` for more details.

    **Examples**::

      1:        STL  R1, R2, 0x12           // MEM[R2 + 0x12 / 4] = R1

      2:        .data                       // Data section definition
        Addr1:  .word     123      "
"         // Define label Addr1 16 bit
                .set      offs, 0x00        // Define constant offs
                .text                       // Text section definition
                MOVE      R1, 1             // R1 = 1
                MOVE      R2, Addr1         // R2 = Addr1
                STL       R1, R2, offs      // MEM[R2 +  0 / 4] = R1
                                            // MEM[Addr1 + 0] will be 32'hxxxx0001
      3:
                MOVE      R1, 1             // R1 "
"= 1
                STL       R1, R2, 0x12, 1   // MEM[R2 + 0x12 / 4] = 0xxxxx4001


    **STH** – Store data to the higher 16 bits of 32-bit memory
    

    **Syntax**

      **STH**     **Rsrc, Rdst, offset, Label**

    **Operands**

      - **Rsrc** – Register R[0..3], holds the 16-bit value to store
      - **Rdst** – Register R[0..3], address of the destination, in 32-bit words
      - **Offset** – 11-bit signed value, offset in bytes
      - **Label** – 2-bit user defined unsigned value
"
"
    **Cycles**

      4 cycles to execute, 4 cycles to fetch next instruction

    **Description**

      The instruction stores the 16-bit value of Rsrc to the upper half-word of memory with address [Rdst + offset / 4]::

        Mem[Rdst + offset / 4]{31:16} = {Rsrc[15:0]}
        Mem[Rdst + offset / 4]{31:16} = {Label[1:0],Rsrc[13:0]}

    .. note::

        Note that the offset specified in bytes is converted to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing"
"` for more details.

    **Examples**::

      1:        STH  R1, R2, 0x12           // MEM[R2 + 0x12 / 4][31:16] = R1

      2:        .data                       // Data section definition
        Addr1:  .word     123               // Define label Addr1 16 bit
                .set      offs, 0x00        // Define constant offs
                .text                       // Text section definition
                MOVE      R1, 1             // R1 = 1
                MOVE      R2, Addr1        "
" // R2 = Addr1
                STH       R1, R2, offs      // MEM[R2 +  0 / 4] = R1
                                            // MEM[Addr1 + 0] will be 32'h0001xxxx
      3:
                MOVE      R1, 1             // R1 = 1
                STH       R1, R2, 0x12, 1   // MEM[R2 + 0x12 / 4] 0x4001xxxx


    **ST32** – Store 32-bits data to the 32-bits memory
    

    **Syntax**

      **ST32**     **Rsrc, Rdst, offset, Label**

    **Operands**

      - **Rsrc** – Register R[0..3], holds th"
"e 16-bit value to store
      - **Rdst** – Register R[0..3], address of the destination, in 32-bit words
      - **Offset** – 11-bit signed value, offset in bytes
      - **Label** – 2-bit user defined unsigned value

    **Cycles**

      4 cycles to execute, 4 cycles to fetch next instruction

    **Description**

      The instruction stores 11 bits of the PC value, label value and the 16-bit value of Rsrc to the 32-bit memory with address [Rdst + offset / 4]::

        Mem[Rdst + offset / 4]"
"{31:0} = {PC[10:0],0[2:0],Label[1:0],Rsrc[15:0]}

    .. note::

        Note that the offset specified in bytes is converted to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing` for more details.

    **Examples**::

      1:        ST32  R1, R2, 0x12, 0       // MEM[R2 + 0x12 / 4][31:0] = {PC[10:0],0[2:0],Label[1:0],Rsrc[15:0]}

      2:        .data                       // Data section definition
        Addr1:  .word     123               // Define label Addr1"
" 16 bit
                .set      offs, 0x00        // Define constant offs
                .text                       // Text section definition
                MOVE      R1, 1             // R1 = 1
                MOVE      R2, Addr1         // R2 = Addr1
                ST32      R1, R2, offs, 1   // MEM[R2 +  0] = {PC[10:0],0[2:0],Label[1:0],Rsrc[15:0]}
                                            // MEM[Addr1 + 0] will be 32'h00010001


    **STO** – Set offset value for auto increment oper"
"ation
    

    **Syntax**

      **STO**     **offset**

    **Operands**

      - **Offset** – 11-bit signed value, offset in bytes

    **Cycles**

      4 cycles to execute, 4 cycles to fetch next instruction

    **Description**

      The instruction sets the 16-bit value to the offset register::

        offset = value / 4

    .. note::

        Note that the offset specified in bytes is converted to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing` for mor"
"e details.

    **Examples**::

      1:        STO  0x12               // Offset = 0x12 / 4

      2:        .data                   // Data section definition
        Addr1:  .word     123           // Define label Addr1 16 bit
                .set      offs, 0x00    // Define constant offs
                .text                   // Text section definition
                STO       offs          // Offset = 0x00


    **STI** – Store data to the 32-bits memory with auto increment of predefined"
" offset address
    

    **Syntax**

      **STI**     **Rsrc, Rdst, Label**

    **Operands**

      - **Rsrc** – Register R[0..3], holds the 16-bit value to store
      - **Rdst** – Register R[0..3], address of the destination, in 32-bit words
      - **Label** – 2-bit user defined unsigned value

    **Cycles**

      4 cycles to execute, 4 cycles to fetch next instruction

    **Description**

      The instruction stores the 16-bit value of Rsrc to the lower and upper half-word of memory w"
"ith address [Rdst + offset / 4].

      The offset value is auto incremented when the STI instruction is called twice. Make sure to execute the ``STO`` instruction to set the offset value before executing the STI instruction::

        Mem[Rdst + offset / 4]{15:0/31:16} = {Rsrc[15:0]}
        Mem[Rdst + offset / 4]{15:0/31:16} = {Label[1:0],Rsrc[13:0]}

    **Examples**::

      1:        STO  4                  // Set offset to 4
                STI  R1, R2             // MEM[R2 + 4 / 4][15:0] "
"= R1
                STI  R1, R2             // MEM[R2 + 4 / 4][31:16] = R1
                                        // offset += (1 * 4) //offset is incremented by 1 word
                STI  R1, R2             // MEM[R2 + 8 / 4][15:0] = R1
                STI  R1, R2             // MEM[R2 + 8 / 4][31:16] = R1


    **STI32** – Store 32-bits data to the 32-bits memory with auto increment of address offset
    

    **Syntax**

      **STI32**     **Rsrc, Rdst, Label**

    **Operands**

      - "
"**Rsrc** – Register R[0..3], holds the 16-bit value to store
      - **Rdst** – Register R[0..3], address of the destination, in 32-bit words
      - **Label** – 2-bit user defined unsigned value

    **Cycles**

      4 cycles to execute, 4 cycles to fetch next instruction

    **Description**

      The instruction stores 11 bits of the PC value, label value and the 16-bit value of Rsrc to the 32-bit memory with address [Rdst + offset / 4].

      The offset value is auto incremented each time"
" the STI32 instruction is called. Make sure to execute the ``STO`` instruction to set the offset value before executing the STI32 instruction::

        Mem[Rdst + offset / 4]{31:0} = {PC[10:0],0[2:0],Label[1:0],Rsrc[15:0]}

    **Examples**::

      1:        STO    0x12
                STI32  R1, R2, 0    // MEM[R2 + 0x12 / 4][31:0] = {PC[10:0],0[2:0],Label[1:0],Rsrc[15:0]}
                                    // offset += (1 * 4) //offset is incremented by 1 word
                STI32  R1, R2,"
" 0    // MEM[R2 + 0x16 / 4][31:0] = {PC[10:0],0[2:0],Label[1:0],Rsrc[15:0]}


**LD** – Load Data from the Memory


**Syntax**

   **LD**      **Rdst, Rsrc, offset**

**Operands**

   - **Rdst** – Register R[0..3], destination
   - **Rsrc** – Register R[0..3], holds address of destination, in 32-bit words
   - **Offset** – 13-bit signed value, offset in bytes

**Cycles**

  4 cycles to execute, 4 cycles to fetch next instruction

**Description**

   The instruction loads the lower 16-bit half-wor"
"d from memory with address [Rsrc + offset / 4] into the destination register Rdst::

     Rdst[15:0] = Mem[Rsrc + offset / 4][15:0]

.. note::

    Note that the offset specified in bytes is converted to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing` for more details.

**Examples**::

  1:        LD  R1, R2, 0x12            // R1 = MEM[R2 + 0x12 / 4]

  2:        .data                       // Data section definition
    Addr1:  .word     123               // De"
"fine label Addr1 16 bit
            .set      offs, 0x00        // Define constant offs
            .text                       // Text section definition
            MOVE      R1, 1             // R1 = 1
            MOVE      R2, Addr1         // R2 = Addr1 / 4 (address of label is converted into words)
            LD        R1, R2, offs      // R1 = MEM[R2 +  0]
                                        // R1 will be 123

.. only:: esp32s2 or esp32s3

    **LDL** – Load Data from the Lower Half-"
"Word of the 32-bit Memory
    

    **Syntax**

       **LDL**     **Rdst, Rsrc, offset**

    **Operands**

       - **Rdst** – Register R[0..3], destination
       - **Rsrc** – Register R[0..3], holds address of destination, in 32-bit words
       - **Offset** – 13-bit signed value, offset in bytes

    **Cycles**

      4 cycles to execute, 4 cycles to fetch next instruction

    **Description**

       The instruction loads the lower 16-bit half-word from memory with address [Rsrc + offset /"
" 4] into the destination register Rdst::

         Rdst[15:0] = Mem[Rsrc + offset / 4][15:0]

       The ``LD`` and the ``LDL`` commands can be used interchangeably and have been provided to maintain backward compatibility with previous versions of the ULP core.

    .. note::

        Note that the offset specified in bytes is converted to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing` for more details.

    **Examples**::

      1:        LDL  R1, R2, 0x12    "
"       // R1 = MEM[R2 + 0x12 / 4]

      2:        .data                       // Data section definition
        Addr1:  .word     123               // Define label Addr1 16 bit
                .set      offs, 0x00        // Define constant offs
                .text                       // Text section definition
                MOVE      R1, 1             // R1 = 1
                MOVE      R2, Addr1         // R2 = Addr1 / 4 (address of label is converted into words)
                LDL    "
"   R1, R2, offs      // R1 = MEM[R2 +  0]
                                            // R1 will be 123


    **LDH** – Load data from upper half-word of the 32-bit memory
    

    **Syntax**

       **LDH**     **Rdst, Rsrc, offset**

    **Operands**

       - **Rdst**  – Register R[0..3], destination
       - **Rsrc** – Register R[0..3], holds address of destination, in 32-bit words
       - **Offset** – 13-bit signed value, offset in bytes

    **Cycles**

      4 cycles to execute, 4 cycle"
"s to fetch next instruction

    **Description**

       The instruction loads the upper 16-bit half-word from memory with address [Rsrc + offset / 4] into the destination register Rdst::

         Rdst[15:0] = Mem[Rsrc + offset / 4][15:0]

    .. note::

        Note that the offset specified in bytes is converted to a 32-bit word offset before execution. See the section :ref:`ulp-fsm-addressing` for more details.

    **Examples**::

      1:        LDH  R1, R2, 0x12           // R1 = MEM[R2 +"
" 0x12 / 4]

      2:        .data                       // Data section definition
        Addr1:  .word     0x12345678        // Define label Addr1 16 bit
                .set      offs, 0x00        // Define constant offs
                .text                       // Text section definition
                MOVE      R1, 1             // R1 = 1
                MOVE      R2, Addr1         // R2 = Addr1 / 4 (address of label is converted into words)
                LDH       R1, R2, offs      //"
" R1 = MEM[R2 +  0]
                                            // R1 will be 0x1234


**JUMP** – Jump to an Absolute Address


**Syntax**

  **JUMP**        **Rdst**

  **JUMP**        **ImmAddr**

  **JUMP**        **Rdst, Condition**

  **JUMP**        **ImmAddr, Condition**


**Operands**

  - **Rdst** – Register R[0..3] containing address to jump to (expressed in 32-bit words)
  - **ImmAddr** – 13 bits address (expressed in bytes), aligned to 4 bytes
  - **Condition**:
    - EQ – jump if the"
" last ALU operation result was zero
    - OV – jump if the last ALU has set overflow flag

**Cycles**

  2 cycles to execute, 2 cycles to fetch next instruction.

**Description**

  The instruction makes jump to the specified address. Jump can be either unconditional or based on an ALU flag.

**Examples**::

  1:        JUMP       R1            // Jump to address in R1 (address in R1 is in 32-bit words)

  2:        JUMP       0x120, EQ     // Jump to address 0x120 (in bytes) if ALU result is ze"
"ro

  3:        JUMP       label         // Jump to label
            ...
    label:  nop                      // Definition of label

  4:        .global    label         // Declaration of global label

            MOVE       R1, label     // R1 = label (value loaded into R1 is in words)
            JUMP       R1            // Jump to label
            ...
    label:  nop                      // Definition of label


**JUMPR** – Jump to a Relative Offset (Condition Based on R0)


**Syntax**

  "
" **JUMPR**        **Step, Threshold, Condition**

**Operands**

   - **Step**          – relative shift from current position, in bytes
   - **Threshold**     – threshold value for branch condition
   - **Condition**:
      - **EQ** (equal) – jump if value in R0 == threshold
      - **LT** (less than) – jump if value in R0  threshold
      - **GE** (greater or equal) – jump if value in R0 >= threshold

**Cycles**

.. only:: esp32

    Conditions **LT**, **GE**, **LE** and **GT**: 2 cycles to exe"
"cute, 2 cycles to fetch next instruction.

    Conditions **LE** and **GT** are implemented in the assembler using one **JUMPR** instruction::

      // JUMPR target, threshold, GT is implemented as:

               JUMPR target, threshold+1, GE

      // JUMPR target, threshold, LE is implemented as:

               JUMPR target, threshold + 1, LT

    Conditions **EQ** is implemented in the assembler using two **JUMPR** instructions::

      // JUMPR target, threshold, EQ is implemented as:

 "
"              JUMPR next, threshold + 1, GE
               JUMPR target, threshold, GE
      next:


.. only:: esp32s2 or esp32s3

    Conditions **EQ**, **GT** and **LT**: 2 cycles to execute, 2 cycles to fetch next instruction.

    Conditions **LE** and **GE** are implemented in the assembler using two **JUMPR** instructions::

      // JUMPR target, threshold, LE is implemented as:

               JUMPR target, threshold, EQ
               JUMPR target, threshold, LT

      // JUMPR target, "
"threshold, GE is implemented as:

               JUMPR target, threshold, EQ
               JUMPR target, threshold, GT

    Therefore the execution time depends on the branches taken: either 2 cycles to execute + 2 cycles to fetch, or 4 cycles to execute + 4 cycles to fetch.


**Description**

   The instruction makes a jump to a relative address if condition is true. Condition is the result of comparison of R0 register value and the threshold value.

**Examples**::

  1:pos:    JUMPR       16,"
" 20, GE   // Jump to address (position + 16 bytes) if value in R0 >= 20

  2:        // Down counting loop using R0 register
            MOVE        R0, 16       // load 16 into R0
    label:  SUB         R0, R0, 1    // R0--
            NOP                      // do something
            JUMPR       label, 1, GE // jump to label if R0 >= 1


**JUMPS** – Jump to a Relative Address (Condition Based on Stage Count)


**Syntax**

   **JUMPS**        **Step, Threshold, Condition**

**Operands**

  "
" - **Step** – relative shift from current position, in bytes
   - **Threshold**  – threshold value for branch condition
   - **Condition**:
       - **EQ** (equal) – jump if value in stage_cnt == threshold
       - **LT** (less than) –  jump if value in stage_cnt  threshold
       - **GE** (greater or equal) — jump if value in stage_cnt >= threshold

**Cycles**

.. only:: esp32

    Conditions **LE**, **LT**, **GE**: 2 cycles to execute, 2 cycles to fetch next instruction.

    Conditions **EQ**"
", **GT** are implemented in the assembler using two **JUMPS** instructions::

      // JUMPS target, threshold, EQ is implemented as:

               JUMPS next, threshold, LT
               JUMPS target, threshold, LE
      next:

      // JUMPS target, threshold, GT is implemented as:

               JUMPS next, threshold, LE
               JUMPS target, threshold, GE
      next:

    Therefore the execution time depends on the branches taken: either 2 cycles to execute + 2 cycles to fetch, or"
" 4 cycles to execute + 4 cycles to fetch.


.. only:: esp32s2 or esp32s3

    2 cycles to execute, 2 cycles to fetch next instruction.


**Description**

    The instruction makes a jump to a relative address if condition is true. Condition is the result of comparison of count register value and threshold value.

**Examples**::

   1:pos:    JUMPS     16, 20, EQ     // Jump to (position + 16 bytes) if stage_cnt == 20

   2:        // Up counting loop using stage count register
             STAGE"
"_RST                  // set stage_cnt to 0
     label:  STAGE_INC  1               // stage_cnt++
             NOP                        // do something
             JUMPS       label, 16, LT  // jump to label if stage_cnt  0


**HALT** – End the Program


**Syntax**

  **HALT**

**Operands**

  No operands

**Cycles**

  2 cycles to execute

**Description**

    The instruction halts the ULP coprocessor and restarts the ULP wakeup timer, if it is enabled

**Examples**::

    1:       HALT    "
"  // Halt the coprocessor


**WAKE** – Wake up the Chip


**Syntax**

   **WAKE**

**Operands**

  No operands

**Cycles**

  2 cycles to execute, 4 cycles to fetch next instruction

**Description**

  The instruction sends an interrupt from the ULP coprocessor to the RTC controller.

  - If the SoC is in deep sleep mode, and ULP wakeup is enabled, this causes the SoC to wake up.

  - If the SoC is not in deep sleep mode, and ULP interrupt bit (RTC_CNTL_ULP_CP_INT_ENA) is set in RTC_CNTL_INT_ENA"
"_REG register, RTC interrupt will be triggered.

.. note::

  Note that before using WAKE instruction, ULP program may need to wait until RTC controller is ready to wake up the main CPU. This is indicated using RTC_CNTL_RDY_FOR_WAKEUP bit of RTC_CNTL_LOW_POWER_ST_REG register. If WAKE instruction is executed while RTC_CNTL_RDY_FOR_WAKEUP is zero, it has no effect (wake up does not occur). If the WAKE instruction is intended to be used while the main CPU is not in sleep mode then the RTC_CNTL_MAI"
"N_STATE_IN_IDLE (bit 27) of RTC_CNTL_LOW_POWER_ST_REG can be used to check whether main CPU is in normal mode or sleep mode.

**Examples**::

  1: is_rdy_for_wakeup:                   // Read RTC_CNTL_RDY_FOR_WAKEUP bit
            READ_RTC_FIELD(RTC_CNTL_LOW_POWER_ST_REG, RTC_CNTL_RDY_FOR_WAKEUP)
            AND r0, r0, 1
            JUMP is_rdy_for_wakeup, eq    // Retry until the bit is set
            WAKE                          // Trigger wake up
            REG_WR 0x006, 24, 24, 0       "
"// Stop ULP timer (clear RTC_CNTL_ULP_CP_SLP_TIMER_EN)
            HALT                          // Stop the ULP program
            // After these instructions, SoC will wake up,
            // and ULP will not run again until started by the main program.

  1: check_wakeup:                        // Read RTC_CNTL_RDY_FOR_WAKEUP and RTC_CNTL_MAIN_STATE_IN_IDLE bit
            READ_RTC_REG(RTC_CNTL_LOW_POWER_ST_REG, 27, 1)
            MOVE r1, r0                   // Copy result in to r1
       "
"     READ_RTC_FIELD(RTC_CNTL_LOW_POWER_ST_REG, RTC_CNTL_RDY_FOR_WAKEUP)
            OR r0, r0, r1
            JUMP check_wakeup, eq         // Retry until either of the bit are set
            WAKE                          // Trigger wake up
            HALT                          // Stop the ULP program


.. only:: esp32

    **SLEEP** – Set ULP Wakeup Timer Period
    

    **Syntax**

      **SLEEP**   **sleep_reg**

    **Operands**

       - **sleep_reg** – 0..4, selects one of ``SENS_ULP"
"_CP_SLEEP_CYCx_REG`` registers

    **Cycles**

      2 cycles to execute, 4 cycles to fetch next instruction

    **Description**

       The instruction selects which of the ``SENS_ULP_CP_SLEEP_CYCx_REG`` (x = 0..4) register values is to be used by the ULP wakeup timer as wakeup period. By default, the value from ``SENS_ULP_CP_SLEEP_CYC0_REG`` is used

    **Examples**::

      1:        SLEEP     1         // Use period set in SENS_ULP_CP_SLEEP_CYC1_REG

      2:        .set sleep_reg, 4   //"
" Set constant
                SLEEP  sleep_reg    // Use period set in SENS_ULP_CP_SLEEP_CYC4_REG


**WAIT** – Wait Some Number of Cycles


**Syntax**

  **WAIT**   **Cycles**

**Operands**

  - **Cycles** – number of cycles for wait

**Cycles**

  (2 + **Cycles**) cycles to execute, 4 cycles to fetch next instruction

**Description**

  The instruction delays for a given number of cycles.

**Examples**::

  1:        WAIT     10         // Do nothing for 10 cycles

  2:        .set  wait_cnt, 1"
"0  // Set a constant
            WAIT  wait_cnt      // wait for 10 cycles

.. only:: not esp32

    **TSENS** – Do Measurement with Temperature Sensor
    

    **Syntax**

      - **TSENS**   **Rdst, Wait_Delay**

    **Operands**

      - **Rdst** – Destination Register R[0..3], result will be stored to this register
      - **Wait_Delay** – number of cycles used to perform the measurement

    **Cycles**

      (2 + **Wait_Delay** + 3 * TSENS_CLK) to execute, 4 cycles to fetch next instructi"
"on

    **Description**

      The instruction performs measurement using TSENS and stores the result into a general purpose register

    **Examples**::

      1:        TSENS     R1, 1000     // Measure temperature sensor for 1000 cycles,
                                      // and store result to R1


**ADC** – Do Measurement with ADC


**Syntax**

  - **ADC**   **Rdst, Sar_sel, Mux**

  - **ADC**   **Rdst, Sar_sel, Mux, 0** — deprecated form

**Operands**

  - **Rdst** – Destination Registe"
"r R[0..3], result will be stored to this register
  - **Sar_sel** – Select ADC: 0 = SARADC1, 1 = SARADC2

.. only:: esp32

  - **Mux**  - Enable ADC channel. Channel number is [Mux-1]. If the user passes Mux value 1, then ADC channel 0 gets used.

.. only:: esp32s2 or esp32s3

  - **Mux**  -  selected PAD, SARADC Pad[Mux-1] is enabled. If the user passes Mux value 1, then ADC pad 0 gets used.

**Cycles**

  ``23 + max(1, SAR_AMP_WAIT1) + max(1, SAR_AMP_WAIT2) + max(1, SAR_AMP_WAIT3) + SARx_SAMPL"
"E_CYCLE + SARx_SAMPLE_BIT`` cycles to execute, 4 cycles to fetch next instruction

**Description**

  The instruction makes measurements from ADC

.. only:: esp32

    **Examples**::

        1:        ADC      R1, 0, 1      // Measure value using ADC1 channel 0 and store result into R1

.. only:: esp32s2 or esp32s3

    **Examples**::

        1:        ADC      R1, 0, 1      // Measure value using ADC1 pad 2 and store result into R1

.. only:: esp32

    **I2C_RD** - Read Single Byte from I2C "
"Slave
    

    **Syntax**

      - **I2C_RD**   **Sub_addr, High, Low, Slave_sel**

    **Operands**

      - **Sub_addr** – Address within the I2C slave to read
      - **High*, *Low** — Define range of bits to read. Bits outside of [High, Low] range are masked
      - **Slave_sel**  -  Index of I2C slave address to use

    **Cycles**

      Execution time mostly depends on I2C communication time. 4 cycles to fetch next instruction

    **Description**

      ``I2C_RD`` instruction reads one "
"byte from I2C slave with index ``Slave_sel``. Slave address (in 7-bit format) has to be set in advance into ``SENS_I2C_SLAVE_ADDRx`` register field, where ``x == Slave_sel``. 8 bits of read result is stored into ``R0`` register.

    **Examples**::

       1:        I2C_RD      0x10, 7, 0, 0      // Read byte from sub-address 0x10 of slave with address set in SENS_I2C_SLAVE_ADDR0


    **I2C_WR** - write single byte to I2C slave
    

    **Syntax**

      - **I2C_WR**   **Sub_addr, Value, High,"
" Low, Slave_sel**

    **Operands**

      - **Sub_addr** – Address within the I2C slave to write
      - **Value** – 8-bit value to be written
      - **High**, **Low** — Define range of bits to write. Bits outside of [High, Low] range are masked
      - **Slave_sel** - Index of I2C slave address to use

    **Cycles**

      Execution time mostly depends on I2C communication time. 4 cycles to fetch next instruction

    **Description**

      ``I2C_WR`` instruction writes one byte to I2C slave"
" address with index ``Slave_sel``. Slave address (in 7-bit format) has to be set in advance into the ``SENS_I2C_SLAVE_ADDRx`` register field, where ``x == Slave_sel``.

    **Examples**::

        1:        I2C_WR      0x20, 0x33, 7, 0, 1      // Write byte 0x33 to sub-address 0x20 of slave with address set in SENS_I2C_SLAVE_ADDR1.


**REG_RD** – Read from Peripheral Register


**Syntax**

   **REG_RD**   **Addr, High, Low**

**Operands**

  - **Addr** – Register address, in 32-bit words
  - **H"
"igh** – Register end bit number
  - **Low** – Register start bit number

**Cycles**

  4 cycles to execute, 4 cycles to fetch next instruction

**Description**

  The instruction reads up to 16 bits from a peripheral register into a general purpose register: ``R0 = REG[Addr][High:Low]``.

.. only:: esp32

  This instruction can access registers in RTC_CNTL, RTC_IO, SENS, and RTC_I2C peripherals. Address of the register, as seen from the ULP, can be calculated from the address of the same registe"
"r on the DPORT bus as follows::

    addr_ulp = (addr_dport - DR_REG_RTCCNTL_BASE) / 4

.. only:: esp32s2 or esp32s3

  This instruction can access registers in RTC_CNTL, RTC_IO, SENS, and RTC_I2C peripherals. Address of the register, as seen from the ULP, can be calculated from the address of the same register on the PeriBUS1 as follows::

    addr_ulp = (addr_peribus1 - DR_REG_RTCCNTL_BASE) / 4

**Examples**::

  1:        REG_RD      0x120, 7, 4     // load 4 bits: R0 = {12'b0, REG[0x120][7:4"
"]}


**REG_WR** – Write to Peripheral Register


**Syntax**

  **REG_WR**   **Addr, High, Low, Data**

**Operands**

  - **Addr** – Register address, in 32-bit words
  - **High** – Register end bit number
  - **Low** – Register start bit number
  - **Data** – Value to write, 8 bits

**Cycles**

  8 cycles to execute, 4 cycles to fetch next instruction

**Description**

  The instruction writes up to 8 bits from an immediate data value into a peripheral register: ``REG[Addr][High:Low] = data``.

"
"  .. only:: esp32

    This instruction can access registers in RTC_CNTL, RTC_IO, SENS, and RTC_I2C peripherals. Address of the register, as seen from the ULP, can be calculated from the address of the same register on the DPORT bus as follows::

      addr_ulp = (addr_dport - DR_REG_RTCCNTL_BASE) / 4

  .. only:: esp32s2 or esp32s3

    This instruction can access registers in RTC_CNTL, RTC_IO, SENS, and RTC_I2C peripherals. Address of the register, as seen from the ULP, can be calculated from "
"the address of the same register on the PeriBUS1 as follows::

      addr_ulp = (addr_peribus1 - DR_REG_RTCCNTL_BASE) / 4

**Examples**::

    1:        REG_WR      0x120, 7, 0, 0x10   // set 8 bits: REG[0x120][7:0] = 0x10


Convenience Macros for Peripheral Registers Access


ULP source files are passed through C preprocessor before the assembler. This allows certain macros to be used to facilitate access to peripheral registers.

Some existing macros are defined in ``soc/soc_ulp.h`` header fil"
"e. These macros allow access to the fields of peripheral registers by their names. Peripheral registers' names which can be used with these macros are the ones defined in ``soc/rtc_cntl_reg.h``, ``soc/rtc_io_reg.h``, ``soc/sens_reg.h``, and ``soc/rtc_i2c_reg.h``.

READ_RTC_REG(rtc_reg, low_bit, bit_width)
  Read up to 16 bits from rtc_reg[low_bit + bit_width - 1 : low_bit] into R0. For example::

    #include ""soc/soc_ulp.h""
    #include ""soc/rtc_cntl_reg.h""

    /* Read 16 lower bits of RTC_CNT"
"L_TIME0_REG into R0 */
    READ_RTC_REG(RTC_CNTL_TIME0_REG, 0, 16)

READ_RTC_FIELD(rtc_reg, field)
  Read from a field in rtc_reg into R0, up to 16 bits. For example::

    #include ""soc/soc_ulp.h""
    #include ""soc/sens_reg.h""

    /* Read 8-bit SENS_TSENS_OUT field of SENS_SAR_SLAVE_ADDR3_REG into R0 */
    READ_RTC_FIELD(SENS_SAR_SLAVE_ADDR3_REG, SENS_TSENS_OUT)

WRITE_RTC_REG(rtc_reg, low_bit, bit_width, value)
  Write immediate value into rtc_reg[low_bit + bit_width - 1 : low_bit], bit_widt"
"h <= 8. For example::

    #include ""soc/soc_ulp.h""
    #include ""soc/rtc_io_reg.h""

    /* Set BIT(2) of RTC_GPIO_OUT_DATA_W1TS field in RTC_GPIO_OUT_W1TS_REG */
    WRITE_RTC_REG(RTC_GPIO_OUT_W1TS_REG, RTC_GPIO_OUT_DATA_W1TS_S + 2, 1, 1)

WRITE_RTC_FIELD(rtc_reg, field, value)
  Write immediate value into a field in rtc_reg, up to 8 bits. For example::

    #include ""soc/soc_ulp.h""
    #include ""soc/rtc_cntl_reg.h""

    /* Set RTC_CNTL_ULP_CP_SLP_TIMER_EN field of RTC_CNTL_STATE0_REG to 0 */
 "
"   WRITE_RTC_FIELD(RTC_CNTL_STATE0_REG, RTC_CNTL_ULP_CP_SLP_TIMER_EN, 0)
"
"eFuse Manager


{IDF_TARGET_CODING_SCHEMES:default=""Reed-Solomon"", esp32=""3/4 or Repeat""}


Introduction


The eFuse Manager library is designed to structure access to eFuse bits and make using these easy. This library operates eFuse bits by a structure name which is assigned in eFuse table. This sections introduces some concepts used by eFuse Manager.


Hardware Description


The {IDF_TARGET_NAME} has a number of eFuses which can store system and user parameters. Each eFuse is a one-bit field w"
"hich can be programmed to 1 after which it cannot be reverted back to 0.
Some of system parameters are using these eFuse bits directly by hardware modules and have special place (for example EFUSE_BLK0).

For more details, see **{IDF_TARGET_NAME} Technical Reference Manual** > **eFuse Controller (eFuse)** [`PDF `__]. Some eFuse bits are available for user applications.

.. only:: esp32

    {IDF_TARGET_NAME} has 4 eFuse blocks each of the size of 256 bits (not all bits are available):

.. only::"
" not esp32 and not esp32c2

  .. list::

    {IDF_TARGET_NAME} has 11 eFuse blocks each of the size of 256 bits (not all bits are available):
    :SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK and SOC_ECDSA_SUPPORTED: * EFUSE_BLK9 (also named EFUSE_BLK_KEY5) can be used for any purpose except for flash encryption or ECDSA (due to a HW bug);
    :SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK and not SOC_ECDSA_SUPPORTED: * EFUSE_BLK9 (also named EFUSE_BLK_KEY5) can be used for any purpose except for flash encryption (d"
"ue to a HW bug);
    :not SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK: * EFUSE_BLK9 (also named EFUSE_BLK_KEY5) can be used as key (for secure_boot or flash_encryption) or for user purposes;

.. only:: esp32c2

    {IDF_TARGET_NAME} has 4 eFuse blocks each of the size of 256 bits (not all bits are available):

Each block is divided into 8 32-bits registers.


eFuse Manager Component


The component has API functions for reading and writing fields. Access to the fields is carried out through the structure"
"s that describe the location of the eFuse bits in the blocks. The component provides the ability to form fields of any length and from any number of individual bits. The description of the fields is made in a CSV file in a table form. To generate from a tabular form (CSV file) in the C-source uses the tool ``efuse_table_gen.py``. The tool checks the CSV file for uniqueness of field names and bit intersection, in case of using a `custom` file from the user's project directory, the utility checks "
"with the `common` CSV file.

CSV files:


Description CSV File


The CSV file contains a description of the eFuse fields. In the simple case, one field has one line of description.
Table header:

{IDF_TARGET_MAX_EFUSE_BLK:default = ""EFUSE_BLK10"", esp32 = ""EFUSE_BLK3"", esp32c2 = ""EFUSE_BLK3""}

.. code-block:: none

    # field_name,  efuse_block(EFUSE_BLK0..{IDF_TARGET_MAX_EFUSE_BLK}), bit_start(0..255),    bit_count(1..256),        comment

Individual params in CSV file the following meanings:

"
"field_name

    Name of field. The prefix `ESP_EFUSE_` is added to the name, and this field name is available in the code. This name is used to access the fields. The name must be unique for all fields. If the line has an empty name, then this line is combined with the previous field. This allows you to set an arbitrary order of bits in the field, and expand the field as well (see ``MAC_FACTORY`` field in the common table). The field_name supports structured format using `.` to show that the fie"
"ld belongs to another field (see ``WR_DIS`` and ``RD_DIS`` in the common table).

efuse_block

    Block number. It determines where the eFuse bits are placed for this field. Available EFUSE_BLK0..{IDF_TARGET_MAX_EFUSE_BLK}.

bit_start

    Start bit number (0..255). The bit_start field can be omitted. In this case, it is set to bit_start + bit_count from the previous record, if it has the same efuse_block. Otherwise (if efuse_block is different, or this is the first entry), an error will be gen"
"erated.

.. only:: esp32

    bit_count

        The number of bits to use in this field (1..-). This parameter cannot be omitted. This field also may be ``MAX_BLK_LEN`` in this case, the field length has the maximum block length, taking into account the coding scheme (applicable for ``ESP_EFUSE_SECURE_BOOT_KEY`` and ``ESP_EFUSE_ENCRYPT_FLASH_KEY`` fields). The value ``MAX_BLK_LEN`` depends on :ref:`CONFIG_EFUSE_CODE_SCHEME_SELECTOR`, which will be replaced with ""None"" - 256, ""3/4"" - 192, ""REPEA"
"T"" - 128.

.. only:: not esp32

    bit_count

        The number of bits to use in this field (1..-). This parameter cannot be omitted. This field also may be ``MAX_BLK_LEN`` in this case, the field length has the maximum block length.

comment

    This param is using for comment field, it also move to C-header file. The comment field can be omitted.

If a non-sequential bit order is required to describe a field, then the field description in the following lines should be continued without spe"
"cifying a name, indicating that it belongs to one field. For example two fields ``MAC_FACTORY`` and ``MAC_FACTORY_CRC``:

.. code-block:: none

    # Factory MAC address #
    #######################
    MAC_FACTORY,            EFUSE_BLK0,    72,    8,    Factory MAC addr [0]
    ,                       EFUSE_BLK0,    64,    8,    Factory MAC addr [1]
    ,                       EFUSE_BLK0,    56,    8,    Factory MAC addr [2]
    ,                       EFUSE_BLK0,    48,    8,    Factory MAC a"
"ddr [3]
    ,                       EFUSE_BLK0,    40,    8,    Factory MAC addr [4]
    ,                       EFUSE_BLK0,    32,    8,    Factory MAC addr [5]
    MAC_FACTORY_CRC,        EFUSE_BLK0,    80,    8,    CRC8 for factory MAC address

This field is available in code as ``ESP_EFUSE_MAC_FACTORY`` and ``ESP_EFUSE_MAC_FACTORY_CRC``.

.. _structured-efuse-fields:

Structured eFuse Fields


.. code-block:: none

    WR_DIS,                           EFUSE_BLK0,   0,    32,     Write prote"
"ction
    WR_DIS.RD_DIS,                    EFUSE_BLK0,   0,    1,      Write protection for RD_DIS
    WR_DIS.FIELD_1,                   EFUSE_BLK0,   1,    1,      Write protection for FIELD_1
    WR_DIS.FIELD_2,                   EFUSE_BLK0,   2,    4,      Write protection for FIELD_2 (includes B1 and B2)
    WR_DIS.FIELD_2.B1,                EFUSE_BLK0,   2,    2,      Write protection for FIELD_2.B1
    WR_DIS.FIELD_2.B2,                EFUSE_BLK0,   4,    2,      Write protection for FIEL"
"D_2.B2
    WR_DIS.FIELD_3,                   EFUSE_BLK0,   5,    1,      Write protection for FIELD_3
    WR_DIS.FIELD_3.ALIAS,             EFUSE_BLK0,   5,    1,      Write protection for FIELD_3 (just a alias for WR_DIS.FIELD_3)
    WR_DIS.FIELD_4,                   EFUSE_BLK0,   7,    1,      Write protection for FIELD_4

The structured eFuse field looks like ``WR_DIS.RD_DIS`` where the dot points that this field belongs to the parent field - ``WR_DIS`` and cannot be out of the parent's range"
".

It is possible to use some levels of structured fields as WR_DIS.FIELD_2.B1 and B2. These fields should not be crossed each other and should be in the range of two fields: ``WR_DIS`` and ``WR_DIS.FIELD_2``.

It is possible to create aliases for fields with the same range, see ``WR_DIS.FIELD_3`` and ``WR_DIS.FIELD_3.ALIAS``.

The ESP-IDF names for structured eFuse fields should be unique. The ``efuse_table_gen`` tool generates the final names where the dot is replaced by ``_``. The names for u"
"sing in ESP-IDF are ESP_EFUSE_WR_DIS, ESP_EFUSE_WR_DIS_RD_DIS, ESP_EFUSE_WR_DIS_FIELD_2_B1, etc.

The ``efuse_table_gen`` tool checks that the fields do not overlap each other and must be within the range of a field if there is a violation, then throws the following error:

.. code-block:: none

    Field at USER_DATA, EFUSE_BLK3, 0, 256  intersected with  SERIAL_NUMBER, EFUSE_BLK3, 0, 32

Solution: Describe ``SERIAL_NUMBER`` to be included in ``USER_DATA``. (``USER_DATA.SERIAL_NUMBER``).

.. co"
"de-block:: none

    Field at FEILD, EFUSE_BLK3, 0, 50  out of range  FEILD.MAJOR_NUMBER, EFUSE_BLK3, 60, 32

Solution: Change ``bit_start`` for ``FIELD.MAJOR_NUMBER`` from 60 to 0, so ``MAJOR_NUMBER`` is in the ``FEILD`` range.

``efuse_table_gen.py`` Tool


The tool is designed to generate C-source files from CSV file and validate fields. First of all, the check is carried out on the uniqueness of the names and overlaps of the field bits. If an additional `custom` file is used, it will be chec"
"ked with the existing `common` file (esp_efuse_table.csv). In case of errors, a message will be displayed and the string that caused the error. C-source files contain structures of type `esp_efuse_desc_t`.

To generate a `common` files, use the following command ``idf.py efuse-common-table`` or:

.. code-block:: bash

    cd $IDF_PATH/components/efuse/
    ./efuse_table_gen.py --idf_target {IDF_TARGET_PATH_NAME} {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv

After generation in the folder $IDF_PATH"
"/components/efuse/`{IDF_TARGET_PATH_NAME}` create:

To generate a `custom` files, use the following command ``idf.py efuse-custom-table`` or:

.. code-block:: bash

    cd $IDF_PATH/components/efuse/
    ./efuse_table_gen.py --idf_target {IDF_TARGET_PATH_NAME} {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv PROJECT_PATH/main/esp_efuse_custom_table.csv

After generation in the folder PROJECT_PATH/main create:

To use the generated fields, you need to include two files:

.. code-block:: c

    #include"
" ""esp_efuse.h""
    #include ""esp_efuse_table.h"" // or ""esp_efuse_custom_table.h""


Supported Coding Scheme


.. only:: esp32

    eFuse have three coding schemes:

    The coding scheme affects only EFUSE_BLK1, EFUSE_BLK2 and EFUSE_BLK3 blocks. EUSE_BLK0 block always has a coding scheme ``None``.
    Coding changes the number of bits that can be written into a block, the block length is constant 256, some of these bits are used for encoding and not avaliable for the user.

    When using a codin"
"g scheme, the length of the payload that can be written is limited (for more details ``20.3.1.3 System Parameter coding_scheme``):

    You can find out the coding scheme of your chip:

    eFuse tables must always comply with the coding scheme in the chip. There is an :ref:`CONFIG_EFUSE_CODE_SCHEME_SELECTOR` option to select the coding type for tables in a Kconfig. When generating source files, if your tables do not follow the coding scheme, an error message will be displayed. Adjust the length"
" or offset fields.
    If your program was compiled with ``None`` encoding and ``3/4`` is used in the chip, then the ``ESP_ERR_CODING`` error may occur when calling the eFuse API (the field is outside the block boundaries). If the field matches the new block boundaries, then the API will work without errors.

    Also, 3/4 coding scheme imposes restrictions on writing bits belonging to one coding unit. The whole block with a length of 256 bits is divided into 4 coding units, and in each coding u"
"nit there are 6 bytes of useful data and 2 service bytes. These 2 service bytes contain the checksum of the previous 6 data bytes.

    It turns out that only one field can be written into one coding unit. Repeated rewriting in one coding unit is prohibited. But if the record was made in advance or through a :cpp:func:`esp_efuse_write_block` function, then reading the fields belonging to one coding unit is possible.

    In case ``3/4`` coding scheme, the writing process is divided into the codi"
"ng units and we cannot use the usual mode of writing some fields. We can prepare all the data for writing and burn it in one time. You can also use this mode for ``None`` coding scheme but it is not necessary. It is important for ``3/4`` coding scheme.
    ``The batch writing mode`` blocks ``esp_efuse_read_...`` operations.

    After changing the coding scheme, run ``efuse_common_table`` and ``efuse_custom_table`` commands to check the tables of the new coding scheme.

.. only:: not esp32

    "
"Coding schemes are used to protect against data corruption. {IDF_TARGET_NAME} supports two coding schemes:

To write some fields into one block, or different blocks in one time, you need to use ``the batch writing mode``. Firstly set this mode through :cpp:func:`esp_efuse_batch_write_begin` function then write some fields as usual using the ``esp_efuse_write_...`` functions. At the end to burn them, call the :cpp:func:`esp_efuse_batch_write_commit` function. It burns prepared data to the eFuse b"
"locks and disables the ``batch recording mode``.

.. note::

    If there is already pre-written data in the eFuse block using the ``{IDF_TARGET_CODING_SCHEMES}`` encoding scheme, then it is not possible to write anything extra (even if the required bits are empty) without breaking the previous encoding data. This encoding data will be overwritten with new encoding data and completely destroyed (however, the payload eFuses are not damaged). It can be related to: CUSTOM_MAC, SPI_PAD_CONFIG_HD, SP"
"I_PAD_CONFIG_CS, etc. Please contact Espressif to order the required pre-burnt eFuses.

    FOR TESTING ONLY (NOT RECOMMENDED): You can ignore or suppress errors that violate encoding scheme data in order to burn the necessary bits in the eFuse block.

.. _efuse_API:

eFuse API


Access to the fields is via a pointer to the description structure. API functions have some basic operation:

For frequently used fields, special functions are made, like this :cpp:func:`esp_efuse_get_pkg_ver`.

.. only"
":: SOC_EFUSE_KEY_PURPOSE_FIELD or SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY

    eFuse API for Keys
    

    .. only:: SOC_EFUSE_KEY_PURPOSE_FIELD

        EFUSE_BLK_KEY0 - EFUSE_BLK_KEY5 are intended to keep up to 6 keys with a length of 256-bits. Each key has an ``ESP_EFUSE_KEY_PURPOSE_x`` field which defines the purpose of these keys. The purpose field is described in :cpp:type:`esp_efuse_purpose_t`.

        The purposes like ``ESP_EFUSE_KEY_PURPOSE_XTS_AES_...`` are used for flash encryption.

  "
"      The purposes like ``ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_DIGEST...`` are used for secure boot.

        There are some eFuse APIs useful to work with states of keys.

    .. only:: SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY


How to Add a New Field


.. include:: inc/show-efuse-table_{IDF_TARGET_NAME}.rst

The number of bits not included in square brackets is free (some bits are reserved for Espressif). All fields are checked for overlapping.

To add fields to an existing field, use the :ref:`Structu"
"red efuse fields ` technique. For example, adding the fields: SERIAL_NUMBER, MODEL_NUMBER and HARDWARE REV to an existing ``USER_DATA`` field. Use ``.`` (dot) to show an attachment in a field.

.. code-block:: none

    USER_DATA.SERIAL_NUMBER,                  EFUSE_BLK3,    0,  32,
    USER_DATA.MODEL_NUMBER,                   EFUSE_BLK3,    32, 10,
    USER_DATA.HARDWARE_REV,                   EFUSE_BLK3,    42, 10,

You may get errors such as ``intersects with`` or ``out of range``. Please s"
"ee how to solve them in the :ref:`Structured efuse fields ` article.

Bit Order


The eFuses bit order is little endian (see the example below), it means that eFuse bits are read and written from LSB to MSB:

.. code-block:: none

    $ espefuse.py dump

    USER_DATA      (BLOCK3          ) [3 ] read_regs: 03020100 07060504 0B0A0908 0F0E0D0C 13121111 17161514 1B1A1918 1F1E1D1C
    BLOCK4         (BLOCK4          ) [4 ] read_regs: 03020100 07060504 0B0A0908 0F0E0D0C 13121111 17161514 1B1A1918 1F"
"1E1D1C

    where is the register representation:

    EFUSE_RD_USR_DATA0_REG = 0x03020100
    EFUSE_RD_USR_DATA1_REG = 0x07060504
    EFUSE_RD_USR_DATA2_REG = 0x0B0A0908
    EFUSE_RD_USR_DATA3_REG = 0x0F0E0D0C
    EFUSE_RD_USR_DATA4_REG = 0x13121111
    EFUSE_RD_USR_DATA5_REG = 0x17161514
    EFUSE_RD_USR_DATA6_REG = 0x1B1A1918
    EFUSE_RD_USR_DATA7_REG = 0x1F1E1D1C

    where is the byte representation:

    byte[0] = 0x00, byte[1] = 0x01, ... byte[3] = 0x03, byte[4] = 0x04, ..., byte[31] = 0"
"x1F

For example, csv file describes the ``USER_DATA`` field, which occupies all 256 bits (a whole block).

.. code-block:: none

    USER_DATA,          EFUSE_BLK3,    0,  256,     User data
    USER_DATA.FIELD1,   EFUSE_BLK3,    16,  16,     Field1

    ID,                 EFUSE_BLK4,    8,  3,      ID bit[0..2]
    ,                   EFUSE_BLK4,    16, 2,      ID bit[3..4]
    ,                   EFUSE_BLK4,    32, 3,      ID bit[5..7]

Thus, reading the eFuse ``USER_DATA`` block written as "
"above gives the following results:

.. code-block:: c

    uint8_t buf[32] = { 0 };
    esp_efuse_read_field_blob(ESP_EFUSE_USER_DATA, &buf, sizeof(buf) * 8);
    // buf[0] = 0x00, buf[1] = 0x01, ... buf[31] = 0x1F

    uint32_t field1 = 0;
    size_t field1_size = ESP_EFUSE_USER_DATA[0]->bit_count; // can be used for this case because it only consists of one entry
    esp_efuse_read_field_blob(ESP_EFUSE_USER_DATA, &field1, field1_size);
    // field1 = 0x0302

    uint32_t field1_1 = 0;
    esp"
"_efuse_read_field_blob(ESP_EFUSE_USER_DATA, &field1_1, 2); // reads only first 2 bits
    // field1 = 0x0002

    uint8_t id = 0;
    size_t id_size = esp_efuse_get_field_size(ESP_EFUSE_ID); // returns 6
    // size_t id_size = ESP_EFUSE_USER_DATA[0]->bit_count; // cannot be used because it consists of 3 entries. It returns 3 not 6.
    esp_efuse_read_field_blob(ESP_EFUSE_ID, &id, id_size);
    // id = 0x91
    // b'100 10  001
    //   [3] [2] [3]

    uint8_t id_1 = 0;
    esp_efuse_read_field"
"_blob(ESP_EFUSE_ID, &id_1, 3);
    // id = 0x01
    // b'001

Get eFuses During Build


There is a way to get the state of eFuses at the build stage of the project. There are two cmake functions for this:

The json string has the following properties:

.. code-block:: json

    {
        ""MAC"": {
            ""bit_len"": 48,
            ""block"": 0,
            ""category"": ""identity"",
            ""description"": ""Factory MAC Address"",
            ""efuse_type"": ""bytes:6"",
            ""name"": ""MAC"",
 "
"           ""pos"": 0,
            ""readable"": true,
            ""value"": ""94:b9:7e:5a:6e:58 (CRC 0xe2 OK)"",
            ""word"": 1,
            ""writeable"": true
        },
    }

These functions can be used from a top-level project ``CMakeLists.txt`` (:example_file:`get-started/hello_world/CMakeLists.txt`):

.. code-block:: cmake

    # ...
    project(hello_world)

    espefuse_get_json_summary(efuse_json)
    espefuse_get_efuse(ret_data ${efuse_json} ""MAC"" ""value"")
    message(""MAC:"" ${ret_data"
"})

The format of the ``value`` property is the same as shown in ``espefuse.py summary``.

.. code-block:: none

    MAC:94:b9:7e:5a:6e:58 (CRC 0xe2 OK)

There is an example test :example_file:`system/efuse/CMakeLists.txt` which adds a custom target ``efuse-summary``. This allows you to run the ``idf.py efuse-summary`` command to read the required eFuses (specified in the ``efuse_names`` list) at any time, not just at project build time.

Debug eFuse & Unit Tests


.. _virtual-efuses:

Virtual e"
"Fuses


The Kconfig option :ref:`CONFIG_EFUSE_VIRTUAL` virtualizes eFuse values inside the eFuse Manager, so writes are emulated and no eFuse values are permanently changed. This can be useful for debugging app and unit tests.
During startup, the eFuses are copied to RAM. All eFuse operations (read and write) are performed with RAM instead of the real eFuse registers.

In addition to the :ref:`CONFIG_EFUSE_VIRTUAL` option there is :ref:`CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH` option that adds a feat"
"ure to keep eFuses in flash memory. To use this mode the partition_table should have the `efuse` partition. partition.csv: ``""efuse_em, data, efuse,   ,   0x2000,""``.
During startup, the eFuses are copied from flash or, in case if flash is empty, from real eFuse to RAM and then update flash. This option allows keeping eFuses after reboots (possible to test secure_boot and flash_encryption features with this option).

Flash Encryption Testing
""""""""""""""""""""""""""""""""""""""""""""""""

Flash Encryption (FE) is a h"
"ardware feature that requires the physical burning of eFuses: key and FLASH_CRYPT_CNT. If FE is not actually enabled then enabling the :ref:`CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH` option just gives testing possibilities and does not encrypt anything in the flash, even though the logs say encryption happens. The :cpp:func:`bootloader_flash_write` is adapted for this purpose. But if FE is already enabled on the chip and you run an application or bootloader created with the :ref:`CONFIG_EFUSE_VIRTUAL_"
"KEEP_IN_FLASH` option then the flash encryption/decryption operations will work properly (data are encrypted as it is written into an encrypted flash partition and decrypted when they are read from an encrypted partition).

``espefuse.py``


esptool includes a useful tool for reading/writing {IDF_TARGET_NAME} eFuse bits - `espefuse.py `_.

.. include:: inc/espefuse_summary_{IDF_TARGET_NAME}.rst


.. include-build-file:: inc/esp_efuse_chip.inc
.. include-build-file:: inc/esp_efuse.inc
"
"Event Loop Library




Overview


The event loop library allows components to declare events so that other components can register handlers -- codes that executes when those events occur. This allows loosely-coupled components to attach desired behavior to state changes of other components without application involvement. This also simplifies event processing by serializing and deferring code execution to another context.

.. only:: SOC_WIFI_SUPPORTED

    One common case is, if a high-level lib"
"rary is using the Wi-Fi library: it may subscribe to :ref:`ESP32 Wi-Fi Programming Model ` directly and act on those events.

.. only:: SOC_BT_SUPPORTED

    .. note::

        Various modules of the Bluetooth stack deliver events to applications via dedicated callback functions instead of via the Event Loop Library.

Using ``esp_event`` APIs


There are two objects of concern for users of this library: events and event loops.

An event indicates an important occurrence, such as a successful Wi-"
"Fi connection to an access point. A two-part identifier should be used when referencing events, see :ref:`declaring and defining events ` for details. The event loop is the bridge between events and event handlers. The event source publishes events to the event loop using the APIs provided by the event loop library, and event handlers registered to the event loop respond to specific types of events.

Using this library roughly entails the following flow:

In code, the flow above may look like as"
" follows:

.. code-block:: c

    // 1. Define the event handler
    void run_on_event(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data)
    {
        // Event handler logic
    }

    void app_main()
    {
        // 2. A configuration structure of type esp_event_loop_args_t is needed to specify the properties of the loop to be created. A handle of type esp_event_loop_handle_t is obtained, which is needed by the other APIs to reference the loop to perform their operations."
"
        esp_event_loop_args_t loop_args = {
            .queue_size = ...,
            .task_name = ...
            .task_priority = ...,
            .task_stack_size = ...,
            .task_core_id = ...
        };

        esp_event_loop_handle_t loop_handle;

        esp_event_loop_create(&loop_args, &loop_handle);

        // 3. Register event handler defined in (1). MY_EVENT_BASE and MY_EVENT_ID specify a hypothetical event that handler run_on_event should execute when it gets posted to t"
"he loop.
        esp_event_handler_register_with(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, run_on_event, ...);

        ...

        // 4. Post events to the loop. This queues the event on the event loop. At some point, the event loop executes the event handler registered to the posted event, in this case, run_on_event. To simplify the process, this example calls esp_event_post_to from app_main, but posting can be done from any other task (which is the more interesting use case).
        esp_even"
"t_post_to(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, ...);

        ...

        // 5. Unregistering an unneeded handler
        esp_event_handler_unregister_with(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, run_on_event);

        ...

        // 6. Deleting an unneeded event loop
        esp_event_loop_delete(loop_handle);
    }

.. _esp-event-declaring-defining-events:

Declaring and Defining Events


As mentioned previously, events consist of two-part identifiers: the event base and the event ID. "
"The event base identifies an independent group of events; the event ID identifies the event within that group. Think of the event base and event ID as a person's last name and first name, respectively. A last name identifies a family, and the first name identifies a person within that family.

The event loop library provides macros to declare and define the event base easily.

Event base declaration:

.. code-block:: c

    ESP_EVENT_DECLARE_BASE(EVENT_BASE);

Event base definition:

.. code-blo"
"ck:: c

    ESP_EVENT_DEFINE_BASE(EVENT_BASE);

.. note::

    In ESP-IDF, the base identifiers for system events are uppercase and are postfixed with ``_EVENT``. For example, the base for Wi-Fi events is declared and defined as ``WIFI_EVENT``, the Ethernet event base ``ETHERNET_EVENT``, and so on. The purpose is to have event bases look like constants (although they are global variables considering the definitions of macros ``ESP_EVENT_DECLARE_BASE`` and ``ESP_EVENT_DEFINE_BASE``).

For event I"
"Ds, declaring them as enumerations is recommended. Once again, for visibility, these are typically placed in public header files.

Event ID:

.. code-block:: c

    enum {
        EVENT_ID_1,
        EVENT_ID_2,
        EVENT_ID_3,
        ...
    }

.. _esp-event-default-loops:

Default Event Loop


The default event loop is a special type of loop used for system events (Wi-Fi events, for example). The handle for this loop is hidden from the user, and the creation, deletion, handler registratio"
"n/deregistration, and posting of events are done through a variant of the APIs for user event loops. The table below enumerates those variants, and the user event loops equivalent.

.. list-table::
    :header-rows: 1
    :widths: 60 60
    :align: center
      - Default Event Loops
      - :cpp:func:`esp_event_loop_create_default`
      - :cpp:func:`esp_event_loop_delete_default`
      - :cpp:func:`esp_event_handler_register`
      - :cpp:func:`esp_event_handler_unregister`
      - :cpp:func:`e"
"sp_event_post`

If you compare the signatures for both, they are mostly similar except for the lack of loop handle specification for the default event loop APIs.

Other than the API difference and the special designation to which system events are posted, there is no difference in how default event loops and user event loops behave. It is even possible for users to post their own events to the default event loop, should the user opt to not create their own loops to save memory.

.. _esp-event-ha"
"ndler-registration:

Notes on Handler Registration


It is possible to register a single handler to multiple events individually by using multiple calls to :cpp:func:`esp_event_handler_register_with`. For those multiple calls, the specific event base and event ID can be specified with which the handler should execute.

However, in some cases, it is desirable for a handler to execute on the following situations:

(1) all events that get posted to a loop
(2) all events of a particular base identif"
"ier

This is possible using the special event base identifier ``ESP_EVENT_ANY_BASE`` and special event ID ``ESP_EVENT_ANY_ID``. These special identifiers may be passed as the event base and event ID arguments for :cpp:func:`esp_event_handler_register_with`.

Therefore, the valid arguments to :cpp:func:`esp_event_handler_register_with` are:

As an example, suppose the following handler registrations were performed:

.. code-block:: c

    esp_event_handler_register_with(loop_handle, MY_EVENT_BASE"
", MY_EVENT_ID, run_on_event_1, ...);
    esp_event_handler_register_with(loop_handle, MY_EVENT_BASE, ESP_EVENT_ANY_ID, run_on_event_2, ...);
    esp_event_handler_register_with(loop_handle, ESP_EVENT_ANY_BASE, ESP_EVENT_ANY_ID, run_on_event_3, ...);

If the hypothetical event ``MY_EVENT_BASE``, ``MY_EVENT_ID`` is posted, all three handlers ``run_on_event_1``, ``run_on_event_2``, and ``run_on_event_3`` would execute.

If the hypothetical event ``MY_EVENT_BASE``, ``MY_OTHER_EVENT_ID`` is posted, o"
"nly  ``run_on_event_2`` and ``run_on_event_3`` would execute.

If the hypothetical event ``MY_OTHER_EVENT_BASE``, ``MY_OTHER_EVENT_ID`` is posted, only ``run_on_event_3`` would execute.

Handler Un-Registering Itself


In general, an event handler run by an event loop is **not allowed to do any registering/unregistering activity on that event loop**. There is one exception, though: un-registering itself is allowed for the handler. E.g., it is possible to do the following:

.. code-block:: c

   "
" void run_on_event(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data)
    {
        esp_event_loop_handle_t *loop_handle = (esp_event_loop_handle_t*) handler_arg;
        esp_event_handler_unregister_with(*loop_handle, MY_EVENT_BASE, MY_EVENT_ID, run_on_event);
    }

    void app_main(void)
    {
        esp_event_loop_handle_t loop_handle;
        esp_event_loop_create(&loop_args, &loop_handle);
        esp_event_handler_register_with(loop_handle, MY_EVENT_BASE, MY_EVENT_I"
"D, run_on_event, &loop_handle);
        // ... post-event MY_EVENT_BASE, MY_EVENT_ID and run loop at some point
    }


Handler Registration and Handler Dispatch Order


The general rule is that, for handlers that match a certain posted event during dispatch, those which are registered first also get executed first. The user can then control which handlers get executed first by registering them before other handlers, provided that all registrations are performed using a single task. If the user "
"plans to take advantage of this behavior, caution must be exercised if there are multiple tasks registering handlers. While the 'first registered, first executed' behavior still holds true, the task which gets executed first also gets its handlers registered first. Handlers registered one after the other by a single task are still dispatched in the order relative to each other, but if that task gets pre-empted in between registration by another task that also registers handlers; then during disp"
"atch those handlers also get executed in between.


Event Loop Profiling


A configuration option :ref:`CONFIG_ESP_EVENT_LOOP_PROFILING` can be enabled in order to activate statistics collection for all event loops created. The function :cpp:func:`esp_event_dump` can be used to output the collected statistics to a file stream. More details on the information included in the dump can be found in the :cpp:func:`esp_event_dump` API Reference.

Application Example


Examples of using the ``esp_event"
"`` library can be found in :example:`system/esp_event`. The examples cover event declaration, loop creation, handler registration and deregistration, and event posting.

Other examples which also adopt ``esp_event`` library:

API Reference


.. include-build-file:: inc/esp_event.inc
.. include-build-file:: inc/esp_event_base.inc

Related Documents


.. toctree::
    :maxdepth: 1
"
"ESP HTTPS OTA




Overview


``esp_https_ota`` provides simplified APIs to perform firmware upgrades over HTTPS. It is an abstraction layer over the existing OTA APIs.

Application Example


    .. code-block:: c

        esp_err_t do_firmware_upgrade()
        {
            esp_http_client_config_t config = {
                .url = CONFIG_FIRMWARE_UPGRADE_URL,
                .cert_pem = (char *)server_cert_pem_start,
            };
            esp_https_ota_config_t ota_config = {
            "
"    .http_config = &config,
            };
            esp_err_t ret = esp_https_ota(&ota_config);
            if (ret == ESP_OK) {
                esp_restart();
            } else {
                return ESP_FAIL;
            }
            return ESP_OK;
        }


Server Verification


Please refer to :ref:`ESP-TLS: TLS Server Verification ` for more information on server verification. The root certificate in PEM format needs to be provided to the :cpp:member:`esp_http_client_config_t::cert"
"_pem` member.

.. note::

    The server-endpoint **root** certificate should be used for verification instead of any intermediate ones from the certificate chain. The reason is that the root certificate has the maximum validity and usually remains the same for a long period of time. Users can also use the :cpp:member:`esp_http_client_config_t::crt_bundle_attach` member for verification by the ``ESP x509 Certificate Bundle`` feature, which covers most of the trusted root certificates.

Partial I"
"mage Download over HTTPS


To use the partial image download feature, enable ``partial_http_download`` configuration in ``esp_https_ota_config_t``. When this configuration is enabled, firmware image will be downloaded in multiple HTTP requests of specified sizes. Maximum content length of each request can be specified by setting ``max_http_request_size`` to the required value.

This option is useful while fetching image from a service like AWS S3, where mbedTLS Rx buffer size (:ref:`CONFIG_MBEDT"
"LS_SSL_IN_CONTENT_LEN`) can be set to a lower value which is not possible without enabling this configuration.

Default value of mbedTLS Rx buffer size is set to 16 KB. By using ``partial_http_download`` with ``max_http_request_size`` of 4 KB, size of mbedTLS Rx buffer can be reduced to 4 KB. With this configuration, memory saving of around 12 KB is expected.


Signature Verification


For additional security, signature of OTA firmware images can be verified. For more information， please refer t"
"o :ref:`secure-ota-updates`.


Advanced APIs


``esp_https_ota`` also provides advanced APIs which can be used if more information and control is needed during the OTA process.

Example that uses advanced ESP_HTTPS_OTA APIs: :example:`system/ota/advanced_https_ota`.


.. _ota_updates_pre-encrypted-firmware:

OTA Upgrades with Pre-Encrypted Firmware


To perform OTA upgrades with pre-encrypted firmware, please enable :ref:`CONFIG_ESP_HTTPS_OTA_DECRYPT_CB` in component menuconfig.

Example that pe"
"rforms OTA upgrade with pre-encrypted firmware: :example:`system/ota/pre_encrypted_ota`.


OTA System Events


ESP HTTPS OTA has various events for which a handler can be triggered by the :doc:`../system/esp_event` when the particular event occurs. The handler has to be registered using :cpp:func:`esp_event_handler_register`. This helps the event handling for ESP HTTPS OTA.

:cpp:enum:`esp_https_ota_event_t` has all the events which can happen when performing OTA upgrade using ESP HTTPS OTA.

Ev"
"ent Handler Example


    .. code-block:: c

        /* Event handler for catching system events */
        static void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
        {
            if (event_base == ESP_HTTPS_OTA_EVENT) {
                switch (event_id) {
                    case ESP_HTTPS_OTA_START:
                        ESP_LOGI(TAG, ""OTA started"");
                        break;
                    case ESP"
"_HTTPS_OTA_CONNECTED:
                        ESP_LOGI(TAG, ""Connected to server"");
                        break;
                    case ESP_HTTPS_OTA_GET_IMG_DESC:
                        ESP_LOGI(TAG, ""Reading Image Description"");
                        break;
                    case ESP_HTTPS_OTA_VERIFY_CHIP_ID:
                        ESP_LOGI(TAG, ""Verifying chip id of new image: %d"", *(esp_chip_id_t *)event_data);
                        break;
                    case ESP_HTTPS_OTA_D"
"ECRYPT_CB:
                        ESP_LOGI(TAG, ""Callback to decrypt function"");
                        break;
                    case ESP_HTTPS_OTA_WRITE_FLASH:
                        ESP_LOGD(TAG, ""Writing to flash: %d written"", *(int *)event_data);
                        break;
                    case ESP_HTTPS_OTA_UPDATE_BOOT_PARTITION:
                        ESP_LOGI(TAG, ""Boot partition updated. Next Partition: %d"", *(esp_partition_subtype_t *)event_data);
                        br"
"eak;
                    case ESP_HTTPS_OTA_FINISH:
                        ESP_LOGI(TAG, ""OTA finish"");
                        break;
                    case ESP_HTTPS_OTA_ABORT:
                        ESP_LOGI(TAG, ""OTA abort"");
                        break;
                }
            }
        }

Expected data type for different ESP HTTPS OTA events in the system event loop:

    - ESP_HTTPS_OTA_START                     : ``NULL``
    - ESP_HTTPS_OTA_CONNECTED                 : ``NULL"
"``
    - ESP_HTTPS_OTA_GET_IMG_DESC              : ``NULL``
    - ESP_HTTPS_OTA_VERIFY_CHIP_ID            : ``esp_chip_id_t``
    - ESP_HTTPS_OTA_DECRYPT_CB                : ``NULL``
    - ESP_HTTPS_OTA_WRITE_FLASH               : ``int``
    - ESP_HTTPS_OTA_UPDATE_BOOT_PARTITION     : ``esp_partition_subtype_t``
    - ESP_HTTPS_OTA_FINISH                    : ``NULL``
    - ESP_HTTPS_OTA_ABORT                     : ``NULL``


API Reference


.. include-build-file:: inc/esp_https_ota.inc
"
"FreeRTOS (IDF)




This document provides information regarding the dual-core SMP implementation of FreeRTOS inside ESP-IDF. This document is split into the following sections:

.. contents:: Sections
  :depth: 2

..  Overview 

Overview


The original FreeRTOS (hereinafter referred to as **Vanilla FreeRTOS**) is a compact and efficient real-time operating system supported on numerous single-core MCUs and SoCs. However, to support dual-core ESP targets, such as ESP32, ESP32-S3, and ESP32-P4, ESP"
"-IDF provides a unique implementation of FreeRTOS with dual-core symmetric multiprocessing (SMP) capabilities (hereinafter referred to as **IDF FreeRTOS**).

IDF FreeRTOS source code is based on Vanilla FreeRTOS v10.5.1 but contains significant modifications to both kernel behavior and API in order to support dual-core SMP. However, IDF FreeRTOS can also be configured for single-core by enabling the :ref:`CONFIG_FREERTOS_UNICORE` option (see :ref:`freertos-idf-single-core` for more details).

.."
" note::

    This document assumes that the reader has a requisite understanding of Vanilla FreeRTOS, i.e., its features, behavior, and API usage. Refer to the `Vanilla FreeRTOS documentation `_ for more details.

..  Symmetric Multiprocessing 

Symmetric Multiprocessing


Basic Concepts


Symmetric multiprocessing is a computing architecture where two or more identical CPU cores are connected to a single shared main memory and controlled by a single operating system. In general, an SMP system:
"
"
- has multiple cores running independently. Each core has its own register file, interrupts, and interrupt handling.
- presents an identical view of memory to each core. Thus, a piece of code that accesses a particular memory address has the same effect regardless of which core it runs on.

The main advantages of an SMP system compared to single-core or asymmetric multiprocessing systems are that:

- the presence of multiple cores allows for multiple hardware threads, thus increasing overall pr"
"ocessing throughput.
- having symmetric memory means that threads can switch cores during execution. This, in general, can lead to better CPU utilization.

Although an SMP system allows threads to switch cores, there are scenarios where a thread must/should only run on a particular core. Therefore, threads in an SMP system also have a core affinity that specifies which particular core the thread is allowed to run on.

- A thread that is pinned to a particular core is only able to run on that cor"
"e.
- A thread that is unpinned will be allowed to switch between cores during execution instead of being pinned to a particular core.

SMP on an ESP Target


ESP targets such as ESP32, ESP32-S3, and ESP32-P4 are dual-core SMP SoCs. These targets have the following hardware features that make them SMP-capable:

- Two identical cores are known as Core 0 and Core 1. This means that the execution of a piece of code is identical regardless of which core it runs on.
- Symmetric memory (with some small"
" exceptions).

  - If multiple cores access the same memory address simultaneously, their access will be serialized by the memory bus.
  - True atomic access to the same memory address is achieved via an atomic compare-and-swap instruction provided by the ISA.

- Cross-core interrupts that allow one core to trigger an interrupt on the other core. This allows cores to signal events to each other (such as requesting a context switch on the other core).

.. note::

    Within ESP-IDF, Core 0 and Co"
"re 1 are sometimes referred to as ``PRO_CPU`` and ``APP_CPU`` respectively. The aliases exist in ESP-IDF as they reflect how typical ESP-IDF applications utilize the two cores. Typically, the tasks responsible for handling protocol related processing such as Wi-Fi or Bluetooth are pinned to Core 0 (thus the name ``PRO_CPU``), where as the tasks handling the remainder of the application are pinned to Core 1, (thus the name ``APP_CPU``).

..  Tasks 

Tasks


Creation


Vanilla FreeRTOS provides th"
"e following functions to create a task:

- :cpp:func:`xTaskCreate` creates a task. The task's memory is dynamically allocated.
- :cpp:func:`xTaskCreateStatic` creates a task. The task's memory is statically allocated, i.e., provided by the user.

However, in an SMP system, tasks need to be assigned a particular affinity. Therefore, ESP-IDF provides a ``...PinnedToCore()`` version of Vanilla FreeRTOS's task creation functions:

- :cpp:func:`xTaskCreatePinnedToCore` creates a task with a particula"
"r core affinity. The task's memory is dynamically allocated.
- :cpp:func:`xTaskCreateStaticPinnedToCore` creates a task with a particular core affinity. The task's memory is statically allocated, i.e., provided by the user.

The ``...PinnedToCore()`` versions of the task creation function API differ from their vanilla counterparts by having an extra ``xCoreID`` parameter that is used to specify the created task's core affinity. The valid values for core affinity are:

- ``0``, which pins the cre"
"ated task to Core 0
- ``1``, which pins the created task to Core 1
- ``tskNO_AFFINITY``, which allows the task to be run on both cores

Note that IDF FreeRTOS still supports the vanilla versions of the task creation functions. However, these standard functions have been modified to essentially invoke their respective ``...PinnedToCore()`` counterparts while setting the core affinity to ``tskNO_AFFINITY``.

.. note::

    IDF FreeRTOS also changes the units of ``ulStackDepth`` in the task creatio"
"n functions. Task stack sizes in Vanilla FreeRTOS are specified in a number of words, whereas in IDF FreeRTOS, the task stack sizes are specified in bytes.

Execution


The anatomy of a task in IDF FreeRTOS is the same as in Vanilla FreeRTOS. More specifically, IDF FreeRTOS tasks:

- Can only be in one of the following states: Running, Ready, Blocked, or Suspended.
- Task functions are typically implemented as an infinite loop.
- Task functions should never return.

Deletion


Task deletion in V"
"anilla FreeRTOS is called via :cpp:func:`vTaskDelete`. The function allows deletion of another task or the currently running task if the provided task handle is ``NULL``. The actual freeing of the task's memory is sometimes delegated to the idle task if the task being deleted is the currently running task.

IDF FreeRTOS provides the same :cpp:func:`vTaskDelete` function. However, due to the dual-core nature, there are some behavioral differences when calling :cpp:func:`vTaskDelete` in IDF FreeRT"
"OS:

- When deleting a task that is currently running on the other core, a yield is triggered on the other core, and the task's memory is freed by one of the idle tasks.
- A deleted task's memory is freed immediately if it is not running on either core.

Please avoid deleting a task that is running on another core as it is difficult to determine what the task is performing, which may lead to unpredictable behavior such as:

- Deleting a task that is holding a mutex.
- Deleting a task that has ye"
"t to free memory it previously allocated.

Where possible, please design your own application so that when calling :cpp:func:`vTaskDelete`, the deleted task is in a known state. For example:

- Tasks self-deleting via ``vTaskDelete(NULL)`` when their execution is complete and have also cleaned up all resources used within the task.
- Tasks placing themselves in the suspend state via :cpp:func:`vTaskSuspend` before being deleted by another task.


..  Scheduling 

SMP Scheduler


The Vanilla Free"
"RTOS scheduler is best described as a **fixed priority preemptive scheduler with time slicing** meaning that:

- Each task is given a constant priority upon creation. The scheduler executes the highest priority ready-state task.
- The scheduler can switch execution to another task without the cooperation of the currently running task.
- The scheduler periodically switches execution between ready-state tasks of the same priority in a round-robin fashion. Time slicing is governed by a tick interru"
"pt.

The IDF FreeRTOS scheduler supports the same scheduling features, i.e., Fixed Priority, Preemption, and Time Slicing, albeit with some small behavioral differences.

Fixed Priority


In Vanilla FreeRTOS, when the scheduler selects a new task to run, it always selects the current highest priority ready-state task. In IDF FreeRTOS, each core independently schedules tasks to run. When a particular core selects a task, the core will select the highest priority ready-state task that can be run b"
"y the core. A task can be run by the core if:

- The task has a compatible affinity, i.e., is either pinned to that core or is unpinned.
- The task is not currently being run by another core.

However, please do not assume that the two highest priority ready-state tasks are always run by the scheduler, as a task's core affinity must also be accounted for. For example, given the following tasks:

- Task A of priority 10 pinned to Core 0
- Task B of priority 9 pinned to Core 0
- Task C of priority"
" 8 pinned to Core 1

The resulting schedule will have Task A running on Core 0 and Task C running on Core 1. Task B is not run even though it is the second-highest priority task.

Preemption


In Vanilla FreeRTOS, the scheduler can preempt the currently running task if a higher priority task becomes ready to execute. Likewise in IDF FreeRTOS, each core can be individually preempted by the scheduler if the scheduler determines that a higher-priority task can run on that core.

However, there are "
"some instances where a higher-priority task that becomes ready can be run on multiple cores. In this case, the scheduler only preempts one core. The scheduler always gives preference to the current core when multiple cores can be preempted. In other words, if the higher priority ready task is unpinned and has a higher priority than the current priority of both cores, the scheduler will always choose to preempt the current core. For example, given the following tasks:

- Task A of priority 8 curr"
"ently running on Core 0
- Task B of priority 9 currently running on Core 1
- Task C of priority 10 that is unpinned and was unblocked by Task B

The resulting schedule will have Task A running on Core 0 and Task C preempting Task B given that the scheduler always gives preference to the current core.

Time Slicing


The Vanilla FreeRTOS scheduler implements time slicing, which means that if the current highest ready priority contains multiple ready tasks, the scheduler will switch between those "
"tasks periodically in a round-robin fashion.

However, in IDF FreeRTOS, it is not possible to implement perfect Round Robin time slicing due to the fact that a particular task may not be able to run on a particular core due to the following reasons:

- The task is pinned to another core.
- For unpinned tasks, the task is already being run by another core.

Therefore, when a core searches the ready-state task list for a task to run, the core may need to skip over a few tasks in the same priority "
"list or drop to a lower priority in order to find a ready-state task that the core can run.

The IDF FreeRTOS scheduler implements a Best Effort Round Robin time slicing for ready-state tasks of the same priority by ensuring that tasks that have been selected to run are placed at the back of the list, thus giving unselected tasks a higher priority on the next scheduling iteration (i.e., the next tick interrupt or yield).

The following example demonstrates the Best Effort Round Robin time slicin"
"g in action. Assume that:

- There are four ready-state tasks of the same priority ``AX``, ``B0``, ``C1``, and ``D1`` where:

  - The priority is the current highest priority with ready-state .
  - The first character represents the task's name, i.e., ``A``, ``B``, ``C``, ``D``.
  - The second character represents the task's core pinning, and ``X`` means unpinned.

- The task list is always searched from the head.

    .. code-block:: none

        Head [ AX , B0 , C1 , D0 ] Tail

    .. code-bl"
"ock:: none

        Core 0 ─┐
                ▼
        Head [ AX , B0 , C1 , D0 ] Tail

                              [0]
        Head [ B0 , C1 , D0 , AX ] Tail

    .. code-block:: none

        Core 1 ──────┐
                     ▼        [0]
        Head [ B0 , C1 , D0 , AX ] Tail

                         [0]  [1]
        Head [ B0 , D0 , AX , C1 ] Tail

    .. code-block:: none

        Core 0 ─┐
                ▼             [1]
        Head [ B0 , D0 , AX , C1 ] Tail

                  "
"       [1]  [0]
        Head [ D0 , AX , C1 , B0 ] Tail

    .. code-block:: none

        Core 1 ──────┐
                     ▼        [0]
        Head [ D0 , AX , C1 , B0 ] Tail

                         [0]  [1]
        Head [ D0 , C1 , B0 , AX ] Tail

The implications to users regarding the Best Effort Round Robin time slicing:

- Users cannot expect multiple ready-state tasks of the same priority to run sequentially as is the case in Vanilla FreeRTOS. As demonstrated in the example above, a"
" core may need to skip over tasks.
- However, given enough ticks, a task will eventually be given some processing time.
- If a core cannot find a task runnable task at the highest ready-state priority, it will drop to a lower priority to search for tasks.
- To achieve ideal round-robin time slicing, users should ensure that all tasks of a particular priority are pinned to the same core.

Tick Interrupts


Vanilla FreeRTOS requires that a periodic tick interrupt occurs. The tick interrupt is resp"
"onsible for:

- Incrementing the scheduler's tick count
- Unblocking any blocked tasks that have timed out
- Checking if time slicing is required, i.e., triggering a context switch
- Executing the application tick hook

In IDF FreeRTOS, each core receives a periodic interrupt and independently runs the tick interrupt. The tick interrupts on each core are of the same period but can be out of phase. However, the tick responsibilities listed above are not run by all cores:

- Core 0 executes all of"
" the tick interrupt responsibilities listed above
- Core 1 only checks for time slicing and executes the application tick hook

.. note::

    Core 0 is solely responsible for keeping time in IDF FreeRTOS. Therefore, anything that prevents Core 0 from incrementing the tick count, such as suspending the scheduler on Core 0, will cause the entire scheduler's timekeeping to lag behind.

Idle Tasks


Vanilla FreeRTOS will implicitly create an idle task of priority 0 when the scheduler is started. Th"
"e idle task runs when no other task is ready to run, and it has the following responsibilities:

- Freeing the memory of deleted tasks
- Executing the application idle hook

In IDF FreeRTOS, a separate pinned idle task is created for each core. The idle tasks on each core have the same responsibilities as their vanilla counterparts.

Scheduler Suspension


Vanilla FreeRTOS allows the scheduler to be suspended/resumed by calling :cpp:func:`vTaskSuspendAll` and :cpp:func:`xTaskResumeAll` respectiv"
"ely. While the scheduler is suspended:

- Task switching is disabled but interrupts are left enabled.
- Calling any blocking/yielding function is forbidden, and time slicing is disabled.
- The tick count is frozen, but the tick interrupt still occurs to execute the application tick hook.

On scheduler resumption, :cpp:func:`xTaskResumeAll` catches up all of the lost ticks and unblock any timed-out tasks.

In IDF FreeRTOS, suspending the scheduler across multiple cores is not possible. Therefore "
"when :cpp:func:`vTaskSuspendAll` is called on a particular core (e.g., core A):

- Task switching is disabled only on core A but interrupts for core A are left enabled.
- Calling any blocking/yielding function on core A is forbidden. Time slicing is disabled on core A.
- If an interrupt on core A unblocks any tasks, tasks with affinity to core A will go into core A's own pending ready task list. Unpinned tasks or tasks with affinity to other cores can be scheduled on cores with the scheduler run"
"ning.
- If the scheduler is suspended on all cores, tasks unblocked by an interrupt will be directed to the pending ready task lists of their pinned cores. For unpinned tasks, they will be placed in the pending ready list of the core where the interrupt occurred.
- If core A is on Core 0, the tick count is frozen, and a pended tick count is incremented instead. However, the tick interrupt will still occur in order to execute the application tick hook.

When :cpp:func:`xTaskResumeAll` is called o"
"n a particular core (e.g., core A):

- Any tasks added to core A's pending ready task list will be resumed.
- If core A is Core 0, the pended tick count is unwound to catch up with the lost ticks.

.. warning::

    Given that scheduler suspension on IDF FreeRTOS only suspends scheduling on a particular core, scheduler suspension is **NOT** a valid method of ensuring mutual exclusion between tasks when accessing shared data. Users should use proper locking primitives such as mutexes or spinlocks"
" if they require mutual exclusion.

..  Critical Sections 

Critical Sections


Disabling Interrupts


Vanilla FreeRTOS allows interrupts to be disabled and enabled by calling :c:macro:`taskDISABLE_INTERRUPTS` and :c:macro:`taskENABLE_INTERRUPTS` respectively. IDF FreeRTOS provides the same API. However, interrupts are only disabled or enabled on the current core.

Disabling interrupts is a valid method of achieving mutual exclusion in Vanilla FreeRTOS (and single-core systems in general). **How"
"ever, in an SMP system, disabling interrupts is not a valid method of ensuring mutual exclusion**. Critical sections that utilize a spinlock should be used instead.

API Changes


Vanilla FreeRTOS implements critical sections by disabling interrupts, which prevents preemptive context switches and the servicing of ISRs during a critical section. Thus a task/ISR that enters a critical section is guaranteed to be the sole entity to access a shared resource. Critical sections in Vanilla FreeRTOS hav"
"e the following API:

- ``taskENTER_CRITICAL()`` enters a critical section by disabling interrupts
- ``taskEXIT_CRITICAL()`` exits a critical section by reenabling interrupts
- ``taskENTER_CRITICAL_FROM_ISR()`` enters a critical section from an ISR by disabling interrupt nesting
- ``taskEXIT_CRITICAL_FROM_ISR()`` exits a critical section from an ISR by reenabling interrupt nesting

However, in an SMP system, merely disabling interrupts does not constitute a critical section as the presence of ot"
"her cores means that a shared resource can still be concurrently accessed. Therefore, critical sections in IDF FreeRTOS are implemented using spinlocks. To accommodate the spinlocks, the IDF FreeRTOS critical section APIs contain an additional spinlock parameter as shown below:

- Spinlocks are of ``portMUX_TYPE`` (**not to be confused to FreeRTOS mutexes**)
- ``taskENTER_CRITICAL(&spinlock)`` enters a critical from a task context
- ``taskEXIT_CRITICAL(&spinlock)`` exits a critical section from "
"a task context
- ``taskENTER_CRITICAL_ISR(&spinlock)`` enters a critical section from an interrupt context
- ``taskEXIT_CRITICAL_ISR(&spinlock)`` exits a critical section from an interrupt context

.. note::

    The critical section API can be called recursively, i.e., nested critical sections. Entering a critical section multiple times recursively is valid so long as the critical section is exited the same number of times it was entered. However, given that critical sections can target differe"
"nt spinlocks, users should take care to avoid deadlocking when entering critical sections recursively.

Spinlocks can be allocated statically or dynamically. As such, macros are provided for both static and dynamic initialization of spinlocks, as demonstrated by the following code snippets.

- Allocating a static spinlock and initializing it using ``portMUX_INITIALIZER_UNLOCKED``:

  .. code:: c

      // Statically allocate and initialize the spinlock
      static portMUX_TYPE my_spinlock = por"
"tMUX_INITIALIZER_UNLOCKED;

      void some_function(void)
      {
          taskENTER_CRITICAL(&my_spinlock);
          // We are now in a critical section
          taskEXIT_CRITICAL(&my_spinlock);
      }

- Allocating a dynamic spinlock and initializing it using ``portMUX_INITIALIZE()``:

  .. code:: c

      // Allocate the spinlock dynamically
      portMUX_TYPE *my_spinlock = malloc(sizeof(portMUX_TYPE));
      // Initialize the spinlock dynamically
      portMUX_INITIALIZE(my_spinlock);
"
"
      ...

      taskENTER_CRITICAL(my_spinlock);
      // Access the resource
      taskEXIT_CRITICAL(my_spinlock);

Implementation


In IDF FreeRTOS, the process of a particular core entering and exiting a critical section is as follows:

- For ``taskENTER_CRITICAL(&spinlock)`` or ``taskENTER_CRITICAL_ISR(&spinlock)``

  #. The core disables its interrupts or interrupt nesting up to ``configMAX_SYSCALL_INTERRUPT_PRIORITY``.
  #. The core then spins on the spinlock using an atomic compare-and-"
"set instruction until it acquires the lock. A lock is acquired when the core is able to set the lock's owner value to the core's ID.
  #. Once the spinlock is acquired, the function returns. The remainder of the critical section runs with interrupts or interrupt nesting disabled.

- For ``taskEXIT_CRITICAL(&spinlock)`` or ``taskEXIT_CRITICAL_ISR(&spinlock)``

  #. The core releases the spinlock by clearing the spinlock's owner value.
  #. The core re-enables interrupts or interrupt nesting.

Res"
"trictions and Considerations


Given that interrupts (or interrupt nesting) are disabled during a critical section, there are multiple restrictions regarding what can be done within critical sections. During a critical section, users should keep the following restrictions and considerations in mind:

- Critical sections should be kept as short as possible

  - The longer the critical section lasts, the longer a pending interrupt can be delayed.
  - A typical critical section should only access a"
" few data structures and/or hardware registers.
  - If possible, defer as much processing and/or event handling to the outside of critical sections.

- FreeRTOS API should not be called from within a critical section
- Users should never call any blocking or yielding functions within a critical section


..  Misc 

Misc


.. only:: SOC_CPU_HAS_FPU

    Floating Point Usage
    

    Usually, when a context switch occurs:

    - the current state of a core's registers are saved to the stack of th"
"e task being switched out
    - the previously saved state of the core's registers is loaded from the stack of the task being switched in

    However, IDF FreeRTOS implements Lazy Context Switching for the Floating Point Unit (FPU) registers of a core. In other words, when a context switch occurs on a particular core (e.g., Core 0), the state of the core's FPU registers is not immediately saved to the stack of the task getting switched out (e.g., Task A). The FPU registers are left untouched un"
"til:

    - A different task (e.g., Task B) runs on the same core and uses FPU. This will trigger an exception that saves the FPU registers to Task A's stack.
    - Task A gets scheduled to the same core and continues execution. Saving and restoring the FPU registers is not necessary in this case.

    However, given that tasks can be unpinned and thus can be scheduled on different cores (e.g., Task A switches to Core 1), it is unfeasible to copy and restore the FPU registers across cores. There"
"fore, when a task utilizes FPU by using a ``float`` type in its call flow, IDF FreeRTOS will automatically pin the task to the current core it is running on. This ensures that all tasks that use FPU are always pinned to a particular core.

    Furthermore, IDF FreeRTOS by default does not support the usage of FPU within an interrupt context given that the FPU register state is tied to a particular task.

    .. only:: esp32

        .. note::

            Users that require the use of the ``floa"
"t`` type in an ISR routine should refer to the :ref:`CONFIG_FREERTOS_FPU_IN_ISR` configuration option.

    .. note::

        ESP targets that contain an FPU do not support hardware acceleration for double precision floating point arithmetic (``double``). Instead, ``double`` is implemented via software, hence the behavioral restrictions regarding the ``float`` type do not apply to ``double``. Note that due to the lack of hardware acceleration, ``double`` operations may consume significantly mor"
"e CPU time in comparison to ``float``.


..  Single Core  

.. _freertos-idf-single-core:

Single-Core Mode


Although IDF FreeRTOS is modified for dual-core SMP, IDF FreeRTOS can also be built for single-core by enabling the :ref:`CONFIG_FREERTOS_UNICORE` option.

For single-core targets (such as ESP32-S2 and ESP32-C3), the :ref:`CONFIG_FREERTOS_UNICORE` option is always enabled. For multi-core targets (such as ESP32 and ESP32-S3), :ref:`CONFIG_FREERTOS_UNICORE` can also be set, but will result"
" in the application only running Core 0.

When building in single-core mode, IDF FreeRTOS is designed to be identical to Vanilla FreeRTOS, thus all aforementioned SMP changes to kernel behavior are removed. As a result, building IDF FreeRTOS in single-core mode has the following characteristics:

- All operations performed by the kernel inside critical sections are now deterministic (i.e., no walking of linked lists inside critical sections).
- Vanilla FreeRTOS scheduling algorithm is restored ("
"including perfect Round Robin time slicing).
- All SMP specific data is removed from single-core builds.

SMP APIs can still be called in single-core mode. These APIs remain exposed to allow source code to be built for single-core and multi-core, without needing to call a different set of APIs. However, SMP APIs will not exhibit any SMP behavior in single-core mode, thus becoming equivalent to their single-core counterparts. For example:

- any ``...ForCore(..., BaseType_t xCoreID)`` SMP API wil"
"l only accept ``0`` as a valid value for ``xCoreID``.
- ``...PinnedToCore()`` task creation APIs will simply ignore the ``xCoreID`` core affinity argument.
- Critical section APIs will still require a spinlock argument, but no spinlock will be taken and critical sections revert to simply disabling/enabling interrupts.


..  API References 

API Reference


This section introduces FreeRTOS types, functions, and macros. It is automatically generated from FreeRTOS header files.

Task API


.. inclu"
"de-build-file:: inc/task.inc

Queue API


.. include-build-file:: inc/queue.inc

Semaphore API


.. include-build-file:: inc/semphr.inc

Timer API


.. include-build-file:: inc/timers.inc

Event Group API


.. include-build-file:: inc/event_groups.inc

Stream Buffer API


.. include-build-file:: inc/stream_buffer.inc

Message Buffer API


.. include-build-file:: inc/message_buffer.inc
"
"Call Function with External Stack




Overview


A given function can be executed with a user-allocated stack space which is independent of current task stack. This mechanism can be used to save stack space wasted by tasks which call a common function with intensive stack usage such as ``printf``. The given function can be called inside the shared stack space, which is a callback function deferred by calling :cpp:func:`esp_execute_shared_stack_function`, passing that function as a parameter.

.."
" warning::

  :cpp:func:`esp_execute_shared_stack_function` does only minimal preparation of the provided shared stack memory. The function passed to it for execution on the shared stack space or any of that function's callees should not do any of the following:

  .. list::
    
     - Use thread-local storage
     :esp32p4: - Use the floating-point unit
     :esp32p4: - Use the AI co-processor
     - Call vTaskDelete(NULL) to delete the currently running task

  Furthermore, backtraces will be"
" wrong when called from the function running on the shared stack or any of its callees. The limitations are quite severe, so that we might deprecate :cpp:func:`esp_execute_shared_stack_function` in the future. If you have any use case which can only be implemented using :cpp:func:`esp_execute_shared_stack_function`, please open a `GitHub Issue `_.


Usage


:cpp:func:`esp_execute_shared_stack_function` takes four arguments:

- a mutex object allocated by the caller, which is used to protect if t"
"he same function shares its allocated stack
- a pointer to the top of stack used for that function
- the size of stack in bytes
- a pointer to the shared stack function

The user-defined function is deferred as a callback and can be called using the user-allocated space without taking space from current task stack.

The usage may look like the code below:

.. code-block:: c

    void external_stack_function(void)
    {
        printf(""Executing this printf from external stack! \n"");
    }

    /"
"/Let us suppose we want to call printf using a separated stack space
    //allowing the app to reduce its stack size.
    void app_main()
    {
        //Allocate a stack buffer, from heap or as a static form:
        StackType_t *shared_stack = malloc(8192 * sizeof(StackType_t));
        assert(shared_stack != NULL);

        //Allocate a mutex to protect its usage:
        SemaphoreHandle_t printf_lock = xSemaphoreCreateMutex();
        assert(printf_lock != NULL);

        //Call the desired "
"function using the macro helper:
        esp_execute_shared_stack_function(printf_lock,
                                        shared_stack,
                                        8192,
                                        external_stack_function);

        vSemaphoreDelete(printf_lock);
        free(shared_stack);
    }


.. _esp-call-with-stack-basic_usage:

API Reference


.. include-build-file:: inc/esp_expression_with_stack.inc
"
"Interrupt Allocation




Overview


.. only:: esp32 or esp32s3

    The {IDF_TARGET_NAME} has two cores, with 32 interrupts each. Each interrupt has a fixed priority, most (but not all) interrupts are connected to the interrupt matrix.

.. only:: esp32s2

    The {IDF_TARGET_NAME} has one core, with 32 interrupts. Each interrupt has a fixed priority, most (but not all) interrupts are connected to the interrupt matrix.

.. only:: esp32c2 or esp32c3

    The {IDF_TARGET_NAME} has one core, with 31"
" interrupts. Each interrupt's priority is independently programmable.

.. only:: esp32c6 or esp32h2

    The {IDF_TARGET_NAME} has one core, with 28 external asynchronous interrupts. Each interrupt's priority is independently programmable. In addition, there are also 4 core local interrupt sources (CLINT). See **{IDF_TARGET_NAME} Technical Reference Manual** [`PDF `__] for more details.

.. only:: esp32p4

    The {IDF_TARGET_NAME} has two cores, with 32 external asynchronous interrupts each. Ea"
"ch interrupt's priority is independently programmable. In addition, there are also 3 core local interrupt sources (CLINT) on each core. See **{IDF_TARGET_NAME} Technical Reference Manual** [`PDF `__] for more details.

Because there are more interrupt sources than interrupts, sometimes it makes sense to share an interrupt in multiple drivers. The :cpp:func:`esp_intr_alloc` abstraction exists to hide all these implementation details.

A driver can allocate an interrupt for a certain peripheral by"
" calling :cpp:func:`esp_intr_alloc` (or :cpp:func:`esp_intr_alloc_intrstatus`). It can use the flags passed to this function to specify the type, priority, and trigger method of the interrupt to allocate. The interrupt allocation code will then find an applicable interrupt, use the interrupt matrix to hook it up to the peripheral, and install the given interrupt handler and ISR to it.

The interrupt allocator presents two different types of interrupts, namely shared interrupts and non-shared int"
"errupts, both of which require different handling. Non-shared interrupts will allocate a separate interrupt for every :cpp:func:`esp_intr_alloc` call, and this interrupt is use solely for the peripheral attached to it, with only one ISR that will get called. Shared interrupts can have multiple peripherals triggering them, with multiple ISRs being called when one of the peripherals attached signals an interrupt. Thus, ISRs that are intended for shared interrupts should check the interrupt status "
"of the peripheral they service in order to check if any action is required.

Non-shared interrupts can be either level- or edge-triggered. Shared interrupts can only be level interrupts due to the chance of missed interrupts when edge interrupts are used.

To illustrate why shard interrupts can only be level-triggered, take the scenario where peripheral A and peripheral B share the same edge-triggered interrupt. Peripheral B triggers an interrupt and sets its interrupt signal high, causing a low"
"-to-high edge, which in turn latches the CPU's interrupt bit and triggers the ISR. The ISR executes, checks that peripheral A did not trigger an interrupt, and proceeds to handle and clear peripheral B's interrupt signal. Before the ISR returns, the CPU clears its interrupt bit latch. Thus, during the entire interrupt handling process, if peripheral A triggers an interrupt, it will be missed due the CPU clearing the interrupt bit latch.


.. only:: esp32 or esp32s3

    Multicore Issues
    

  "
"  Peripherals that can generate interrupts can be divided in two types:

      - External peripherals, within the {IDF_TARGET_NAME} but outside the Xtensa cores themselves. Most {IDF_TARGET_NAME} peripherals are of this type.
      - Internal peripherals, part of the Xtensa CPU cores themselves.

    Interrupt handling differs slightly between these two types of peripherals.

    Internal Peripheral Interrupts
    

    Each Xtensa CPU core has its own set of six internal peripherals:

      - T"
"hree timer comparators
      - A performance monitor
      - Two software interrupts

    Internal interrupt sources are defined in ``esp_intr_alloc.h`` as ``ETS_INTERNAL_*_INTR_SOURCE``.

    These peripherals can only be configured from the core they are associated with. When generating an interrupt, the interrupt they generate is hard-wired to their associated core; it is not possible to have, for example, an internal timer comparator of one core generate an interrupt on another core. That is"
" why these sources can only be managed using a task running on that specific core. Internal interrupt sources are still allocatable using :cpp:func:`esp_intr_alloc` as normal, but they cannot be shared and will always have a fixed interrupt level (namely, the one associated in hardware with the peripheral).

    External Peripheral Interrupts
    

    The remaining interrupt sources are from external peripherals.

.. only:: esp32p4

    Multicore Considerations
    

    Each core on {IDF_TARGE"
"T_NAME} provides internal interrupts that are triggered by the core itself and external interrupts that are triggered by peripherals. However, ESP-IDF only makes use of the external interrupts on {IDF_TARGET_NAME}. Most {IDF_TARGET_NAME} interrupt sources are external interrupts.

    Each external interrupt slot of each core is wired to the interrupt matrix. The interrupt matrix allows any interrupt slot to be connected to any external interrupt source. Mapping multiple external interrupts sour"
"ces to a single slot is also supported. These external interrupt sources are defined in ``soc/interrupts.h`` as ``ETS_*_INTR_SOURCE``.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    - Allocating an external interrupt will always allocate it on the core that does the allocation.
    - Freeing an external interrupt must always happen on the same core it was allocated on.
    - Disabling and enabling external interrupts from another core is allowed.
    - Multiple external interrupt sources can shar"
"e an interrupt slot by passing ``ESP_INTR_FLAG_SHARED`` as a flag to :cpp:func:`esp_intr_alloc`.

    Care should be taken when calling :cpp:func:`esp_intr_alloc` from a task which is not pinned to a core. During task switching, these tasks can migrate between cores. Therefore it is impossible to tell which CPU the interrupt is allocated on, which makes it difficult to free the interrupt handle and may also cause debugging difficulties. It is advised to use :cpp:func:`xTaskCreatePinnedToCore` wi"
"th a specific CoreID argument to create tasks that allocate interrupts. In the case of internal interrupt sources, this is required.


IRAM-Safe Interrupt Handlers


The ``ESP_INTR_FLAG_IRAM`` flag registers an interrupt handler that always runs from IRAM (and reads all its data from DRAM), and therefore does not need to be disabled during flash erase and write operations.

This is useful for interrupts which need a guaranteed minimum execution latency, as flash write and erase operations can be"
" slow (erases can take tens or hundreds of milliseconds to complete).

It can also be useful to keep an interrupt handler in IRAM if it is called very frequently, to avoid flash cache misses.

Refer to the :ref:`SPI flash API documentation ` for more details.

.. _intr-alloc-shared-interrupts:

Multiple Handlers Sharing A Source


Several handlers can be assigned to a same source, given that all handlers are allocated using the ``ESP_INTR_FLAG_SHARED`` flag. They will all be allocated to the int"
"errupt, which the source is attached to, and called sequentially when the source is active. The handlers can be disabled and freed individually. The source is attached to the interrupt (enabled), if one or more handlers are enabled, otherwise detached. A handler will never be called when disabled, while **its source may still be triggered** if any one of its handler enabled.

Sources attached to non-shared interrupt do not support this feature.

.. only:: not SOC_CPU_HAS_FLEXIBLE_INTC

    By de"
"fault, when ``ESP_INTR_FLAG_SHARED`` flag is specified, the interrupt allocator will allocate only priority level 1 interrupts. Use ``ESP_INTR_FLAG_SHARED | ESP_INTR_FLAG_LOWMED`` to also allow allocating shared interrupts at priority levels 2 and 3.

Though the framework supports this feature, you have to use it **very carefully**. There usually exist two ways to stop an interrupt from being triggered: **disable the source** or **mask peripheral interrupt status**. ESP-IDF only handles enabling"
" and disabling of the source itself, leaving status and mask bits to be handled by users.

**Status bits shall either be masked before the handler responsible for it is disabled, or be masked and then properly handled in another enabled interrupt**.

.. note::

    Leaving some status bits unhandled without masking them, while disabling the handlers for them, will cause the interrupt(s) to be triggered indefinitely, resulting therefore in a system crash.


Troubleshooting Interrupt Allocation


"
"On most Espressif SoCs, CPU interrupts are a limited resource. Therefore it is possible for a program to run out of CPU interrupts, for example by initializing several peripheral drivers. Typically, this will result in the driver initialization function returning ``ESP_ERR_NOT_FOUND`` error code.

If this happens, you can use :cpp:func:`esp_intr_dump` function to print the list of interrupts along with their status. The output of this function typically looks like this:

.. code-block::

    CPU"
" 0 interrupt status:
    Int  Level  Type   Status
    0     1    Level  Reserved
    1     1    Level  Reserved
    2     1    Level  Used: RTC_CORE
    3     1    Level  Used: TG0_LACT_LEVEL
    ...

The columns of the output have the following meaning:

.. list::

    - ``Int``: CPU interrupt input number. This is typically not used in software directly, and is provided for reference only.
    :not SOC_CPU_HAS_FLEXIBLE_INTC: - ``Level``: Interrupt priority (1-7) of the CPU interrupt. This pri"
"ority is fixed in hardware, and cannot be changed.
    :SOC_CPU_HAS_FLEXIBLE_INTC: - ``Level``: For interrupts which have been allocated, the priority of the interrupt. For free interrupts ``*`` is printed.
    :not SOC_CPU_HAS_FLEXIBLE_INTC: - ``Type``: Interrupt type (Level or Edge) of the CPU interrupt. This type is fixed in hardware, and cannot be changed.
    :SOC_CPU_HAS_FLEXIBLE_INTC: - ``Type``: For interrupts which have been allocated, the type (Level or Edge) of the interrupt. For free"
" interrupts ``*`` is printed.
    - ``Status``: One of the possible statuses of the interrupt:
        - ``Reserved``: The interrupt is reserved either at hardware level, or by one of the parts of ESP-IDF. It can not be allocated using :cpp:func:`esp_intr_alloc`.
        - ``Used: ``: The interrupt is allocated and connected to a single peripheral.
        - ``Shared:   ...``: The interrupt is allocated and connected to multiple peripherals. See :ref:`intr-alloc-shared-interrupts` above.
       "
" - ``Free``: The interrupt is not allocated and can be used by :cpp:func:`esp_intr_alloc`.
        :not SOC_CPU_HAS_FLEXIBLE_INTC: - ``Free (not general-use)``: The interrupt is not allocated, but is either a high-priority interrupt (priority 4-7) or an edge-triggered interrupt. High-priority interrupts can be allocated using :cpp:func:`esp_intr_alloc` but requires the handlers to be written in Assembly, see :doc:`../../api-guides/hlinterrupts`. Edge-triggered low- and medium-priority interrupts"
" can also be allocated using :cpp:func:`esp_intr_alloc`, but are not used often since most peripheral interrupts are level-triggered.

If you have confirmed that the application is indeed running out of interrupts, a combination of the following suggestions can help resolve the issue:

.. list::

    :SOC_HP_CPU_HAS_MULTIPLE_CORES: - On multi-core targets, try initializing some of the peripheral drivers from a task pinned to the second core. Interrupts are typically allocated on the same core wh"
"ere the peripheral driver initialization function runs. Therefore by running the initialization function on the second core, more interrupt inputs can be used.
    - Determine the interrupts which can tolerate higher latency, and allocate them using ``ESP_INTR_FLAG_SHARED`` flag (optionally ORed with ``ESP_INTR_FLAG_LOWMED``). Using this flag for two or more peripherals will let them use a single interrupt input, and therefore save interrupt inputs for other peripherals. See :ref:`intr-alloc-sha"
"red-interrupts` above.
    :not SOC_CPU_HAS_FLEXIBLE_INTC: - Some peripheral driver may default to allocating interrupts with ``ESP_INTR_FLAG_LEVEL1`` flag, so priority 2 and 3 interrupts do not get used by default. If :cpp:func:`esp_intr_dump` shows that some priority 2 or 3 interrupts are available, try changing the interrupt allocation flags when initializing the driver to ``ESP_INTR_FLAG_LEVEL2`` or ``ESP_INTR_FLAG_LEVEL3``.
    - Check if some of the peripheral drivers do not need to be use"
"d all the time, and initialize or deinitialize them on demand. This can reduce the number of simultaneously allocated interrupts.


API Reference


.. include-build-file:: inc/esp_intr_types.inc
.. include-build-file:: inc/esp_intr_alloc.inc
"
"FreeRTOS (Supplemental Features)




ESP-IDF provides multiple features to supplement the features offered by FreeRTOS. These supplemental features are available on all FreeRTOS implementations supported by ESP-IDF (i.e., ESP-IDF FreeRTOS and Amazon SMP FreeRTOS). This document describes these supplemental features and is split into the following sections:

.. contents:: Contents
    :depth: 2

..  Overview 

Overview


ESP-IDF adds various new features to supplement the capabilities of FreeRTOS"
" as follows:

- **Ring buffers**: Ring buffers provide a FIFO buffer that can accept entries of arbitrary lengths.
- **ESP-IDF Tick and Idle Hooks**: ESP-IDF provides multiple custom tick interrupt hooks and idle task hooks that are more numerous and more flexible when compared to FreeRTOS tick and idle hooks.
- **Thread Local Storage Pointer (TLSP) Deletion Callbacks**: TLSP Deletion callbacks are run automatically when a task is deleted, thus allowing users to clean up their TLSPs automaticall"
"y.
- **IDF Additional API**: ESP-IDF specific functions added to augment the features of FreeRTOS.
- **Component Specific Properties**: Currently added only one component specific property ``ORIG_INCLUDE_PATH``.

..  Ring Buffers 

Ring Buffers


FreeRTOS provides stream buffers and message buffers as the primary mechanisms to send arbitrarily sized data between tasks and ISRs. However, FreeRTOS stream buffers and message buffers have the following limitations:

- Strictly single sender and sing"
"le receiver
- Data is passed by copy
- Unable to reserve buffer space for a deferred send (i.e., send acquire)

Therefore, ESP-IDF provides a separate ring buffer implementation to address the issues above.

ESP-IDF ring buffers are strictly FIFO buffers that supports arbitrarily sized items. Ring buffers are a more memory efficient alternative to FreeRTOS queues in situations where the size of items is variable. The capacity of a ring buffer is not measured by the number of items it can store, "
"but rather by the amount of memory used for storing items.

The ring buffer provides APIs to send an item, or to allocate space for an item in the ring buffer to be filled manually by the user. For efficiency reasons, **items are always retrieved from the ring buffer by reference**. As a result, all retrieved items **must also be returned** to the ring buffer by using :cpp:func:`vRingbufferReturnItem` or :cpp:func:`vRingbufferReturnItemFromISR`, in order for them to be removed from the ring buff"
"er completely.

The ring buffers are split into the three following types:

**No-Split buffers** guarantee that an item is stored in contiguous memory and does not attempt to split an item under any circumstances. Use No-Split buffers when items must occupy contiguous memory. **Only this buffer type allows reserving buffer space for deferred sending.** Refer to the documentation of the functions :cpp:func:`xRingbufferSendAcquire` and :cpp:func:`xRingbufferSendComplete` for more details.

**Allow"
"-Split buffers** allow an item to be split in two parts when wrapping around the end of the buffer if there is enough space at the tail and the head of the buffer combined to store the item. Allow-Split buffers are more memory efficient than No-Split buffers but can return an item in two parts when retrieving.

**Byte buffers** do not store data as separate items. All data is stored as a sequence of bytes, and any number of bytes can be sent or retrieved each time. Use byte buffers when separate"
" items do not need to be maintained, e.g., a byte stream.

.. note::

    No-Split buffers and Allow-Split buffers always store items at 32-bit aligned addresses. Therefore, when retrieving an item, the item pointer is guaranteed to be 32-bit aligned. This is useful especially when you need to send some data to the DMA.

.. note::

    Each item stored in No-Split or Allow-Split buffers **requires an additional 8 bytes for a header**. Item sizes are also rounded up to a 32-bit aligned size, i.e."
", multiple of 4 bytes. However the true item size is recorded within the header. The sizes of No-Split and Allow-Split buffers will also be rounded up when created.

Usage


The following example demonstrates the usage of :cpp:func:`xRingbufferCreate` and :cpp:func:`xRingbufferSend` to create a ring buffer and then send an item to it:

.. code-block:: c

    #include ""freertos/ringbuf.h""
    static char tx_item[] = ""test_item"";

    ...

        //Create ring buffer
        RingbufHandle_t buf_h"
"andle;
        buf_handle = xRingbufferCreate(1028, RINGBUF_TYPE_NOSPLIT);
        if (buf_handle == NULL) {
            printf(""Failed to create ring buffer\n"");
        }

        //Send an item
        UBaseType_t res =  xRingbufferSend(buf_handle, tx_item, sizeof(tx_item), pdMS_TO_TICKS(1000));
        if (res != pdTRUE) {
            printf(""Failed to send item\n"");
        }

The following example demonstrates the usage of :cpp:func:`xRingbufferSendAcquire` and :cpp:func:`xRingbufferSendCo"
"mplete` instead of :cpp:func:`xRingbufferSend` to acquire memory on the ring buffer (of type :cpp:enumerator:`RINGBUF_TYPE_NOSPLIT`) and then send an item to it. This adds one more step, but allows getting the address of the memory to write to, and writing to the memory yourself.

.. code-block:: c

    #include ""freertos/ringbuf.h""
    #include ""soc/lldesc.h""

    typedef struct {
        lldesc_t dma_desc;
        uint8_t buf[1];
    } dma_item_t;

    #define DMA_ITEM_SIZE(N) (sizeof(lldesc_t"
")+(((N)+3)&(~3)))

    ...

        //Retrieve space for DMA descriptor and corresponding data buffer
        //This has to be done with SendAcquire, or the address may be different when we copy
        dma_item_t item;
        UBaseType_t res =  xRingbufferSendAcquire(buf_handle,
                            &item, DMA_ITEM_SIZE(buffer_size), pdMS_TO_TICKS(1000));
        if (res != pdTRUE) {
            printf(""Failed to acquire memory for item\n"");
        }
        item->dma_desc = (lldesc_t)"
" {
            .size = buffer_size,
            .length = buffer_size,
            .eof = 0,
            .owner = 1,
            .buf = &item->buf,
        };
        //Actually send to the ring buffer for consumer to use
        res = xRingbufferSendComplete(buf_handle, &item);
        if (res != pdTRUE) {
            printf(""Failed to send item\n"");
        }

The following example demonstrates retrieving and returning an item from a **No-Split ring buffer** using :cpp:func:`xRingbufferReceive"
"` and :cpp:func:`vRingbufferReturnItem`

.. code-block:: c

    ...

        //Receive an item from no-split ring buffer
        size_t item_size;
        char *item = (char *)xRingbufferReceive(buf_handle, &item_size, pdMS_TO_TICKS(1000));

        //Check received item
        if (item != NULL) {
            //Print item
            for (int i = 0; i ` for more details.

..  TLSP Callback 

TLSP Deletion Callbacks


Vanilla FreeRTOS provides a Thread Local Storage Pointers (TLSP) feature. Thes"
"e are pointers stored directly in the Task Control Block (TCB) of a particular task. TLSPs allow each task to have its own unique set of pointers to data structures. Vanilla FreeRTOS expects users to:

- set a task's TLSPs by calling :cpp:func:`vTaskSetThreadLocalStoragePointer` after the task has been created.
- get a task's TLSPs by calling :cpp:func:`pvTaskGetThreadLocalStoragePointer` during the task's lifetime.
- free the memory pointed to by the TLSPs before the task is deleted.

However, "
"there can be instances where users may want the freeing of TLSP memory to be automatic. Therefore, ESP-IDF provides the additional feature of TLSP deletion callbacks. These user-provided deletion callbacks are called automatically when a task is deleted, thus allowing the TLSP memory to be cleaned up without needing to add the cleanup logic explicitly to the code of every task.

The TLSP deletion callbacks are set in a similar fashion to the TLSPs themselves.

- :cpp:func:`vTaskSetThreadLocalSto"
"ragePointerAndDelCallback` sets both a particular TLSP and its associated callback.
- Calling the Vanilla FreeRTOS function :cpp:func:`vTaskSetThreadLocalStoragePointer` simply sets the TLSP's associated Deletion Callback to `NULL`, meaning that no callback is called for that TLSP during task deletion.

When implementing TLSP callbacks, users should note the following:

- The callback **must never attempt to block or yield** and critical sections should be kept as short as possible.
- The callba"
"ck is called shortly before a deleted task's memory is freed. Thus, the callback can either be called from :cpp:func:`vTaskDelete` itself, or from the idle task.

..  ESP-IDF Additional API 

.. _freertos-idf-additional-api:

IDF Additional API


The :component_file:`freertos/esp_additions/include/freertos/idf_additions.h` header contains FreeRTOS-related helper functions added by ESP-IDF. Users can include this header via ``#include ""freertos/idf_additions.h""``.

..  Component Specific Properti"
"es 

Component Specific Properties


Besides standard component variables that are available with basic cmake build properties, FreeRTOS component also provides arguments (only one so far) for simpler integration with other modules:

- `ORIG_INCLUDE_PATH` -  contains an absolute path to freertos root include folder. Thus instead of `#include ""freertos/FreeRTOS.h""` you can refer to headers directly: `#include ""FreeRTOS.h""`.


..  API Reference 

API Reference


Ring Buffer API


.. include-build-"
"file:: inc/ringbuf.inc

Hooks API


.. include-build-file:: inc/esp_freertos_hooks.inc

Additional API


.. include-build-file:: inc/idf_additions.inc
"
"Heap Memory Allocation




Stack and Heap


ESP-IDF applications use the common computer architecture patterns of **stack** (dynamic memory allocated by program control flow), **heap** (dynamic memory allocated by function calls), and **static memory** (memory allocated at compile time).

Because ESP-IDF is a multi-threaded RTOS environment, each RTOS task has its own stack. By default, each of these stacks is allocated from the heap when the task is created. See :cpp:func:`xTaskCreateStatic` fo"
"r the alternative where stacks are statically allocated.

Because {IDF_TARGET_NAME} uses multiple types of RAM, it also contains multiple heaps with different capabilities. A capabilities-based memory allocator allows apps to make heap allocations for different purposes.

For most purposes, the C Standard Library's ``malloc()`` and ``free()`` functions can be used for heap allocation without any special consideration. However, in order to fully make use of all of the memory types and their chara"
"cteristics, ESP-IDF also has a capabilities-based heap memory allocator. If you want to have a memory with certain properties (e.g., :ref:`dma-capable-memory` or executable-memory), you can create an OR-mask of the required capabilities and pass that to :cpp:func:`heap_caps_malloc`.

.. _memory_capabilities:

Memory Capabilities


The {IDF_TARGET_NAME} contains multiple types of RAM:

- DRAM (Data RAM) is memory that is connected to CPU's data bus and is used to hold data. This is the most commo"
"n kind of memory accessed as a heap.
- IRAM (Instruction RAM) is memory that is connected to the CPU's instruction bus and usually holds executable data only (i.e., instructions). If accessed as generic memory, all accesses must be aligned to :ref:`32-Bit Accessible Memory `.
- D/IRAM is RAM that is connected to CPU's data bus and instruction bus, thus can be used either Instruction or Data RAM.

For more details on these internal memory types, see :ref:`memory-layout`.

.. only:: SOC_SPIRAM_SUP"
"PORTED

    It is also possible to connect external SPI RAM to the {IDF_TARGET_NAME}. The :doc:`external RAM ` is integrated into the {IDF_TARGET_NAME}'s memory map via the cache, and accessed similarly to DRAM.

All DRAM memory is single-byte accessible, thus all DRAM heaps possess the ``MALLOC_CAP_8BIT`` capability. Users can call ``heap_caps_get_free_size(MALLOC_CAP_8BIT)`` to get the free size of all DRAM heaps.

.. only:: esp32

    If ran out of ``MALLOC_CAP_8BIT``, the users can use ``MAL"
"LOC_CAP_IRAM_8BIT`` instead. In that case, IRAM can still be used as a ""reserve"" pool of internal memory if the users only access it in a 32-bit aligned manner, or if they enable ``CONFIG_ESP32_IRAM_AS_8BIT_ACCESSIBLE_MEMORY)``.


When calling ``malloc()``, the ESP-IDF ``malloc()`` internally calls ``heap_caps_malloc_default(size)``. This will allocate memory with the capability ``MALLOC_CAP_DEFAULT``, which is byte-addressable.

Because ``malloc()`` uses the capabilities-based allocation system"
", memory allocated using :cpp:func:`heap_caps_malloc` can be freed by calling the standard ``free()`` function.

Available Heap


.. _dram-definition:

DRAM


At startup, the DRAM heap contains all data memory that is not statically allocated by the app. Reducing statically-allocated buffers increases the amount of available free heap.

To find the amount of statically allocated memory, use the :ref:`idf.py size ` command.

.. only:: esp32

    .. note::

        See the :ref:`dram` section for "
"more details about the DRAM usage limitations.

.. note::

    At runtime, the available heap DRAM may be less than calculated at compile time, because, at startup, some memory is allocated from the heap before the FreeRTOS scheduler is started (including memory for the stacks of initial FreeRTOS tasks).

IRAM


At startup, the IRAM heap contains all instruction memory that is not used by the app executable code.

The :ref:`idf.py size ` command can be used to find the amount of IRAM used by the"
" app.

D/IRAM


Some memory in the {IDF_TARGET_NAME} is available as either DRAM or IRAM. If memory is allocated from a D/IRAM region, the free heap size for both types of memory will decrease.

Heap Sizes


At startup, all ESP-IDF apps log a summary of all heap addresses (and sizes) at level Info:

.. code-block:: none

    I (252) heap_init: Initializing. RAM available for dynamic allocation:
    I (259) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM
    I (265) heap_init: At 3FFB2EC8 len 0"
"002D138 (180 KiB): DRAM
    I (272) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D/IRAM
    I (278) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D/IRAM
    I (284) heap_init: At 4008944C len 00016BB4 (90 KiB): IRAM

Finding Available Heap


See :ref:`heap-information`.

Special Capabilities


.. _dma-capable-memory:

DMA-Capable Memory


Use the ``MALLOC_CAP_DMA`` flag to allocate memory which is suitable for use with hardware DMA engines (for example SPI and I2S). This capability flag exclud"
"es any external PSRAM.

.. only SOC_SPIRAM_SUPPORTED and not esp32::

    The EDMA hardware feature allows DMA buffers to be placed in external PSRAM, but there may be additional alignment constraints. Consult the {IDF_TARGET_NAME} Technical Reference Manual for details. To allocate a DMA-capable external memory buffer, use the ``MALLOC_CAP_SPIRAM`` capabilities flag together with :cpp:func:`heap_caps_aligned_alloc` with the necessary alignment specified.

.. _32-bit accessible memory:

32-Bit A"
"ccessible Memory


If a certain memory structure is only addressed in 32-bit units, for example, an array of ints or pointers, it can be useful to allocate it with the ``MALLOC_CAP_32BIT`` flag. This also allows the allocator to give out IRAM memory, which is sometimes unavailable for a normal ``malloc()`` call. This can help to use all the available memory in the {IDF_TARGET_NAME}.

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA and SOC_CPU_HAS_FPU

    Please note that on {IDF_TARGET_NAME} series chi"
"ps, ``MALLOC_CAP_32BIT`` cannot be used for storing floating-point variables. This is because ``MALLOC_CAP_32BIT`` may return instruction RAM and the floating-point assembly instructions on {IDF_TARGET_NAME} cannot access instruction RAM.

Memory allocated with ``MALLOC_CAP_32BIT`` can **only** be accessed via 32-bit reads and writes, any other type of access will generate a fatal LoadStoreError exception.

.. only:: SOC_SPIRAM_SUPPORTED

    External SPI Memory
    

    When :doc:`external RAM"
" ` is enabled, external SPI RAM can be allocated using standard ``malloc`` calls, or via ``heap_caps_malloc(MALLOC_CAP_SPIRAM)``, depending on the configuration. See :ref:`external_ram_config` for more details.

    .. only:: esp32

        On ESP32 only external SPI RAM under 4 MiB in size can be allocated this way. To use the region above the 4 MiB limit, you can use the :doc:`himem API `.

Thread Safety


Heap functions are thread-safe, meaning they can be called from different tasks simultan"
"eously without any limitations.

It is technically possible to call ``malloc``, ``free``, and related functions from interrupt handler (ISR) context (see :ref:`calling-heap-related-functions-from-isr`). However, this is not recommended, as heap function calls may delay other interrupts. It is strongly recommended to refactor applications so that any buffers used by an ISR are pre-allocated outside of the ISR. Support for calling heap functions from ISRs may be removed in a future update.

.. _ca"
"lling-heap-related-functions-from-isr:

Calling Heap-Related Functions from ISR


The following functions from the heap component can be called from the interrupt handler (ISR):

.. note::

    However, this practice is strongly discouraged.

Heap Tracing & Debugging


The following features are documented on the :doc:`Heap Memory Debugging ` page:

- :ref:`Heap Information ` (free space, etc.)
- :ref:`Heap Allocation and Free Function Hooks `
- :ref:`Heap Corruption Detection `
- :ref:`Heap Tra"
"cing ` (memory leak detection, monitoring, etc.)

Implementation Notes


Knowledge about the regions of memory in the chip comes from the ""SoC"" component, which contains memory layout information for the chip, and the different capabilities of each region. Each region's capabilities are prioritized, so that (for example) dedicated DRAM and IRAM regions are used for allocations ahead of the more versatile D/IRAM regions.

Each contiguous region of memory contains its own memory heap. The heaps ar"
"e created using the :ref:`multi_heap ` functionality. ``multi_heap`` allows any contiguous region of memory to be used as a heap.

The heap capabilities allocator uses knowledge of the memory regions to initialize each individual heap. Allocation functions in the heap capabilities API will find the most appropriate heap for the allocation based on desired capabilities, available space, and preferences for each region's use, and then calling :cpp:func:`multi_heap_malloc` for the heap situated in "
"that particular region.

Calling ``free()`` involves finding the particular heap corresponding to the freed address, and then call :cpp:func:`multi_heap_free` on that particular ``multi_heap`` instance.


API Reference - Heap Allocation


.. include-build-file:: inc/esp_heap_caps.inc


API Reference - Initialisation


.. include-build-file:: inc/esp_heap_caps_init.inc

.. _multi-heap:

API Reference - Multi-Heap API


(Note: The multi-heap API is used internally by the heap capabilities allocato"
"r. Most ESP-IDF programs never need to call this API directly.)

.. include-build-file:: inc/multi_heap.inc
"
"Memory Synchronization


.. toctree::
   :maxdepth: 1


Introduction


.. only:: SOC_PSRAM_DMA_CAPABLE

   {IDF_TARGET_NAME} can access its connected PSRAM via these ways:

   - CPU
   - DMA

.. only:: SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE

   {IDF_TARGET_NAME} can access its internal memory via these ways:

   - CPU
   - DMA

By default, CPU accesses the above mentioned memory via cache. Whereas DMA accesses the memory directly, without going through cache.

This leads to potential cache data cohe"
"rence issue:

- When a DMA transaction changes the content of a piece of memory, and the content has been cached already. Under this condition:

   - CPU may read stale data.
   - the stale data in the cache may be written back to the memory. The new data updated by the previous DMA transaction will be overwritten.

- CPU changes the content of an address. The content is in the cache, but not in the memory yet (cache will write back the content to the memory according to its own strategy). Under"
" this condition:

   - The next DMA transactions to read this content from the memory will get stale data.

There are three common methods to address such cache data coherence issue:

.. list::


Memory Synchronisation Driver


The suggested way to deal with such cache data coherence issue is by using the memory synchronization API :cpp:func:`esp_cache_msync` provided by ESP-IDF `esp_mm` component.


Driver Concept


Direction of the cache memory synchronization:

- :c:macro:`ESP_CACHE_MSYNC_FLA"
"G_DIR_C2M`, for synchronization from cache to memory.
- :c:macro:`ESP_CACHE_MSYNC_FLAG_DIR_M2C`, for synchronization from memory to cache.

Type of the cache memory synchronization:

- :c:macro:`ESP_CACHE_MSYNC_FLAG_TYPE_DATA`, for synchronization to a data address region.
- :c:macro:`ESP_CACHE_MSYNC_FLAG_TYPE_INST`, for synchronization to an instruction address region.


Driver Behaviour


Calling :cpp:func:`esp_cache_msync` will do a synchronization between cache and memory. The first paramete"
"r `addr` and the second parameter `size` together describe the memory region that is to be synchronized. About the third parameter `flags`:

.. list::

   - :c:macro:`ESP_CACHE_MSYNC_FLAG_DIR_C2M`. With this flag, content in the specified address region is written back to the memory. This direction is usually used **after** the content of an address is updated by the CPU, e.g. a memset to the address. Operation in this direction should happen **before** a DMA operation to the same address.
   - "
":c:macro:`ESP_CACHE_MSYNC_FLAG_DIR_M2C`. With this flag, content in the specified address region is invalidated from the cache. This direction is usually used **after** the content of an address is updated by the DMA. Operation in this direction should happen **before** a CPU read operation to the same address.

The above two flags help select the synchronization direction. Specially, if neither of these two flags are used, :cpp:func:`esp_cache_msync` will by default select the :c:macro:`ESP_CAC"
"HE_MSYNC_FLAG_DIR_C2M` direction. Users are not allowed to set both of the two flags at the same time.

.. list::

   - :c:macro:`ESP_CACHE_MSYNC_FLAG_TYPE_DATA`.
   - :c:macro:`ESP_CACHE_MSYNC_FLAG_TYPE_INST`.

The above two flags help select the type of the synchronization address. Specially, if neither of these two flags are used, :cpp:func:`esp_cache_msync` will by default select the :c:macro:`ESP_CACHE_MSYNC_FLAG_TYPE_DATA` direction. Users are not allowed to set both of the two flags at th"
"e same time.


.. list::

   - :c:macro:`ESP_CACHE_MSYNC_FLAG_INVALIDATE`. This flag is used to trigger a cache invalidation to the specified address region, after the region is written back to the memory. This flag is mainly used for :c:macro:`ESP_CACHE_MSYNC_FLAG_DIR_C2M` direction. For :c:macro:`ESP_CACHE_MSYNC_FLAG_DIR_M2C` direction, behaviour is the same as if the :c:macro:`ESP_CACHE_MSYNC_FLAG_INVALIDATE` flag is not set.
   - :c:macro:`ESP_CACHE_MSYNC_FLAG_UNALIGNED`. This flag force the"
" :cpp:func:`esp_cache_msync` API to do synchronization without checking the address and size alignment. For more details, see chapter `Address Alignment Requirement` following.


Address Alignment Requirement


There is address and size alignment requirement (in bytes) for using :cpp:func:`esp_cache_msync`. The alignment requirement comes from cache.

- An address region whose start address and size both meet the cache memory synchronization alignment requirement is defined as an **aligned addre"
"ss region**.
- An address region whose start address or size does not meet the cache memory synchronization alignment requirement is defined as an **unaligned address region**.

By default, if you specify an unaligned address region, :cpp:func:`esp_cache_msync` will return an :c:macro:`ESP_ERR_INVALID_ARG` error, together with the required alignment.


Memory Allocation Helper


cache memory synchronization is usually considered when DMA is involved. ESP-IDF provides an API to do memory allocati"
"on that can meet the alignment requirement from both the cache and the DMA.

- :cpp:func:`esp_dma_malloc`, this API allocates a chunk of memory that meets the alignment requirement from both the cache and the DMA.
- :cpp:func:`esp_dma_calloc`, this API allocates a chunk of memory that meets the alignment requirement from both the cache and the DMA. The initialized value in the memory is set to zero.

You can also use :c:macro:`ESP_DMA_MALLOC_FLAG_PSRAM` to allocate from the PSRAM.


Warning for "
"Address Alignment Requirement


You can set the :c:macro:`ESP_CACHE_MSYNC_FLAG_UNALIGNED` flag to bypass such check. Note you should be very careful about using this flag. cache memory synchronization to an unaligned address region may silently corrupt the memory.

For example, assume:

- alignment requirement is 0x40 bytes.
- a call to :cpp:func:`esp_cache_msync`, with `ESP_CACHE_MSYNC_FLAG_DIR_M2C | ESP_CACHE_MSYNC_FLAG_UNALIGNED` flags, the specified address region is 0x4000_0020 ~ 0x4000_006"
"0 (see **data C** in below graph).

Above settings will trigger a cache invalidation to the address region 0x4000_0000 ~ 0x4000_0080, see **sync item0** and **sync item1** in the below graph.

If the content in 0x4000_0000 ~ 0x4000_0020 (**data A** in the below graph) or 0x4000_0060 ~ 0x4000_0080 (**data B** in the below graph) are not written back to the memory yet, then these **data A** and **data B** will be discarded.

.. image:: /../_static/diagrams/mmu/cache_align_issue.png
    :scale: 80 "
"%
    :align: center


API Reference


API Reference - ESP Msync Driver


.. include-build-file:: inc/esp_cache.inc


API Reference - ESP DMA Utils


.. include-build-file:: inc/esp_dma_utils.inc
"
"Bootloader Image Format




The bootloader image consists of the same structures as the application image, see :ref:`Application Image Structures `. The only difference is in the :ref:`image-format-bootloader-description` structure.

To get information about the bootloader image, please run the following command:

.. code-block::

    esptool.py --chip {IDF_TARGET_PATH_NAME} image_info build/bootloader/bootloader.bin --version 2

The resultant output will resemble the following:

.. code-block::"
"

    File size: 26576 (bytes)

    ESP32 image header
    
    Image version: 1
    Entry point: 0x40080658
    Segments: 4
    Flash size: 2MB
    Flash freq: 40m
    Flash mode: DIO

    ESP32 extended image header
    
    WP pin: 0xee
    Flash pins drive settings: clk_drv: 0x0, q_drv: 0x0, d_drv: 0x0, cs0_drv: 0x0, hd_drv: 0x0, wp_drv: 0x0
    Chip ID: 0
    Minimal chip revision: v0.0, (legacy min_rev = 0)
    Maximal chip revision: v3.99

    Segments information
    
    Segment   Lengt"
"h   Load addr   File offs  Memory types
            
        1  0x01bb0  0x3fff0030  0x00000018  BYTE_ACCESSIBLE, DRAM, DIRAM_DRAM
        2  0x03c90  0x40078000  0x00001bd0  CACHE_APP
        3  0x00004  0x40080400  0x00005868  IRAM
        4  0x00f2c  0x40080404  0x00005874  IRAM

    ESP32 image footer
    
    Checksum: 0x65 (valid)
    Validation hash: 6f31a7f8512f26f6bce7c3b270f93bf6cf1ee4602c322998ca8ce27433527e92 (valid)

    Bootloader information
    
    Bootloader version: 1
    ESP-"
"IDF: v5.1-dev-4304-gcb51a3b-dirty
    Compile time: Mar 30 2023 19:14:17


.. _image-format-bootloader-description:

Bootloader Description


The ``DRAM0`` segment of the bootloader binary starts with the :cpp:type:`esp_bootloader_desc_t` structure which carries specific fields describing the bootloader. This structure is located at a fixed offset = sizeof(:cpp:type:`esp_image_header_t`) + sizeof(:cpp:type:`esp_image_segment_header_t`).

.. [#f1] The maximum length is 32 characters, including nu"
"ll-termination character.

To get the :cpp:type:`esp_bootloader_desc_t` structure from the running bootloader, use :cpp:func:`esp_bootloader_get_description`.

To get the :cpp:type:`esp_bootloader_desc_t` structure from a running application, use :cpp:func:`esp_ota_get_bootloader_description`.

API Reference


.. include-build-file:: inc/esp_bootloader_desc.inc
"
"ULP RISC-V Coprocessor Programming




The ULP RISC-V coprocessor is a variant of the ULP present in {IDF_TARGET_NAME}. Similar to ULP FSM, the ULP RISC-V coprocessor can perform tasks such as sensor readings while the main CPU stays in low power modes. The main difference between ULP FSM and ULP RISC-V is that the latter can be programmed in C using standard GNU tools. The ULP RISC-V coprocessor can access the RTC_SLOW_MEM memory region, and registers in ``RTC_CNTL``, ``RTC_IO``, and ``SARADC``"
" peripherals. The RISC-V processor is a 32-bit fixed point machine. Its instruction set is based on RV32IMC which includes hardware multiplication and division, and compressed code.

Installing the ULP RISC-V Toolchain


The ULP RISC-V coprocessor code is written in C (assembly is also possible) and compiled using the RISC-V toolchain based on GCC.

If you have already set up ESP-IDF with CMake build system according to the :doc:`Getting Started Guide `, then the toolchain should already be inst"
"alled.

.. note::

    In earlier versions of ESP-IDF, RISC-V toolchain had a different prefix: ``riscv-none-embed-gcc``.

Compiling the ULP RISC-V Code


To compile the ULP RISC-V code as part of the component, the following steps must be taken:

.. note::

    When registering the component (via ``idf_component_register``), this directory should not be added to the ``SRC_DIRS`` argument as it is currently done for the ULP FSM. See the step below for how to properly add ULP source files.

    ."
"..
    idf_component_register()

    set(ulp_app_name ulp_${COMPONENT_NAME})
    set(ulp_sources ""ulp/ulp_c_source_file.c"" ""ulp/ulp_assembly_source_file.S"")
    set(ulp_exp_dep_srcs ""ulp_c_source_file.c"")

    ulp_embed_binary(${ulp_app_name} ""${ulp_sources}"" ""${ulp_exp_dep_srcs}"")

 The first argument to ``ulp_embed_binary`` specifies the ULP binary name. The name specified here will also be used by other generated artifacts such as the ELF file, map file, header file, and linker export file. T"
"he second argument specifies the ULP source files. Finally, the third argument specifies the list of component source files which include the header file to be generated. This list is needed to build the dependencies correctly and ensure that the generated header file will be created before any of these files are compiled. See the section below for the concept of generated header files for ULP applications.

   Inside, the build system will take the following steps to build ULP program:

.. _ulp"
"-riscv-access-variables:

Accessing the ULP RISC-V Program Variables


Global symbols defined in the ULP RISC-V program may be used inside the main program.

For example, the ULP RISC-V program may define a variable ``measurement_count`` which will define the number of ADC measurements the program needs to make before waking up the chip from deep sleep.

.. code-block:: c

    volatile int measurement_count;

    int some_function()
    {
        //read the measurement count for later use.
     "
"   int temp = measurement_count;

        ...do something.
    }

The main program can access the global ULP RISC-V program variables as the build system makes this possible by generating the ``${ULP_APP_NAME}.h`` and ``${ULP_APP_NAME}.ld`` files which define the global symbols present in the ULP RISC-V program. Each global symbol defined in the ULP RISC-V program is included in these files and are prefixed with ``ulp_``.

The header file contains the declaration of the symbol:

.. code-block:: "
"c

    extern uint32_t ulp_measurement_count;

Note that all symbols (variables, arrays, functions) are declared as ``uint32_t``. For functions and arrays, take the address of the symbol and cast it to the appropriate type.

The generated linker script file defines the locations of symbols in RTC_SLOW_MEM::

    PROVIDE ( ulp_measurement_count = 0x50000060 );

To access the ULP RISC-V program variables from the main program, the generated header file should be included using an ``include`` state"
"ment. This will allow the ULP RISC-V program variables to be accessed as regular variables.

.. code-block:: c

    #include ""ulp_app_name.h""

    void init_ulp_vars() {
        ulp_measurement_count = 64;
    }

Mutual Exclusion


If mutual exclusion is needed when accessing a variable shared between the main program and ULP, then this can be achieved by using the ULP RISC-V lock API:

The ULP does not have any hardware instructions to facilitate mutual exclusion, so the lock API achieves this "
"through a software algorithm (`Peterson's algorithm `_).

The locks are intended to only be called from a single thread in the main program, and will not provide mutual exclusion if used simultaneously from multiple threads.

Starting the ULP RISC-V Program


To run a ULP RISC-V program, the main application needs to load the ULP program into RTC memory using the :cpp:func:`ulp_riscv_load_binary` function, and then start it using the :cpp:func:`ulp_riscv_run` function.

Note that the ``CONFIG_UL"
"P_COPROC_ENABLED`` and ``CONFIG_ULP_COPROC_TYPE_RISCV`` options must be enabled in menuconfig to work with ULP RISC-V. To reserve memory for the ULP, the ``RTC slow memory reserved for coprocessor`` option must be set to a value big enough to store ULP RISC-V code and data. If the application components contain multiple ULP programs, then the size of the RTC memory must be sufficient to hold the largest one.

Each ULP RISC-V program is embedded into the ESP-IDF application as a binary blob. The "
"application can reference this blob and load it in the following way (suppose ULP_APP_NAME was defined to ``ulp_app_name``):

.. code-block:: c

    extern const uint8_t bin_start[] asm(""_binary_ulp_app_name_bin_start"");
    extern const uint8_t bin_end[]   asm(""_binary_ulp_app_name_bin_end"");

    void start_ulp_program() {
        ESP_ERROR_CHECK( ulp_riscv_load_binary( bin_start,
            (bin_end - bin_start)) );
    }

Once the program is loaded into RTC memory, the application can start"
" it by calling the :cpp:func:`ulp_riscv_run` function:

.. code-block:: c

    ESP_ERROR_CHECK( ulp_riscv_run() );

ULP RISC-V Program Flow


{IDF_TARGET_RTC_CLK_FRE:default=""150 kHz"", esp32s2=""90 kHz"", esp32s3=""136 kHz""}

The ULP RISC-V coprocessor is started by a timer. The timer is started once :cpp:func:`ulp_riscv_run` is called. The timer counts the number of RTC_SLOW_CLK ticks (by default, produced by an internal {IDF_TARGET_RTC_CLK_FRE} RC oscillator). The number of ticks is set using ``R"
"TC_CNTL_ULP_CP_TIMER_1_REG`` register. When starting the ULP, ``RTC_CNTL_ULP_CP_TIMER_1_REG`` will be used to set the number of timer ticks.

The application can set ULP timer period values (RTC_CNTL_ULP_CP_TIMER_1_REG) using the :cpp:func:`ulp_set_wakeup_period` function.

Once the timer counts the number of ticks set in the ``RTC_CNTL_ULP_CP_TIMER_1_REG`` register, the ULP RISC-V coprocessor will power up and start running the program from the entry point set in the call to :cpp:func:`ulp_risc"
"v_run`.

The program runs until the field ``RTC_CNTL_COCPU_DONE`` in register ``RTC_CNTL_COCPU_CTRL_REG`` gets written or when a trap occurs due to illegal processor state. Once the program halts, the ULP RISC-V coprocessor will power down, and the timer will be started again.

To disable the timer (effectively preventing the ULP program from running again), please clear the ``RTC_CNTL_ULP_CP_SLP_TIMER_EN`` bit in the ``RTC_CNTL_ULP_CP_TIMER_REG`` register. This can be done both from the ULP cod"
"e and from the main program.

ULP RISC-V Peripheral Support


To enhance the capabilities of the ULP RISC-V coprocessor, it has access to peripherals which operate in the low-power (RTC) domain. The ULP RISC-V coprocessor can interact with these peripherals when the main CPU is in sleep mode, and can wake up the main CPU once a wakeup condition is reached. The following peripherals are supported.

RTC I2C


The RTC I2C controller provides I2C master functionality in the RTC domain. The ULP RISC-"
"V coprocessor can read from or write to I2C slave devices using this controller. To use the RTC I2C peripheral, call the :cpp:func:`ulp_riscv_i2c_master_init` from your application running on the main core before initializing the ULP RISC-V core and going to sleep.

Once the RTC I2C controller is initialized, the I2C slave device address must be programmed via the :cpp:func:`ulp_riscv_i2c_master_set_slave_addr` API before any read or write operation is performed.

.. note::

    The RTC I2C peri"
"pheral always expects a slave sub-register address to be programmed via the :cpp:func:`ulp_riscv_i2c_master_set_slave_reg_addr` API. If it is not, the I2C peripheral uses the ``SENS_SAR_I2C_CTRL_REG[18:11]`` as the sub-register address for the subsequent read or write operations. This could make the RTC I2C peripheral incompatible with certain I2C devices or sensors which do not need any sub-register to be programmed.

.. note::

    There is no hardware atomicity protection in accessing the RTC"
" I2C peripheral between the main CPU and the ULP RISC-V core. Therefore, care must be taken that both cores are not accessing the peripheral simultaneously.

In case your RTC I2C based ULP RISC-V program is not working as expected, the following sanity checks can help in debugging the issue:

ULP RISC-V Interrupt Handling


The ULP RISC-V core supports interrupt handling from certain internal and external events. By design, the ULP RISC-V core can handle interrupts from the following sources:

."
". list-table:: ULP RISC-V interrupt sources
    :widths: 10 5 5
    :header-rows: 1
      - Type
      - IRQ
      - Internal
      - 0
      - Internal
      - 1
      - Internal
      - 2
      - External
      - 31

Interrupt handling is enabled via special 32-bit registers Q0-Q3 and custom R-type instructions. For more information, see *{IDF_TARGET_NAME} Technical Reference Manual* > *ULP Coprocessor* > *ULP-RISC-V* > *ULP-RISC-V Interrupts* [`PDF `__].

All interrupts are enabled globally d"
"uring start-up. When an interrupt occurs, the processor jumps to the IRQ vector. The IRQ vector performs the task of saving the register context and then calling the global interrupt dispatcher. The ULP RISC-V driver implements a *weak* interrupt dispatcher :cpp:func:`_ulp_riscv_interrupt_handler` which serves as the central point for handling all interrupts. This global dispatcher calls respective interrupt handlers which have been allocated via the :cpp:func:`ulp_riscv_intr_alloc`.

Interrupt "
"handling on the ULP RISC-V is not fully featured yet. At present, interrupt handling for internal interrupt sources is not supported. Support is provided for two RTC peripheral sources, viz., software-triggered interrupts and RTC IO-triggered interrupts. ULP RISC-V does not support nested interrupts. If users need custom interrupt handling then they may override the default global interrupt dispatcher by defining their own :cpp:func:`_ulp_riscv_interrupt_handler`.

Debugging Your ULP RISC-V Prog"
"ram


When programming the ULP RISC-V, it can sometimes be challenging to figure out why the program is not behaving as expected. Due to the simplicity of the core, many of the standard methods of debugging, e.g., JTAG or ``printf``, are simply not available.

Keeping this in mind, here are some ways that may help you debug your ULP RISC-V program:

Application Examples


API Reference


.. include-build-file:: inc/ulp_riscv.inc
.. include-build-file:: inc/ulp_riscv_lock_shared.inc
.. include-bu"
"ild-file:: inc/ulp_riscv_lock.inc
.. include-build-file:: inc/ulp_riscv_i2c.inc
"
"Random Number Generation




{IDF_TARGET_RF_NAME: default=""Wi-Fi or Bluetooth"", esp32s2=""Wi-Fi"", esp32h2=""Bluetooth or 802.15.4 Thread/Zigbee"", esp32c6=""Wi-Fi or Bluetooth or 802.15.4 Thread/Zigbee""}
{IDF_TARGET_RF_IS: default=""are"", esp32s2=""is""}
{IDF_TARGET_BOOTLOADER_RANDOM_INCOMPATIBLE: default="""", esp32=""I2S, ""}

{IDF_TARGET_NAME} contains a hardware random number generator (RNG). You can use the APIs :cpp:func:`esp_random` and :cpp:func:`esp_fill_random` to obtained random values from it.
"
"
The hardware RNG produces true random numbers so long as one or more of the following conditions are met:

- RF subsystem is enabled. i.e., {IDF_TARGET_RF_NAME} {IDF_TARGET_RF_IS} enabled.
- An internal entropy source has been enabled by calling :cpp:func:`bootloader_random_enable` and not yet disabled by calling :cpp:func:`bootloader_random_disable`.
- While the ESP-IDF :ref:`second-stage-bootloader` is running. This is because the default ESP-IDF bootloader implementation calls :cpp:func:`boo"
"tloader_random_enable` when the bootloader starts, and :cpp:func:`bootloader_random_disable` before executing the application.

When any of these conditions are true, samples of physical noise are continuously mixed into the internal hardware RNG state to provide entropy. Consult the **{IDF_TARGET_NAME} Technical Reference Manual** > **Random Number Generator (RNG)** [`PDF `__] chapter for more details.

If none of the above conditions are true, the output of the RNG should be considered as pseu"
"do-random only.

Startup


During startup, ESP-IDF bootloader temporarily enables a non-RF entropy source (internal reference voltage noise) that provides entropy for any first boot key generation. However, after the application starts executing, then normally only pseudo-random numbers are available until {IDF_TARGET_RF_NAME} {IDF_TARGET_RF_IS} initialized.

To re-enable the entropy source temporarily during application startup, or for an application that does not use {IDF_TARGET_RF_NAME}, call"
" the function :cpp:func:`bootloader_random_enable` to re-enable the internal entropy source. The function :cpp:func:`bootloader_random_disable` must be called to disable the entropy source again before using ADC, {IDF_TARGET_BOOTLOADER_RANDOM_INCOMPATIBLE} {IDF_TARGET_RF_NAME}.

.. note::

    The entropy source enabled during the boot process by the ESP-IDF Second Stage Bootloader seeds the internal RNG state with some entropy. However, the internal hardware RNG state is not large enough to pro"
"vide a continuous stream of true random numbers. This is why a continuous entropy source must be enabled whenever true random numbers are required.

.. note::

    If an application requires a source of true random numbers but cannot permanently enable a hardware entropy source, consider using a strong software DRBG implementation such as the mbedTLS CTR-DRBG or HMAC-DRBG, with an initial seed of entropy from hardware RNG true random numbers.

.. only:: not esp32

    Secondary Entropy
    

   "
" {IDF_TARGET_NAME} RNG contains a secondary entropy source, based on sampling an asynchronous 8 MHz internal oscillator (see the Technical Reference Manual for details). This entropy source is always enabled in ESP-IDF and is continuously mixed into the RNG state by hardware. In testing, this secondary entropy source was sufficient to pass the `Dieharder`_ random number test suite without the main entropy source enabled (test input was created by concatenating short samples from continuously res"
"etting {IDF_TARGET_NAME}). However, it is currently only guaranteed that true random numbers are produced when the main entropy source is also enabled as described above.

API Reference


.. include-build-file:: inc/esp_random.inc
.. include-build-file:: inc/bootloader_random.inc

``getrandom()``


A compatible version of the Linux ``getrandom()`` function is also provided for ease of porting:

.. code-block:: c

    #include 

    ssize_t getrandom(void *buf, size_t buflen, unsigned int flags);"
"

This function is implemented by calling :cpp:func:`esp_fill_random` internally.

The ``flags`` argument is ignored. This function is always non-blocking but the strength of any random numbers is dependent on the same conditions described above.

Return value is -1 (with ``errno`` set to ``EFAULT``) if the ``buf`` argument is NULL, and equal to ``buflen`` otherwise.

``getentropy()``


A compatible version of the Linux ``getentropy()`` function is also provided for easy porting:

.. code-block:"
": c

    #include 

    int getentropy(void *buffer, size_t length);

This function is implemented by calling :cpp:func:`getrandom` internally.

The strength of any random numbers is dependent on the same conditions described above.

Return value is 0 on success and -1 otherwise with ``errno`` set to:

    - ``EFAULT`` if the ``buffer`` argument is NULL.
    - ``EIO`` if the ``length`` is more then 256.

.. _Dieharder: https://webhome.phy.duke.edu/~rgb/General/dieharder.php
"
"Console




ESP-IDF provides ``console`` component, which includes building blocks needed to develop an interactive console over serial port. This component includes the following features:

- Line editing, provided by `linenoise`_ library. This includes handling of backspace and arrow keys, scrolling through command history, command auto-completion, and argument hints.
- Splitting of command line into arguments.
- Argument parsing, provided by `argtable3`_ library. This library includes APIs us"
"ed for parsing GNU style command line arguments.
- Functions for registration and dispatching of commands.
- Functions to establish a basic REPL (Read-Evaluate-Print-Loop) environment.

.. note::

  These features can be used together or independently. For example, it is possible to use line editing and command registration features, but use ``getopt`` or custom code for argument parsing, instead of `argtable3`_. Likewise, it is possible to use simpler means of command input (such as ``fgets``) "
"together with the rest of the means for command splitting and argument parsing.

.. note::

  When using a console application on a chip that supports a hardware USB serial interface, we suggest to disable the secondary serial console output. The secondary output will be output-only and consequently does not make sense in an interactive application.

Line Editing


Line editing feature lets users compose commands by typing them, erasing symbols using the ``backspace`` key, navigating within the "
"command using the left/right keys, navigating to previously typed commands using the up/down keys, and performing autocompletion using the ``tab`` key.

.. note::

  This feature relies on ANSI escape sequence support in the terminal application. As such, serial monitors which display raw UART data can not be used together with the line editing library. If you see ``[6n`` or similar escape sequence when running :example:`system/console` example instead of a command prompt (e.g., ``esp>`` ), it m"
"eans that the serial monitor does not support escape sequences. Programs which are known to work are GNU screen, minicom, and esp-idf-monitor (which can be invoked using ``idf.py monitor`` from project directory).

Here is an overview of functions provided by `linenoise `_ library.

Configuration


Linenoise library does not need explicit initialization. However, some configuration defaults may need to be changed before invoking the main line editing function.

- :cpp:func:`linenoiseClearScreen`"
"

  Clear terminal screen using an escape sequence and position the cursor at the top left corner.

- :cpp:func:`linenoiseSetMultiLine`

  Switch between single line and multi line editing modes. In single line mode, if the length of the command exceeds the width of the terminal, the command text is scrolled within the line to show the end of the text. In this case the beginning of the text is hidden. Single line mode needs less data to be sent to refresh screen on each key press, so exhibits le"
"ss glitching compared to the multi line mode. On the flip side, editing commands and copying command text from terminal in single line mode is harder. Default is single line mode.

- :cpp:func:`linenoiseAllowEmpty`

  Set whether linenoise library returns a zero-length string (if ``true``) or ``NULL`` (if ``false``) for empty lines. By default, zero-length strings are returned.

- :cpp:func:`linenoiseSetMaxLineLen`

  Set maximum length of the line for linenoise library. Default length is 4096 b"
"ytes. The default value can be updated to optimize RAM memory usage.


Main Loop


- :cpp:func:`linenoise`

  In most cases, console applications have some form of read/eval loop. :cpp:func:`linenoise` is the single function which handles user's key presses and returns the completed line once the ``enter`` key is pressed. As such, it handles the ``read`` part of the loop.

- :cpp:func:`linenoiseFree`

  This function must be called to release the command line buffer obtained from :cpp:func:`line"
"noise` function.


Hints and Completions


- :cpp:func:`linenoiseSetCompletionCallback`

  When the user presses the ``tab`` key, linenoise library invokes the completion callback. The callback should inspect the contents of the command typed so far and provide a list of possible completions using calls to :cpp:func:`linenoiseAddCompletion` function. :cpp:func:`linenoiseSetCompletionCallback` function should be called to register this completion callback, if completion feature is desired.

  ``c"
"onsole`` component provides a ready made function to provide completions for registered commands, :cpp:func:`esp_console_get_completion` (see below).

- :cpp:func:`linenoiseAddCompletion`

  Function to be called by completion callback to inform the library about possible completions of the currently typed command.

- :cpp:func:`linenoiseSetHintsCallback`

  Whenever user input changes, linenoise invokes the hints callback. This callback can inspect the command line typed so far, and provide a s"
"tring with hints (which can include list of command arguments, for example). The library then displays the hint text on the same line where editing happens, possibly with a different color.

- :cpp:func:`linenoiseSetFreeHintsCallback`

  If the hint string returned by hints callback is dynamically allocated or needs to be otherwise recycled, the function which performs such cleanup should be registered via :cpp:func:`linenoiseSetFreeHintsCallback`.


History


- :cpp:func:`linenoiseHistorySetMax"
"Len`

  This function sets the number of most recently typed commands to be kept in memory. Users can navigate the history using the up/down arrows keys.

- :cpp:func:`linenoiseHistoryAdd`

  Linenoise does not automatically add commands to history. Instead, applications need to call this function to add command strings to the history.

- :cpp:func:`linenoiseHistorySave`

  Function saves command history from RAM to a text file, for example on an SD card or on a filesystem in flash memory.

- :c"
"pp:func:`linenoiseHistoryLoad`

  Counterpart to :cpp:func:`linenoiseHistorySave`, loads history from a file.

- :cpp:func:`linenoiseHistoryFree`

  Releases memory used to store command history. Call this function when done working with linenoise library.


Splitting of Command Line into Arguments


``console`` component provides :cpp:func:`esp_console_split_argv` function to split command line string into arguments. The function returns the number of arguments found (``argc``) and fills an arr"
"ay of pointers which can be passed as ``argv`` argument to any function which accepts arguments in ``argc, argv`` format.

The command line is split into arguments according to the following rules:

- Arguments are separated by spaces
- If spaces within arguments are required, they can be escaped using ``\`` (backslash) character.
- Other escape sequences which are recognized are ``\\`` (which produces literal backslash) and ``\""``, which produces a double quote.
- Arguments can be quoted using "
"double quotes. Quotes may appear only in the beginning and at the end of the argument. Quotes within the argument must be escaped as mentioned above. Quotes surrounding the argument are stripped by ``esp_console_split_argv`` function.

Examples:

- ``abc def 1 20 .3`` > [ ``abc``, ``def``, ``1``, ``20``, ``.3`` ]
- ``abc ""123 456"" def`` > [ ``abc``, ``123 456``, ``def`` ]
- ```a\ b\\c\""`` > [ ``a b\c""`` ]


Argument Parsing


For argument parsing, ``console`` component includes `argtable3 `_ lib"
"rary. Please see `tutorial `_ for an introduction to `argtable3 `_. Github repository also includes `examples `_.


Command Registration and Dispatching


``console`` component includes utility functions which handle registration of commands, matching commands typed by the user to registered ones, and calling these commands with the arguments given on the command line.

Application first initializes command registration module using a call to :cpp:func:`esp_console_init`, and calls :cpp:func:`es"
"p_console_cmd_register` function to register command handlers.

For each command, application provides the following information (in the form of ``esp_console_cmd_t`` structure):

- Command name (string without spaces)
- Help text explaining what the command does
- Optional hint text listing the arguments of the command. If application uses Argtable3 for argument parsing, hint text can be generated automatically by providing a pointer to argtable argument definitions structure instead.
- Command"
" handler function (without context), or
- Command handler function (with context). If this function is given, an additional call to :cpp:func:`esp_console_cmd_set_context` must follow *before* the command may be called to initialize the context.

.. note::

  You can either use a command handler function which takes a context or a command handler function which does not take a context, not both. If you use the command handler function which takes a context, you MUST call :cpp:func:`esp_console_c"
"md_set_context` to initialize its context, otherwise the function may access the uninitialized context.

A few other functions are provided by the command registration module:

- :cpp:func:`esp_console_run`

  This function takes the command line string, splits it into argc/argv argument list using :cpp:func:`esp_console_split_argv`, looks up the command in the list of registered components, and if it is found, executes its handler.

- :cpp:func:`esp_console_register_help_command`

  Adds ``help"
"`` command to the list of registered commands. This command prints the list of all the registered commands, along with their arguments and help texts.

- :cpp:func:`esp_console_get_completion`

  Callback function to be used with :cpp:func:`linenoiseSetCompletionCallback` from linenoise library. Provides completions to linenoise based on the list of registered commands.

- :cpp:func:`esp_console_get_hint`

  Callback function to be used with :cpp:func:`linenoiseSetHintsCallback` from linenoise l"
"ibrary. Provides argument hints for registered commands to linenoise.


Initialize Console REPL Environment


To establish a basic REPL environment, ``console`` component provides several useful APIs, combining those functions described above.

In a typical application, you only need to call :cpp:func:`esp_console_new_repl_uart` to initialize the REPL environment based on UART device, including driver install, basic console configuration, spawning a thread to do REPL task and register several us"
"eful commands (e.g., `help`).

After that, you can register your own commands with :cpp:func:`esp_console_cmd_register`. The REPL environment keeps in init state until you call :cpp:func:`esp_console_start_repl`.

.. only:: SOC_USB_SERIAL_JTAG_SUPPORTED

    Likewise, if your REPL environment is based on USB_SERIAL_JTAG device, you only need to call :cpp:func:`esp_console_new_repl_usb_serial_jtag` at first step. Then call other functions as usual.

Application Example


Example application illus"
"trating usage of the ``console`` component is available in :example:`system/console` directory. This example shows how to initialize UART and VFS functions, set up linenoise library, read and handle commands from UART, and store command history in Flash. See README.md in the example directory for more details.

Besides that, ESP-IDF contains several useful examples which are based on the ``console`` component and can be treated as ""tools"" when developing applications. For example, :example:`peri"
"pherals/i2c/i2c_tools`, :example:`wifi/iperf`.


API Reference


.. include-build-file:: inc/esp_console.inc
"
"Error Code and Helper Functions




This section lists definitions of common ESP-IDF error codes and several helper functions related to error handling.

For general information about error codes in ESP-IDF, see :doc:`Error Handling `.

For the full list of error codes defined in ESP-IDF, see :doc:`Error Codes Reference `.

API Reference


.. include-build-file:: inc/esp_check.inc
.. include-build-file:: inc/esp_err.inc
"
"POSIX Threads Support




Overview


ESP-IDF is based on FreeRTOS but offers a range of POSIX-compatible APIs that allow easy porting of third-party code. This includes support for common parts of the POSIX Threads ``pthread`` API.

POSIX Threads are implemented in ESP-IDF as wrappers around equivalent FreeRTOS features. The runtime memory or performance overhead of using the pthreads API is quite low, but not every feature available in either pthreads or FreeRTOS is available via the ESP-IDF pt"
"hreads support.

Pthreads can be used in ESP-IDF by including standard ``pthread.h`` header, which is included in the toolchain libc. An additional ESP-IDF specific header, ``esp_pthread.h``, provides additional non-POSIX APIs for using some ESP-IDF features with pthreads.

C++ Standard Library implementations for ``std::thread``, ``std::mutex``, ``std::condition_variable``, etc., are realized using pthreads (via GCC libstdc++). Therefore, restrictions mentioned here also apply to the equivalent"
" C++ standard library functionality.

RTOS Integration


Unlike many operating systems using POSIX Threads, ESP-IDF is a real-time operating system with a real-time scheduler. This means that a thread will only stop running if a higher priority task is ready to run, the thread blocks on an OS synchronization structure like a mutex, or the thread calls any of the functions ``sleep``, :cpp:func:`vTaskDelay`, or ``usleep``.

.. note::

    When calling a standard libc or C++ sleep function, such as"
" ``usleep`` defined in ``unistd.h``, the task will only block and yield the core if the sleep time is longer than :ref:`one FreeRTOS tick period `. If the time is shorter, the thread will busy-wait instead of yielding to another RTOS task.

By default, all POSIX Threads have the same RTOS priority, but it is possible to change this by calling a :ref:`custom API `.

Standard Features


The following standard APIs are implemented in ESP-IDF.

Refer to `standard POSIX Threads documentation `__, or "
"``pthread.h``, for details about the standard arguments and behaviour of each function. Differences or limitations compared to the standard APIs are noted below.

.. _posix_thread_api:

Thread APIs

    - The ``attr`` argument is supported for setting stack size and detach state only. Other attribute fields are ignored.
    - Unlike FreeRTOS task functions, the ``start_routine`` function is allowed to return. A detached type thread is automatically deleted if the function returns. The default jo"
"inable type thread will be suspended until ``pthread_join()`` is called on it.
    - An assert will fail if this function is called from a FreeRTOS task which is not a pthread.

Thread Attributes

    - This function does not need to free any resources and instead resets the ``attr`` structure to defaults. The implementation is the same as ``pthread_attr_init()``.

Once


Static initializer constant ``PTHREAD_ONCE_INIT`` is supported.

.. note::

    This function can be called from tasks create"
"d using either pthread or FreeRTOS APIs.

Mutexes


POSIX Mutexes are implemented as FreeRTOS Mutex Semaphores (normal type for ""fast"" or ""error check"" mutexes, and Recursive type for ""recursive"" mutexes). This means that they have the same priority inheritance behavior as mutexes created with :cpp:func:`xSemaphoreCreateMutex`.

Static initializer constant ``PTHREAD_MUTEX_INITIALIZER`` is supported, but the non-standard static initializer constants for other mutex types are not supported.

.. no"
"te::

    These functions can be called from tasks created using either pthread or FreeRTOS APIs.

Condition Variables

    - The ``attr`` argument is not implemented and is ignored.

Static initializer constant ``PTHREAD_COND_INITIALIZER`` is supported.

.. note::

    These functions can be called from tasks created using either pthread or FreeRTOS APIs.

Semaphores


In ESP-IDF, POSIX **unnamed** semaphores are implemented. The accessible API is described below. It implements `semaphores as s"
"pecified in the POSIX standard `_, unless specified otherwise.

    - ``pshared`` is ignored. Semaphores can always be shared between FreeRTOS tasks.

    - If the semaphore has a value of ``SEM_VALUE_MAX`` already, ``-1`` is returned and ``errno`` is set to ``EAGAIN``.

    - The time value passed by abstime will be rounded up to the next FreeRTOS tick.
    - The actual timeout happens after the tick that the time was rounded to and before the following tick.
    - It is possible, though unlike"
"ly, that the task is preempted directly after the timeout calculation, delaying the timeout of the following blocking operating system call by the duration of the preemption.

Read/Write Locks

The following API functions of the POSIX reader-writer locks specification are implemented:

    - The ``attr`` argument is not implemented and is ignored.

The static initializer constant ``PTHREAD_RWLOCK_INITIALIZER`` is supported.

.. note::

    These functions can be called from tasks created using e"
"ither pthread or FreeRTOS APIs.

Thread-Specific Data

    - The ``destr_function`` argument is supported and will be called if a thread function exits normally, calls ``pthread_exit()``, or if the underlying task is deleted directly using the FreeRTOS function :cpp:func:`vTaskDelete`.

.. note::

    These functions can be called from tasks created using either pthread or FreeRTOS APIs. When calling these functions from tasks created using FreeRTOS APIs, :ref:`CONFIG_FREERTOS_TLSP_DELETION_CALL"
"BACKS` config option must be enabled to ensure the thread-specific data is cleaned up before the task is deleted.

.. note::

    There are other options for thread local storage in ESP-IDF, including options with higher performance. See :doc:`/api-guides/thread-local-storage`.

Not Implemented


The ``pthread.h`` header is a standard header and includes additional APIs and features which are not implemented in ESP-IDF. These include:

Other POSIX Threads functions (not listed here) are not impl"
"emented and will produce either a compiler or a linker error if referenced from an ESP-IDF application. If you identify a useful API that you would like to see implemented in ESP-IDF, please open a `feature request on GitHub `_ with the details.

.. _esp-pthread:

ESP-IDF Extensions


The API :cpp:func:`esp_pthread_set_cfg` defined in the ``esp_pthreads.h`` header offers custom extensions to control how subsequent calls to ``pthread_create()`` behaves. Currently, the following configuration can "
"be set:

.. list::
    - Default stack size of new threads, if not specified when calling ``pthread_create()`` (overrides :ref:`CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT`).
    - Stack memory capabilities determine which kind of memory is used for allocating pthread stacks. The field takes ESP-IDF heap capability flags, as defined in :component_file:`heap/include/esp_heap_caps.h`. The memory must be 8-bit accessible (MALLOC_CAP_8BIT), besides other custom flags the user can choose from. The user is"
" responsible for ensuring the correctness of the stack memory capabilities. For more information about memory locations, refer to the documentation of :ref:`memory_capabilities`.
    - RTOS priority of new threads (overrides :ref:`CONFIG_PTHREAD_TASK_PRIO_DEFAULT`).
    :SOC_HP_CPU_HAS_MULTIPLE_CORES: - Core affinity / core pinning of new threads (overrides :ref:`CONFIG_PTHREAD_TASK_CORE_DEFAULT`).
    - FreeRTOS task name for new threads (overrides :ref:`CONFIG_PTHREAD_TASK_NAME_DEFAULT`)

This"
" configuration is scoped to the calling thread (or FreeRTOS task), meaning that :cpp:func:`esp_pthread_set_cfg` can be called independently in different threads or tasks. If the ``inherit_cfg`` flag is set in the current configuration then any new thread created will inherit the creator's configuration (if that thread calls ``pthread_create()`` recursively), otherwise the new thread will have the default configuration.

Examples


- :example:`system/pthread` demonstrates using the pthreads API t"
"o create threads.
- :example:`cxx/pthread` demonstrates using C++ Standard Library functions with threads.


API Reference


.. include-build-file:: inc/esp_pthread.inc
"
"ULP LP-Core Coprocessor Programming




The ULP LP-Core (Low-power core) coprocessor is a variant of the ULP present in {IDF_TARGET_NAME}. It features ultra-low power consumption while also being able to stay powered on while the main CPU stays in low-power modes. This enables the LP-Core coprocessor to handle tasks like GPIO or sensor readings while the main CPU is in sleep mode, resulting in significant overall power savings for the entire system.

The ULP LP-Core coprocessor has the following"
" features:

Compiling Code for the ULP LP-Core


The ULP LP-Core code is compiled together with your ESP-IDF project as a separate binary and automatically embedded into the main project binary. To acheive this do the following:

    idf_component_register()

    set(ulp_app_name ulp_${COMPONENT_NAME})
    set(ulp_sources ""ulp/ulp_c_source_file.c"" ""ulp/ulp_assembly_source_file.S"")
    set(ulp_exp_dep_srcs ""ulp_c_source_file.c"")

    ulp_embed_binary(${ulp_app_name} ""${ulp_sources}"" ""${ulp_exp_de"
"p_srcs}"")

The first argument to ``ulp_embed_binary`` specifies the ULP binary name. The name specified here is also used by other generated artifacts such as the ELF file, map file, header file, and linker export file. The second argument specifies the ULP source files. Finally, the third argument specifies the list of component source files which include the header file to be generated. This list is needed to build the dependencies correctly and ensure that the generated header file is created"
" before any of these files are compiled. See the section below for the concept of generated header files for ULP applications.

During the build process, the following steps are taken to build ULP program:

.. _ulp-lp-core-access-variables:

Accessing the ULP LP-Core Program Variables


Global symbols defined in the ULP LP-Core program may be used inside the main program.

For example, the ULP LP-Core program may define a variable ``measurement_count`` which defines the number of GPIO measuremen"
"ts the program needs to make before waking up the chip from deep sleep.

.. code-block:: c

    volatile int measurement_count;

    int some_function()
    {
        //read the measurement count for later use.
        int temp = measurement_count;

        ...do something.
    }

The main program can access the global ULP LP-Core program variables as the build system makes this possible by generating the ``${ULP_APP_NAME}.h`` and ``${ULP_APP_NAME}.ld`` files which define the global symbols pres"
"ent in the ULP LP-Core program. Each global symbol defined in the ULP LP-Core program is included in these files and are prefixed with ``ulp_``.

The header file contains the declaration of the symbol:

.. code-block:: c

    extern uint32_t ulp_measurement_count;

Note that all symbols (variables, arrays, functions) are declared as ``uint32_t``. For functions and arrays, take the address of the symbol and cast it to the appropriate type.

The generated linker script file defines the locations o"
"f symbols in LP_MEM::

    PROVIDE ( ulp_measurement_count = 0x50000060 );

To access the ULP LP-Core program variables from the main program, the generated header file should be included using an ``include`` statement. This allows the ULP LP-Core program variables to be accessed as regular variables.

.. code-block:: c

    #include ""ulp_app_name.h""

    void init_ulp_vars() {
        ulp_measurement_count = 64;
    }


Starting the ULP LP-Core Program


To run a ULP LP-Core program, the main a"
"pplication needs to load the ULP program into RTC memory using the :cpp:func:`ulp_lp_core_load_binary` function, and then start it using the :cpp:func:`ulp_lp_core_run` function.

Each ULP LP-Core program is embedded into the ESP-IDF application as a binary blob. The application can reference this blob and load it in the following way (supposed ULP_APP_NAME was defined to ``ulp_app_name``):

.. code-block:: c

    extern const uint8_t bin_start[] asm(""_binary_ulp_app_name_bin_start"");
    extern"
" const uint8_t bin_end[]   asm(""_binary_ulp_app_name_bin_end"");

    void start_ulp_program() {
        ESP_ERROR_CHECK( ulp_lp_core_load_binary( bin_start,
            (bin_end - bin_start)) );
    }

Once the program is loaded into LP memory, the application can be configured and started by calling :cpp:func:`ulp_lp_core_run`:

.. code-block:: c

    ulp_lp_core_cfg_t cfg = {
        .wakeup_source = ULP_LP_CORE_WAKEUP_SOURCE_LP_TIMER, // LP core will be woken up periodically by LP timer
     "
"   .lp_timer_sleep_duration_us = 10000,
    };

    ESP_ERROR_CHECK( ulp_lp_core_run(&cfg) );

ULP LP-Core Program Flow


How the ULP LP-Core coprocessor is started depends on the wakeup source selected in :cpp:type:`ulp_lp_core_cfg_t`. The most common use-case is for the ULP to periodically wake-up, do some measurements before either waking up the main CPU or going back to sleep again.

The ULP has the following wake-up sources:

When the ULP is woken up, it will go through the following steps:"
"

ULP LP-Core Peripheral Support


To enhance the capabilities of the ULP LP-Core coprocessor, it has access to peripherals which operate in the low-power domain. The ULP LP-Core coprocessor can interact with these peripherals when the main CPU is in sleep mode, and can wake up the main CPU once a wakeup condition is reached. The following peripherals are supported:

Application Examples


API Reference


Main CPU API Reference
~~~~~~~~~~~~~~~~~~~~~~

.. include-build-file:: inc/ulp_lp_core.inc
"
".. include-build-file:: inc/lp_core_i2c.inc
.. include-build-file:: inc/lp_core_uart.inc

LP Core API Reference
~~~~~~~~~~~~~~~~~~~~~~

.. include-build-file:: inc/ulp_lp_core_utils.inc
.. include-build-file:: inc/ulp_lp_core_gpio.inc
.. include-build-file:: inc/ulp_lp_core_i2c.inc
.. include-build-file:: inc/ulp_lp_core_uart.inc
.. include-build-file:: inc/ulp_lp_core_print.inc
"
"Sleep Modes




{IDF_TARGET_SPI_POWER_DOMAIN:default=""VDD_SPI"", esp32=""VDD_SDIO""}

Overview


{IDF_TARGET_NAME} supports two major power saving modes: Light-sleep and Deep-sleep. According to the features used by an application, there are some sub sleep modes. See :ref:`sleep_modes` for these sleep modes and sub sleep modes. Additionally, there are some power-down options that can be configured to further reduce the power consumption. See :ref:`power_down_options` for more details.

There are se"
"veral wakeup sources in the sleep modes. These sources can also be combined so that the chip will wake up when any of the sources are triggered. :ref:`api-reference-wakeup-source` describes these wakeup sources and configuration APIs in detail.

The configuration of power-down options and wakeup sources are optional. They can be configured at any moment before entering the sleep modes.

Then the application can call sleep start APIs to enter one of the sleep modes. See :ref:`enter_sleep` for mor"
"e details. When the wakeup condition is met, the application is awoken from sleep. See :ref:`wakeup_cause` on how to get the wakeup cause, and :ref:`disable_sleep_wakeup_source` on how to handle the wakeup sources after wakeup.

.. _sleep_modes:

Sleep Modes


In Light-sleep mode, the digital peripherals, most of the RAM, and CPUs are clock-gated and their supply voltage is reduced. Upon exit from Light-sleep, the digital peripherals, RAM, and CPUs resume operation and their internal states are "
"preserved.

In Deep-sleep mode, the CPUs, most of the RAM, and all digital peripherals that are clocked from APB_CLK are powered off. The only parts of the chip that remain powered on are:

    .. list::

        - RTC controller
        :SOC_ULP_SUPPORTED: - ULP coprocessor
        :SOC_RTC_FAST_MEM_SUPPORTED: - RTC FAST memory
        :SOC_RTC_SLOW_MEM_SUPPORTED: - RTC SLOW memory

.. only:: SOC_BT_SUPPORTED

    Wi-Fi/Bluetooth and Sleep Modes
    

    In Deep-sleep and Light-sleep modes, th"
"e wireless peripherals are powered down. Before entering Deep-sleep or Light-sleep modes, the application must disable Wi-Fi and Bluetooth using the appropriate calls (i.e., :cpp:func:`esp_bluedroid_disable`, :cpp:func:`esp_bt_controller_disable`, :cpp:func:`esp_wifi_stop`). Wi-Fi and Bluetooth connections are not maintained in Deep-sleep or Light-sleep mode, even if these functions are not called.

    If Wi-Fi/Bluetooth connections need to be maintained, enable Wi-Fi/Bluetooth Modem-sleep mode"
" and automatic Light-sleep feature (see :doc:`Power Management APIs `). This allows the system to wake up from sleep automatically when required by the Wi-Fi/Bluetooth driver, thereby maintaining the connection.

.. only:: not SOC_BT_SUPPORTED

    Wi-Fi and Sleep Modes
    

    In Deep-sleep and Light-sleep modes, the wireless peripherals are powered down. Before entering Deep-sleep or Light-sleep modes, applications must disable Wi-Fi using the appropriate calls (:cpp:func:`esp_wifi_stop`). W"
"i-Fi connections are not maintained in Deep-sleep or Light-sleep mode, even if these functions are not called.

    If Wi-Fi connections need to be maintained, enable Wi-Fi Modem-sleep mode and automatic Light-sleep feature (see :doc:`Power Management APIs `). This will allow the system to wake up from sleep automatically when required by the Wi-Fi driver, thereby maintaining a connection to the AP.

.. only:: esp32s2 or esp32s3 or esp32c2 or esp32c3

    Sub Sleep Modes
    

    Tables below l"
"ist the sub sleep modes in the first row and the features they support in the first column. Modes that support more features may consume more power during sleep mode. The sleep system automatically selects the mode that satisfies all the features required by the user while consuming least power.

    Deep-sleep:

    .. list-table::
       :widths: auto
       :header-rows: 2
         - DSLP_ULTRA_LOW
         - DSLP_DEFAULT
         - DSLP_8MD256/
         -
         -
         - DSLP_ADC_TSENS"
"
         - Y
         - Y
         - Y
         -
         - Y
         - Y
         -
         -
         - Y
         -
         -
         - Y

    Features:

    Light-sleep:

    .. list-table::
       :widths: auto
       :header-rows: 2
         - LSLP_DEFAULT
         - LSLP_ADC_TSENS
         - LSLP_8MD256
         - LSLP_LEDC8M/
         -
         -
         -
         - LSLP_XTAL_FPU
         - Y
         - Y
         - Y
         - Y
         - Y
         - Y
         - Y
         "
"- Y
         -
         - Y
         - Y
         - Y
         -
         -
         - Y
         - Y
         -
         -
         -
         - Y
         -
         -
         -
         - Y

    Features: (Also see 8MD256 and ADC_TSEN_MONITOR features for Deep-sleep mode above)

    .. only:: esp32s2

        {IDF_TARGET_NAME} uses the same power mode for LSLP_8MD256, LSLP_LEDC8M, and LSLP_XTAL_FPU features.

    .. only:: esp32s3

        Default mode of {IDF_TARGET_NAME} already supports A"
"DC_TSEN_MONITOR feature.

    .. only:: esp32c2 or esp32c3

        {IDF_TARGET_NAME} does not have ADC_TSEN_MONITOR or LSLP_ADC_TSENS feature.

.. _api-reference-wakeup-source:

Wakeup Sources


Wakeup sources can be enabled using ``esp_sleep_enable_X_wakeup`` APIs. Wakeup sources are not disabled after wakeup, you can disable them using :cpp:func:`esp_sleep_disable_wakeup_source` API if you do not need them any more. See :ref:`disable_sleep_wakeup_source`.

Following are the wakeup sources sup"
"ported on {IDF_TARGET_NAME}.

Timer


The RTC controller has a built-in timer which can be used to wake up the chip after a predefined amount of time. Time is specified at microsecond precision, but the actual resolution depends on the clock source selected for RTC_SLOW_CLK.

.. only:: SOC_ULP_SUPPORTED

    For details on RTC clock options, see **{IDF_TARGET_NAME} Technical Reference Manual** > **ULP Coprocessor** [`PDF `__].

RTC peripherals or RTC memories do not need to be powered on during "
"sleep in this wakeup mode.

:cpp:func:`esp_sleep_enable_timer_wakeup` function can be used to enable sleep wakeup using a timer.

.. only:: SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP

    Touchpad
    

    The RTC IO module contains the logic to trigger wakeup when a touch sensor interrupt occurs. To wakeup from a touch sensor interrupt, users need to configure the touch pad interrupt before the chip enters Deep-sleep or Light-sleep modes.

    .. only:: esp32

        Revisions 0 and 1 of ESP32 only s"
"upport this wakeup mode when RTC peripherals are not forced to be powered on (i.e., ESP_PD_DOMAIN_RTC_PERIPH should be set to ESP_PD_OPTION_AUTO).

    :cpp:func:`esp_sleep_enable_touchpad_wakeup` function can be used to enable this wakeup source.

.. only:: SOC_PM_SUPPORT_EXT0_WAKEUP

    External Wakeup (``ext0``)
    

    The RTC IO module contains the logic to trigger wakeup when one of RTC GPIOs is set to a predefined logic level. RTC IO is part of the RTC peripherals power domain, so RTC "
"peripherals will be kept powered on during Deep-sleep if this wakeup source is requested.

    The RTC IO module is enabled in this mode, so internal pullup or pulldown resistors can also be used. They need to be configured by the application using :cpp:func:`rtc_gpio_pullup_en` and :cpp:func:`rtc_gpio_pulldown_en` functions before calling :cpp:func:`esp_deep_sleep_start`.

    .. only:: esp32

        In revisions 0 and 1 of ESP32, this wakeup source is incompatible with ULP and touch wakeup so"
"urces.

    :cpp:func:`esp_sleep_enable_ext0_wakeup` function can be used to enable this wakeup source.

    .. warning::

        After waking up from sleep, the IO pad used for wakeup will be configured as RTC IO. Therefore, before using this pad as digital GPIO, users need to reconfigure it using :cpp:func:`rtc_gpio_deinit` function.

.. only:: SOC_PM_SUPPORT_EXT1_WAKEUP

    External Wakeup (``ext1``)
    

    The RTC controller contains the logic to trigger wakeup using multiple RTC GPIOs."
" One of the following two logic functions can be used to trigger ext1 wakeup:

    .. only:: esp32

        - wake up if any of the selected pins is high (``ESP_EXT1_WAKEUP_ANY_HIGH``)
        - wake up if all the selected pins are low (``ESP_EXT1_WAKEUP_ALL_LOW``)

    .. only:: esp32s2 or esp32s3 or esp32c6 or esp32h2

        - wake up if any of the selected pins is high (``ESP_EXT1_WAKEUP_ANY_HIGH``)
        - wake up if any of the selected pins is low (``ESP_EXT1_WAKEUP_ANY_LOW``)

    This"
" wakeup source is controlled by the RTC controller. Unlike ``ext0``, this wakeup source supports wakeup even when the RTC peripheral is powered down. Although the power domain of the RTC peripheral, where RTC IOs are located, is powered down during sleep modes, ESP-IDF will automatically lock the state of the wakeup pin before the system enters sleep modes and unlock upon exiting sleep modes. Therefore, the internal pull-up or pull-down resistors can still be configured for the wakeup pin::

   "
"     esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);
        rtc_gpio_pullup_dis(gpio_num);
        rtc_gpio_pulldown_en(gpio_num);

    If we turn off the ``RTC_PERIPH`` domain, we will use the HOLD feature to maintain the pull-up and pull-down on the pins during sleep. HOLD feature will be acted on the pin internally before the system enters sleep modes, and this can further reduce power consumption::

        rtc_gpio_pullup_dis(gpio_num);
        rtc_gpio_pulldown_en(gpio_nu"
"m);

    If certain chips lack the ``RTC_PERIPH`` domain, we can only use the HOLD feature to maintain the pull-up and pull-down on the pins during sleep modes::

        gpio_pullup_dis(gpio_num);
        gpio_pulldown_en(gpio_num);

    :cpp:func:`esp_sleep_enable_ext1_wakeup_io` function can be used to append ext1 wakeup IO and set corresponding wakeup level.

    :cpp:func:`esp_sleep_disable_ext1_wakeup_io` function can be used to remove ext1 wakeup IO.

    .. only:: SOC_PM_SUPPORT_EXT1_WAK"
"EUP_MODE_PER_PIN

        The RTC controller also supports triggering wakeup, allowing configurable IO to use different wakeup levels simultaneously. This can be configured with :cpp:func:`esp_sleep_enable_ext1_wakeup_io`.

    .. only:: not SOC_PM_SUPPORT_EXT1_WAKEUP_MODE_PER_PIN

        .. note::

           Due to hardware limitation, when we use more than one IO for EXT1 wakeup, it is not allowed to configure different wakeup levels for the IOs, and there is corresponding inspection mechani"
"sm in :cpp:func:`esp_sleep_enable_ext1_wakeup_io`.

    .. warning::

        - To use the EXT1 wakeup, the IO pad(s) are configured as RTC IO. Therefore, before using these pads as digital GPIOs, users need to reconfigure them by calling the :cpp:func:`rtc_gpio_deinit` function.

        - If the RTC peripherals are configured to be powered down (which is by default), the wakeup IOs will be set to the holding state before entering sleep. Therefore, after the chip wakes up from Light-sleep, plea"
"se call ``rtc_gpio_hold_dis`` to disable the hold function to perform any pin re-configuration. For Deep-sleep wakeup, this is already being handled at the application startup stage.

.. only:: SOC_ULP_SUPPORTED

    ULP Coprocessor Wakeup
    

    ULP coprocessor can run while the chip is in sleep mode, and may be used to poll sensors, monitor ADC or touch sensor values, and wake up the chip when a specific event is detected. ULP coprocessor is part of the RTC peripherals power domain, and it "
"runs the program stored in RTC SLOW memory. RTC SLOW memory will be powered on during sleep if this wakeup mode is requested. RTC peripherals will be automatically powered on before ULP coprocessor starts running the program; once the program stops running, RTC peripherals are automatically powered down again.

    .. only:: esp32

        Revisions 0 and 1 of ESP32 only support this wakeup mode when RTC peripherals are not forced to be powered on (i.e., ESP_PD_DOMAIN_RTC_PERIPH should be set to"
" ESP_PD_OPTION_AUTO).

    :cpp:func:`esp_sleep_enable_ulp_wakeup` function can be used to enable this wakeup source.

.. only:: SOC_RTCIO_WAKE_SUPPORTED

    GPIO Wakeup (Light-sleep Only)
    

    .. only:: (SOC_PM_SUPPORT_EXT0_WAKEUP or SOC_PM_SUPPORT_EXT1_WAKEUP)

        In addition to EXT0 and EXT1 wakeup sources described above, one more method of wakeup from external inputs is available in Light-sleep mode. With this wakeup source, each pin can be individually configured to trigger wake"
"up on high or low level using :cpp:func:`gpio_wakeup_enable` function. Unlike EXT0 and EXT1 wakeup sources, which can only be used with RTC IOs, this wakeup source can be used with any IO (RTC or digital).

    .. only:: not (SOC_PM_SUPPORT_EXT0_WAKEUP or SOC_PM_SUPPORT_EXT1_WAKEUP)

        One more method of wakeup from external inputs is available in Light-sleep mode. With this wakeup source, each pin can be individually configured to trigger wakeup on high or low level using :cpp:func:`gpio_"
"wakeup_enable` function. This wakeup source can be used with any IO (RTC or digital).

    :cpp:func:`esp_sleep_enable_gpio_wakeup` function can be used to enable this wakeup source.

    .. warning::

        Before entering Light-sleep mode, check if any GPIO pin to be driven is part of the {IDF_TARGET_SPI_POWER_DOMAIN} power domain. If so, this power domain must be configured to remain ON during sleep.

        For example, on ESP32-WROOM-32 board, GPIO16 and GPIO17 are linked to {IDF_TARGET_"
"SPI_POWER_DOMAIN} power domain. If they are configured to remain high during Light-sleep, the power domain should be configured to remain powered ON. This can be done with :cpp:func:`esp_sleep_pd_config()`::

            esp_sleep_pd_config(ESP_PD_DOMAIN_VDDSDIO, ESP_PD_OPTION_ON);

.. only:: not SOC_RTCIO_WAKE_SUPPORTED

    GPIO Wakeup
    

    Any IO can be used as the external input to wake up the chip from Light-sleep. Each pin can be individually configured to trigger wakeup on high or lo"
"w level using the :cpp:func:`gpio_wakeup_enable` function. Then the :cpp:func:`esp_sleep_enable_gpio_wakeup` function should be called to enable this wakeup source.

    Additionally, IOs that are powered by the VDD3P3_RTC power domain can be used to wake up the chip from Deep-sleep. The wakeup pin and wakeup trigger level can be configured by calling :cpp:func:`esp_deep_sleep_enable_gpio_wakeup`. The function will enable the Deep-sleep wakeup for the selected pin.

    .. only:: esp32c6 or esp3"
"2h2

       .. note::

           In Light-sleep mode, setting Kconfig option :ref:`CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP` will invalidate GPIO wakeup.

UART Wakeup (Light-sleep Only)


When {IDF_TARGET_NAME} receives UART input from external devices, it is often necessary to wake up the chip when input data is available. The UART peripheral contains a feature which allows waking up the chip from Light-sleep when a certain number of positive edges on RX pin are seen. This number of posi"
"tive edges can be set using :cpp:func:`uart_set_wakeup_threshold` function. Note that the character which triggers wakeup (and any characters before it) will not be received by the UART after wakeup. This means that the external device typically needs to send an extra character to the {IDF_TARGET_NAME} to trigger wakeup before sending the data.

:cpp:func:`esp_sleep_enable_uart_wakeup` function can be used to enable this wakeup source.

    .. only:: esp32c6 or esp32h2

       .. note::

       "
"    In Light-sleep mode, setting Kconfig option :ref:`CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP` will invalidate UART wakeup.

.. _disable_sleep_wakeup_source:

Disable Sleep Wakeup Source


Previously configured wakeup sources can be disabled later using :cpp:func:`esp_sleep_disable_wakeup_source` API. This function deactivates trigger for the given wakeup source. Additionally, it can disable all triggers if the argument is ``ESP_SLEEP_WAKEUP_ALL``.

.. _power_down_options:

Power-down Opt"
"ions


The application can force specific powerdown modes for RTC peripherals and RTC memories. In Deep-sleep mode, we can also isolate some IOs to further reduce current consumption.

Power-down of RTC Peripherals and Memories


By default, :cpp:func:`esp_deep_sleep_start` and :cpp:func:`esp_light_sleep_start` functions power down all RTC power domains which are not needed by the enabled wakeup sources. To override this behaviour, :cpp:func:`esp_sleep_pd_config` function is provided.

.. only::"
" esp32

    Note: in revision 0 of ESP32, RTC FAST memory is always kept enabled in Deep-sleep, so that the Deep-sleep stub can run after reset. This can be overridden, if the application does not need clean reset behaviour after Deep-sleep.

.. only:: SOC_RTC_SLOW_MEM_SUPPORTED

    If some variables in the program are placed into RTC SLOW memory (for example, using ``RTC_DATA_ATTR`` attribute), RTC SLOW memory will be kept powered on by default. This can be overridden using :cpp:func:`esp_slee"
"p_pd_config` function, if desired.

.. only:: not SOC_RTC_SLOW_MEM_SUPPORTED and SOC_RTC_FAST_MEM_SUPPORTED

    In {IDF_TARGET_NAME}, there is only RTC FAST memory, so if some variables in the program are marked by ``RTC_DATA_ATTR``, ``RTC_SLOW_ATTR`` or ``RTC_FAST_ATTR`` attributes, all of them go to RTC FAST memory. It will be kept powered on by default. This can be overridden using :cpp:func:`esp_sleep_pd_config` function, if desired.

Power-down of Flash


By default, to avoid potential iss"
"ues, :cpp:func:`esp_light_sleep_start` function does **not** power down flash. To be more specific, it takes time to power down the flash and during this period the system may be woken up, which then actually powers up the flash before this flash could be powered down completely. As a result, there is a chance that the flash may not work properly.

So, in theory, it is ok if you only wake up the system after the flash is completely powered down. However, in reality, the flash power-down period c"
"an be hard to predict (for example, this period can be much longer when you add filter capacitors to the flash's power supply circuit) and uncontrollable (for example, the asynchronous wake-up signals make the actual sleep time uncontrollable).

.. warning::

    If a filter capacitor is added to your flash power supply circuit, please do everything possible to avoid powering down flash.

Therefore, it is recommended not to power down flash when using ESP-IDF. For power-sensitive applications, i"
"t is recommended to use Kconfig option :ref:`CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND` to reduce the power consumption of the flash during Light-sleep, instead of powering down the flash.

.. only:: SOC_SPIRAM_SUPPORTED

    It is worth mentioning that PSRAM has a similar Kconfig option :ref:`CONFIG_ESP_SLEEP_PSRAM_LEAKAGE_WORKAROUND`.

However, for those who have fully understood the risk and are still willing to power down the flash to further reduce the power consumption, please check the fo"
"llowing mechanisms:

    .. list::

        - Setting Kconfig option :ref:`CONFIG_ESP_SLEEP_POWER_DOWN_FLASH` only powers down the flash when the RTC timer is the only wake-up source **and** the sleep time is longer than the flash power-down period.
        - Calling ``esp_sleep_pd_config(ESP_PD_DOMAIN_VDDSDIO, ESP_PD_OPTION_OFF)`` powers down flash when the RTC timer is not enabled as a wakeup source **or** the sleep time is longer than the flash power-down period.

.. note::

    .. list::

  "
"      - ESP-IDF does not provide any mechanism that can power down the flash in all conditions when Light-sleep.
        - :cpp:func:`esp_deep_sleep_start` function forces power down flash regardless of user configuration.

Configuring IOs (Deep-sleep Only)


Some {IDF_TARGET_NAME} IOs have internal pullups or pulldowns, which are enabled by default. If an external circuit drives this pin in Deep-sleep mode, current consumption may increase due to current flowing through these pullups and pulldo"
"wns.

.. only:: SOC_RTCIO_HOLD_SUPPORTED and SOC_RTCIO_INPUT_OUTPUT_SUPPORTED

    To isolate a pin to prevent extra current draw, call :cpp:func:`rtc_gpio_isolate` function.

    For example, on ESP32-WROVER module, GPIO12 is pulled up externally, and it also has an internal pulldown in the ESP32 chip. This means that in Deep-sleep, some current flows through these external and internal resistors, increasing Deep-sleep current above the minimal possible value.

    Add the following code before"
" :cpp:func:`esp_deep_sleep_start` to remove such extra current::

        rtc_gpio_isolate(GPIO_NUM_12);

.. only:: esp32c2 or esp32c3

    In Deep-sleep mode:
        - digital GPIOs (GPIO6 ~ 21) are in a high impedance state.
        - RTC GPIOs (GPIO0 ~ 5) can be in the following states, depending on their hold function enabled or not:
            - if the hold function is not enabled, RTC GPIOs will be in a high impedance state.
            - if the hold function is enabled, RTC GPIOs will r"
"etain the pin state latched at that hold moment.

.. _enter_sleep:

Entering Sleep


:cpp:func:`esp_light_sleep_start` or :cpp:func:`esp_deep_sleep_start` functions can be used to enter Light-sleep or Deep-sleep modes correspondingly. After that, the system configures the parameters of RTC controller according to the requested wakeup sources and power-down options.

It is also possible to enter sleep modes with no wakeup sources configured. In this case, the chip will be in sleep modes indefinit"
"ely until external reset is applied.

UART Output Handling


Before entering sleep mode, :cpp:func:`esp_deep_sleep_start` will flush the contents of UART FIFOs.

When entering Light-sleep mode using :cpp:func:`esp_light_sleep_start`, UART FIFOs will not be flushed. Instead, UART output will be suspended, and remaining characters in the FIFO will be sent out after wakeup from Light-sleep.

.. _wakeup_cause:

Checking Sleep Wakeup Cause


:cpp:func:`esp_sleep_get_wakeup_cause` function can be used"
" to check which wakeup source has triggered wakeup from sleep mode.

.. only:: SOC_TOUCH_SENSOR_SUPPORTED

    For touchpad, it is possible to identify which touch pin has caused wakeup using :cpp:func:`esp_sleep_get_touchpad_wakeup_status` functions.

.. only:: SOC_PM_SUPPORT_EXT1_WAKEUP

    For ext1 wakeup sources, it is possible to identify which touch pin has caused wakeup using :cpp:func:`esp_sleep_get_ext1_wakeup_status` functions.

Application Example


.. list::

    - :example:`protoco"
"ls/sntp`: the implementation of basic functionality of Deep-sleep, where ESP module is periodically waken up to retrieve time from NTP server.
    - :example:`wifi/power_save`: the usage of Wi-Fi Modem-sleep mode and automatic Light-sleep feature to maintain Wi-Fi connections.
    :SOC_BT_SUPPORTED: - :example:`bluetooth/nimble/power_save`: the usage of Bluetooth Modem-sleep mode and automatic Light-sleep feature to maintain Bluetooth connections.
    :SOC_ULP_SUPPORTED: - :example:`system/deep_"
"sleep`: the usage of various Deep-sleep wakeup triggers and ULP coprocessor programming.
    :not SOC_ULP_SUPPORTED: - :example:`system/deep_sleep`: the usage of Deep-sleep wakeup triggered by various sources supported by the chip (RTC Timer, GPIO, EXT0, EXT1, Touch Sensor, etc.).
    - :example:`system/light_sleep`: the usage of Light-sleep wakeup triggered by various sources supported by the chip (Timer, GPIO, Touch Sensor, etc.).


API Reference


.. include-build-file:: inc/esp_sleep.inc
"
"Logging library




Overview


The logging library provides three ways for setting log verbosity:

- **At compile time**: in menuconfig, set the verbosity level using the option :ref:`CONFIG_LOG_DEFAULT_LEVEL`.
- Optionally, also in menuconfig, set the maximum verbosity level using the option :ref:`CONFIG_LOG_MAXIMUM_LEVEL`. By default, this is the same as the default level, but it can be set higher in order to compile more optional logs into the firmware.
- **At runtime**: all logs for verbosit"
"y levels lower than :ref:`CONFIG_LOG_DEFAULT_LEVEL` are enabled by default. The function :cpp:func:`esp_log_level_set` can be used to set a logging level on a per-module basis. Modules are identified by their tags, which are human-readable ASCII zero-terminated strings.
- **At runtime**: if :ref:`CONFIG_LOG_MASTER_LEVEL` is enabled then a ``Master logging level`` can be set using :cpp:func:`esp_log_set_level_master`. This option adds an additional logging level check for all compiled logs. Note "
"that this will increase application size. This feature is useful if you want to compile a lot of logs that are selectable at runtime, but also want to avoid the performance hit from looking up the tags and their log level when you don't want log output.

There are the following verbosity levels:

- Error (lowest)
- Warning
- Info
- Debug
- Verbose (highest)

.. note::

    The function :cpp:func:`esp_log_level_set` cannot set logging levels higher than specified by :ref:`CONFIG_LOG_MAXIMUM_LEVEL"
"`. To increase log level for a specific file above this maximum at compile time, use the macro `LOG_LOCAL_LEVEL` (see the details below).


How to Use Logging Library


In each C file that uses logging functionality, define the TAG variable as shown below:

.. code-block:: c

    static const char* TAG = ""MyModule"";

Then use one of logging macros to produce output, e.g:

.. code-block:: c

    ESP_LOGW(TAG, ""Baud rate error %.1f%%. Requested: %d baud, actual: %d baud"", error * 100, baud_req, ba"
"ud_real);

Several macros are available for different verbosity levels:

Additionally, there are ``ESP_EARLY_LOGx`` versions for each of these macros, e.g. :c:macro:`ESP_EARLY_LOGE`. These versions have to be used explicitly in the early startup code only, before heap allocator and syscalls have been initialized. Normal ``ESP_LOGx`` macros can also be used while compiling the bootloader, but they will fall back to the same implementation as ``ESP_EARLY_LOGx`` macros.

There are also ``ESP_DRAM_L"
"OGx`` versions for each of these macros, e.g. :c:macro:`ESP_DRAM_LOGE`. These versions are used in some places where logging may occur with interrupts disabled or with flash cache inaccessible. Use of this macros should be as sparse as possible, as logging in these types of code should be avoided for performance reasons.

.. note::

    Inside critical sections interrupts are disabled so it's only possible to use ``ESP_DRAM_LOGx`` (preferred) or ``ESP_EARLY_LOGx``. Even though it's possible to l"
"og in these situations, it's better if your program can be structured not to require it.

To override default verbosity level at file or component scope, define the ``LOG_LOCAL_LEVEL`` macro.

At file scope, define it before including ``esp_log.h``, e.g.:

.. code-block:: c

    #define LOG_LOCAL_LEVEL ESP_LOG_VERBOSE
    #include ""esp_log.h""

At component scope, define it in the component CMakeLists:

.. code-block:: cmake

    target_compile_definitions(${COMPONENT_LIB} PUBLIC ""-DLOG_LOCAL_LEV"
"EL=ESP_LOG_VERBOSE"")

To configure logging output per module at runtime, add calls to the function :cpp:func:`esp_log_level_set` as follows:

.. code-block:: c

   esp_log_level_set(""*"", ESP_LOG_ERROR);        // set all components to ERROR level
   esp_log_level_set(""wifi"", ESP_LOG_WARN);      // enable WARN logs from WiFi stack
   esp_log_level_set(""dhcpc"", ESP_LOG_INFO);     // enable INFO logs from DHCP client

.. note::

    The ""DRAM"" and ""EARLY"" log macro variants documented above do not "
"support per module setting of log verbosity. These macros will always log at the ""default"" verbosity level, which can only be changed at runtime by calling ``esp_log_level(""*"", level)``.

Even when logs are disabled by using a tag name, they will still require a processing time of around 10.9 microseconds per entry.

Master Logging Level


To enable the Master logging level feature, the :ref:`CONFIG_LOG_MASTER_LEVEL` option must be enabled. It adds an additional level check for ``ESP_LOGx`` macr"
"os before calling :cpp:func:`esp_log_write`. This allows to set a higher :ref:`CONFIG_LOG_MAXIMUM_LEVEL`, but not inflict a performance hit during normal operation (only when directed). An application may set the master logging level (:cpp:func:`esp_log_set_level_master`) globally to enforce a maximum log level. ``ESP_LOGx`` macros above this level will be skipped immediately, rather than calling :cpp:func:`esp_log_write` and doing a tag lookup. It is recommended to only use this in an top-level"
" application and not in shared components as this would override the global log level for any user using the component. By default, at startup, the Master logging level is :ref:`CONFIG_LOG_DEFAULT_LEVEL`.

Note that this feature increases application size because the additional check is added into all ``ESP_LOGx`` macros.

The snippet below shows how it works. Setting the Master logging level to ``ESP_LOG_NONE`` disables all logging globally. :cpp:func:`esp_log_level_set` does not currently affe"
"ct logging. But after the Master logging level is released, the logs will be printed as set by :cpp:func:`esp_log_level_set`.

.. code-block:: c

    // Master logging level is CONFIG_LOG_DEFAULT_LEVEL at start up and = ESP_LOG_INFO
    ESP_LOGI(""lib_name"", ""Message for print"");          // prints a INFO message
    esp_log_level_set(""lib_name"", ESP_LOG_WARN);        // enables WARN logs from lib_name

    esp_log_set_level_master(ESP_LOG_NONE);             // disables all logs globally. esp_log"
"_level_set has no effect at the moment

    ESP_LOGW(""lib_name"", ""Message for print"");          // no print, Master logging level blocks it
    esp_log_level_set(""lib_name"", ESP_LOG_INFO);        // enable INFO logs from lib_name
    ESP_LOGI(""lib_name"", ""Message for print"");          // no print, Master logging level blocks it

    esp_log_set_level_master(ESP_LOG_INFO);             // enables all INFO logs globally

    ESP_LOGI(""lib_name"", ""Message for print"");          // prints a INFO messa"
"ge

Logging to Host via JTAG


By default, the logging library uses the vprintf-like function to write formatted output to the dedicated UART. By calling a simple API, all log output may be routed to JTAG instead, making logging several times faster. For details, please refer to Section :ref:`app_trace-logging-to-host`.

Thread Safety


The log string is first written into a memory buffer and then sent to the UART for printing. Log calls are thread-safe, i.e., logs of different threads do not co"
"nflict with each other.


Application Example


The logging library is commonly used by most ESP-IDF components and examples. For demonstration of log functionality, check ESP-IDF's :idf:`examples` directory. The most relevant examples that deal with logging are the following:

API Reference


.. include-build-file:: inc/esp_log.inc
"
"Memory Management for MMU Supported Memory




.. toctree::
    :maxdepth: 1

Introduction


{IDF_TARGET_NAME} Memory Management Unit (MMU) is relatively simple. It can do memory address translation between physical memory addresses and virtual memory addresses. So CPU can access physical memories via virtual addresses. There are multiple types of virtual memory addresses, which have different capabilities.

ESP-IDF provides a memory mapping driver that manages the relation between these physica"
"l memory addresses and virtual memory addresses, so as to achieve some features such as reading from SPI flash via a pointer.

Memory mapping driver is actually a capabilities-based virtual memory address allocator that allows applications to make virtual memory address allocations for different purposes. In the following chapters, we call this driver ``esp_mmap`` driver.

ESP-IDF also provides a memory synchronization driver which can be used for potential memory desynchronization scenarios.

P"
"hysical Memory Types


Memory mapping driver currently supports mapping to following physical memory type(s):

.. list::

    - SPI flash
    :SOC_SPIRAM_SUPPORTED and not esp32: - PSRAM


Virtual Memory Capabilities


.. list::

    - :cpp:enumerator:`MMU_MEM_CAP_EXEC`: This capability indicates that the virtual memory address has the execute permission. Note this permission scope is within the MMU hardware.
    - :cpp:enumerator:`MMU_MEM_CAP_READ`: This capability indicates that the virtual me"
"mory address has the read permission. Note this permission scope is within the MMU hardware.
    - :cpp:enumerator:`MMU_MEM_CAP_WRITE`: This capability indicates that the virtual memory address has the write permission. Note this permission scope is within the MMU hardware.
    - :cpp:enumerator:`MMU_MEM_CAP_32BIT`: This capability indicates that the virtual memory address allows for 32 bits or multiples of 32 bits access.
    - :cpp:enumerator:`MMU_MEM_CAP_8BIT`: This capability indicates that "
"the virtual memory address allows for 8 bits or multiples of 8 bits access.


.. only:: esp32


    8 MB external memory addresses (from 0x40400000 to 0x40C00000) which have the :cpp:enumerator:`MMU_MEM_CAP_EXEC` and :cpp:enumerator:`MMU_MEM_CAP_READ` capabilities are not available for users to allocate, due to hardware limitations.


.. only:: esp32s2

    4 MB external memory addresses (from 0x40400000 to 0x40800000) which have the :cpp:enumerator:`MMU_MEM_CAP_EXEC` and :cpp:enumerator:`MMU_ME"
"M_CAP_READ` capabilities are not avaiable for users to allocate, due to hardware limitations.


You can call :cpp:func:`esp_mmu_map_get_max_consecutive_free_block_size` to know the largest consecutive mappable block size with certain capabilities.


Memory Management Drivers



Driver Concept



Terminology


The virtual memory pool is made up with one or multiple virtual memory regions, see below figure:

.. image:: /../_static/diagrams/mmu/mem_pool.png
    :scale: 80 %
    :align: center


- A"
" virtual memory pool stands for the whole virtual address range that can be mapped to physical memory.
- A virtual memory region is a range of virtual address with same attributes.
- A virtual memory block is a piece of virtual address range that is dynamically mapped.
- A slot is the virtual address range between two virtual memory blocks.
- A physical memory block is a piece of physical address range that is to-be-mapped or already mapped to a virtual memory block.
- Dynamical mapping is done "
"by calling ``esp_mmap`` driver API :cpp:func:`esp_mmu_map`. This API maps the given physical memory block to a virtual memory block which is allocated by the ``esp_mmap`` driver.


Relation Between Memory Blocks


When mapping a physical memory block A, block A can have one of the following relations with another previously mapped physical memory block B:

- Enclosed: block A is completely enclosed within block B, see figure below:

  .. image:: /../_static/diagrams/mmu/enclosed.png
    :scale: "
"80 %
    :align: center

- Identical: block A is completely the same as block B, see figure below:

  .. image:: /../_static/diagrams/mmu/identical.png
    :scale: 80 %
    :align: center

  Note that ``esp_mmap`` driver considers the identical scenario **the same as the enclosed scenario**.

- Overlapped: block A is overlapped with block B, see figure below:

  .. image:: /../_static/diagrams/mmu/overlapped.png
    :scale: 80 %
    :align: center

  There is a special condition, when block A en"
"tirely encloses block B, see figure below:

  .. image:: /../_static/diagrams/mmu/inversed_enclosed.png
    :scale: 70 %
    :align: center

  Note that ``esp_mmap`` driver considers this scenario **the same as the overlapped scenario**.


Driver Behaviour


Memory Map


You can call :cpp:func:`esp_mmu_map` to do a dynamical mapping. This API can allocate a certain size of virtual memory block according to the virtual memory capabilities you selected, then map this virtual memory block to the ph"
"ysical memory block as you requested. The ``esp_mmap`` driver supports mapping to one or more types of physical memory, so you should specify the physical memory target when mapping.

By default, physical memory blocks and virtual memory blocks are one-to-one mapped. This means, when calling :cpp:func:`esp_mmu_map`:

Specially, you can use :c:macro:`ESP_MMU_MMAP_FLAG_PADDR_SHARED`. This flag stands for one-to-multiple mapping between a physical address and multiple virtual addresses:


Memory Un"
"map


You can call :cpp:func:`esp_mmu_unmap` to unmap a previously mapped memory block. This API returns an :c:macro:`ESP_ERR_NOT_FOUND` if you are trying to unmap a virtual memory block that is not mapped to any physical memory block yet.


Memory Address Conversion


The ``esp_mmap`` driver provides two helper APIs to do the conversion between virtual memory address and physical memory address：


Memory Synchronization


MMU supported physical memories can be accessed by one or multiple method"
"s.

SPI flash can be accessed by SPI1 (ESP-IDF ``esp_flash`` driver APIs), or by pointers. ESP-IDF ``esp_flash`` driver APIs have already considered the memory synchronization, so users do not need to worry about this.

.. only:: SOC_SPIRAM_SUPPORTED

    PSRAM can be accessed by pointers, hardware guarantees the data consistency when PSRAM is only accessed via pointers.

.. only:: esp32s3

    PSRAM can also be accessed by EDMA. Data desynchronization may happen because hardware does not guaran"
"tee the data consistency under such condition. You should call :cpp:func:`esp_cache_msync` to synchronize the Cache and the PSRAM.

    See :doc:`/api-reference/system/mm_sync` for more details.


Thread Safety


APIs in ``esp_mmu_map.h`` are not guaranteed to be thread-safe.

APIs in ``esp_cache.h`` are guaranteed to be thread-safe.


API Reference


API Reference - ESP MMAP Driver


.. include-build-file:: inc/esp_mmu_map.inc
"
"Internal and Unstable APIs




This section is listing some APIs that are internal or likely to be changed or removed in the next releases of ESP-IDF.


API Reference


.. include-build-file:: inc/esp_rom_sys.inc
"
"Inter-Processor Call (IPC)




.. note::

    IPC stands for an **""Inter-Processor Call""** and **NOT** ""Inter-Process Communication"" as found on other operating systems.

Overview


Due to the dual core nature of the {IDF_TARGET_NAME}, there are some scenarios where a certain callback must be executed from a particular core such as:

- When allocating an ISR to an interrupt source of a particular core (applies to freeing a particular core's interrupt source as well)
- On particular chips (such a"
"s the ESP32), accessing memory that is exclusive to a particular core (such as RTC Fast Memory)
- Reading the registers/state of another core

The IPC (Inter-Processor Call) feature allows a particular core (the calling core) to trigger the execution of a callback function on another core (the target core). The IPC feature allows execution of a callback function on the target core in either a task context, or an interrupt context. Depending on the context that the callback function is executed i"
"n, different restrictions apply to the implementation of the callback function.

IPC in Task Context


The IPC feature implements callback execution in a task context by creating an IPC task for each core during application startup. When the calling core needs to execute a callback on the target core, the callback will execute in the context of the target core's IPC task.

When using IPCs in a task context, users need to consider the following:

- IPC callbacks should ideally be simple and short"
". An IPC callback **must never block or yield**.
- The IPC tasks are created at the highest possible priority (i.e., ``configMAX_PRIORITIES - 1``).

    - If :ref:`CONFIG_ESP_IPC_USES_CALLERS_PRIORITY` is enabled, the target core's IPC task will be lowered to the current priority of the target core before executing the callback.
    - If :ref:`CONFIG_ESP_IPC_USES_CALLERS_PRIORITY` is disabled, the target core will always execute the callback at the highest possible priority.

- Depending on the "
"complexity of the callback, users may need to configure the stack size of the IPC task via :ref:`CONFIG_ESP_IPC_TASK_STACK_SIZE`.
- The IPC feature is internally protected by a mutex. Therefore, simultaneous IPC calls from two or more calling core's are serialized on a first come first serve basis.

API Usage


Task Context IPC callbacks have the following restrictions:

- The callback must be of the :cpp:type:`esp_ipc_func_t` type.
- The callback **must never block or yield** as this will resul"
"t in the target core's IPC task blocking or yielding.
- The callback must avoid changing any aspect of the IPC task's state, e.g., by calling ``vTaskPrioritySet(NULL, x)``.

The IPC feature offers the API listed below to execute a callback in a task context on a target core. The API allows the calling core to block until the callback's execution has completed, or return immediately once the callback's execution has started.

- :cpp:func:`esp_ipc_call` triggers an IPC call on the target core. Thi"
"s function will block until the target core's IPC task **begins** execution of the callback.
- :cpp:func:`esp_ipc_call_blocking` triggers an IPC on the target core. This function will block until the target core's IPC task **completes** execution of the callback.

IPC in Interrupt Context


In some cases, we need to quickly obtain the state of another core such as in a core dump, GDB stub, various unit tests, and hardware errata workarounds. The IPC ISR feature implements callback execution from"
" a High Priority Interrupt context by reserving a High Priority Interrupt on each core for IPC usage. When a calling core needs to execute a callback on the target core, the callback will execute in the context of the High Priority Interrupt of the target core.

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    For such scenarios, the IPC ISR feature supports execution of callbacks in a :doc:`High Priority Interrupt ` context.

When using IPCs in High Priority Interrupt context, users need to conside"
"r the following:

.. list::

    :CONFIG_IDF_TARGET_ARCH_XTENSA: - Since the callback is executed in a High Priority Interrupt context, the callback must be written entirely in assembly. See the API Usage below for more details regarding writing assembly callbacks.
    - The priority of the reserved High Priority Interrupt is dependent on the :ref:`CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL` option.

When the callback executes, users need to consider the following:

.. list::

    - The calling core will"
" disable interrupts of priority level 3 and lower.
    :CONFIG_IDF_TARGET_ARCH_XTENSA: - Although the priority of the reserved interrupt depends on :ref:`CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL`, during the execution of IPC ISR callback, the target core will disable interrupts of priority level 5 and lower regardless of what :ref:`CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL` is set to.
    :CONFIG_IDF_TARGET_ARCH_RISCV: - Although the priority of the reserved interrupt depends on :ref:`CONFIG_ESP_SYSTEM_CHECK_I"
"NT_LEVEL`, during the execution of IPC ISR callback, the target core will disable all interrupts.

API Usage


.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    High Priority Interrupt IPC callbacks have the following restrictions:

    - The callback must be of type :cpp:type:`esp_ipc_isr_func_t` but implemented entirely in assembly.
    - The callback is invoked via the ``CALLX0`` instruction with register windowing disabled, thus the callback:
        - must not call any register window related in"
"structions, e.g., ``entry`` and ``retw``.
        - must not call other C functions as register windowing is disabled.
    - The callback should be placed in IRAM at a 4-byte aligned address.
    - On invocation of, or after returning from the callback, the registers ``a2, a3, a4`` are saved/restored automatically, thus can be used in the callback. The callback should **ONLY** use those registers.
        - ``a2`` contains the ``void *arg`` of the callback.
        - ``a3/a4`` are free to use as"
" scratch registers.

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

    High Priority Interrupt IPC callbacks must be of type :cpp:type:`esp_ipc_isr_func_t` and have the same restrictions as for regular interrupt handlers. The callback function can be written in C.

The IPC feature offers the API listed below to execute a callback in a High Priority Interrupt context:

- :cpp:func:`esp_ipc_isr_call` triggers an IPC call on the target core. This function will busy-wait until the target core **begins** e"
"xecution of the callback.
- :cpp:func:`esp_ipc_isr_call_blocking` triggers an IPC call on the target core. This function will busy-wait until the target core **completes** execution of the callback.

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    The following code-blocks demonstrates a High Priority Interrupt IPC callback written in assembly that simply reads the target core's cycle count:

    .. code-block:: asm

        /* esp_test_ipc_isr_get_cycle_count_other_cpu(void *arg) */
        // thi"
"s function reads CCOUNT of the target core and stores it in arg.
        // use only a2, a3 and a4 regs here.
        .section    .iram1, ""ax""
        .align      4
        .global     esp_test_ipc_isr_get_cycle_count_other_cpu
        .type       esp_test_ipc_isr_get_cycle_count_other_cpu, @function
        // Args:
        // a2 - void* arg
        esp_test_ipc_isr_get_cycle_count_other_cpu:
        rsr.ccount a3
        s32i    a3, a2, 0
        ret

    .. code-block:: c

        unit32_t cy"
"cle_count;
        esp_ipc_isr_call_blocking(esp_test_ipc_isr_get_cycle_count_other_cpu, (void *)cycle_count);

    .. note::

        The number of scratch registers available for use is sufficient for most simple use cases. But if your callback requires more scratch registers, ``void *arg`` can point to a buffer that is used as a register save area. The callback can then save and restore more registers. See the :example:`system/ipc/ipc_isr`.

    .. note::

        For more examples of High Pr"
"iority Interrupt IPC callbacks, you can refer to :idf_file:`components/esp_system/port/arch/xtensa/esp_ipc_isr_routines.S` and :idf_file:`components/esp_system/test_apps/esp_system_unity_tests/main/port/arch/xtensa/test_ipc_isr.S`.

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

    See :idf_file:`examples/system/ipc/ipc_isr/riscv/main/main.c` for an example of its use.

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    See :idf_file:`examples/system/ipc/ipc_isr/xtensa/main/main.c` for an example of its use"
".

The High Priority Interrupt IPC API also provides the following convenience functions that can stall/resume the target core. These APIs utilize the High Priority Interrupt IPC, but supply their own internal callbacks:

.. list::

    :CONFIG_IDF_TARGET_ARCH_RISCV: - :cpp:func:`esp_ipc_isr_stall_other_cpu` stalls the target core. The calling core disables interrupts of level 3 and lower, while the target core will busy-wait with all interrupts disabled. The target core will busy-wait until :cp"
"p:func:`esp_ipc_isr_release_other_cpu` is called.
    :CONFIG_IDF_TARGET_ARCH_XTENSA: - :cpp:func:`esp_ipc_isr_stall_other_cpu` stalls the target core. The calling core disables interrupts of level 3 and lower while the target core will busy-wait with interrupts of level 5 and lower disabled. The target core will busy-wait until :cpp:func:`esp_ipc_isr_release_other_cpu` is called.
    - :cpp:func:`esp_ipc_isr_release_other_cpu` resumes the target core.

API Reference


.. include-build-file:: in"
"c/esp_ipc.inc

.. include-build-file:: inc/esp_ipc_isr.inc
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
| ECO1   | v0.1                   |
+++
"
"
.. code-block:: none

    $ ./efuse_table_gen.py {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Parsing efuse CSV input file $IDF_PATH/components/efuse/esp32s2/esp_efuse_table.csv ...
    Verifying efuse table...
    Max number of bits in BLK 256
    Sorted efuse table:
    #       field_name                      efuse_block     bit_start       bit_count
    1       WR_DIS                          EFUSE_BLK0         0               32
    2       WR_DIS.RD_DIS                   EFUSE_BL"
"K0         0               1
    3       WR_DIS.DIS_ICACHE               EFUSE_BLK0         2               1
    4       WR_DIS.DIS_DCACHE               EFUSE_BLK0         2               1
    5       WR_DIS.DIS_DOWNLOAD_ICACHE      EFUSE_BLK0         2               1
    6       WR_DIS.DIS_DOWNLOAD_DCACHE      EFUSE_BLK0         2               1
    7       WR_DIS.DIS_FORCE_DOWNLOAD       EFUSE_BLK0         2               1
    8       WR_DIS.DIS_USB                  EFUSE_BLK0         2  "
"             1
    9       WR_DIS.DIS_TWAI                 EFUSE_BLK0         2               1
    10      WR_DIS.DIS_BOOT_REMAP           EFUSE_BLK0         2               1
    11      WR_DIS.SOFT_DIS_JTAG            EFUSE_BLK0         2               1
    12      WR_DIS.HARD_DIS_JTAG            EFUSE_BLK0         2               1
    13      WR_DIS.DIS_DOWNLOAD_MANUAL_ENCRYPT      EFUSE_BLK0         2               1
    14      WR_DIS.VDD_SPI_XPD              EFUSE_BLK0         3        "
"       1
    15      WR_DIS.VDD_SPI_TIEH             EFUSE_BLK0         3               1
    16      WR_DIS.VDD_SPI_FORCE            EFUSE_BLK0         3               1
    17      WR_DIS.WDT_DELAY_SEL            EFUSE_BLK0         3               1
    18      WR_DIS.SPI_BOOT_CRYPT_CNT       EFUSE_BLK0         4               1
    19      WR_DIS.SECURE_BOOT_KEY_REVOKE0  EFUSE_BLK0         5               1
    20      WR_DIS.SECURE_BOOT_KEY_REVOKE1  EFUSE_BLK0         6               1
    2"
"1      WR_DIS.SECURE_BOOT_KEY_REVOKE2  EFUSE_BLK0         7               1
    22      WR_DIS.KEY_PURPOSE_0            EFUSE_BLK0         8               1
    23      WR_DIS.KEY_PURPOSE_1            EFUSE_BLK0         9               1
    24      WR_DIS.KEY_PURPOSE_2            EFUSE_BLK0         10              1
    25      WR_DIS.KEY_PURPOSE_3            EFUSE_BLK0         11              1
    26      WR_DIS.KEY_PURPOSE_4            EFUSE_BLK0         12              1
    27      WR_DIS."
"KEY_PURPOSE_5            EFUSE_BLK0         13              1
    28      WR_DIS.SECURE_BOOT_EN           EFUSE_BLK0         15              1
    29      WR_DIS.SECURE_BOOT_AGGRESSIVE_REVOKE    EFUSE_BLK0         16              1
    30      WR_DIS.FLASH_TPUW               EFUSE_BLK0         18              1
    31      WR_DIS.DIS_DOWNLOAD_MODE        EFUSE_BLK0         18              1
    32      WR_DIS.DIS_LEGACY_SPI_BOOT      EFUSE_BLK0         18              1
    33      WR_DIS.UART_P"
"RINT_CHANNEL       EFUSE_BLK0         18              1
    34      WR_DIS.DIS_USB_DOWNLOAD_MODE    EFUSE_BLK0         18              1
    35      WR_DIS.ENABLE_SECURITY_DOWNLOAD         EFUSE_BLK0         18              1
    36      WR_DIS.UART_PRINT_CONTROL       EFUSE_BLK0         18              1
    37      WR_DIS.PIN_POWER_SELECTION      EFUSE_BLK0         18              1
    38      WR_DIS.FLASH_TYPE               EFUSE_BLK0         18              1
    39      WR_DIS.FORCE_SEND_R"
"ESUME        EFUSE_BLK0         18              1
    40      WR_DIS.SECURE_VERSION           EFUSE_BLK0         18              1
    41      WR_DIS.BLK1                     EFUSE_BLK0         20              1
    42      WR_DIS.MAC                      EFUSE_BLK0         20              1
    43      WR_DIS.SPI_PAD_CONFIG_CLK       EFUSE_BLK0         20              1
    44      WR_DIS.SPI_PAD_CONFIG_Q         EFUSE_BLK0         20              1
    45      WR_DIS.SPI_PAD_CONFIG_D         E"
"FUSE_BLK0         20              1
    46      WR_DIS.SPI_PAD_CONFIG_CS        EFUSE_BLK0         20              1
    47      WR_DIS.SPI_PAD_CONFIG_HD        EFUSE_BLK0         20              1
    48      WR_DIS.SPI_PAD_CONFIG_WP        EFUSE_BLK0         20              1
    49      WR_DIS.SPI_PAD_CONFIG_DQS       EFUSE_BLK0         20              1
    50      WR_DIS.SPI_PAD_CONFIG_D4        EFUSE_BLK0         20              1
    51      WR_DIS.SPI_PAD_CONFIG_D5        EFUSE_BLK0     "
"    20              1
    52      WR_DIS.SPI_PAD_CONFIG_D6        EFUSE_BLK0         20              1
    53      WR_DIS.SPI_PAD_CONFIG_D7        EFUSE_BLK0         20              1
    54      WR_DIS.WAFER_VERSION_MAJOR      EFUSE_BLK0         20              1
    55      WR_DIS.WAFER_VERSION_MINOR_HI   EFUSE_BLK0         20              1
    56      WR_DIS.FLASH_VERSION            EFUSE_BLK0         20              1
    57      WR_DIS.BLK_VERSION_MAJOR        EFUSE_BLK0         20        "
"      1
    58      WR_DIS.PSRAM_VERSION            EFUSE_BLK0         20              1
    59      WR_DIS.PKG_VERSION              EFUSE_BLK0         20              1
    60      WR_DIS.WAFER_VERSION_MINOR_LO   EFUSE_BLK0         20              1
    61      WR_DIS.SYS_DATA_PART1           EFUSE_BLK0         21              1
    62      WR_DIS.OPTIONAL_UNIQUE_ID       EFUSE_BLK0         21              1
    63      WR_DIS.ADC_CALIB                EFUSE_BLK0         21              1
    64"
"      WR_DIS.BLK_VERSION_MINOR        EFUSE_BLK0         21              1
    65      WR_DIS.TEMP_CALIB               EFUSE_BLK0         21              1
    66      WR_DIS.RTCCALIB_V1IDX_A10H      EFUSE_BLK0         21              1
    67      WR_DIS.RTCCALIB_V1IDX_A11H      EFUSE_BLK0         21              1
    68      WR_DIS.RTCCALIB_V1IDX_A12H      EFUSE_BLK0         21              1
    69      WR_DIS.RTCCALIB_V1IDX_A13H      EFUSE_BLK0         21              1
    70      WR_DIS.R"
"TCCALIB_V1IDX_A20H      EFUSE_BLK0         21              1
    71      WR_DIS.RTCCALIB_V1IDX_A21H      EFUSE_BLK0         21              1
    72      WR_DIS.RTCCALIB_V1IDX_A22H      EFUSE_BLK0         21              1
    73      WR_DIS.RTCCALIB_V1IDX_A23H      EFUSE_BLK0         21              1
    74      WR_DIS.RTCCALIB_V1IDX_A10L      EFUSE_BLK0         21              1
    75      WR_DIS.RTCCALIB_V1IDX_A11L      EFUSE_BLK0         21              1
    76      WR_DIS.RTCCALIB_V1IDX_"
"A12L      EFUSE_BLK0         21              1
    77      WR_DIS.RTCCALIB_V1IDX_A13L      EFUSE_BLK0         21              1
    78      WR_DIS.RTCCALIB_V1IDX_A20L      EFUSE_BLK0         21              1
    79      WR_DIS.RTCCALIB_V1IDX_A21L      EFUSE_BLK0         21              1
    80      WR_DIS.RTCCALIB_V1IDX_A22L      EFUSE_BLK0         21              1
    81      WR_DIS.RTCCALIB_V1IDX_A23L      EFUSE_BLK0         21              1
    82      WR_DIS.BLOCK_USR_DATA           EFUS"
"E_BLK0         22              1
    83      WR_DIS.CUSTOM_MAC               EFUSE_BLK0         22              1
    84      WR_DIS.BLOCK_KEY0               EFUSE_BLK0         23              1
    85      WR_DIS.BLOCK_KEY1               EFUSE_BLK0         24              1
    86      WR_DIS.BLOCK_KEY2               EFUSE_BLK0         25              1
    87      WR_DIS.BLOCK_KEY3               EFUSE_BLK0         26              1
    88      WR_DIS.BLOCK_KEY4               EFUSE_BLK0        "
" 27              1
    89      WR_DIS.BLOCK_KEY5               EFUSE_BLK0         28              1
    90      WR_DIS.BLOCK_SYS_DATA2          EFUSE_BLK0         29              1
    91      WR_DIS.USB_EXCHG_PINS           EFUSE_BLK0         30              1
    92      WR_DIS.USB_EXT_PHY_ENABLE       EFUSE_BLK0         30              1
    93      WR_DIS.USB_FORCE_NOPERSIST      EFUSE_BLK0         30              1
    94      WR_DIS.BLOCK0_VERSION           EFUSE_BLK0         30           "
"   1
    95      RD_DIS                          EFUSE_BLK0         32              7
    96      RD_DIS.BLOCK_KEY0               EFUSE_BLK0         32              1
    97      RD_DIS.BLOCK_KEY1               EFUSE_BLK0         33              1
    98      RD_DIS.BLOCK_KEY2               EFUSE_BLK0         34              1
    99      RD_DIS.BLOCK_KEY3               EFUSE_BLK0         35              1
    100     RD_DIS.BLOCK_KEY4               EFUSE_BLK0         36              1
    101  "
"   RD_DIS.BLOCK_KEY5               EFUSE_BLK0         37              1
    102     RD_DIS.BLOCK_SYS_DATA2          EFUSE_BLK0         38              1
    103     DIS_ICACHE                      EFUSE_BLK0         40              1
    104     DIS_DCACHE                      EFUSE_BLK0         41              1
    105     DIS_DOWNLOAD_ICACHE             EFUSE_BLK0         42              1
    106     DIS_DOWNLOAD_DCACHE             EFUSE_BLK0         43              1
    107     DIS_FORCE_D"
"OWNLOAD              EFUSE_BLK0         44              1
    108     DIS_USB                         EFUSE_BLK0         45              1
    109     DIS_TWAI                        EFUSE_BLK0         46              1
    110     DIS_BOOT_REMAP                  EFUSE_BLK0         47              1
    111     SOFT_DIS_JTAG                   EFUSE_BLK0         49              1
    112     HARD_DIS_JTAG                   EFUSE_BLK0         50              1
    113     DIS_DOWNLOAD_MANUAL_ENCRY"
"PT     EFUSE_BLK0         51              1
    114     USB_EXCHG_PINS                  EFUSE_BLK0         56              1
    115     USB_EXT_PHY_ENABLE              EFUSE_BLK0         57              1
    116     USB_FORCE_NOPERSIST             EFUSE_BLK0         58              1
    117     BLOCK0_VERSION                  EFUSE_BLK0         59              2
    118     VDD_SPI_XPD                     EFUSE_BLK0         68              1
    119     VDD_SPI_TIEH                    EFUSE_B"
"LK0         69              1
    120     VDD_SPI_FORCE                   EFUSE_BLK0         70              1
    121     WDT_DELAY_SEL                   EFUSE_BLK0         80              2
    122     SPI_BOOT_CRYPT_CNT              EFUSE_BLK0         82              3
    123     SECURE_BOOT_KEY_REVOKE0         EFUSE_BLK0         85              1
    124     SECURE_BOOT_KEY_REVOKE1         EFUSE_BLK0         86              1
    125     SECURE_BOOT_KEY_REVOKE2         EFUSE_BLK0         87"
"              1
    126     KEY_PURPOSE_0                   EFUSE_BLK0         88              4
    127     KEY_PURPOSE_1                   EFUSE_BLK0         92              4
    128     KEY_PURPOSE_2                   EFUSE_BLK0         96              4
    129     KEY_PURPOSE_3                   EFUSE_BLK0        100              4
    130     KEY_PURPOSE_4                   EFUSE_BLK0        104              4
    131     KEY_PURPOSE_5                   EFUSE_BLK0        108              "
"4
    132     SECURE_BOOT_EN                  EFUSE_BLK0        116              1
    133     SECURE_BOOT_AGGRESSIVE_REVOKE   EFUSE_BLK0        117              1
    134     FLASH_TPUW                      EFUSE_BLK0        124              4
    135     DIS_DOWNLOAD_MODE               EFUSE_BLK0        128              1
    136     DIS_LEGACY_SPI_BOOT             EFUSE_BLK0        129              1
    137     UART_PRINT_CHANNEL              EFUSE_BLK0        130              1
    138     "
"DIS_USB_DOWNLOAD_MODE           EFUSE_BLK0        132              1
    139     ENABLE_SECURITY_DOWNLOAD        EFUSE_BLK0        133              1
    140     UART_PRINT_CONTROL              EFUSE_BLK0        134              2
    141     PIN_POWER_SELECTION             EFUSE_BLK0        136              1
    142     FLASH_TYPE                      EFUSE_BLK0        137              1
    143     FORCE_SEND_RESUME               EFUSE_BLK0        138              1
    144     SECURE_VERSION"
"                  EFUSE_BLK0        139              16
    145     DISABLE_WAFER_VERSION_MAJOR     EFUSE_BLK0        160              1
    146     DISABLE_BLK_VERSION_MAJOR       EFUSE_BLK0        161              1
    147     MAC                             EFUSE_BLK1         0               8
    148     MAC                             EFUSE_BLK1         8               8
    149     MAC                             EFUSE_BLK1         16              8
    150     MAC                        "
"     EFUSE_BLK1         24              8
    151     MAC                             EFUSE_BLK1         32              8
    152     MAC                             EFUSE_BLK1         40              8
    153     SPI_PAD_CONFIG_CLK              EFUSE_BLK1         48              6
    154     SPI_PAD_CONFIG_Q                EFUSE_BLK1         54              6
    155     SPI_PAD_CONFIG_D                EFUSE_BLK1         60              6
    156     SPI_PAD_CONFIG_CS               EFUSE_BLK"
"1         66              6
    157     SPI_PAD_CONFIG_HD               EFUSE_BLK1         72              6
    158     SPI_PAD_CONFIG_WP               EFUSE_BLK1         78              6
    159     SPI_PAD_CONFIG_DQS              EFUSE_BLK1         84              6
    160     SPI_PAD_CONFIG_D4               EFUSE_BLK1         90              6
    161     SPI_PAD_CONFIG_D5               EFUSE_BLK1         96              6
    162     SPI_PAD_CONFIG_D6               EFUSE_BLK1        102  "
"            6
    163     SPI_PAD_CONFIG_D7               EFUSE_BLK1        108              6
    164     WAFER_VERSION_MAJOR             EFUSE_BLK1        114              2
    165     WAFER_VERSION_MINOR_HI          EFUSE_BLK1        116              1
    166     FLASH_VERSION                   EFUSE_BLK1        117              4
    167     BLK_VERSION_MAJOR               EFUSE_BLK1        121              2
    168     PSRAM_VERSION                   EFUSE_BLK1        124              4
"
"    169     PKG_VERSION                     EFUSE_BLK1        128              4
    170     WAFER_VERSION_MINOR_LO          EFUSE_BLK1        132              3
    171     SYS_DATA_PART2                  EFUSE_BLK10        0              256
    172     OPTIONAL_UNIQUE_ID              EFUSE_BLK2         0              128
    173     ADC_CALIB                       EFUSE_BLK2        128              4
    174     BLK_VERSION_MINOR               EFUSE_BLK2        132              3
    175     "
"TEMP_CALIB                      EFUSE_BLK2        135              9
    176     RTCCALIB_V1IDX_A10H             EFUSE_BLK2        144              8
    177     RTCCALIB_V1IDX_A11H             EFUSE_BLK2        152              8
    178     RTCCALIB_V1IDX_A12H             EFUSE_BLK2        160              8
    179     RTCCALIB_V1IDX_A13H             EFUSE_BLK2        168              8
    180     RTCCALIB_V1IDX_A20H             EFUSE_BLK2        176              8
    181     RTCCALIB_V1IDX"
"_A21H             EFUSE_BLK2        184              8
    182     RTCCALIB_V1IDX_A22H             EFUSE_BLK2        192              8
    183     RTCCALIB_V1IDX_A23H             EFUSE_BLK2        200              8
    184     RTCCALIB_V1IDX_A10L             EFUSE_BLK2        208              6
    185     RTCCALIB_V1IDX_A11L             EFUSE_BLK2        214              6
    186     RTCCALIB_V1IDX_A12L             EFUSE_BLK2        220              6
    187     RTCCALIB_V1IDX_A13L         "
"    EFUSE_BLK2        226              6
    188     RTCCALIB_V1IDX_A20L             EFUSE_BLK2        232              6
    189     RTCCALIB_V1IDX_A21L             EFUSE_BLK2        238              6
    190     RTCCALIB_V1IDX_A22L             EFUSE_BLK2        244              6
    191     RTCCALIB_V1IDX_A23L             EFUSE_BLK2        250              6
    192     USER_DATA                       EFUSE_BLK3         0              256
    193     USER_DATA.MAC_CUSTOM            EFUSE_BLK"
"3        200              48
    194     KEY0                            EFUSE_BLK4         0              256
    195     KEY1                            EFUSE_BLK5         0              256
    196     KEY2                            EFUSE_BLK6         0              256
    197     KEY3                            EFUSE_BLK7         0              256
    198     KEY4                            EFUSE_BLK8         0              256
    199     KEY5                            EFUSE_BLK9       "
"  0              256

    Used bits in efuse table:
    EFUSE_BLK0
    [0 31] [0 0] [2 2] ... [32 38] [40 47] [49 51] [56 60] [68 70] [80 111] [116 117] [124 130] [132 154] [160 161]
    EFUSE_BLK1
    [0 122] [124 134]
    EFUSE_BLK10
    [0 255]
    EFUSE_BLK2
    [0 255]
    EFUSE_BLK3
    [0 255] [200 247]
    EFUSE_BLK4
    [0 255]
    EFUSE_BLK5
    [0 255]
    EFUSE_BLK6
    [0 255]
    EFUSE_BLK7
    [0 255]
    EFUSE_BLK8
    [0 255]
    EFUSE_BLK9
    [0 255]
    Note: Not printed rang"
"es are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
"
"
.. code-block:: none

    $ ./efuse_table_gen.py {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Max number of bits in BLK 256
    Sorted efuse table:
    #       field_name                              efuse_block     bit_start       bit_count
    1       WR_DIS                                  EFUSE_BLK0         0               32
    2       WR_DIS.RD_DIS                           EFUSE_BLK0         0               1
    3       WR_DIS.DIS_ICACHE                       EFUSE_BLK0      "
"   2               1
    4       WR_DIS.DIS_DCACHE                       EFUSE_BLK0         2               1
    5       WR_DIS.DIS_DOWNLOAD_ICACHE              EFUSE_BLK0         2               1
    6       WR_DIS.DIS_DOWNLOAD_DCACHE              EFUSE_BLK0         2               1
    7       WR_DIS.DIS_FORCE_DOWNLOAD               EFUSE_BLK0         2               1
    8       WR_DIS.DIS_USB_OTG                      EFUSE_BLK0         2               1
    9       WR_DIS.DIS_TWAI       "
"                  EFUSE_BLK0         2               1
    10      WR_DIS.DIS_APP_CPU                      EFUSE_BLK0         2               1
    11      WR_DIS.DIS_PAD_JTAG                     EFUSE_BLK0         2               1
    12      WR_DIS.DIS_DOWNLOAD_MANUAL_ENCRYPT      EFUSE_BLK0         2               1
    13      WR_DIS.DIS_USB_JTAG                     EFUSE_BLK0         2               1
    14      WR_DIS.DIS_USB_SERIAL_JTAG              EFUSE_BLK0         2               1
"
"    15      WR_DIS.STRAP_JTAG_SEL                   EFUSE_BLK0         2               1
    16      WR_DIS.USB_PHY_SEL                      EFUSE_BLK0         2               1
    17      WR_DIS.VDD_SPI_XPD                      EFUSE_BLK0         3               1
    18      WR_DIS.VDD_SPI_TIEH                     EFUSE_BLK0         3               1
    19      WR_DIS.VDD_SPI_FORCE                    EFUSE_BLK0         3               1
    20      WR_DIS.WDT_DELAY_SEL                    EFU"
"SE_BLK0         3               1
    21      WR_DIS.SPI_BOOT_CRYPT_CNT               EFUSE_BLK0         4               1
    22      WR_DIS.SECURE_BOOT_KEY_REVOKE0          EFUSE_BLK0         5               1
    23      WR_DIS.SECURE_BOOT_KEY_REVOKE1          EFUSE_BLK0         6               1
    24      WR_DIS.SECURE_BOOT_KEY_REVOKE2          EFUSE_BLK0         7               1
    25      WR_DIS.KEY_PURPOSE_0                    EFUSE_BLK0         8               1
    26      WR_DIS.KE"
"Y_PURPOSE_1                    EFUSE_BLK0         9               1
    27      WR_DIS.KEY_PURPOSE_2                    EFUSE_BLK0         10              1
    28      WR_DIS.KEY_PURPOSE_3                    EFUSE_BLK0         11              1
    29      WR_DIS.KEY_PURPOSE_4                    EFUSE_BLK0         12              1
    30      WR_DIS.KEY_PURPOSE_5                    EFUSE_BLK0         13              1
    31      WR_DIS.SECURE_BOOT_EN                   EFUSE_BLK0         15   "
"           1
    32      WR_DIS.SECURE_BOOT_AGGRESSIVE_REVOKE    EFUSE_BLK0         16              1
    33      WR_DIS.FLASH_TPUW                       EFUSE_BLK0         18              1
    34      WR_DIS.DIS_DOWNLOAD_MODE                EFUSE_BLK0         18              1
    35      WR_DIS.DIS_DIRECT_BOOT                  EFUSE_BLK0         18              1
    36      WR_DIS.DIS_USB_SERIAL_JTAG_ROM_PRINT    EFUSE_BLK0         18              1
    37      WR_DIS.FLASH_ECC_MODE         "
"          EFUSE_BLK0         18              1
    38      WR_DIS.DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE EFUSE_BLK0        18              1
    39      WR_DIS.ENABLE_SECURITY_DOWNLOAD         EFUSE_BLK0         18              1
    40      WR_DIS.UART_PRINT_CONTROL               EFUSE_BLK0         18              1
    41      WR_DIS.PIN_POWER_SELECTION              EFUSE_BLK0         18              1
    42      WR_DIS.FLASH_TYPE                       EFUSE_BLK0         18              1
    43  "
"    WR_DIS.FLASH_PAGE_SIZE                  EFUSE_BLK0         18              1
    44      WR_DIS.FLASH_ECC_EN                     EFUSE_BLK0         18              1
    45      WR_DIS.FORCE_SEND_RESUME                EFUSE_BLK0         18              1
    46      WR_DIS.SECURE_VERSION                   EFUSE_BLK0         18              1
    47      WR_DIS.DIS_USB_OTG_DOWNLOAD_MODE        EFUSE_BLK0         19              1
    48      WR_DIS.DISABLE_WAFER_VERSION_MAJOR      EFUSE_BLK0 "
"        19              1
    49      WR_DIS.DISABLE_BLK_VERSION_MAJOR        EFUSE_BLK0         19              1
    50      WR_DIS.BLK1                             EFUSE_BLK0         20              1
    51      WR_DIS.MAC                              EFUSE_BLK0         20              1
    52      WR_DIS.SPI_PAD_CONFIG_CLK               EFUSE_BLK0         20              1
    53      WR_DIS.SPI_PAD_CONFIG_Q                 EFUSE_BLK0         20              1
    54      WR_DIS.SPI_PAD_CO"
"NFIG_D                 EFUSE_BLK0         20              1
    55      WR_DIS.SPI_PAD_CONFIG_CS                EFUSE_BLK0         20              1
    56      WR_DIS.SPI_PAD_CONFIG_HD                EFUSE_BLK0         20              1
    57      WR_DIS.SPI_PAD_CONFIG_WP                EFUSE_BLK0         20              1
    58      WR_DIS.SPI_PAD_CONFIG_DQS               EFUSE_BLK0         20              1
    59      WR_DIS.SPI_PAD_CONFIG_D4                EFUSE_BLK0         20           "
"   1
    60      WR_DIS.SPI_PAD_CONFIG_D5                EFUSE_BLK0         20              1
    61      WR_DIS.SPI_PAD_CONFIG_D6                EFUSE_BLK0         20              1
    62      WR_DIS.SPI_PAD_CONFIG_D7                EFUSE_BLK0         20              1
    63      WR_DIS.WAFER_VERSION_MINOR_LO           EFUSE_BLK0         20              1
    64      WR_DIS.PKG_VERSION                      EFUSE_BLK0         20              1
    65      WR_DIS.BLK_VERSION_MINOR              "
"  EFUSE_BLK0         20              1
    66      WR_DIS.K_RTC_LDO                        EFUSE_BLK0         20              1
    67      WR_DIS.K_DIG_LDO                        EFUSE_BLK0         20              1
    68      WR_DIS.V_RTC_DBIAS20                    EFUSE_BLK0         20              1
    69      WR_DIS.V_DIG_DBIAS20                    EFUSE_BLK0         20              1
    70      WR_DIS.DIG_DBIAS_HVT                    EFUSE_BLK0         20              1
    71      WR_D"
"IS.WAFER_VERSION_MINOR_HI           EFUSE_BLK0         20              1
    72      WR_DIS.WAFER_VERSION_MAJOR              EFUSE_BLK0         20              1
    73      WR_DIS.ADC2_CAL_VOL_ATTEN3              EFUSE_BLK0         20              1
    74      WR_DIS.SYS_DATA_PART1                   EFUSE_BLK0         21              1
    75      WR_DIS.OPTIONAL_UNIQUE_ID               EFUSE_BLK0         21              1
    76      WR_DIS.BLK_VERSION_MAJOR                EFUSE_BLK0         "
"21              1
    77      WR_DIS.TEMP_CALIB                       EFUSE_BLK0         21              1
    78      WR_DIS.OCODE                            EFUSE_BLK0         21              1
    79      WR_DIS.ADC1_INIT_CODE_ATTEN0            EFUSE_BLK0         21              1
    80      WR_DIS.ADC1_INIT_CODE_ATTEN1            EFUSE_BLK0         21              1
    81      WR_DIS.ADC1_INIT_CODE_ATTEN2            EFUSE_BLK0         21              1
    82      WR_DIS.ADC1_INIT_CODE_ATT"
"EN3            EFUSE_BLK0         21              1
    83      WR_DIS.ADC2_INIT_CODE_ATTEN0            EFUSE_BLK0         21              1
    84      WR_DIS.ADC2_INIT_CODE_ATTEN1            EFUSE_BLK0         21              1
    85      WR_DIS.ADC2_INIT_CODE_ATTEN2            EFUSE_BLK0         21              1
    86      WR_DIS.ADC2_INIT_CODE_ATTEN3            EFUSE_BLK0         21              1
    87      WR_DIS.ADC1_CAL_VOL_ATTEN0              EFUSE_BLK0         21              1
   "
" 88      WR_DIS.ADC1_CAL_VOL_ATTEN1              EFUSE_BLK0         21              1
    89      WR_DIS.ADC1_CAL_VOL_ATTEN2              EFUSE_BLK0         21              1
    90      WR_DIS.ADC1_CAL_VOL_ATTEN3              EFUSE_BLK0         21              1
    91      WR_DIS.ADC2_CAL_VOL_ATTEN0              EFUSE_BLK0         21              1
    92      WR_DIS.ADC2_CAL_VOL_ATTEN1              EFUSE_BLK0         21              1
    93      WR_DIS.ADC2_CAL_VOL_ATTEN2              EFUSE_"
"BLK0         21              1
    94      WR_DIS.BLOCK_USR_DATA                   EFUSE_BLK0         22              1
    95      WR_DIS.CUSTOM_MAC                       EFUSE_BLK0         22              1
    96      WR_DIS.BLOCK_KEY0                       EFUSE_BLK0         23              1
    97      WR_DIS.BLOCK_KEY1                       EFUSE_BLK0         24              1
    98      WR_DIS.BLOCK_KEY2                       EFUSE_BLK0         25              1
    99      WR_DIS.BLOCK"
"_KEY3                       EFUSE_BLK0         26              1
    100     WR_DIS.BLOCK_KEY4                       EFUSE_BLK0         27              1
    101     WR_DIS.BLOCK_KEY5                       EFUSE_BLK0         28              1
    102     WR_DIS.BLOCK_SYS_DATA2                  EFUSE_BLK0         29              1
    103     WR_DIS.USB_EXCHG_PINS                   EFUSE_BLK0         30              1
    104     WR_DIS.USB_EXT_PHY_ENABLE               EFUSE_BLK0         30      "
"        1
    105     WR_DIS.SOFT_DIS_JTAG                    EFUSE_BLK0         31              1
    106     RD_DIS                                  EFUSE_BLK0         32              7
    107     RD_DIS.BLOCK_KEY0                       EFUSE_BLK0         32              1
    108     RD_DIS.BLOCK_KEY1                       EFUSE_BLK0         33              1
    109     RD_DIS.BLOCK_KEY2                       EFUSE_BLK0         34              1
    110     RD_DIS.BLOCK_KEY3                "
"       EFUSE_BLK0         35              1
    111     RD_DIS.BLOCK_KEY4                       EFUSE_BLK0         36              1
    112     RD_DIS.BLOCK_KEY5                       EFUSE_BLK0         37              1
    113     RD_DIS.BLOCK_SYS_DATA2                  EFUSE_BLK0         38              1
    114     DIS_ICACHE                              EFUSE_BLK0         40              1
    115     DIS_DCACHE                              EFUSE_BLK0         41              1
    116    "
" DIS_DOWNLOAD_ICACHE                     EFUSE_BLK0         42              1
    117     DIS_DOWNLOAD_DCACHE                     EFUSE_BLK0         43              1
    118     DIS_FORCE_DOWNLOAD                      EFUSE_BLK0         44              1
    119     DIS_USB_OTG                             EFUSE_BLK0         45              1
    120     DIS_TWAI                                EFUSE_BLK0         46              1
    121     DIS_APP_CPU                             EFUSE_BLK0    "
"     47              1
    122     SOFT_DIS_JTAG                           EFUSE_BLK0         48              3
    123     DIS_PAD_JTAG                            EFUSE_BLK0         51              1
    124     DIS_DOWNLOAD_MANUAL_ENCRYPT             EFUSE_BLK0         52              1
    125     USB_EXCHG_PINS                          EFUSE_BLK0         57              1
    126     USB_EXT_PHY_ENABLE                      EFUSE_BLK0         58              1
    127     VDD_SPI_XPD         "
"                    EFUSE_BLK0         68              1
    128     VDD_SPI_TIEH                            EFUSE_BLK0         69              1
    129     VDD_SPI_FORCE                           EFUSE_BLK0         70              1
    130     WDT_DELAY_SEL                           EFUSE_BLK0         80              2
    131     SPI_BOOT_CRYPT_CNT                      EFUSE_BLK0         82              3
    132     SECURE_BOOT_KEY_REVOKE0                 EFUSE_BLK0         85              "
"1
    133     SECURE_BOOT_KEY_REVOKE1                 EFUSE_BLK0         86              1
    134     SECURE_BOOT_KEY_REVOKE2                 EFUSE_BLK0         87              1
    135     KEY_PURPOSE_0                           EFUSE_BLK0         88              4
    136     KEY_PURPOSE_1                           EFUSE_BLK0         92              4
    137     KEY_PURPOSE_2                           EFUSE_BLK0         96              4
    138     KEY_PURPOSE_3                           E"
"FUSE_BLK0        100              4
    139     KEY_PURPOSE_4                           EFUSE_BLK0        104              4
    140     KEY_PURPOSE_5                           EFUSE_BLK0        108              4
    141     SECURE_BOOT_EN                          EFUSE_BLK0        116              1
    142     SECURE_BOOT_AGGRESSIVE_REVOKE           EFUSE_BLK0        117              1
    143     DIS_USB_JTAG                            EFUSE_BLK0        118              1
    144     DIS_USB"
"_SERIAL_JTAG                     EFUSE_BLK0        119              1
    145     STRAP_JTAG_SEL                          EFUSE_BLK0        120              1
    146     USB_PHY_SEL                             EFUSE_BLK0        121              1
    147     FLASH_TPUW                              EFUSE_BLK0        124              4
    148     DIS_DOWNLOAD_MODE                       EFUSE_BLK0        128              1
    149     DIS_DIRECT_BOOT                         EFUSE_BLK0        129 "
"             1
    150     DIS_USB_SERIAL_JTAG_ROM_PRINT           EFUSE_BLK0        130              1
    151     FLASH_ECC_MODE                          EFUSE_BLK0        131              1
    152     DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE       EFUSE_BLK0        132              1
    153     ENABLE_SECURITY_DOWNLOAD                EFUSE_BLK0        133              1
    154     UART_PRINT_CONTROL                      EFUSE_BLK0        134              2
    155     PIN_POWER_SELECTION         "
"            EFUSE_BLK0        136              1
    156     FLASH_TYPE                              EFUSE_BLK0        137              1
    157     FLASH_PAGE_SIZE                         EFUSE_BLK0        138              2
    158     FLASH_ECC_EN                            EFUSE_BLK0        140              1
    159     FORCE_SEND_RESUME                       EFUSE_BLK0        141              1
    160     SECURE_VERSION                          EFUSE_BLK0        142              16
    1"
"61     DIS_USB_OTG_DOWNLOAD_MODE               EFUSE_BLK0        159              1
    162     DISABLE_WAFER_VERSION_MAJOR             EFUSE_BLK0        160              1
    163     DISABLE_BLK_VERSION_MAJOR               EFUSE_BLK0        161              1
    164     MAC                                     EFUSE_BLK1         0               8
    165     MAC                                     EFUSE_BLK1         8               8
    166     MAC                                     EFUSE_BL"
"K1         16              8
    167     MAC                                     EFUSE_BLK1         24              8
    168     MAC                                     EFUSE_BLK1         32              8
    169     MAC                                     EFUSE_BLK1         40              8
    170     SPI_PAD_CONFIG_CLK                      EFUSE_BLK1         48              6
    171     SPI_PAD_CONFIG_Q                        EFUSE_BLK1         54              6
    172     SPI_PAD_CONFIG"
"_D                        EFUSE_BLK1         60              6
    173     SPI_PAD_CONFIG_CS                       EFUSE_BLK1         66              6
    174     SPI_PAD_CONFIG_HD                       EFUSE_BLK1         72              6
    175     SPI_PAD_CONFIG_WP                       EFUSE_BLK1         78              6
    176     SPI_PAD_CONFIG_DQS                      EFUSE_BLK1         84              6
    177     SPI_PAD_CONFIG_D4                       EFUSE_BLK1         90        "
"      6
    178     SPI_PAD_CONFIG_D5                       EFUSE_BLK1         96              6
    179     SPI_PAD_CONFIG_D6                       EFUSE_BLK1        102              6
    180     SPI_PAD_CONFIG_D7                       EFUSE_BLK1        108              6
    181     WAFER_VERSION_MINOR_LO                  EFUSE_BLK1        114              3
    182     PKG_VERSION                             EFUSE_BLK1        117              3
    183     BLK_VERSION_MINOR                  "
"     EFUSE_BLK1        120              3
    184     K_RTC_LDO                               EFUSE_BLK1        141              7
    185     K_DIG_LDO                               EFUSE_BLK1        148              7
    186     V_RTC_DBIAS20                           EFUSE_BLK1        155              8
    187     V_DIG_DBIAS20                           EFUSE_BLK1        163              8
    188     DIG_DBIAS_HVT                           EFUSE_BLK1        171              5
    189     W"
"AFER_VERSION_MINOR_HI                  EFUSE_BLK1        183              1
    190     WAFER_VERSION_MAJOR                     EFUSE_BLK1        184              2
    191     ADC2_CAL_VOL_ATTEN3                     EFUSE_BLK1        186              6
    192     SYS_DATA_PART2                          EFUSE_BLK10        0              256
    193     OPTIONAL_UNIQUE_ID                      EFUSE_BLK2         0              128
    194     BLK_VERSION_MAJOR                       EFUSE_BLK2    "
"    128              2
    195     TEMP_CALIB                              EFUSE_BLK2        132              9
    196     OCODE                                   EFUSE_BLK2        141              8
    197     ADC1_INIT_CODE_ATTEN0                   EFUSE_BLK2        149              8
    198     ADC1_INIT_CODE_ATTEN1                   EFUSE_BLK2        157              6
    199     ADC1_INIT_CODE_ATTEN2                   EFUSE_BLK2        163              6
    200     ADC1_INIT_CODE_ATTEN"
"3                   EFUSE_BLK2        169              6
    201     ADC2_INIT_CODE_ATTEN0                   EFUSE_BLK2        175              8
    202     ADC2_INIT_CODE_ATTEN1                   EFUSE_BLK2        183              6
    203     ADC2_INIT_CODE_ATTEN2                   EFUSE_BLK2        189              6
    204     ADC2_INIT_CODE_ATTEN3                   EFUSE_BLK2        195              6
    205     ADC1_CAL_VOL_ATTEN0                     EFUSE_BLK2        201              "
"8
    206     ADC1_CAL_VOL_ATTEN1                     EFUSE_BLK2        209              8
    207     ADC1_CAL_VOL_ATTEN2                     EFUSE_BLK2        217              8
    208     ADC1_CAL_VOL_ATTEN3                     EFUSE_BLK2        225              8
    209     ADC2_CAL_VOL_ATTEN0                     EFUSE_BLK2        233              8
    210     ADC2_CAL_VOL_ATTEN1                     EFUSE_BLK2        241              7
    211     ADC2_CAL_VOL_ATTEN2                     E"
"FUSE_BLK2        248              7
    212     USER_DATA                               EFUSE_BLK3         0              256
    213     USER_DATA.MAC_CUSTOM                    EFUSE_BLK3        200              48
    214     KEY0                                    EFUSE_BLK4         0              256
    215     KEY1                                    EFUSE_BLK5         0              256
    216     KEY2                                    EFUSE_BLK6         0              256
    217     KE"
"Y3                                    EFUSE_BLK7         0              256
    218     KEY4                                    EFUSE_BLK8         0              256
    219     KEY5                                    EFUSE_BLK9         0              256

    Used bits in efuse table:
    EFUSE_BLK0
    [0 31] [0 0] [2 2] ... [22 30] [30 38] [32 38] [40 52] [57 58] [68 70] [80 111] [116 121] [124 157] [159 161]
    EFUSE_BLK1
    [0 122] [141 175] [183 191]
    EFUSE_BLK10
    [0 255]
    EFUSE"
"_BLK2
    [0 129] [132 254]
    EFUSE_BLK3
    [0 255] [200 247]
    EFUSE_BLK4
    [0 255]
    EFUSE_BLK5
    [0 255]
    EFUSE_BLK6
    [0 255]
    EFUSE_BLK7
    [0 255]
    EFUSE_BLK8
    [0 255]
    EFUSE_BLK9
    [0 255]
    Note: Not printed ranges are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
|       96      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 96 MHz                       |
|               |                                       | | APB: 32 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 32 MHz               "
"        |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 32 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       64      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 64 MHz                       |
|               |                                       | | APB: 32 MHz          "
"             |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 32 MHz                       |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 32 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       48      | ``ESP_PM_CPU_FREQ_MAX`` acquired      "
"| | CPU: 48 MHz                       |
|               |                                       | | APB: 32 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 32 MHz                       |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 32 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                   "
"                    | with :cpp:func:`esp_pm_configure`   |
++++
"
"TO BE UPDATED IDF-7672
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
| ECO1   | v1.0                   |
+++
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO1   | v0.1                   |
+++
| ECO2   | v0.2                   |
+++
| ECO3   | v0.3                   |
+++
| ECO4   | v0.4                   |
+++
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... Unsupported detection protocol, switching and trying again...
    Connecting.....
    Detecting chip type... ESP32

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Calibration fuses:
    ADC_VREF (BLOCK0)                                  True ADC reference voltage                         "
"= 1121 R/W (0b00011)

    Config fuses:
    WR_DIS (BLOCK0)                                    Efuse write disable mask                           = 0 R/W (0x0000)
    RD_DIS (BLOCK0)                                    Disable reading from BlOCK1-3                      = 0 R/W (0x0)
    DISABLE_APP_CPU (BLOCK0)                           Disables APP CPU                                   = False R/W (0b0)
    DISABLE_BT (BLOCK0)                                Disables Bluetooth                    "
"             = False R/W (0b0)
    DIS_CACHE (BLOCK0)                                 Disables cache                                     = False R/W (0b0)
    CHIP_CPU_FREQ_LOW (BLOCK0)                         If set alongside EFUSE_RD_CHIP_CPU_FREQ_RATED; the = False R/W (0b0)
                                                        ESP32's max CPU frequency is rated for 160MHz. 24
                                                       0MHz otherwise
    CHIP_CPU_FREQ_RATED (BLOCK0)             "
"          If set; the ESP32's maximum CPU frequency has been = True R/W (0b1)
                                                        rated
    BLK3_PART_RESERVE (BLOCK0)                         BLOCK3 partially served for ADC calibration data   = False R/W (0b0)
    CLK8M_FREQ (BLOCK0)                                8MHz clock freq override                           = 51 R/W (0x33)
    VOL_LEVEL_HP_INV (BLOCK0)                          This field stores the voltage level for CPU to run = 0 R/W "
"(0b00)
                                                        at 240 MHz; or for flash/PSRAM to run at 80 MHz.0
                                                       x0: level 7; 0x1: level 6; 0x2: level 5; 0x3: leve
                                                       l 4. (RO)
    CODING_SCHEME (BLOCK0)                             Efuse variable block length scheme
       = NONE (BLK1-3 len=256 bits) R/W (0b00)
    CONSOLE_DEBUG_DISABLE (BLOCK0)                     Disable ROM BASIC interp"
"reter fallback             = True R/W (0b1)
    DISABLE_SDIO_HOST (BLOCK0)                                                                            = False R/W (0b0)
    DISABLE_DL_CACHE (BLOCK0)                          Disable flash cache in UART bootloader             = False R/W (0b0)

    Flash fuses:
    FLASH_CRYPT_CNT (BLOCK0)                           Flash encryption is enabled if this field has an o = 0 R/W (0b0000000)
                                                       dd number"
" of bits set
    FLASH_CRYPT_CONFIG (BLOCK0)                        Flash encryption config (key tweak bits)           = 0 R/W (0x0)

    Identity fuses:
    CHIP_PACKAGE_4BIT (BLOCK0)                         Chip package identifier #4bit                      = False R/W (0b0)
    CHIP_PACKAGE (BLOCK0)                              Chip package identifier                            = 1 R/W (0b001)
    CHIP_VER_REV1 (BLOCK0)                             bit is set to 1 for rev1 silicon             "
"      = True R/W (0b1)
    CHIP_VER_REV2 (BLOCK0)                                                                                = True R/W (0b1)
    WAFER_VERSION_MINOR (BLOCK0)                                                                          = 0 R/W (0b00)
    WAFER_VERSION_MAJOR (BLOCK0)                       calc WAFER VERSION MAJOR from CHIP_VER_REV1 and CH = 3 R/W (0b011)
                                                       IP_VER_REV2 and apb_ctl_date (read only)
    PKG_VERSION"
" (BLOCK0)                               calc Chip package = CHIP_PACKAGE_4BIT << 3 + CHIP_ = 1 R/W (0x1)
                                                       PACKAGE (read only)

    Jtag fuses:
    JTAG_DISABLE (BLOCK0)                              Disable JTAG                                       = False R/W (0b0)

    Mac fuses:
    MAC (BLOCK0)                                       MAC address
       = 94:b9:7e:5a:6e:58 (CRC 0xe2 OK) R/W
    MAC_CRC (BLOCK0)                               "
"    CRC8 for MAC address                               = 226 R/W (0xe2)
    MAC_VERSION (BLOCK3)                               Version of the MAC field                           = 0 R/W (0x00)

    Security fuses:
    UART_DOWNLOAD_DIS (BLOCK0)                         Disable UART download mode. Valid for ESP32 V3 and = False R/W (0b0)
                                                        newer; only
    ABS_DONE_0 (BLOCK0)                                Secure boot V1 is enabled for bootloade"
"r image     = False R/W (0b0)
    ABS_DONE_1 (BLOCK0)                                Secure boot V2 is enabled for bootloader image     = False R/W (0b0)
    DISABLE_DL_ENCRYPT (BLOCK0)                        Disable flash encryption in UART bootloader        = False R/W (0b0)
    DISABLE_DL_DECRYPT (BLOCK0)                        Disable flash decryption in UART bootloader        = False R/W (0b0)
    KEY_STATUS (BLOCK0)                                Usage of efuse block 3 (reserved)          "
"        = False R/W (0b0)
    SECURE_VERSION (BLOCK3)                            Secure version for anti-rollback                   = 0 R/W (0x00000000)
    BLOCK1 (BLOCK1)                                    Flash encryption key
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK2 (BLOCK2)                                    Security boot key
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
" 00 00 00 00 00 R/W
    BLOCK3 (BLOCK3)                                    Variable Block 3
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Spi Pad fuses:
    SPI_PAD_CONFIG_HD (BLOCK0)                         read for SPI_pad_config_hd                         = 0 R/W (0b00000)
    SPI_PAD_CONFIG_CLK (BLOCK0)                        Override SD_CLK pad (GPIO6/SPICLK)                 = 0 R/W (0b00000)
    SPI_PAD_CONFIG_Q (BLOCK0)  "
"                        Override SD_DATA_0 pad (GPIO7/SPIQ)                = 0 R/W (0b00000)
    SPI_PAD_CONFIG_D (BLOCK0)                          Override SD_DATA_1 pad (GPIO8/SPID)                = 0 R/W (0b00000)
    SPI_PAD_CONFIG_CS0 (BLOCK0)                        Override SD_CMD pad (GPIO11/SPICS0)                = 0 R/W (0b00000)

    Vdd fuses:
    XPD_SDIO_REG (BLOCK0)                              read for XPD_SDIO_REG                              = False R/W (0b0)
    XPD_SDIO_TIEH ("
"BLOCK0)                             If XPD_SDIO_FORCE & XPD_SDIO_REG                   = 1.8V R/W (0b0)
    XPD_SDIO_FORCE (BLOCK0)                            Ignore MTDI pin (GPIO12) for VDD_SDIO on reset     = False R/W (0b0)

    Flash voltage (VDD_SDIO) determined by GPIO12 on reset (High for 1.8V, Low/NC for 3.3V)


To get a dump for all eFuse registers.

.. code-block:: none

    espefuse.py -p PORT dump

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... Unsupported de"
"tection protocol, switching and trying again...
    Connecting.......
    Detecting chip type... ESP32
    BLOCK0          (                ) [0 ] read_regs: 00000000 7e5a6e58 00e294b9 0000a200 00000333 00100000 00000004
    BLOCK1          (flash_encryption) [1 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK2          (secure_boot_v1 s) [2 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK3          (    "
"            ) [3 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

    EFUSE_REG_DEC_STATUS        0x00000000

    === Run ""dump"" command ===
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
| ECO1   | v0.1                   |
+++
| ECO2   | v0.2                   |
+++
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-S3

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Calibration fuses:
    K_RTC_LDO (BLOCK1)                                 BLOCK1 K_RTC_LDO                                   = 12 R/W (0b0000011)
    K_DIG_LDO (BLOCK1)                                 BLOCK1 K_DIG_LDO              "
"                     = -28 R/W (0b1000111)
    V_RTC_DBIAS20 (BLOCK1)                             BLOCK1 voltage of rtc dbias20                      = 20 R/W (0x05)
    V_DIG_DBIAS20 (BLOCK1)                             BLOCK1 voltage of digital dbias20                  = -44 R/W (0x8b)
    DIG_DBIAS_HVT (BLOCK1)                             BLOCK1 digital dbias when hvt                      = -36 R/W (0b11001)
    ADC2_CAL_VOL_ATTEN3 (BLOCK1)                       ADC2 calibration voltage at att"
"en3                 = -24 R/W (0b100110)
    TEMP_CALIB (BLOCK2)                                Temperature calibration data                       = -10.9 R/W (0b101101101)
    OCODE (BLOCK2)                                     ADC OCode                                          = 88 R/W (0x58)
    ADC1_INIT_CODE_ATTEN0 (BLOCK2)                     ADC1 init code at atten0                           = 432 R/W (0x6c)
    ADC1_INIT_CODE_ATTEN1 (BLOCK2)                     ADC1 init code at atten1   "
"                        = -16 R/W (0b100100)
    ADC1_INIT_CODE_ATTEN2 (BLOCK2)                     ADC1 init code at atten2                           = 88 R/W (0b010110)
    ADC1_INIT_CODE_ATTEN3 (BLOCK2)                     ADC1 init code at atten3                           = 0 R/W (0b100000)
    ADC2_INIT_CODE_ATTEN0 (BLOCK2)                     ADC2 init code at atten0                           = -72 R/W (0x92)
    ADC2_INIT_CODE_ATTEN1 (BLOCK2)                     ADC2 init code at atten1  "
"                         = -16 R/W (0b100100)
    ADC2_INIT_CODE_ATTEN2 (BLOCK2)                     ADC2 init code at atten2                           = 48 R/W (0b001100)
    ADC2_INIT_CODE_ATTEN3 (BLOCK2)                     ADC2 init code at atten3                           = 112 R/W (0b011100)
    ADC1_CAL_VOL_ATTEN0 (BLOCK2)                       ADC1 calibration voltage at atten0                 = 412 R/W (0x67)
    ADC1_CAL_VOL_ATTEN1 (BLOCK2)                       ADC1 calibration voltag"
"e at atten1                 = 392 R/W (0x62)
    ADC1_CAL_VOL_ATTEN2 (BLOCK2)                       ADC1 calibration voltage at atten2                 = 356 R/W (0x59)
    ADC1_CAL_VOL_ATTEN3 (BLOCK2)                       ADC1 calibration voltage at atten3                 = 412 R/W (0x67)
    ADC2_CAL_VOL_ATTEN0 (BLOCK2)                       ADC2 calibration voltage at atten0                 = -116 R/W (0x9d)
    ADC2_CAL_VOL_ATTEN1 (BLOCK2)                       ADC2 calibration voltage at at"
"ten1                 = -72 R/W (0b1010010)
    ADC2_CAL_VOL_ATTEN2 (BLOCK2)                       ADC2 calibration voltage at atten2                 = -64 R/W (0b1010000)

    Config fuses:
    WR_DIS (BLOCK0)                                    Disable programming of individual eFuses           = 0 R/W (0x00000000)
    RD_DIS (BLOCK0)                                    Disable reading from BlOCK4-10                     = 0 R/W (0b0000000)
    DIS_ICACHE (BLOCK0)                                Se"
"t this bit to disable Icache                     = False R/W (0b0)
    DIS_DCACHE (BLOCK0)                                Set this bit to disable Dcache                     = False R/W (0b0)
    DIS_TWAI (BLOCK0)                                  Set this bit to disable CAN function               = False R/W (0b0)
    DIS_APP_CPU (BLOCK0)                               Disable app cpu                                    = False R/W (0b0)
    DIS_DIRECT_BOOT (BLOCK0)                           Disabl"
"e direct boot mode                           = False R/W (0b0)
    UART_PRINT_CONTROL (BLOCK0)                        Set the default UART boot message output mode      = Enable R/W (0b00)
    PIN_POWER_SELECTION (BLOCK0)                       Set default power supply for GPIO33-GPIO37; set wh = VDD3P3_CPU R/W (0b0)
                                                       en SPI flash is initialized
    BLOCK_USR_DATA (BLOCK3)                            User data
       = 00 00 00 00 00 00 00 00 0"
"0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_SYS_DATA2 (BLOCK10)                          System data part 2 (reserved)
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Flash fuses:
    FLASH_TPUW (BLOCK0)                                Configures flash waiting time after power-up; in u = 0 R/W (0x0)
                                                       nit of ms. If the value is less than 1"
"5; the waiti
                                                       ng time is the configurable value.  Otherwise; the
                                                        waiting time is twice the configurable value
    FLASH_ECC_MODE (BLOCK0)                            Flash ECC mode in ROM                              = 16to18 byte R/W (0b0)
    FLASH_TYPE (BLOCK0)                                SPI flash type                                     = 4 data lines R/W (0b0)
    FLASH_PAGE_SIZE"
" (BLOCK0)                           Set Flash page size                                = 0 R/W (0b00)
    FLASH_ECC_EN (BLOCK0)                              Set 1 to enable ECC for flash boot                 = False R/W (0b0)
    FORCE_SEND_RESUME (BLOCK0)                         Set this bit to force ROM code to send a resume co = False R/W (0b0)
                                                       mmand during SPI boot

    Identity fuses:
    DISABLE_WAFER_VERSION_MAJOR (BLOCK0)            "
"   Disables check of wafer version major              = False R/W (0b0)
    DISABLE_BLK_VERSION_MAJOR (BLOCK0)                 Disables check of blk version major                = False R/W (0b0)
    WAFER_VERSION_MINOR_LO (BLOCK1)                    WAFER_VERSION_MINOR least significant bits         = 3 R/W (0b011)
    PKG_VERSION (BLOCK1)                               Package version                                    = 0 R/W (0b000)
    BLK_VERSION_MINOR (BLOCK1)                         BLK_V"
"ERSION_MINOR                                  = 3 R/W (0b011)
    WAFER_VERSION_MINOR_HI (BLOCK1)                    WAFER_VERSION_MINOR most significant bit           = False R/W (0b0)
    WAFER_VERSION_MAJOR (BLOCK1)                       WAFER_VERSION_MAJOR                                = 0 R/W (0b00)
    OPTIONAL_UNIQUE_ID (BLOCK2)                        Optional unique 128-bit ID
       = cb 3a c9 b8 88 2b c3 bc 5e f4 00 60 ac 25 be 4b R/W
    BLK_VERSION_MAJOR (BLOCK2)                    "
"     BLK_VERSION_MAJOR of BLOCK2                        = ADC calib V1 R/W (0b01)
    WAFER_VERSION_MINOR (BLOCK0)                       calc WAFER VERSION MINOR = WAFER_VERSION_MINOR_HI  = 3 R/W (0x3)
                                                       << 3 + WAFER_VERSION_MINOR_LO (read only)

    Jtag fuses:
    SOFT_DIS_JTAG (BLOCK0)                             Set these bits to disable JTAG in the soft way (od = 0 R/W (0b000)
                                                       d numbe"
"r 1 means disable ). JTAG can be enabled in
                                                        HMAC module
    DIS_PAD_JTAG (BLOCK0)                              Set this bit to disable JTAG in the hard way. JTAG = False R/W (0b0)
                                                        is disabled permanently
    STRAP_JTAG_SEL (BLOCK0)                            Set this bit to enable selection between usb_to_jt = False R/W (0b0)
                                                       ag an"
"d pad_to_jtag through strapping gpio10 when b
                                                       oth reg_dis_usb_jtag and reg_dis_pad_jtag are equa
                                                       l to 0

    Mac fuses:
    MAC (BLOCK1)                                       MAC address
       = ec:da:3b:41:f2:70 (OK) R/W
    CUSTOM_MAC (BLOCK3)                                Custom MAC
       = 00:00:00:00:00:00 (OK) R/W

    Security fuses:
    DIS_DOWNLOAD_ICACHE (BLOCK0)            "
"           Set this bit to disable Icache in download mode (b = False R/W (0b0)
                                                       oot_mode[3:0] is 0; 1; 2; 3; 6; 7)
    DIS_DOWNLOAD_DCACHE (BLOCK0)                       Set this bit to disable Dcache in download mode (  = False R/W (0b0)
                                                       boot_mode[3:0] is 0; 1; 2; 3; 6; 7)
    DIS_FORCE_DOWNLOAD (BLOCK0)                        Set this bit to disable the function that forces c = False R"
"/W (0b0)
                                                       hip into download mode
    DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Set this bit to disable flash encryption when in d = False R/W (0b0)
                                                       ownload boot modes
    SPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables flash encryption when 1 or 3 bits are set  = Disable R/W (0b000)
                                                       and disabled otherwise
    SECUR"
"E_BOOT_KEY_REVOKE0 (BLOCK0)                   Revoke 1st secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   Revoke 2nd secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE2 (BLOCK0)                   Revoke 3rd secure boot key                         = False R/W (0b0)
    KEY_PURPOSE_0 (BLOCK0)                             Purpose of Key0                                    = USER R/W (0x0)
    KEY_PURPOS"
"E_1 (BLOCK0)                             Purpose of Key1                                    = USER R/W (0x0)
    KEY_PURPOSE_2 (BLOCK0)                             Purpose of Key2                                    = USER R/W (0x0)
    KEY_PURPOSE_3 (BLOCK0)                             Purpose of Key3                                    = USER R/W (0x0)
    KEY_PURPOSE_4 (BLOCK0)                             Purpose of Key4                                    = USER R/W (0x0)
    KEY_PURPOSE_5 (BLO"
"CK0)                             Purpose of Key5                                    = USER R/W (0x0)
    SECURE_BOOT_EN (BLOCK0)                            Set this bit to enable secure boot                 = False R/W (0b0)
    SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0)             Set this bit to enable revoking aggressive secure  = False R/W (0b0)
                                                       boot
    DIS_DOWNLOAD_MODE (BLOCK0)                         Set this bit to disable download mod"
"e (boot_mode[3 = False R/W (0b0)
                                                       :0] = 0; 1; 2; 3; 6; 7)
    ENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Set this bit to enable secure UART download mode   = False R/W (0b0)
    SECURE_VERSION (BLOCK0)                            Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000)
                                                       ure)
    BLOCK_KEY0 (BLOCK4)
      Purpose: USER
                   Key0 or user data
"
"       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY1 (BLOCK5)
      Purpose: USER
                   Key1 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY2 (BLOCK6)
      Purpose: USER
                   Key2 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_K"
"EY3 (BLOCK7)
      Purpose: USER
                   Key3 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY4 (BLOCK8)
      Purpose: USER
                   Key4 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY5 (BLOCK9)
      Purpose: USER
                   Key5 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
" 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Spi Pad fuses:
    SPI_PAD_CONFIG_CLK (BLOCK1)                        SPI_PAD_configure CLK                              = 0 R/W (0b000000)
    SPI_PAD_CONFIG_Q (BLOCK1)                          SPI_PAD_configure Q(D1)                            = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D (BLOCK1)                          SPI_PAD_configure D(D0)                            = 0 R/W (0b000000)
    SPI_PAD_CONFIG_CS (BLOCK1)                "
"         SPI_PAD_configure CS                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_HD (BLOCK1)                         SPI_PAD_configure HD(D3)                           = 0 R/W (0b000000)
    SPI_PAD_CONFIG_WP (BLOCK1)                         SPI_PAD_configure WP(D2)                           = 0 R/W (0b000000)
    SPI_PAD_CONFIG_DQS (BLOCK1)                        SPI_PAD_configure DQS                              = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D4 (BLOCK1)                "
"         SPI_PAD_configure D4                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D5 (BLOCK1)                         SPI_PAD_configure D5                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D6 (BLOCK1)                         SPI_PAD_configure D6                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D7 (BLOCK1)                         SPI_PAD_configure D7                               = 0 R/W (0b000000)

    Usb fuses:
    DIS_USB_OTG (BLOCK0)      "
"                         Set this bit to disable USB function               = False R/W (0b0)
    USB_EXCHG_PINS (BLOCK0)                            Set this bit to exchange USB D+ and D- pins        = False R/W (0b0)
    USB_EXT_PHY_ENABLE (BLOCK0)                        Set this bit to enable external PHY                = False R/W (0b0)
    DIS_USB_JTAG (BLOCK0)                              Set this bit to disable function of usb switch to  = False R/W (0b0)
                                  "
"                     jtag in module of usb device
    DIS_USB_SERIAL_JTAG (BLOCK0)                       Set this bit to disable usb device                 = False R/W (0b0)
    USB_PHY_SEL (BLOCK0)                               This bit is used to switch internal PHY and extern
       = internal PHY is assigned to USB Device while external PHY is assigned to USB OTG R/W (0b0)
                                                       al PHY for USB OTG and USB Device
    DIS_USB_SERIAL_JTAG_ROM_PRI"
"NT (BLOCK0)             USB printing                                       = Enable R/W (0b0)
    DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0)         Set this bit to disable UART download mode through = False R/W (0b0)
                                                        USB
    DIS_USB_OTG_DOWNLOAD_MODE (BLOCK0)                 Set this bit to disable download through USB-OTG   = False R/W (0b0)

    Vdd fuses:
    VDD_SPI_XPD (BLOCK0)                               SPI regulator power up sign"
"al                      = False R/W (0b0)
    VDD_SPI_TIEH (BLOCK0)                              If VDD_SPI_FORCE is 1; determines VDD_SPI voltage
       = VDD_SPI connects to 1.8 V LDO R/W (0b0)
    VDD_SPI_FORCE (BLOCK0)                             Set this bit and force to use the configuration of = False R/W (0b0)
                                                        eFuse to configure VDD_SPI

    Wdt fuses:
    WDT_DELAY_SEL (BLOCK0)                             RTC watchdog timeout thres"
"hold; in unit of slow cl = 40000 R/W (0b00)
                                                       ock cycle

    Flash voltage (VDD_SPI) determined by GPIO45 on reset (GPIO45=High: VDD_SPI pin is powered from internal 1.8V LDO
    GPIO45=Low or NC: VDD_SPI pin is powered directly from VDD3P3_RTC_IO via resistor Rspi. Typically this voltage is 3.3 V).


To get a dump for all eFuse registers.

.. code-block:: none

    espefuse.py -p PORT dump

    espefuse.py v4.6-dev
    Connecting....
    Dete"
"cting chip type... ESP32-S3
    BLOCK0          (                ) [0 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000
    MAC_SPI_8M_0    (BLOCK1          ) [1 ] read_regs: 3b41f270 0000ecda 00000000 030c0000 2c707800 9800cc58
    BLOCK_SYS_DATA  (BLOCK2          ) [2 ] read_regs: b8c93acb bcc32b88 6000f45e 4bbe25ac 8d8b16d1 924940b4 b2c4cee1 50a53ace
    BLOCK_USR_DATA  (BLOCK3          ) [3 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
"
"    BLOCK_KEY0      (BLOCK4          ) [4 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY1      (BLOCK5          ) [5 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY2      (BLOCK6          ) [6 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY3      (BLOCK7          ) [7 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0"
"0000000
    BLOCK_KEY4      (BLOCK8          ) [8 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY5      (BLOCK9          ) [9 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA2 (BLOCK10         ) [10] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

    BLOCK0          (                ) [0 ] err__regs: 00000000 00000000 00000000 00000000 00000000 00000000
 "
"   EFUSE_RD_RS_ERR0_REG        0x00000000
    EFUSE_RD_RS_ERR1_REG        0x00000000

    === Run ""dump"" command ===
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
|      120      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 120 MHz                      |
|               |                                       | | APB: 40 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz               "
"        |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 40 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       80      | | Any of ``ESP_PM_CPU_FREQ_MAX``      | | CPU: 80 MHz                       |
|               | | or ``ESP_PM_APB_FREQ_MAX`` acquired | | APB: 40 MHz          "
"             |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
|      160      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 160 MHz                      |
|               |                                       | | APB: 80 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz               "
"        |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       80      | | Any of ``ESP_PM_CPU_FREQ_MAX``      | | CPU: 80 MHz                       |
|               | | or ``ESP_PM_APB_FREQ_MAX`` acquired | | APB: 80 MHz          "
"             |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... Unsupported detection protocol, switching and trying again...
    Detecting chip type... ESP32-S2

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Config fuses:
    WR_DIS (BLOCK0)                                    Disable programming of individual eFuses           = 0 R/W (0x00000000)
 "
"   RD_DIS (BLOCK0)                                    Disable reading from BlOCK4-10                     = 0 R/W (0b0000000)
    DIS_ICACHE (BLOCK0)                                Set this bit to disable Icache                     = False R/W (0b0)
    DIS_DCACHE (BLOCK0)                                Set this bit to disable Dcache                     = False R/W (0b0)
    DIS_TWAI (BLOCK0)                                  Set this bit to disable the TWAI Controller functi = False R/W (0b0)
   "
"                                                    on
    DIS_BOOT_REMAP (BLOCK0)                            Disables capability to Remap RAM to ROM address sp = False R/W (0b0)
                                                       ace
    DIS_LEGACY_SPI_BOOT (BLOCK0)                       Set this bit to disable Legacy SPI boot mode       = False R/W (0b0)
    UART_PRINT_CHANNEL (BLOCK0)                        Selects the default UART for printing boot message = UART0 R/W (0b0)
              "
"                                         s
    UART_PRINT_CONTROL (BLOCK0)                        Set the default UART boot message output mode      = Enable R/W (0b00)
    PIN_POWER_SELECTION (BLOCK0)                       Set default power supply for GPIO33-GPIO37; set wh = VDD3P3_CPU R/W (0b0)
                                                       en SPI flash is initialized
    BLOCK_USR_DATA (BLOCK3)                            User data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_SYS_DATA2 (BLOCK10)                          System data part 2 (reserved)
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Flash fuses:
    FLASH_TPUW (BLOCK0)                                Configures flash startup delay after SoC power-up; = 0 R/W (0x0)
                                                        in unit of (ms/2). When the value is 15; delay is
       "
"                                                 7.5 ms
    FLASH_TYPE (BLOCK0)                                SPI flash type                                     = 4 data lines R/W (0b0)
    FORCE_SEND_RESUME (BLOCK0)                         If set; forces ROM code to send an SPI flash resum = False R/W (0b0)
                                                       e command during SPI boot
    FLASH_VERSION (BLOCK1)                             Flash version                                      = "
"2 R/W (0x2)

    Identity fuses:
    BLOCK0_VERSION (BLOCK0)                            BLOCK0 efuse version                               = 0 R/W (0b00)
    DISABLE_WAFER_VERSION_MAJOR (BLOCK0)               Disables check of wafer version major              = False R/W (0b0)
    DISABLE_BLK_VERSION_MAJOR (BLOCK0)                 Disables check of blk version major                = False R/W (0b0)
    WAFER_VERSION_MAJOR (BLOCK1)                       WAFER_VERSION_MAJOR                        "
"        = 1 R/W (0b01)
    WAFER_VERSION_MINOR_HI (BLOCK1)                    WAFER_VERSION_MINOR most significant bit           = False R/W (0b0)
    BLK_VERSION_MAJOR (BLOCK1)                         BLK_VERSION_MAJOR                                  = 0 R/W (0b00)
    PSRAM_VERSION (BLOCK1)                             PSRAM version                                      = 1 R/W (0x1)
    PKG_VERSION (BLOCK1)                               Package version                                    = 0 R/"
"W (0x0)
    WAFER_VERSION_MINOR_LO (BLOCK1)                    WAFER_VERSION_MINOR least significant bits         = 0 R/W (0b000)
    OPTIONAL_UNIQUE_ID (BLOCK2)                        Optional unique 128-bit ID
       = ea 0e c6 f1 01 f2 38 82 e9 98 5b 59 81 fe 00 02 R/W
    BLK_VERSION_MINOR (BLOCK2)                         BLK_VERSION_MINOR of BLOCK2                        = ADC calib V2 R/W (0b010)
    WAFER_VERSION_MINOR (BLOCK0)                       calc WAFER VERSION MINOR = WAFER_VERSIO"
"N_MINOR_HI  = 0 R/W (0x0)
                                                       << 3 + WAFER_VERSION_MINOR_LO (read only)

    Jtag fuses:
    SOFT_DIS_JTAG (BLOCK0)                             Software disables JTAG. When software disabled; JT = False R/W (0b0)
                                                       AG can be activated temporarily by HMAC peripheral
    HARD_DIS_JTAG (BLOCK0)                             Hardware disables JTAG permanently                 = False R/W (0b0)

    M"
"ac fuses:
    MAC (BLOCK1)                                       MAC address
       = 58:cf:79:b3:b9:54 (OK) R/W
    CUSTOM_MAC (BLOCK3)                                Custom MAC
       = 00:00:00:00:00:00 (OK) R/W

    Security fuses:
    DIS_DOWNLOAD_ICACHE (BLOCK0)                       Disables Icache when SoC is in Download mode       = False R/W (0b0)
    DIS_DOWNLOAD_DCACHE (BLOCK0)                       Disables Dcache when SoC is in Download mode       = False R/W (0b0)
    DIS_FORCE_DO"
"WNLOAD (BLOCK0)                        Set this bit to disable the function that forces c = False R/W (0b0)
                                                       hip into download mode
    DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Disables flash encryption when in download boot mo = False R/W (0b0)
                                                       des
    SPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables flash encryption when 1 or 3 bits are set  = Disable R/W (0b000)
   "
"                                                    and disabled otherwise
    SECURE_BOOT_KEY_REVOKE0 (BLOCK0)                   Revoke 1st secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   Revoke 2nd secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE2 (BLOCK0)                   Revoke 3rd secure boot key                         = False R/W (0b0)
    KEY_PURPOSE_0 (BLOCK0)                           "
"  Purpose of KEY0                                    = USER R/W (0x0)
    KEY_PURPOSE_1 (BLOCK0)                             Purpose of KEY1                                    = USER R/W (0x0)
    KEY_PURPOSE_2 (BLOCK0)                             Purpose of KEY2                                    = USER R/W (0x0)
    KEY_PURPOSE_3 (BLOCK0)                             Purpose of KEY3                                    = USER R/W (0x0)
    KEY_PURPOSE_4 (BLOCK0)                             Purpos"
"e of KEY4                                    = USER R/W (0x0)
    KEY_PURPOSE_5 (BLOCK0)                             Purpose of KEY5                                    = USER R/W (0x0)
    SECURE_BOOT_EN (BLOCK0)                            Set this bit to enable secure boot                 = False R/W (0b0)
    SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0)             Set this bit to enable aggressive secure boot key  = False R/W (0b0)
                                                       revocation m"
"ode
    DIS_DOWNLOAD_MODE (BLOCK0)                         Set this bit to disable all download boot modes    = False R/W (0b0)
    ENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Set this bit to enable secure UART download mode ( = False R/W (0b0)
                                                       read/write flash only)
    SECURE_VERSION (BLOCK0)                            Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000)
                                               "
"        ure)
    BLOCK_KEY0 (BLOCK4)
      Purpose: USER
                   Key0 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY1 (BLOCK5)
      Purpose: USER
                   Key1 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY2 (BLOCK6)
      Purpose: USER
                   Key2 or user data
       = 00 00 00 00 00 00"
" 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY3 (BLOCK7)
      Purpose: USER
                   Key3 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY4 (BLOCK8)
      Purpose: USER
                   Key4 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY5 (BLOCK9)
      Purpose"
": USER
                   Key5 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Spi Pad fuses:
    SPI_PAD_CONFIG_CLK (BLOCK1)                        SPI_PAD_configure CLK                              = 0 R/W (0b000000)
    SPI_PAD_CONFIG_Q (BLOCK1)                          SPI_PAD_configure Q(D1)                            = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D (BLOCK1)                          SPI_PAD_configure D(D0"
")                            = 0 R/W (0b000000)
    SPI_PAD_CONFIG_CS (BLOCK1)                         SPI_PAD_configure CS                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_HD (BLOCK1)                         SPI_PAD_configure HD(D3)                           = 0 R/W (0b000000)
    SPI_PAD_CONFIG_WP (BLOCK1)                         SPI_PAD_configure WP(D2)                           = 0 R/W (0b000000)
    SPI_PAD_CONFIG_DQS (BLOCK1)                        SPI_PAD_configure DQS "
"                             = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D4 (BLOCK1)                         SPI_PAD_configure D4                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D5 (BLOCK1)                         SPI_PAD_configure D5                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D6 (BLOCK1)                         SPI_PAD_configure D6                               = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D7 (BLOCK1)                         SPI_PAD_configure D7  "
"                             = 0 R/W (0b000000)

    Usb fuses:
    DIS_USB (BLOCK0)                                   Set this bit to disable USB OTG function           = False R/W (0b0)
    USB_EXCHG_PINS (BLOCK0)                            Set this bit to exchange USB D+ and D- pins        = False R/W (0b0)
    USB_EXT_PHY_ENABLE (BLOCK0)                        Set this bit to enable external USB PHY            = False R/W (0b0)
    USB_FORCE_NOPERSIST (BLOCK0)                       If set; f"
"orces USB BVALID to 1                     = False R/W (0b0)
    DIS_USB_DOWNLOAD_MODE (BLOCK0)                     Set this bit to disable use of USB OTG in UART dow = False R/W (0b0)
                                                       nload boot mode

    Vdd fuses:
    VDD_SPI_XPD (BLOCK0)                               If VDD_SPI_FORCE is 1; this value determines if th = False R/W (0b0)
                                                       e VDD_SPI regulator is powered on
    VDD_SPI_TIEH"
" (BLOCK0)                              If VDD_SPI_FORCE is 1; determines VDD_SPI voltage
       = VDD_SPI connects to 1.8 V LDO R/W (0b0)
    VDD_SPI_FORCE (BLOCK0)                             Set this bit to use XPD_VDD_PSI_REG and VDD_SPI_TI = False R/W (0b0)
                                                       EH to configure VDD_SPI LDO

    Wdt fuses:
    WDT_DELAY_SEL (BLOCK0)                             RTC watchdog timeout threshold; in unit of slow cl = 40000 R/W (0b00)
              "
"                                         ock cycle

    Flash voltage (VDD_SPI) determined by GPIO45 on reset (GPIO45=High: VDD_SPI pin is powered from internal 1.8V LDO
    GPIO45=Low or NC: VDD_SPI pin is powered directly from VDD3P3_RTC_IO via resistor Rspi. Typically this voltage is 3.3 V).


To get a dump for all eFuse registers.

.. code-block:: none

    espefuse.py -p PORT dump

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... Unsupported detection protocol, switchi"
"ng and trying again...
    Detecting chip type... ESP32-S2
    BLOCK0          (                ) [0 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000
    MAC_SPI_8M_0    (BLOCK1          ) [1 ] read_regs: 79b3b954 000058cf 00000000 10440000 00000000 00000000
    BLOCK_SYS_DATA  (BLOCK2          ) [2 ] read_regs: f1c60eea 8238f201 595b98e9 0200fe81 1c549f24 88491102 06461421 070c2083
    BLOCK_USR_DATA  (BLOCK3          ) [3 ] read_regs: 00000000 00000000 00000000 00000000 00000"
"000 00000000 00000000 00000000
    BLOCK_KEY0      (BLOCK4          ) [4 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY1      (BLOCK5          ) [5 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY2      (BLOCK6          ) [6 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY3      (BLOCK7          ) [7 ] read_regs: 00000000 00000000 00000000 000000"
"00 00000000 00000000 00000000 00000000
    BLOCK_KEY4      (BLOCK8          ) [8 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY5      (BLOCK9          ) [9 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA2 (BLOCK10         ) [10] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

    BLOCK0          (                ) [0 ] err__regs: 00000000 00000000 000000"
"00 00000000 00000000 00000000
    EFUSE_RD_RS_ERR0_REG        0x00000000
    EFUSE_RD_RS_ERR1_REG        0x00000000

    === Run ""dump"" command ===
"
"
.. code-block:: none

    $ ./efuse_table_gen.py {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Parsing efuse CSV input file $IDF_PATH/components/efuse/esp32/esp_efuse_table.csv ...
    Verifying efuse table...
    Max number of bits in BLK 192
    Sorted efuse table:
    #       field_name                      efuse_block     bit_start       bit_count
    1       WR_DIS                          EFUSE_BLK0         0               16
    2       WR_DIS.RD_DIS                   EFUSE_BLK0"
"         0               1
    3       WR_DIS.WR_DIS                   EFUSE_BLK0         1               1
    4       WR_DIS.FLASH_CRYPT_CNT          EFUSE_BLK0         2               1
    5       WR_DIS.UART_DOWNLOAD_DIS        EFUSE_BLK0         2               1
    6       WR_DIS.MAC                      EFUSE_BLK0         3               1
    7       WR_DIS.MAC_CRC                  EFUSE_BLK0         3               1
    8       WR_DIS.DISABLE_APP_CPU          EFUSE_BLK0         3    "
"           1
    9       WR_DIS.DISABLE_BT               EFUSE_BLK0         3               1
    10      WR_DIS.DIS_CACHE                EFUSE_BLK0         3               1
    11      WR_DIS.VOL_LEVEL_HP_INV         EFUSE_BLK0         3               1
    12      WR_DIS.CLK8M_FREQ               EFUSE_BLK0         4               1
    13      WR_DIS.ADC_VREF                 EFUSE_BLK0         4               1
    14      WR_DIS.XPD_SDIO_REG             EFUSE_BLK0         5               1
 "
"   15      WR_DIS.XPD_SDIO_TIEH            EFUSE_BLK0         5               1
    16      WR_DIS.XPD_SDIO_FORCE           EFUSE_BLK0         5               1
    17      WR_DIS.SPI_PAD_CONFIG_CLK       EFUSE_BLK0         6               1
    18      WR_DIS.SPI_PAD_CONFIG_Q         EFUSE_BLK0         6               1
    19      WR_DIS.SPI_PAD_CONFIG_D         EFUSE_BLK0         6               1
    20      WR_DIS.SPI_PAD_CONFIG_CS0       EFUSE_BLK0         6               1
    21      WR_"
"DIS.BLOCK1                   EFUSE_BLK0         7               1
    22      WR_DIS.BLOCK2                   EFUSE_BLK0         8               1
    23      WR_DIS.BLOCK3                   EFUSE_BLK0         9               1
    24      WR_DIS.CUSTOM_MAC_CRC           EFUSE_BLK0         9               1
    25      WR_DIS.CUSTOM_MAC               EFUSE_BLK0         9               1
    26      WR_DIS.ADC1_TP_LOW              EFUSE_BLK0         9               1
    27      WR_DIS.ADC1_TP_HI"
"GH             EFUSE_BLK0         9               1
    28      WR_DIS.ADC2_TP_LOW              EFUSE_BLK0         9               1
    29      WR_DIS.ADC2_TP_HIGH             EFUSE_BLK0         9               1
    30      WR_DIS.SECURE_VERSION           EFUSE_BLK0         9               1
    31      WR_DIS.MAC_VERSION              EFUSE_BLK0         9               1
    32      WR_DIS.BLK3_PART_RESERVE        EFUSE_BLK0         10              1
    33      WR_DIS.FLASH_CRYPT_CONFIG      "
" EFUSE_BLK0         10              1
    34      WR_DIS.CODING_SCHEME            EFUSE_BLK0         10              1
    35      WR_DIS.KEY_STATUS               EFUSE_BLK0         10              1
    36      WR_DIS.ABS_DONE_0               EFUSE_BLK0         12              1
    37      WR_DIS.ABS_DONE_1               EFUSE_BLK0         13              1
    38      WR_DIS.JTAG_DISABLE             EFUSE_BLK0         14              1
    39      WR_DIS.CONSOLE_DEBUG_DISABLE    EFUSE_BLK0   "
"      15              1
    40      WR_DIS.DISABLE_DL_ENCRYPT       EFUSE_BLK0         15              1
    41      WR_DIS.DISABLE_DL_DECRYPT       EFUSE_BLK0         15              1
    42      WR_DIS.DISABLE_DL_CACHE         EFUSE_BLK0         15              1
    43      RD_DIS                          EFUSE_BLK0         16              4
    44      RD_DIS.BLOCK1                   EFUSE_BLK0         16              1
    45      RD_DIS.BLOCK2                   EFUSE_BLK0         17      "
"        1
    46      RD_DIS.BLOCK3                   EFUSE_BLK0         18              1
    47      RD_DIS.CUSTOM_MAC_CRC           EFUSE_BLK0         18              1
    48      RD_DIS.CUSTOM_MAC               EFUSE_BLK0         18              1
    49      RD_DIS.ADC1_TP_LOW              EFUSE_BLK0         18              1
    50      RD_DIS.ADC1_TP_HIGH             EFUSE_BLK0         18              1
    51      RD_DIS.ADC2_TP_LOW              EFUSE_BLK0         18              1
    "
"52      RD_DIS.ADC2_TP_HIGH             EFUSE_BLK0         18              1
    53      RD_DIS.SECURE_VERSION           EFUSE_BLK0         18              1
    54      RD_DIS.MAC_VERSION              EFUSE_BLK0         18              1
    55      RD_DIS.BLK3_PART_RESERVE        EFUSE_BLK0         19              1
    56      RD_DIS.FLASH_CRYPT_CONFIG       EFUSE_BLK0         19              1
    57      RD_DIS.CODING_SCHEME            EFUSE_BLK0         19              1
    58      RD_DIS"
".KEY_STATUS               EFUSE_BLK0         19              1
    59      FLASH_CRYPT_CNT                 EFUSE_BLK0         20              7
    60      UART_DOWNLOAD_DIS               EFUSE_BLK0         27              1
    61      MAC                             EFUSE_BLK0         32              8
    62      MAC                             EFUSE_BLK0         40              8
    63      MAC                             EFUSE_BLK0         48              8
    64      MAC                 "
"            EFUSE_BLK0         56              8
    65      MAC                             EFUSE_BLK0         64              8
    66      MAC                             EFUSE_BLK0         72              8
    67      MAC_CRC                         EFUSE_BLK0         80              8
    68      DISABLE_APP_CPU                 EFUSE_BLK0         96              1
    69      DISABLE_BT                      EFUSE_BLK0         97              1
    70      CHIP_PACKAGE_4BIT               EF"
"USE_BLK0         98              1
    71      DIS_CACHE                       EFUSE_BLK0         99              1
    72      SPI_PAD_CONFIG_HD               EFUSE_BLK0        100              5
    73      CHIP_PACKAGE                    EFUSE_BLK0        105              3
    74      CHIP_CPU_FREQ_LOW               EFUSE_BLK0        108              1
    75      CHIP_CPU_FREQ_RATED             EFUSE_BLK0        109              1
    76      BLK3_PART_RESERVE               EFUSE_BLK0      "
"  110              1
    77      CHIP_VER_REV1                   EFUSE_BLK0        111              1
    78      CLK8M_FREQ                      EFUSE_BLK0        128              8
    79      ADC_VREF                        EFUSE_BLK0        136              5
    80      XPD_SDIO_REG                    EFUSE_BLK0        142              1
    81      XPD_SDIO_TIEH                   EFUSE_BLK0        143              1
    82      XPD_SDIO_FORCE                  EFUSE_BLK0        144         "
"     1
    83      SPI_PAD_CONFIG_CLK              EFUSE_BLK0        160              5
    84      SPI_PAD_CONFIG_Q                EFUSE_BLK0        165              5
    85      SPI_PAD_CONFIG_D                EFUSE_BLK0        170              5
    86      SPI_PAD_CONFIG_CS0              EFUSE_BLK0        175              5
    87      CHIP_VER_REV2                   EFUSE_BLK0        180              1
    88      VOL_LEVEL_HP_INV                EFUSE_BLK0        182              2
    89 "
"     WAFER_VERSION_MINOR             EFUSE_BLK0        184              2
    90      FLASH_CRYPT_CONFIG              EFUSE_BLK0        188              4
    91      CODING_SCHEME                   EFUSE_BLK0        192              2
    92      CONSOLE_DEBUG_DISABLE           EFUSE_BLK0        194              1
    93      DISABLE_SDIO_HOST               EFUSE_BLK0        195              1
    94      ABS_DONE_0                      EFUSE_BLK0        196              1
    95      ABS_DONE_"
"1                      EFUSE_BLK0        197              1
    96      JTAG_DISABLE                    EFUSE_BLK0        198              1
    97      DISABLE_DL_ENCRYPT              EFUSE_BLK0        199              1
    98      DISABLE_DL_DECRYPT              EFUSE_BLK0        200              1
    99      DISABLE_DL_CACHE                EFUSE_BLK0        201              1
    100     KEY_STATUS                      EFUSE_BLK0        202              1
    101     BLOCK1                 "
"         EFUSE_BLK1         0              192
    102     BLOCK2                          EFUSE_BLK2         0              192
    103     CUSTOM_MAC_CRC                  EFUSE_BLK3         0               8
    104     MAC_CUSTOM                      EFUSE_BLK3         8               48
    105     ADC1_TP_LOW                     EFUSE_BLK3         96              7
    106     ADC1_TP_HIGH                    EFUSE_BLK3        103              9
    107     ADC2_TP_LOW                     EF"
"USE_BLK3        112              7
    108     ADC2_TP_HIGH                    EFUSE_BLK3        119              9
    109     SECURE_VERSION                  EFUSE_BLK3        128              32
    110     MAC_VERSION                     EFUSE_BLK3        184              8

    Used bits in efuse table:
    EFUSE_BLK0
    [0 15] [0 2] [2 3] ... [19 19] [19 27] [32 87] [96 111] [128 140] [142 144] [160 180] [182 185] [188 202]
    EFUSE_BLK1
    [0 191]
    EFUSE_BLK2
    [0 191]
    EFUSE_B"
"LK3
    [0 55] [96 159] [184 191]
    Note: Not printed ranges are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
|      160      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 160 MHz                      |
|               |                                       | | APB: 80 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz               "
"        |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       80      | | Any of ``ESP_PM_CPU_FREQ_MAX``      | | CPU: 80 MHz                       |
|               | | or ``ESP_PM_APB_FREQ_MAX`` acquired | | APB: 80 MHz          "
"             |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
"
"
.. code-block:: none

    $ ./efuse_table_gen.py -t IDF_TARGET_PATH_NAME {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Max number of bits in BLK 256
    Parsing efuse CSV input file esp32c6/esp_efuse_table.csv ...
    Verifying efuse table...
    Sorted efuse table:
    #       field_name                              efuse_block     bit_start       bit_count
    1       WR_DIS                                  EFUSE_BLK0         0               32
    2       WR_DIS.RD_DIS              "
"             EFUSE_BLK0         0               1
    3       WR_DIS.CRYPT_DPA_ENABLE                 EFUSE_BLK0         1               1
    4       WR_DIS.SWAP_UART_SDIO_EN                EFUSE_BLK0         2               1
    5       WR_DIS.DIS_ICACHE                       EFUSE_BLK0         2               1
    6       WR_DIS.DIS_USB_JTAG                     EFUSE_BLK0         2               1
    7       WR_DIS.DIS_DOWNLOAD_ICACHE              EFUSE_BLK0         2               1
    8"
"       WR_DIS.DIS_USB_SERIAL_JTAG              EFUSE_BLK0         2               1
    9       WR_DIS.DIS_FORCE_DOWNLOAD               EFUSE_BLK0         2               1
    10      WR_DIS.DIS_TWAI                         EFUSE_BLK0         2               1
    11      WR_DIS.JTAG_SEL_ENABLE                  EFUSE_BLK0         2               1
    12      WR_DIS.DIS_PAD_JTAG                     EFUSE_BLK0         2               1
    13      WR_DIS.DIS_DOWNLOAD_MANUAL_ENCRYPT      EFUSE_BL"
"K0         2               1
    14      WR_DIS.WDT_DELAY_SEL                    EFUSE_BLK0         3               1
    15      WR_DIS.SPI_BOOT_CRYPT_CNT               EFUSE_BLK0         4               1
    16      WR_DIS.SECURE_BOOT_KEY_REVOKE0          EFUSE_BLK0         5               1
    17      WR_DIS.SECURE_BOOT_KEY_REVOKE1          EFUSE_BLK0         6               1
    18      WR_DIS.SECURE_BOOT_KEY_REVOKE2          EFUSE_BLK0         7               1
    19      WR_DIS.KEY_PUR"
"POSE_0                    EFUSE_BLK0         8               1
    20      WR_DIS.KEY_PURPOSE_1                    EFUSE_BLK0         9               1
    21      WR_DIS.KEY_PURPOSE_2                    EFUSE_BLK0         10              1
    22      WR_DIS.KEY_PURPOSE_3                    EFUSE_BLK0         11              1
    23      WR_DIS.KEY_PURPOSE_4                    EFUSE_BLK0         12              1
    24      WR_DIS.KEY_PURPOSE_5                    EFUSE_BLK0         13        "
"      1
    25      WR_DIS.SEC_DPA_LEVEL                    EFUSE_BLK0         14              1
    26      WR_DIS.SECURE_BOOT_EN                   EFUSE_BLK0         15              1
    27      WR_DIS.SECURE_BOOT_AGGRESSIVE_REVOKE    EFUSE_BLK0         16              1
    28      WR_DIS.SPI_DOWNLOAD_MSPI_DIS            EFUSE_BLK0         17              1
    29      WR_DIS.FLASH_TPUW                       EFUSE_BLK0         18              1
    30      WR_DIS.DIS_DOWNLOAD_MODE           "
"     EFUSE_BLK0         18              1
    31      WR_DIS.DIS_DIRECT_BOOT                  EFUSE_BLK0         18              1
    32      WR_DIS.DIS_USB_SERIAL_JTAG_ROM_PRINT    EFUSE_BLK0         18              1
    33      WR_DIS.DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE EFUSE_BLK0        18              1
    34      WR_DIS.ENABLE_SECURITY_DOWNLOAD         EFUSE_BLK0         18              1
    35      WR_DIS.UART_PRINT_CONTROL               EFUSE_BLK0         18              1
    36      W"
"R_DIS.FORCE_SEND_RESUME                EFUSE_BLK0         18              1
    37      WR_DIS.SECURE_VERSION                   EFUSE_BLK0         18              1
    38      WR_DIS.SECURE_BOOT_DISABLE_FAST_WAKE    EFUSE_BLK0         19              1
    39      WR_DIS.DISABLE_WAFER_VERSION_MAJOR      EFUSE_BLK0         19              1
    40      WR_DIS.DISABLE_BLK_VERSION_MAJOR        EFUSE_BLK0         19              1
    41      WR_DIS.BLK1                             EFUSE_BLK0      "
"   20              1
    42      WR_DIS.MAC                              EFUSE_BLK0         20              1
    43      WR_DIS.MAC_EXT                          EFUSE_BLK0         20              1
    44      WR_DIS.WAFER_VERSION_MINOR              EFUSE_BLK0         20              1
    45      WR_DIS.WAFER_VERSION_MAJOR              EFUSE_BLK0         20              1
    46      WR_DIS.PKG_VERSION                      EFUSE_BLK0         20              1
    47      WR_DIS.BLK_VERSION_MIN"
"OR                EFUSE_BLK0         20              1
    48      WR_DIS.BLK_VERSION_MAJOR                EFUSE_BLK0         20              1
    49      WR_DIS.FLASH_CAP                        EFUSE_BLK0         20              1
    50      WR_DIS.FLASH_TEMP                       EFUSE_BLK0         20              1
    51      WR_DIS.FLASH_VENDOR                     EFUSE_BLK0         20              1
    52      WR_DIS.SYS_DATA_PART1                   EFUSE_BLK0         21              1
"
"    53      WR_DIS.OPTIONAL_UNIQUE_ID               EFUSE_BLK0         21              1
    54      WR_DIS.BLOCK_USR_DATA                   EFUSE_BLK0         22              1
    55      WR_DIS.CUSTOM_MAC                       EFUSE_BLK0         22              1
    56      WR_DIS.BLOCK_KEY0                       EFUSE_BLK0         23              1
    57      WR_DIS.BLOCK_KEY1                       EFUSE_BLK0         24              1
    58      WR_DIS.BLOCK_KEY2                       EFU"
"SE_BLK0         25              1
    59      WR_DIS.BLOCK_KEY3                       EFUSE_BLK0         26              1
    60      WR_DIS.BLOCK_KEY4                       EFUSE_BLK0         27              1
    61      WR_DIS.BLOCK_KEY5                       EFUSE_BLK0         28              1
    62      WR_DIS.BLOCK_SYS_DATA2                  EFUSE_BLK0         29              1
    63      WR_DIS.USB_EXCHG_PINS                   EFUSE_BLK0         30              1
    64      WR_DIS.VD"
"D_SPI_AS_GPIO                  EFUSE_BLK0         30              1
    65      WR_DIS.SOFT_DIS_JTAG                    EFUSE_BLK0         31              1
    66      RD_DIS                                  EFUSE_BLK0         32              7
    67      RD_DIS.BLOCK_KEY0                       EFUSE_BLK0         32              1
    68      RD_DIS.BLOCK_KEY1                       EFUSE_BLK0         33              1
    69      RD_DIS.BLOCK_KEY2                       EFUSE_BLK0         34   "
"           1
    70      RD_DIS.BLOCK_KEY3                       EFUSE_BLK0         35              1
    71      RD_DIS.BLOCK_KEY4                       EFUSE_BLK0         36              1
    72      RD_DIS.BLOCK_KEY5                       EFUSE_BLK0         37              1
    73      RD_DIS.BLOCK_SYS_DATA2                  EFUSE_BLK0         38              1
    74      SWAP_UART_SDIO_EN                       EFUSE_BLK0         39              1
    75      DIS_ICACHE                    "
"          EFUSE_BLK0         40              1
    76      DIS_USB_JTAG                            EFUSE_BLK0         41              1
    77      DIS_DOWNLOAD_ICACHE                     EFUSE_BLK0         42              1
    78      DIS_USB_SERIAL_JTAG                     EFUSE_BLK0         43              1
    79      DIS_FORCE_DOWNLOAD                      EFUSE_BLK0         44              1
    80      SPI_DOWNLOAD_MSPI_DIS                   EFUSE_BLK0         45              1
    81  "
"    DIS_TWAI                                EFUSE_BLK0         46              1
    82      JTAG_SEL_ENABLE                         EFUSE_BLK0         47              1
    83      SOFT_DIS_JTAG                           EFUSE_BLK0         48              3
    84      DIS_PAD_JTAG                            EFUSE_BLK0         51              1
    85      DIS_DOWNLOAD_MANUAL_ENCRYPT             EFUSE_BLK0         52              1
    86      USB_EXCHG_PINS                          EFUSE_BLK0 "
"        57              1
    87      VDD_SPI_AS_GPIO                         EFUSE_BLK0         58              1
    88      WDT_DELAY_SEL                           EFUSE_BLK0         80              2
    89      SPI_BOOT_CRYPT_CNT                      EFUSE_BLK0         82              3
    90      SECURE_BOOT_KEY_REVOKE0                 EFUSE_BLK0         85              1
    91      SECURE_BOOT_KEY_REVOKE1                 EFUSE_BLK0         86              1
    92      SECURE_BOOT_KEY_R"
"EVOKE2                 EFUSE_BLK0         87              1
    93      KEY_PURPOSE_0                           EFUSE_BLK0         88              4
    94      KEY_PURPOSE_1                           EFUSE_BLK0         92              4
    95      KEY_PURPOSE_2                           EFUSE_BLK0         96              4
    96      KEY_PURPOSE_3                           EFUSE_BLK0        100              4
    97      KEY_PURPOSE_4                           EFUSE_BLK0        104           "
"   4
    98      KEY_PURPOSE_5                           EFUSE_BLK0        108              4
    99      SEC_DPA_LEVEL                           EFUSE_BLK0        112              2
    100     CRYPT_DPA_ENABLE                        EFUSE_BLK0        114              1
    101     SECURE_BOOT_EN                          EFUSE_BLK0        116              1
    102     SECURE_BOOT_AGGRESSIVE_REVOKE           EFUSE_BLK0        117              1
    103     FLASH_TPUW                            "
"  EFUSE_BLK0        124              4
    104     DIS_DOWNLOAD_MODE                       EFUSE_BLK0        128              1
    105     DIS_DIRECT_BOOT                         EFUSE_BLK0        129              1
    106     DIS_USB_SERIAL_JTAG_ROM_PRINT           EFUSE_BLK0        130              1
    107     DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE       EFUSE_BLK0        132              1
    108     ENABLE_SECURITY_DOWNLOAD                EFUSE_BLK0        133              1
    109     UART"
"_PRINT_CONTROL                      EFUSE_BLK0        134              2
    110     FORCE_SEND_RESUME                       EFUSE_BLK0        141              1
    111     SECURE_VERSION                          EFUSE_BLK0        142              16
    112     SECURE_BOOT_DISABLE_FAST_WAKE           EFUSE_BLK0        158              1
    113     DISABLE_WAFER_VERSION_MAJOR             EFUSE_BLK0        160              1
    114     DISABLE_BLK_VERSION_MAJOR               EFUSE_BLK0        "
"161              1
    115     MAC                                     EFUSE_BLK1         0               8
    116     MAC                                     EFUSE_BLK1         8               8
    117     MAC                                     EFUSE_BLK1         16              8
    118     MAC                                     EFUSE_BLK1         24              8
    119     MAC                                     EFUSE_BLK1         32              8
    120     MAC                     "
"                EFUSE_BLK1         40              8
    121     MAC_EXT                                 EFUSE_BLK1         48              16
    122     WAFER_VERSION_MINOR                     EFUSE_BLK1        114              4
    123     WAFER_VERSION_MAJOR                     EFUSE_BLK1        118              2
    124     PKG_VERSION                             EFUSE_BLK1        120              3
    125     BLK_VERSION_MINOR                       EFUSE_BLK1        123              3
 "
"   126     BLK_VERSION_MAJOR                       EFUSE_BLK1        126              2
    127     FLASH_CAP                               EFUSE_BLK1        128              3
    128     FLASH_TEMP                              EFUSE_BLK1        131              2
    129     FLASH_VENDOR                            EFUSE_BLK1        133              3
    130     SYS_DATA_PART2                          EFUSE_BLK10        0              256
    131     OPTIONAL_UNIQUE_ID                      EFU"
"SE_BLK2         0              128
    132     USER_DATA                               EFUSE_BLK3         0              256
    133     USER_DATA.MAC_CUSTOM                    EFUSE_BLK3        200              48
    134     KEY0                                    EFUSE_BLK4         0              256
    135     KEY1                                    EFUSE_BLK5         0              256
    136     KEY2                                    EFUSE_BLK6         0              256
    137     KEY"
"3                                    EFUSE_BLK7         0              256
    138     KEY4                                    EFUSE_BLK8         0              256
    139     KEY5                                    EFUSE_BLK9         0              256

    Used bits in efuse table:
    EFUSE_BLK0
    [0 31] [0 2] [2 2] ... [30 38] [32 52] [57 58] [80 114] [116 117] [124 130] [132 135] [141 158] [160 161]
    EFUSE_BLK1
    [0 63] [114 135]
    EFUSE_BLK10
    [0 255]
    EFUSE_BLK2
    [0 127"
"]
    EFUSE_BLK3
    [0 255] [200 247]
    EFUSE_BLK4
    [0 255]
    EFUSE_BLK5
    [0 255]
    EFUSE_BLK6
    [0 255]
    EFUSE_BLK7
    [0 255]
    EFUSE_BLK8
    [0 255]
    EFUSE_BLK9
    [0 255]
    Note: Not printed ranges are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.7.0
    Connecting....
    Detecting chip type... ESP32-P4

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Config fuses:
    WR_DIS (BLOCK0)                                    Disable programming of individual eFuses           = 0 R/W (0x00000000)
    RD_DIS (BLOCK0)                                    Disable reading from BlOCK4-10       "
"              = 0 R/W (0b0000000)
    POWERGLITCH_EN (BLOCK0)                            Represents whether power glitch function is enable = False R/W (0b0)
                                                       d. 1: enabled. 0: disabled
    DIS_TWAI (BLOCK0)                                  Represents whether TWAI function is disabled or en = False R/W (0b0)
                                                       abled. 1: disabled. 0: enabled
    KM_HUK_GEN_STATE (BLOCK0)                     "
"     Set this bit to control validation of HUK generate = 0 R/W (0b000000000)
                                                        mode. Odd of 1 is invalid; even of 1 is valid
    KM_RND_SWITCH_CYCLE (BLOCK0)                       Set bits to control key manager random number swit = 0 R/W (0b00)
                                                       ch cycle. 0: control by register. 1: 8 km clk cycl
                                                       es. 2: 16 km cycles. 3: 32 km cycles
 "
"   KM_DEPLOY_ONLY_ONCE (BLOCK0)                       Set each bit to control whether corresponding key  = 0 R/W (0x0)
                                                       can only be deployed once. 1 is true; 0 is false.
                                                       Bit0: ecdsa. Bit1: xts. Bit2: hmac. Bit3: ds
    DIS_DIRECT_BOOT (BLOCK0)                           Represents whether direct boot mode is disabled or = False R/W (0b0)
                                                    "
"    enabled. 1: disabled. 0: enabled
    UART_PRINT_CONTROL (BLOCK0)                        Represents the type of UART printing. 00: force en = 0 R/W (0b00)
                                                       able printing. 01: enable printing when GPIO8 is r
                                                       eset at low level. 10: enable printing when GPIO8
                                                       is reset at high level. 11: force disable printing
    HYS_EN_PAD (BLOCK0)  "
"                              Represents whether the hysteresis function of corr = False R/W (0b0)
                                                       esponding PAD is enabled. 1: enabled. 0:disabled
    DCDC_VSET (BLOCK0)                                 Set the dcdc voltage default                       = 0 R/W (0b00000)
    PXA0_TIEH_SEL_0 (BLOCK0)                           TBD                                                = 0 R/W (0b00)
    PXA0_TIEH_SEL_1 (BLOCK0)                        "
"   TBD                                                = 0 R/W (0b00)
    PXA0_TIEH_SEL_2 (BLOCK0)                           TBD                                                = 0 R/W (0b00)
    PXA0_TIEH_SEL_3 (BLOCK0)                           TBD                                                = 0 R/W (0b00)
    KM_DISABLE_DEPLOY_MODE (BLOCK0)                    TBD                                                = 0 R/W (0x0)
    HP_PWR_SRC_SEL (BLOCK0)                            HP system powe"
"r source select. 0:LDO. 1: DCDC      = False R/W (0b0)
    DCDC_VSET_EN (BLOCK0)                              Select dcdc vset use efuse_dcdc_vset               = False R/W (0b0)
    DIS_SWD (BLOCK0)                                   Set this bit to disable super-watchdog             = False R/W (0b0)
    PSRAM_CAP (BLOCK1)                                 PSRAM capacity                                     = 0 R/W (0b00)
    PSRAM_TEMP (BLOCK1)                                PSRAM temperature    "
"                              = 0 R/W (0b00)
    PSRAM_VENDOR (BLOCK1)                              PSRAM vendor                                       = 0 R/W (0b00)
    BLOCK_USR_DATA (BLOCK3)                            User data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_SYS_DATA2 (BLOCK10)                          System data part 2 (reserved)
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
"00 00 00 00 00 00 00 00 00 00 R/W

    Flash fuses:
    FLASH_TYPE (BLOCK0)                                The type of interfaced flash. 0: four data lines;  = False R/W (0b0)
                                                       1: eight data lines
    FLASH_PAGE_SIZE (BLOCK0)                           Set flash page size                                = 0 R/W (0b00)
    FLASH_ECC_EN (BLOCK0)                              Set this bit to enable ecc for flash boot          = False R/W (0b0)
    "
"FLASH_TPUW (BLOCK0)                                Represents the flash waiting time after power-up;  = 0 R/W (0x0)
                                                       in unit of ms. When the value less than 15; the wa
                                                       iting time is the programmed value. Otherwise; the
                                                        waiting time is 2 times the programmed value
    FORCE_SEND_RESUME (BLOCK0)                         Represents wheth"
"er ROM code is forced to send a re = False R/W (0b0)
                                                       sume command during SPI boot. 1: forced. 0:not for
                                                       ced
    FLASH_CAP (BLOCK1)                                 Flash capacity                                     = 0 R/W (0b000)
    FLASH_TEMP (BLOCK1)                                Flash temperature                                  = 0 R/W (0b00)
    FLASH_VENDOR (BLOCK1)              "
"                Flash vendor                                       = 0 R/W (0b000)

    Identity fuses:
    WAFER_VERSION_MINOR (BLOCK1)                       Minor chip version                                 = 0 R/W (0x0)
    WAFER_VERSION_MAJOR (BLOCK1)                       Major chip version                                 = 0 R/W (0b00)
    DISABLE_WAFER_VERSION_MAJOR (BLOCK1)               Disables check of wafer version major              = False R/W (0b0)
    DISABLE_BLK_VERSION_MAJOR ("
"BLOCK1)                 Disables check of blk version major                = False R/W (0b0)
    BLK_VERSION_MINOR (BLOCK1)                         BLK_VERSION_MINOR of BLOCK2                        = 0 R/W (0b000)
    BLK_VERSION_MAJOR (BLOCK1)                         BLK_VERSION_MAJOR of BLOCK2                        = 0 R/W (0b00)
    PKG_VERSION (BLOCK1)                               Package version                                    = 0 R/W (0b000)
    OPTIONAL_UNIQUE_ID (BLOCK2)           "
"             Optional unique 128-bit ID
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Jtag fuses:
    JTAG_SEL_ENABLE (BLOCK0)                           Represents whether the selection between usb_to_jt = False R/W (0b0)
                                                       ag and pad_to_jtag through strapping gpio15 when b
                                                       oth EFUSE_DIS_PAD_JTAG and EFUSE_DIS_USB_JTAG are
                                               "
"        equal to 0 is enabled or disabled. 1: enabled. 0:
                                                       disabled
    SOFT_DIS_JTAG (BLOCK0)                             Represents whether JTAG is disabled in soft way. O = 0 R/W (0b000)
                                                       dd number: disabled. Even number: enabled
    DIS_PAD_JTAG (BLOCK0)                              Represents whether JTAG is disabled in the hard wa = False R/W (0b0)
                                   "
"                    y(permanently). 1: disabled. 0: enabled

    Mac fuses:
    MAC (BLOCK1)                                       MAC address
       = 60:55:f9:f8:80:40 (OK) R/W
    CUSTOM_MAC (BLOCK3)                                Custom MAC
       = 00:00:00:00:00:00 (OK) R/W

    Security fuses:
    DIS_FORCE_DOWNLOAD (BLOCK0)                        Represents whether the function that forces chip i = False R/W (0b0)
                                                       nto download mode i"
"s disabled or enabled. 1: disab
                                                       led. 0: enabled
    SPI_DOWNLOAD_MSPI_DIS (BLOCK0)                     Set this bit to disable accessing MSPI flash/MSPI  = False R/W (0b0)
                                                       ram by SYS AXI matrix during boot_mode_download
    DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Represents whether flash encrypt function is disab = False R/W (0b0)
                                              "
"         led or enabled(except in SPI boot mode). 1: disabl
                                                       ed. 0: enabled
    FORCE_USE_KEY_MANAGER_KEY (BLOCK0)                 Set each bit to control whether corresponding key  = 0 R/W (0x0)
                                                       must come from key manager.. 1 is true; 0 is false
                                                       . Bit0: ecdsa. Bit1: xts. Bit2: hmac. Bit3: ds
    FORCE_DISABLE_SW_INIT_KEY (BLOCK0)    "
"             Set this bit to disable software written init key; = False R/W (0b0)
                                                        and force use efuse_init_key
    XTS_KEY_LENGTH_256 (BLOCK0)                        Set this bit to configure flash encryption use xts = False R/W (0b0)
                                                       -128 key; else use xts-256 key
    SPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables flash encryption when 1 or 3 bits are set  = Disable R/W (0b"
"000)
                                                       and disables otherwise
    SECURE_BOOT_KEY_REVOKE0 (BLOCK0)                   Revoke 1st secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   Revoke 2nd secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE2 (BLOCK0)                   Revoke 3rd secure boot key                         = False R/W (0b0)
    KEY_PURPOSE_0 (BLOCK0)                   "
"          Represents the purpose of Key0                     = USER R/W (0x0)
    KEY_PURPOSE_1 (BLOCK0)                             Represents the purpose of Key1                     = USER R/W (0x0)
    KEY_PURPOSE_2 (BLOCK0)                             Represents the purpose of Key2                     = USER R/W (0x0)
    KEY_PURPOSE_3 (BLOCK0)                             Represents the purpose of Key3                     = USER R/W (0x0)
    KEY_PURPOSE_4 (BLOCK0)                           "
"  Represents the purpose of Key4                     = USER R/W (0x0)
    KEY_PURPOSE_5 (BLOCK0)                             Represents the purpose of Key5                     = USER R/W (0x0)
    SEC_DPA_LEVEL (BLOCK0)                             Represents the spa secure level by configuring the = 0 R/W (0b00)
                                                        clock random divide mode
    ECDSA_ENABLE_SOFT_K (BLOCK0)                       Represents whether hardware random number k is for"
" = False R/W (0b0)
                                                       ced used in ESDCA. 1: force used. 0: not force use
                                                       d
    CRYPT_DPA_ENABLE (BLOCK0)                          Represents whether anti-dpa attack is enabled. 1:e = False R/W (0b0)
                                                       nabled. 0: disabled
    SECURE_BOOT_EN (BLOCK0)                            Represents whether secure boot is enabled or disab = False R/W ("
"0b0)
                                                       led. 1: enabled. 0: disabled
    SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0)             Represents whether revoking aggressive secure boot = False R/W (0b0)
                                                        is enabled or disabled. 1: enabled. 0: disabled
    DIS_DOWNLOAD_MODE (BLOCK0)                         Represents whether Download mode is disabled or en = False R/W (0b0)
                                                       able"
"d. 1: disabled. 0: enabled
    LOCK_KM_KEY (BLOCK0)                               TBD                                                = False R/W (0b0)
    ENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Represents whether security download is enabled or = False R/W (0b0)
                                                        disabled. 1: enabled. 0: disabled
    SECURE_VERSION (BLOCK0)                            Represents the version used by ESP-IDF anti-rollba = 0 R/W (0x0000)
            "
"                                           ck feature
    SECURE_BOOT_DISABLE_FAST_WAKE (BLOCK0)             Represents whether FAST VERIFY ON WAKE is disabled = False R/W (0b0)
                                                        or enabled when Secure Boot is enabled. 1: disabl
                                                       ed. 0: enabled
    BLOCK_KEY0 (BLOCK4)
      Purpose: USER
                   Key0 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
" 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY1 (BLOCK5)
      Purpose: USER
                   Key1 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY2 (BLOCK6)
      Purpose: USER
                   Key2 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY3 (BLOCK7)
      Purpose: USER
                   Key3 or user "
"data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY4 (BLOCK8)
      Purpose: USER
                   Key4 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY5 (BLOCK9)
      Purpose: USER
                   Key5 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    U"
"sb fuses:
    USB_DEVICE_EXCHG_PINS (BLOCK0)                     Enable usb device exchange pins of D+ and D-       = False R/W (0b0)
    USB_OTG11_EXCHG_PINS (BLOCK0)                      Enable usb otg11 exchange pins of D+ and D-        = False R/W (0b0)
    DIS_USB_JTAG (BLOCK0)                              Represents whether the function of usb switch to j = False R/W (0b0)
                                                       tag is disabled or enabled. 1: disabled. 0: enable
            "
"                                           d
    USB_PHY_SEL (BLOCK0)                               TBD                                                = False R/W (0b0)
    DIS_USB_OTG_DOWNLOAD_MODE (BLOCK0)                 Set this bit to disable download via USB-OTG       = False R/W (0b0)
    DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0)             Represents whether print from USB-Serial-JTAG is d = False R/W (0b0)
                                                       isabled or enabled. 1: disab"
"led. 0: enabled
    DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0)         Represents whether the USB-Serial-JTAG download fu = False R/W (0b0)
                                                       nction is disabled or enabled. 1: disabled. 0: ena
                                                       bled

    Wdt fuses:
    WDT_DELAY_SEL (BLOCK0)                             Represents whether RTC watchdog timeout threshold  = 0 R/W (0b00)
                                                       is"
" selected at startup. 1: selected. 0: not select
                                                       ed
    DIS_WDT (BLOCK0)                                   Set this bit to disable watch dog                  = False R/W (0b0)


To get a dump for all eFuse registers.

.. code-block:: none

    espefuse.py v4.7.dev1
    Connecting....
    Detecting chip type... ESP32-P4
    BLOCK0          (                ) [0 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000
    MAC_SPI_8M_"
"0    (BLOCK1          ) [1 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA  (BLOCK2          ) [2 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_USR_DATA  (BLOCK3          ) [3 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY0      (BLOCK4          ) [4 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY1      (BLOC"
"K5          ) [5 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY2      (BLOCK6          ) [6 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY3      (BLOCK7          ) [7 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY4      (BLOCK8          ) [8 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY5   "
"   (BLOCK9          ) [9 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA2 (BLOCK10         ) [10] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK0          (                ) [0 ] err__regs: 00000000 00000000 00000000 00000000 00000000 00000000
    EFUSE_RD_RS_ERR0_REG        0x00000000
    EFUSE_RD_RS_ERR1_REG        0x00000000
    === Run ""dump"" command ===
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-H2

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Config fuses:
    WR_DIS (BLOCK0)                                    Disable programming of individual eFuses           = 0 R/W (0x00000000)
    RD_DIS (BLOCK0)                                    Disable reading from BlOCK4-10     "
"                = 0 R/W (0b0000000)
    DIS_ICACHE (BLOCK0)                                Represents whether icache is disabled or enabled.  = False R/W (0b0)
                                                       1: disabled. 0: enabled
    POWERGLITCH_EN (BLOCK0)                            Represents whether power glitch function is enable = False R/W (0b0)
                                                       d. 1: enabled. 0: disabled
    DIS_TWAI (BLOCK0)                                  "
"Represents whether TWAI function is disabled or en = False R/W (0b0)
                                                       abled. 1: disabled. 0: enabled
    DIS_DIRECT_BOOT (BLOCK0)                           Represents whether direct boot mode is disabled or = False R/W (0b0)
                                                        enabled. 1: disabled. 0: enabled
    UART_PRINT_CONTROL (BLOCK0)                        Set the default UARTboot message output mode       = Enable R/W (0b00)
    HY"
"S_EN_PAD0 (BLOCK0)                               Set bits to enable hysteresis function of PAD0~5   = 0 R/W (0b000000)
    HYS_EN_PAD1 (BLOCK0)                               Set bits to enable hysteresis function of PAD6~27  = 0 R/W (0b0000000000000000000000)
    BLOCK_USR_DATA (BLOCK3)                            User data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_SYS_DATA2 (BLOCK10)                          System data"
" part 2 (reserved)
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Flash fuses:
    FLASH_TPUW (BLOCK0)                                Represents the flash waiting time after power-up;  = 0 R/W (0x0)
                                                       in unit of ms. When the value less than 15; the wa
                                                       iting time is the programmed value. Otherwise; the
                      "
"                                  waiting time is 2 times the programmed value
    FORCE_SEND_RESUME (BLOCK0)                         Represents whether ROM code is forced to send a re = False R/W (0b0)
                                                       sume command during SPI boot. 1: forced. 0:not for
                                                       ced
    FLASH_CAP (BLOCK1)                                                                                    = 0 R/W (0b000)
    FLASH_"
"TEMP (BLOCK1)                                                                                   = 0 R/W (0b00)
    FLASH_VENDOR (BLOCK1)                                                                                 = 0 R/W (0b000)

    Identity fuses:
    WAFER_VERSION_MINOR (BLOCK1)                                                                          = 0 R/W (0b000)
    WAFER_VERSION_MAJOR (BLOCK1)                                                                          = 0 R/W (0b00)
   "
" DISABLE_WAFER_VERSION_MAJOR (BLOCK1)               Disables check of wafer version major              = False R/W (0b0)
    PKG_VERSION (BLOCK1)                               Package version                                    = 0 R/W (0b000)
    OPTIONAL_UNIQUE_ID (BLOCK2)                        Optional unique 128-bit ID
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLK_VERSION_MINOR (BLOCK2)                         BLK_VERSION_MINOR of BLOCK2                        = 0 R/W "
"(0b000)
    BLK_VERSION_MAJOR (BLOCK2)                         BLK_VERSION_MAJOR of BLOCK2                        = 0 R/W (0b00)
    DISABLE_BLK_VERSION_MAJOR (BLOCK2)                 Disables check of blk version major                = False R/W (0b0)

    Jtag fuses:
    JTAG_SEL_ENABLE (BLOCK0)                           Set this bit to enable selection between usb_to_jt = False R/W (0b0)
                                                       ag and pad_to_jtag through strapping gpio25 when b
"
"                                                       oth EFUSE_DIS_PAD_JTAG and EFUSE_DIS_USB_JTAG are
                                                       equal to 0
    SOFT_DIS_JTAG (BLOCK0)                             Represents whether JTAG is disabled in soft way. O = 0 R/W (0b000)
                                                       dd number: disabled. Even number: enabled
    DIS_PAD_JTAG (BLOCK0)                              Represents whether JTAG is disabled in the hard wa = Fa"
"lse R/W (0b0)
                                                       y(permanently). 1: disabled. 0: enabled

    Mac fuses:
    MAC (BLOCK1)                                       MAC address
       = 60:55:f9:f7:2c:a2:ff:fe (OK) R/W
    MAC_EXT (BLOCK1)                                   Stores the extended bits of MAC address            = ff:fe (OK) R/W
    CUSTOM_MAC (BLOCK3)                                Custom MAC
       = 00:00:00:00:00:00:ff:fe (OK) R/W

    Security fuses:
    DIS_FORCE_"
"DOWNLOAD (BLOCK0)                        Represents whether the function that forces chip i = False R/W (0b0)
                                                       nto download mode is disabled or enabled. 1: disab
                                                       led. 0: enabled
    SPI_DOWNLOAD_MSPI_DIS (BLOCK0)                     Represents whether SPI0 controller during boot_mod = False R/W (0b0)
                                                       e_download is disabled or enabled."
" 1: disabled. 0:
                                                        enabled
    DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Represents whether flash encrypt function is disab = False R/W (0b0)
                                                       led or enabled(except in SPI boot mode). 1: disabl
                                                       ed. 0: enabled
    SPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables flash encryption when 1 or 3 bits are set  = Disable R/W"
" (0b000)
                                                       and disables otherwise
    SECURE_BOOT_KEY_REVOKE0 (BLOCK0)                   Revoke 1st secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   Revoke 2nd secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE2 (BLOCK0)                   Revoke 3rd secure boot key                         = False R/W (0b0)
    KEY_PURPOSE_0 (BLOCK0)               "
"              Represents the purpose of Key0                     = USER R/W (0x0)
    KEY_PURPOSE_1 (BLOCK0)                             Represents the purpose of Key1                     = USER R/W (0x0)
    KEY_PURPOSE_2 (BLOCK0)                             Represents the purpose of Key2                     = USER R/W (0x0)
    KEY_PURPOSE_3 (BLOCK0)                             Represents the purpose of Key3                     = USER R/W (0x0)
    KEY_PURPOSE_4 (BLOCK0)                       "
"      Represents the purpose of Key4                     = USER R/W (0x0)
    KEY_PURPOSE_5 (BLOCK0)                             Represents the purpose of Key5                     = USER R/W (0x0)
    SEC_DPA_LEVEL (BLOCK0)                             Represents the spa secure level by configuring the = 0 R/W (0b00)
                                                        clock random divide mode
    ECDSA_FORCE_USE_HARDWARE_K (BLOCK0)                Represents whether hardware random number k is"
" for = False R/W (0b0)
                                                       ced used in ESDCA. 1: force used. 0: not force use
                                                       d
    CRYPT_DPA_ENABLE (BLOCK0)                          Represents whether anti-dpa attack is enabled. 1:e = False R/W (0b0)
                                                       nabled. 0: disabled
    SECURE_BOOT_EN (BLOCK0)                            Represents whether secure boot is enabled or disab = False R"
"/W (0b0)
                                                       led. 1: enabled. 0: disabled
    SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0)             Represents whether revoking aggressive secure boot = False R/W (0b0)
                                                        is enabled or disabled. 1: enabled. 0: disabled
    DIS_DOWNLOAD_MODE (BLOCK0)                         Represents whether Download mode is disabled or en = False R/W (0b0)
                                                       "
"abled. 1: disabled. 0: enabled
    ENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Represents whether security download is enabled or = False R/W (0b0)
                                                        disabled. 1: enabled. 0: disabled
    SECURE_VERSION (BLOCK0)                            Represents the version used by ESP-IDF anti-rollba = 0 R/W (0x0000)
                                                       ck feature
    SECURE_BOOT_DISABLE_FAST_WAKE (BLOCK0)             Represents "
"whether FAST VERIFY ON WAKE is disabled = False R/W (0b0)
                                                        or enabled when Secure Boot is enabled. 1: disabl
                                                       ed. 0: enabled
    BLOCK_KEY0 (BLOCK4)
      Purpose: USER
                   Key0 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY1 (BLOCK5)
      Purpose: USER
                   Key1 or user "
"data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY2 (BLOCK6)
      Purpose: USER
                   Key2 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY3 (BLOCK7)
      Purpose: USER
                   Key3 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BL"
"OCK_KEY4 (BLOCK8)
      Purpose: USER
                   Key4 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY5 (BLOCK9)
      Purpose: USER
                   Key5 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Usb fuses:
    DIS_USB_JTAG (BLOCK0)                              Represents whether the function of usb switch to j = Fa"
"lse R/W (0b0)
                                                       tag is disabled or enabled. 1: disabled. 0: enable
                                                       d
    USB_EXCHG_PINS (BLOCK0)                            Represents whether the D+ and D- pins is exchanged = False R/W (0b0)
                                                       . 1: exchanged. 0: not exchanged
    DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0)             Set this bit to disable USB-Serial-JTAG print duri = Fal"
"se R/W (0b0)
                                                       ng rom boot
    DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0)         Represents whether the USB-Serial-JTAG download fu = False R/W (0b0)
                                                       nction is disabled or enabled. 1: disabled. 0: ena
                                                       bled

    Vdd fuses:
    VDD_SPI_AS_GPIO (BLOCK0)                           Represents whether vdd spi pin is functioned as gp = False "
"R/W (0b0)
                                                       io. 1: functioned. 0: not functioned

    Wdt fuses:
    WDT_DELAY_SEL (BLOCK0)                             Represents whether RTC watchdog timeout threshold  = 0 R/W (0b00)
                                                       is selected at startup. 1: selected. 0: not select
                                                       ed


To get a dump for all eFuse registers.

.. code-block:: none

    espefuse.py -p PORT dump

   "
" espefuse.py dump
    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-H2
    BLOCK0          (                ) [0 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000
    MAC_SPI_8M_0    (BLOCK1          ) [1 ] read_regs: f9f72ca2 fffe6055 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA  (BLOCK2          ) [2 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_USR_DATA  (BLOCK3          ) [3 ] read_regs: 00"
"000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY0      (BLOCK4          ) [4 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY1      (BLOCK5          ) [5 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY2      (BLOCK6          ) [6 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY3      (BLOCK7          ) [7 ] read_"
"regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY4      (BLOCK8          ) [8 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY5      (BLOCK9          ) [9 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA2 (BLOCK10         ) [10] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

    BLOCK0          (                ) ["
"0 ] err__regs: 00000000 00000000 00000000 00000000 00000000 00000000
    EFUSE_RD_RS_ERR0_REG        0x00000000
    EFUSE_RD_RS_ERR1_REG        0x00000000

    === Run ""dump"" command ===
"
"
.. code-block:: none

    To be updated for C5
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
| ECO1   | v0.1                   |
+++
| ECO2   | v0.2                   |
+++
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
| ECO1   | v1.0                   |
+++
"
"
+++
| ECO    | Revision (Major.Minor) |
+++
| ECO0   | v0.0                   |
+++
| ECO1   | v1.0                   |
+++
| ECO1.1 | v1.1                   |
+++
| ECO2   | v2.0                   |
+++
| ECO3   | v3.0                   |
+++
| ECO4   | v3.1                   |
+++
"
"
.. code-block:: none

    $ ./efuse_table_gen.py {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Max number of bits in BLK 256
    Sorted efuse table:
    #       field_name                              efuse_block     bit_start       bit_count
    1       WR_DIS                                  EFUSE_BLK0         0               32
    2       WR_DIS.RD_DIS                           EFUSE_BLK0         0               1
    3       WR_DIS.DIS_ICACHE                       EFUSE_BLK0      "
"   2               1
    4       WR_DIS.DIS_USB_JTAG                     EFUSE_BLK0         2               1
    5       WR_DIS.DIS_DOWNLOAD_ICACHE              EFUSE_BLK0         2               1
    6       WR_DIS.DIS_USB_SERIAL_JTAG              EFUSE_BLK0         2               1
    7       WR_DIS.DIS_FORCE_DOWNLOAD               EFUSE_BLK0         2               1
    8       WR_DIS.DIS_TWAI                         EFUSE_BLK0         2               1
    9       WR_DIS.JTAG_SEL_ENABLE"
"                  EFUSE_BLK0         2               1
    10      WR_DIS.DIS_PAD_JTAG                     EFUSE_BLK0         2               1
    11      WR_DIS.DIS_DOWNLOAD_MANUAL_ENCRYPT      EFUSE_BLK0         2               1
    12      WR_DIS.WDT_DELAY_SEL                    EFUSE_BLK0         3               1
    13      WR_DIS.SPI_BOOT_CRYPT_CNT               EFUSE_BLK0         4               1
    14      WR_DIS.SECURE_BOOT_KEY_REVOKE0          EFUSE_BLK0         5               1
"
"    15      WR_DIS.SECURE_BOOT_KEY_REVOKE1          EFUSE_BLK0         6               1
    16      WR_DIS.SECURE_BOOT_KEY_REVOKE2          EFUSE_BLK0         7               1
    17      WR_DIS.KEY_PURPOSE_0                    EFUSE_BLK0         8               1
    18      WR_DIS.KEY_PURPOSE_1                    EFUSE_BLK0         9               1
    19      WR_DIS.KEY_PURPOSE_2                    EFUSE_BLK0         10              1
    20      WR_DIS.KEY_PURPOSE_3                    EFU"
"SE_BLK0         11              1
    21      WR_DIS.KEY_PURPOSE_4                    EFUSE_BLK0         12              1
    22      WR_DIS.KEY_PURPOSE_5                    EFUSE_BLK0         13              1
    23      WR_DIS.SECURE_BOOT_EN                   EFUSE_BLK0         15              1
    24      WR_DIS.SECURE_BOOT_AGGRESSIVE_REVOKE    EFUSE_BLK0         16              1
    25      WR_DIS.FLASH_TPUW                       EFUSE_BLK0         18              1
    26      WR_DIS.DI"
"S_DOWNLOAD_MODE                EFUSE_BLK0         18              1
    27      WR_DIS.DIS_DIRECT_BOOT                  EFUSE_BLK0         18              1
    28      WR_DIS.DIS_USB_SERIAL_JTAG_ROM_PRINT    EFUSE_BLK0         18              1
    29      WR_DIS.DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE EFUSE_BLK0        18              1
    30      WR_DIS.ENABLE_SECURITY_DOWNLOAD         EFUSE_BLK0         18              1
    31      WR_DIS.UART_PRINT_CONTROL               EFUSE_BLK0         18   "
"           1
    32      WR_DIS.FORCE_SEND_RESUME                EFUSE_BLK0         18              1
    33      WR_DIS.SECURE_VERSION                   EFUSE_BLK0         18              1
    34      WR_DIS.ERR_RST_ENABLE                   EFUSE_BLK0         19              1
    35      WR_DIS.DISABLE_WAFER_VERSION_MAJOR      EFUSE_BLK0         19              1
    36      WR_DIS.DISABLE_BLK_VERSION_MAJOR        EFUSE_BLK0         19              1
    37      WR_DIS.BLK1                   "
"          EFUSE_BLK0         20              1
    38      WR_DIS.MAC                              EFUSE_BLK0         20              1
    39      WR_DIS.SPI_PAD_CONFIG_CLK               EFUSE_BLK0         20              1
    40      WR_DIS.SPI_PAD_CONFIG_Q                 EFUSE_BLK0         20              1
    41      WR_DIS.SPI_PAD_CONFIG_D                 EFUSE_BLK0         20              1
    42      WR_DIS.SPI_PAD_CONFIG_CS                EFUSE_BLK0         20              1
    43  "
"    WR_DIS.SPI_PAD_CONFIG_HD                EFUSE_BLK0         20              1
    44      WR_DIS.SPI_PAD_CONFIG_WP                EFUSE_BLK0         20              1
    45      WR_DIS.SPI_PAD_CONFIG_DQS               EFUSE_BLK0         20              1
    46      WR_DIS.SPI_PAD_CONFIG_D4                EFUSE_BLK0         20              1
    47      WR_DIS.SPI_PAD_CONFIG_D5                EFUSE_BLK0         20              1
    48      WR_DIS.SPI_PAD_CONFIG_D6                EFUSE_BLK0 "
"        20              1
    49      WR_DIS.SPI_PAD_CONFIG_D7                EFUSE_BLK0         20              1
    50      WR_DIS.WAFER_VERSION_MINOR_LO           EFUSE_BLK0         20              1
    51      WR_DIS.PKG_VERSION                      EFUSE_BLK0         20              1
    52      WR_DIS.BLK_VERSION_MINOR                EFUSE_BLK0         20              1
    53      WR_DIS.K_RTC_LDO                        EFUSE_BLK0         20              1
    54      WR_DIS.K_DIG_LDO "
"                       EFUSE_BLK0         20              1
    55      WR_DIS.V_RTC_DBIAS20                    EFUSE_BLK0         20              1
    56      WR_DIS.V_DIG_DBIAS20                    EFUSE_BLK0         20              1
    57      WR_DIS.DIG_DBIAS_HVT                    EFUSE_BLK0         20              1
    58      WR_DIS.THRES_HVT                        EFUSE_BLK0         20              1
    59      WR_DIS.WAFER_VERSION_MINOR_HI           EFUSE_BLK0         20           "
"   1
    60      WR_DIS.WAFER_VERSION_MAJOR              EFUSE_BLK0         20              1
    61      WR_DIS.SYS_DATA_PART1                   EFUSE_BLK0         21              1
    62      WR_DIS.OPTIONAL_UNIQUE_ID               EFUSE_BLK0         21              1
    63      WR_DIS.BLK_VERSION_MAJOR                EFUSE_BLK0         21              1
    64      WR_DIS.TEMP_CALIB                       EFUSE_BLK0         21              1
    65      WR_DIS.OCODE                          "
"  EFUSE_BLK0         21              1
    66      WR_DIS.ADC1_INIT_CODE_ATTEN0            EFUSE_BLK0         21              1
    67      WR_DIS.ADC1_INIT_CODE_ATTEN1            EFUSE_BLK0         21              1
    68      WR_DIS.ADC1_INIT_CODE_ATTEN2            EFUSE_BLK0         21              1
    69      WR_DIS.ADC1_INIT_CODE_ATTEN3            EFUSE_BLK0         21              1
    70      WR_DIS.ADC1_CAL_VOL_ATTEN0              EFUSE_BLK0         21              1
    71      WR_D"
"IS.ADC1_CAL_VOL_ATTEN1              EFUSE_BLK0         21              1
    72      WR_DIS.ADC1_CAL_VOL_ATTEN2              EFUSE_BLK0         21              1
    73      WR_DIS.ADC1_CAL_VOL_ATTEN3              EFUSE_BLK0         21              1
    74      WR_DIS.BLOCK_USR_DATA                   EFUSE_BLK0         22              1
    75      WR_DIS.CUSTOM_MAC                       EFUSE_BLK0         22              1
    76      WR_DIS.BLOCK_KEY0                       EFUSE_BLK0         "
"23              1
    77      WR_DIS.BLOCK_KEY1                       EFUSE_BLK0         24              1
    78      WR_DIS.BLOCK_KEY2                       EFUSE_BLK0         25              1
    79      WR_DIS.BLOCK_KEY3                       EFUSE_BLK0         26              1
    80      WR_DIS.BLOCK_KEY4                       EFUSE_BLK0         27              1
    81      WR_DIS.BLOCK_KEY5                       EFUSE_BLK0         28              1
    82      WR_DIS.BLOCK_SYS_DATA2   "
"               EFUSE_BLK0         29              1
    83      WR_DIS.USB_EXCHG_PINS                   EFUSE_BLK0         30              1
    84      WR_DIS.VDD_SPI_AS_GPIO                  EFUSE_BLK0         30              1
    85      WR_DIS.SOFT_DIS_JTAG                    EFUSE_BLK0         31              1
    86      RD_DIS                                  EFUSE_BLK0         32              7
    87      RD_DIS.BLOCK_KEY0                       EFUSE_BLK0         32              1
   "
" 88      RD_DIS.BLOCK_KEY1                       EFUSE_BLK0         33              1
    89      RD_DIS.BLOCK_KEY2                       EFUSE_BLK0         34              1
    90      RD_DIS.BLOCK_KEY3                       EFUSE_BLK0         35              1
    91      RD_DIS.BLOCK_KEY4                       EFUSE_BLK0         36              1
    92      RD_DIS.BLOCK_KEY5                       EFUSE_BLK0         37              1
    93      RD_DIS.BLOCK_SYS_DATA2                  EFUSE_"
"BLK0         38              1
    94      DIS_ICACHE                              EFUSE_BLK0         40              1
    95      DIS_USB_JTAG                            EFUSE_BLK0         41              1
    96      DIS_DOWNLOAD_ICACHE                     EFUSE_BLK0         42              1
    97      DIS_USB_SERIAL_JTAG                     EFUSE_BLK0         43              1
    98      DIS_FORCE_DOWNLOAD                      EFUSE_BLK0         44              1
    99      DIS_TWAI    "
"                            EFUSE_BLK0         46              1
    100     JTAG_SEL_ENABLE                         EFUSE_BLK0         47              1
    101     SOFT_DIS_JTAG                           EFUSE_BLK0         48              3
    102     DIS_PAD_JTAG                            EFUSE_BLK0         51              1
    103     DIS_DOWNLOAD_MANUAL_ENCRYPT             EFUSE_BLK0         52              1
    104     USB_EXCHG_PINS                          EFUSE_BLK0         57      "
"        1
    105     VDD_SPI_AS_GPIO                         EFUSE_BLK0         58              1
    106     WDT_DELAY_SEL                           EFUSE_BLK0         80              2
    107     SPI_BOOT_CRYPT_CNT                      EFUSE_BLK0         82              3
    108     SECURE_BOOT_KEY_REVOKE0                 EFUSE_BLK0         85              1
    109     SECURE_BOOT_KEY_REVOKE1                 EFUSE_BLK0         86              1
    110     SECURE_BOOT_KEY_REVOKE2          "
"       EFUSE_BLK0         87              1
    111     KEY_PURPOSE_0                           EFUSE_BLK0         88              4
    112     KEY_PURPOSE_1                           EFUSE_BLK0         92              4
    113     KEY_PURPOSE_2                           EFUSE_BLK0         96              4
    114     KEY_PURPOSE_3                           EFUSE_BLK0        100              4
    115     KEY_PURPOSE_4                           EFUSE_BLK0        104              4
    116    "
" KEY_PURPOSE_5                           EFUSE_BLK0        108              4
    117     SECURE_BOOT_EN                          EFUSE_BLK0        116              1
    118     SECURE_BOOT_AGGRESSIVE_REVOKE           EFUSE_BLK0        117              1
    119     FLASH_TPUW                              EFUSE_BLK0        124              4
    120     DIS_DOWNLOAD_MODE                       EFUSE_BLK0        128              1
    121     DIS_DIRECT_BOOT                         EFUSE_BLK0    "
"    129              1
    122     DIS_USB_SERIAL_JTAG_ROM_PRINT           EFUSE_BLK0        130              1
    123     DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE       EFUSE_BLK0        132              1
    124     ENABLE_SECURITY_DOWNLOAD                EFUSE_BLK0        133              1
    125     UART_PRINT_CONTROL                      EFUSE_BLK0        134              2
    126     FORCE_SEND_RESUME                       EFUSE_BLK0        141              1
    127     SECURE_VERSION      "
"                    EFUSE_BLK0        142              16
    128     ERR_RST_ENABLE                          EFUSE_BLK0        159              1
    129     DISABLE_WAFER_VERSION_MAJOR             EFUSE_BLK0        160              1
    130     DISABLE_BLK_VERSION_MAJOR               EFUSE_BLK0        161              1
    131     MAC                                     EFUSE_BLK1         0               8
    132     MAC                                     EFUSE_BLK1         8              "
" 8
    133     MAC                                     EFUSE_BLK1         16              8
    134     MAC                                     EFUSE_BLK1         24              8
    135     MAC                                     EFUSE_BLK1         32              8
    136     MAC                                     EFUSE_BLK1         40              8
    137     SPI_PAD_CONFIG_CLK                      EFUSE_BLK1         48              6
    138     SPI_PAD_CONFIG_Q                        "
"EFUSE_BLK1         54              6
    139     SPI_PAD_CONFIG_D                        EFUSE_BLK1         60              6
    140     SPI_PAD_CONFIG_CS                       EFUSE_BLK1         66              6
    141     SPI_PAD_CONFIG_HD                       EFUSE_BLK1         72              6
    142     SPI_PAD_CONFIG_WP                       EFUSE_BLK1         78              6
    143     SPI_PAD_CONFIG_DQS                      EFUSE_BLK1         84              6
    144     SPI_PA"
"D_CONFIG_D4                       EFUSE_BLK1         90              6
    145     SPI_PAD_CONFIG_D5                       EFUSE_BLK1         96              6
    146     SPI_PAD_CONFIG_D6                       EFUSE_BLK1        102              6
    147     SPI_PAD_CONFIG_D7                       EFUSE_BLK1        108              6
    148     WAFER_VERSION_MINOR_LO                  EFUSE_BLK1        114              3
    149     PKG_VERSION                             EFUSE_BLK1        117"
"              3
    150     BLK_VERSION_MINOR                       EFUSE_BLK1        120              3
    151     K_RTC_LDO                               EFUSE_BLK1        135              7
    152     K_DIG_LDO                               EFUSE_BLK1        142              7
    153     V_RTC_DBIAS20                           EFUSE_BLK1        149              8
    154     V_DIG_DBIAS20                           EFUSE_BLK1        157              8
    155     DIG_DBIAS_HVT              "
"             EFUSE_BLK1        165              5
    156     THRES_HVT                               EFUSE_BLK1        170              10
    157     WAFER_VERSION_MINOR_HI                  EFUSE_BLK1        183              1
    158     WAFER_VERSION_MAJOR                     EFUSE_BLK1        184              2
    159     SYS_DATA_PART2                          EFUSE_BLK10        0              256
    160     OPTIONAL_UNIQUE_ID                      EFUSE_BLK2         0              128
  "
"  161     BLK_VERSION_MAJOR                       EFUSE_BLK2        128              2
    162     TEMP_CALIB                              EFUSE_BLK2        131              9
    163     OCODE                                   EFUSE_BLK2        140              8
    164     ADC1_INIT_CODE_ATTEN0                   EFUSE_BLK2        148              10
    165     ADC1_INIT_CODE_ATTEN1                   EFUSE_BLK2        158              10
    166     ADC1_INIT_CODE_ATTEN2                   EFU"
"SE_BLK2        168              10
    167     ADC1_INIT_CODE_ATTEN3                   EFUSE_BLK2        178              10
    168     ADC1_CAL_VOL_ATTEN0                     EFUSE_BLK2        188              10
    169     ADC1_CAL_VOL_ATTEN1                     EFUSE_BLK2        198              10
    170     ADC1_CAL_VOL_ATTEN2                     EFUSE_BLK2        208              10
    171     ADC1_CAL_VOL_ATTEN3                     EFUSE_BLK2        218              10
    172     USE"
"R_DATA                               EFUSE_BLK3         0              256
    173     USER_DATA.MAC_CUSTOM                    EFUSE_BLK3        200              48
    174     KEY0                                    EFUSE_BLK4         0              256
    175     KEY1                                    EFUSE_BLK5         0              256
    176     KEY2                                    EFUSE_BLK6         0              256
    177     KEY3                                    EFUSE_BLK7   "
"      0              256
    178     KEY4                                    EFUSE_BLK8         0              256
    179     KEY5                                    EFUSE_BLK9         0              256

    Used bits in efuse table:
    EFUSE_BLK0
    [0 31] [0 0] [2 2] ... [40 44] [46 52] [57 58] [80 111] [116 117] [124 130] [132 135] [141 157] [159 161]
    EFUSE_BLK1
    [0 122] [135 179] [183 185]
    EFUSE_BLK10
    [0 255]
    EFUSE_BLK2
    [0 129] [131 227]
    EFUSE_BLK3
    [0 255] "
"[200 247]
    EFUSE_BLK4
    [0 255]
    EFUSE_BLK5
    [0 255]
    EFUSE_BLK6
    [0 255]
    EFUSE_BLK7
    [0 255]
    EFUSE_BLK8
    [0 255]
    EFUSE_BLK9
    [0 255]
    Note: Not printed ranges are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
"
"
.. code-block:: none

    $ ./efuse_table_gen.py {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Parsing efuse CSV input file $IDF_PATH/components/efuse/esp32c2/esp_efuse_table.csv ...
    Verifying efuse table...
    Max number of bits in BLK 256
    Sorted efuse table:
    #       field_name                              efuse_block     bit_start       bit_count
    1       WR_DIS                                  EFUSE_BLK0         0               8
    2       WR_DIS.RD_DIS            "
"               EFUSE_BLK0         0               1
    3       WR_DIS.WDT_DELAY_SEL                    EFUSE_BLK0         1               1
    4       WR_DIS.DIS_PAD_JTAG                     EFUSE_BLK0         1               1
    5       WR_DIS.DIS_DOWNLOAD_ICACHE              EFUSE_BLK0         1               1
    6       WR_DIS.DIS_DOWNLOAD_MANUAL_ENCRYPT      EFUSE_BLK0         2               1
    7       WR_DIS.SPI_BOOT_CRYPT_CNT               EFUSE_BLK0         2               1
   "
" 8       WR_DIS.XTS_KEY_LENGTH_256               EFUSE_BLK0         2               1
    9       WR_DIS.SECURE_BOOT_EN                   EFUSE_BLK0         2               1
    10      WR_DIS.UART_PRINT_CONTROL               EFUSE_BLK0         3               1
    11      WR_DIS.FORCE_SEND_RESUME                EFUSE_BLK0         3               1
    12      WR_DIS.DIS_DOWNLOAD_MODE                EFUSE_BLK0         3               1
    13      WR_DIS.DIS_DIRECT_BOOT                  EFUSE_"
"BLK0         3               1
    14      WR_DIS.ENABLE_SECURITY_DOWNLOAD         EFUSE_BLK0         3               1
    15      WR_DIS.FLASH_TPUW                       EFUSE_BLK0         3               1
    16      WR_DIS.SECURE_VERSION                   EFUSE_BLK0         4               1
    17      WR_DIS.CUSTOM_MAC_USED                  EFUSE_BLK0         4               1
    18      WR_DIS.DISABLE_WAFER_VERSION_MAJOR      EFUSE_BLK0         4               1
    19      WR_DIS.DISAB"
"LE_BLK_VERSION_MAJOR        EFUSE_BLK0         4               1
    20      WR_DIS.CUSTOM_MAC                       EFUSE_BLK0         5               1
    21      WR_DIS.MAC                              EFUSE_BLK0         6               1
    22      WR_DIS.WAFER_VERSION_MINOR              EFUSE_BLK0         6               1
    23      WR_DIS.WAFER_VERSION_MAJOR              EFUSE_BLK0         6               1
    24      WR_DIS.PKG_VERSION                      EFUSE_BLK0         6       "
"        1
    25      WR_DIS.BLK_VERSION_MINOR                EFUSE_BLK0         6               1
    26      WR_DIS.BLK_VERSION_MAJOR                EFUSE_BLK0         6               1
    27      WR_DIS.OCODE                            EFUSE_BLK0         6               1
    28      WR_DIS.TEMP_CALIB                       EFUSE_BLK0         6               1
    29      WR_DIS.ADC1_INIT_CODE_ATTEN0            EFUSE_BLK0         6               1
    30      WR_DIS.ADC1_INIT_CODE_ATTEN3     "
"       EFUSE_BLK0         6               1
    31      WR_DIS.ADC1_CAL_VOL_ATTEN0              EFUSE_BLK0         6               1
    32      WR_DIS.ADC1_CAL_VOL_ATTEN3              EFUSE_BLK0         6               1
    33      WR_DIS.DIG_DBIAS_HVT                    EFUSE_BLK0         6               1
    34      WR_DIS.DIG_LDO_SLP_DBIAS2               EFUSE_BLK0         6               1
    35      WR_DIS.DIG_LDO_SLP_DBIAS26              EFUSE_BLK0         6               1
    36     "
" WR_DIS.DIG_LDO_ACT_DBIAS26              EFUSE_BLK0         6               1
    37      WR_DIS.DIG_LDO_ACT_STEPD10              EFUSE_BLK0         6               1
    38      WR_DIS.RTC_LDO_SLP_DBIAS13              EFUSE_BLK0         6               1
    39      WR_DIS.RTC_LDO_SLP_DBIAS29              EFUSE_BLK0         6               1
    40      WR_DIS.RTC_LDO_SLP_DBIAS31              EFUSE_BLK0         6               1
    41      WR_DIS.RTC_LDO_ACT_DBIAS31              EFUSE_BLK0    "
"     6               1
    42      WR_DIS.RTC_LDO_ACT_DBIAS13              EFUSE_BLK0         6               1
    43      WR_DIS.ADC_CALIBRATION_3                EFUSE_BLK0         6               1
    44      WR_DIS.BLOCK_KEY0                       EFUSE_BLK0         7               1
    45      RD_DIS                                  EFUSE_BLK0         32              2
    46      RD_DIS.KEY0                             EFUSE_BLK0         32              2
    47      RD_DIS.KEY0.LOW     "
"                    EFUSE_BLK0         32              1
    48      RD_DIS.KEY0.HI                          EFUSE_BLK0         33              1
    49      WDT_DELAY_SEL                           EFUSE_BLK0         34              2
    50      DIS_PAD_JTAG                            EFUSE_BLK0         36              1
    51      DIS_DOWNLOAD_ICACHE                     EFUSE_BLK0         37              1
    52      DIS_DOWNLOAD_MANUAL_ENCRYPT             EFUSE_BLK0         38              "
"1
    53      SPI_BOOT_CRYPT_CNT                      EFUSE_BLK0         39              3
    54      XTS_KEY_LENGTH_256                      EFUSE_BLK0         42              1
    55      UART_PRINT_CONTROL                      EFUSE_BLK0         43              2
    56      FORCE_SEND_RESUME                       EFUSE_BLK0         45              1
    57      DIS_DOWNLOAD_MODE                       EFUSE_BLK0         46              1
    58      DIS_DIRECT_BOOT                         E"
"FUSE_BLK0         47              1
    59      ENABLE_SECURITY_DOWNLOAD                EFUSE_BLK0         48              1
    60      FLASH_TPUW                              EFUSE_BLK0         49              4
    61      SECURE_BOOT_EN                          EFUSE_BLK0         53              1
    62      SECURE_VERSION                          EFUSE_BLK0         54              4
    63      CUSTOM_MAC_USED                         EFUSE_BLK0         58              1
    64      DISABLE"
"_WAFER_VERSION_MAJOR             EFUSE_BLK0         59              1
    65      DISABLE_BLK_VERSION_MAJOR               EFUSE_BLK0         60              1
    66      USER_DATA                               EFUSE_BLK1         0               88
    67      USER_DATA.MAC_CUSTOM                    EFUSE_BLK1         0               48
    68      MAC                                     EFUSE_BLK2         0               8
    69      MAC                                     EFUSE_BLK2         8"
"               8
    70      MAC                                     EFUSE_BLK2         16              8
    71      MAC                                     EFUSE_BLK2         24              8
    72      MAC                                     EFUSE_BLK2         32              8
    73      MAC                                     EFUSE_BLK2         40              8
    74      WAFER_VERSION_MINOR                     EFUSE_BLK2         48              4
    75      WAFER_VERSION_MAJOR       "
"              EFUSE_BLK2         52              2
    76      PKG_VERSION                             EFUSE_BLK2         54              3
    77      BLK_VERSION_MINOR                       EFUSE_BLK2         57              3
    78      BLK_VERSION_MAJOR                       EFUSE_BLK2         60              2
    79      OCODE                                   EFUSE_BLK2         62              7
    80      TEMP_CALIB                              EFUSE_BLK2         69              9
    "
"81      ADC1_INIT_CODE_ATTEN0                   EFUSE_BLK2         78              8
    82      ADC1_INIT_CODE_ATTEN3                   EFUSE_BLK2         86              5
    83      ADC1_CAL_VOL_ATTEN0                     EFUSE_BLK2         91              8
    84      ADC1_CAL_VOL_ATTEN3                     EFUSE_BLK2         99              6
    85      DIG_DBIAS_HVT                           EFUSE_BLK2        105              5
    86      DIG_LDO_SLP_DBIAS2                      EFUSE_B"
"LK2        110              7
    87      DIG_LDO_SLP_DBIAS26                     EFUSE_BLK2        117              8
    88      DIG_LDO_ACT_DBIAS26                     EFUSE_BLK2        125              6
    89      DIG_LDO_ACT_STEPD10                     EFUSE_BLK2        131              4
    90      RTC_LDO_SLP_DBIAS13                     EFUSE_BLK2        135              7
    91      RTC_LDO_SLP_DBIAS29                     EFUSE_BLK2        142              9
    92      RTC_LDO_SLP_D"
"BIAS31                     EFUSE_BLK2        151              6
    93      RTC_LDO_ACT_DBIAS31                     EFUSE_BLK2        157              6
    94      RTC_LDO_ACT_DBIAS13                     EFUSE_BLK2        163              8
    95      ADC_CALIBRATION_3                       EFUSE_BLK2        192              11
    96      KEY0                                    EFUSE_BLK3         0              256
    97      KEY0.FE_256BIT                          EFUSE_BLK3         0      "
"        256
    98      KEY0.FE_128BIT                          EFUSE_BLK3         0              128
    99      KEY0.SB_128BIT                          EFUSE_BLK3        128             128

    Used bits in efuse table:
    EFUSE_BLK0
    [0 7] [0 1] [1 1] [1 2] [2 2] ... [6 6] [6 6] [6 6] [6 6] [6 6] [6 6] [6 6] [6 6] [6 6] [6 7] [32 33] [32 33] [32 60]
    EFUSE_BLK1
    [0 87] [0 47]
    EFUSE_BLK2
    [0 170] [192 202]
    EFUSE_BLK3
    [0 255] [0 255] [0 255]
    Note: Not printed range"
"s are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
"
"
.. code-block:: none

    $ ./efuse_table_gen.py -t IDF_TARGET_PATH_NAME {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Max number of bits in BLK 256
    Parsing efuse CSV input file esp32c6/esp_efuse_table.csv ...
    Verifying efuse table...
    Sorted efuse table:
    #       field_name                              efuse_block     bit_start       bit_count
    1       WR_DIS                                  EFUSE_BLK0         0               32
    2       WR_DIS.RD_DIS              "
"             EFUSE_BLK0         0               1
    3       WR_DIS.DIS_ICACHE                       EFUSE_BLK0         2               1
    4       WR_DIS.DIS_USB_JTAG                     EFUSE_BLK0         2               1
    5       WR_DIS.POWERGLITCH_EN                   EFUSE_BLK0         2               1
    6       WR_DIS.DIS_FORCE_DOWNLOAD               EFUSE_BLK0         2               1
    7       WR_DIS.SPI_DOWNLOAD_MSPI_DIS            EFUSE_BLK0         2               1
    8"
"       WR_DIS.DIS_TWAI                         EFUSE_BLK0         2               1
    9       WR_DIS.JTAG_SEL_ENABLE                  EFUSE_BLK0         2               1
    10      WR_DIS.DIS_PAD_JTAG                     EFUSE_BLK0         2               1
    11      WR_DIS.DIS_DOWNLOAD_MANUAL_ENCRYPT      EFUSE_BLK0         2               1
    12      WR_DIS.WDT_DELAY_SEL                    EFUSE_BLK0         3               1
    13      WR_DIS.SPI_BOOT_CRYPT_CNT               EFUSE_BL"
"K0         4               1
    14      WR_DIS.SECURE_BOOT_KEY_REVOKE0          EFUSE_BLK0         5               1
    15      WR_DIS.SECURE_BOOT_KEY_REVOKE1          EFUSE_BLK0         6               1
    16      WR_DIS.SECURE_BOOT_KEY_REVOKE2          EFUSE_BLK0         7               1
    17      WR_DIS.KEY_PURPOSE_0                    EFUSE_BLK0         8               1
    18      WR_DIS.KEY_PURPOSE_1                    EFUSE_BLK0         9               1
    19      WR_DIS.KEY_PUR"
"POSE_2                    EFUSE_BLK0         10              1
    20      WR_DIS.KEY_PURPOSE_3                    EFUSE_BLK0         11              1
    21      WR_DIS.KEY_PURPOSE_4                    EFUSE_BLK0         12              1
    22      WR_DIS.KEY_PURPOSE_5                    EFUSE_BLK0         13              1
    23      WR_DIS.SEC_DPA_LEVEL                    EFUSE_BLK0         14              1
    24      WR_DIS.CRYPT_DPA_ENABLE                 EFUSE_BLK0         14        "
"      1
    25      WR_DIS.SECURE_BOOT_EN                   EFUSE_BLK0         15              1
    26      WR_DIS.SECURE_BOOT_AGGRESSIVE_REVOKE    EFUSE_BLK0         16              1
    27      WR_DIS.ECDSA_FORCE_USE_HARDWARE_K       EFUSE_BLK0         17              1
    28      WR_DIS.FLASH_TPUW                       EFUSE_BLK0         18              1
    29      WR_DIS.DIS_DOWNLOAD_MODE                EFUSE_BLK0         18              1
    30      WR_DIS.DIS_DIRECT_BOOT             "
"     EFUSE_BLK0         18              1
    31      WR_DIS.DIS_USB_SERIAL_JTAG_ROM_PRINT    EFUSE_BLK0         18              1
    32      WR_DIS.DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE EFUSE_BLK0        18              1
    33      WR_DIS.ENABLE_SECURITY_DOWNLOAD         EFUSE_BLK0         18              1
    34      WR_DIS.UART_PRINT_CONTROL               EFUSE_BLK0         18              1
    35      WR_DIS.FORCE_SEND_RESUME                EFUSE_BLK0         18              1
    36      W"
"R_DIS.SECURE_VERSION                   EFUSE_BLK0         18              1
    37      WR_DIS.SECURE_BOOT_DISABLE_FAST_WAKE    EFUSE_BLK0         18              1
    38      WR_DIS.HYS_EN_PAD0                      EFUSE_BLK0         19              1
    39      WR_DIS.HYS_EN_PAD1                      EFUSE_BLK0         19              1
    40      WR_DIS.BLK1                             EFUSE_BLK0         20              1
    41      WR_DIS.MAC                              EFUSE_BLK0      "
"   20              1
    42      WR_DIS.MAC_EXT                          EFUSE_BLK0         20              1
    43      WR_DIS.WAFER_VERSION_MINOR              EFUSE_BLK0         20              1
    44      WR_DIS.WAFER_VERSION_MAJOR              EFUSE_BLK0         20              1
    45      WR_DIS.DISABLE_WAFER_VERSION_MAJOR      EFUSE_BLK0         20              1
    46      WR_DIS.FLASH_CAP                        EFUSE_BLK0         20              1
    47      WR_DIS.FLASH_TEMP     "
"                  EFUSE_BLK0         20              1
    48      WR_DIS.FLASH_VENDOR                     EFUSE_BLK0         20              1
    49      WR_DIS.PKG_VERSION                      EFUSE_BLK0         20              1
    50      WR_DIS.SYS_DATA_PART1                   EFUSE_BLK0         21              1
    51      WR_DIS.OPTIONAL_UNIQUE_ID               EFUSE_BLK0         21              1
    52      WR_DIS.BLK_VERSION_MINOR                EFUSE_BLK0         21              1
"
"    53      WR_DIS.BLK_VERSION_MAJOR                EFUSE_BLK0         21              1
    54      WR_DIS.DISABLE_BLK_VERSION_MAJOR        EFUSE_BLK0         21              1
    55      WR_DIS.BLOCK_USR_DATA                   EFUSE_BLK0         22              1
    56      WR_DIS.CUSTOM_MAC                       EFUSE_BLK0         22              1
    57      WR_DIS.BLOCK_KEY0                       EFUSE_BLK0         23              1
    58      WR_DIS.BLOCK_KEY1                       EFU"
"SE_BLK0         24              1
    59      WR_DIS.BLOCK_KEY2                       EFUSE_BLK0         25              1
    60      WR_DIS.BLOCK_KEY3                       EFUSE_BLK0         26              1
    61      WR_DIS.BLOCK_KEY4                       EFUSE_BLK0         27              1
    62      WR_DIS.BLOCK_KEY5                       EFUSE_BLK0         28              1
    63      WR_DIS.BLOCK_SYS_DATA2                  EFUSE_BLK0         29              1
    64      WR_DIS.US"
"B_EXCHG_PINS                   EFUSE_BLK0         30              1
    65      WR_DIS.VDD_SPI_AS_GPIO                  EFUSE_BLK0         30              1
    66      WR_DIS.SOFT_DIS_JTAG                    EFUSE_BLK0         31              1
    67      RD_DIS                                  EFUSE_BLK0         32              7
    68      RD_DIS.BLOCK_KEY0                       EFUSE_BLK0         32              1
    69      RD_DIS.BLOCK_KEY1                       EFUSE_BLK0         33   "
"           1
    70      RD_DIS.BLOCK_KEY2                       EFUSE_BLK0         34              1
    71      RD_DIS.BLOCK_KEY3                       EFUSE_BLK0         35              1
    72      RD_DIS.BLOCK_KEY4                       EFUSE_BLK0         36              1
    73      RD_DIS.BLOCK_KEY5                       EFUSE_BLK0         37              1
    74      RD_DIS.BLOCK_SYS_DATA2                  EFUSE_BLK0         38              1
    75      DIS_ICACHE                    "
"          EFUSE_BLK0         40              1
    76      DIS_USB_JTAG                            EFUSE_BLK0         41              1
    77      POWERGLITCH_EN                          EFUSE_BLK0         42              1
    78      DIS_FORCE_DOWNLOAD                      EFUSE_BLK0         44              1
    79      SPI_DOWNLOAD_MSPI_DIS                   EFUSE_BLK0         45              1
    80      DIS_TWAI                                EFUSE_BLK0         46              1
    81  "
"    JTAG_SEL_ENABLE                         EFUSE_BLK0         47              1
    82      SOFT_DIS_JTAG                           EFUSE_BLK0         48              3
    83      DIS_PAD_JTAG                            EFUSE_BLK0         51              1
    84      DIS_DOWNLOAD_MANUAL_ENCRYPT             EFUSE_BLK0         52              1
    85      USB_EXCHG_PINS                          EFUSE_BLK0         57              1
    86      VDD_SPI_AS_GPIO                         EFUSE_BLK0 "
"        58              1
    87      WDT_DELAY_SEL                           EFUSE_BLK0         80              2
    88      SPI_BOOT_CRYPT_CNT                      EFUSE_BLK0         82              3
    89      SECURE_BOOT_KEY_REVOKE0                 EFUSE_BLK0         85              1
    90      SECURE_BOOT_KEY_REVOKE1                 EFUSE_BLK0         86              1
    91      SECURE_BOOT_KEY_REVOKE2                 EFUSE_BLK0         87              1
    92      KEY_PURPOSE_0    "
"                       EFUSE_BLK0         88              4
    93      KEY_PURPOSE_1                           EFUSE_BLK0         92              4
    94      KEY_PURPOSE_2                           EFUSE_BLK0         96              4
    95      KEY_PURPOSE_3                           EFUSE_BLK0        100              4
    96      KEY_PURPOSE_4                           EFUSE_BLK0        104              4
    97      KEY_PURPOSE_5                           EFUSE_BLK0        108           "
"   4
    98      SEC_DPA_LEVEL                           EFUSE_BLK0        112              2
    99      ECDSA_FORCE_USE_HARDWARE_K              EFUSE_BLK0        114              1
    100     CRYPT_DPA_ENABLE                        EFUSE_BLK0        115              1
    101     SECURE_BOOT_EN                          EFUSE_BLK0        116              1
    102     SECURE_BOOT_AGGRESSIVE_REVOKE           EFUSE_BLK0        117              1
    103     FLASH_TPUW                            "
"  EFUSE_BLK0        124              4
    104     DIS_DOWNLOAD_MODE                       EFUSE_BLK0        128              1
    105     DIS_DIRECT_BOOT                         EFUSE_BLK0        129              1
    106     DIS_USB_SERIAL_JTAG_ROM_PRINT           EFUSE_BLK0        130              1
    107     DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE       EFUSE_BLK0        132              1
    108     ENABLE_SECURITY_DOWNLOAD                EFUSE_BLK0        133              1
    109     UART"
"_PRINT_CONTROL                      EFUSE_BLK0        134              2
    110     FORCE_SEND_RESUME                       EFUSE_BLK0        136              1
    111     SECURE_VERSION                          EFUSE_BLK0        137              16
    112     SECURE_BOOT_DISABLE_FAST_WAKE           EFUSE_BLK0        153              1
    113     HYS_EN_PAD0                             EFUSE_BLK0        154              6
    114     HYS_EN_PAD1                             EFUSE_BLK0        "
"160              22
    115     MAC                                     EFUSE_BLK1         0               8
    116     MAC                                     EFUSE_BLK1         8               8
    117     MAC                                     EFUSE_BLK1         16              8
    118     MAC                                     EFUSE_BLK1         24              8
    119     MAC                                     EFUSE_BLK1         32              8
    120     MAC                    "
"                 EFUSE_BLK1         40              8
    121     MAC_EXT                                 EFUSE_BLK1         48              16
    122     WAFER_VERSION_MINOR                     EFUSE_BLK1        114              3
    123     WAFER_VERSION_MAJOR                     EFUSE_BLK1        117              2
    124     DISABLE_WAFER_VERSION_MAJOR             EFUSE_BLK1        119              1
    125     FLASH_CAP                               EFUSE_BLK1        120              3
"
"    126     FLASH_TEMP                              EFUSE_BLK1        123              2
    127     FLASH_VENDOR                            EFUSE_BLK1        125              3
    128     PKG_VERSION                             EFUSE_BLK1        128              3
    129     SYS_DATA_PART2                          EFUSE_BLK10        0              256
    130     OPTIONAL_UNIQUE_ID                      EFUSE_BLK2         0              128
    131     BLK_VERSION_MINOR                       E"
"FUSE_BLK2        130              3
    132     BLK_VERSION_MAJOR                       EFUSE_BLK2        133              2
    133     DISABLE_BLK_VERSION_MAJOR               EFUSE_BLK2        135              1
    134     USER_DATA                               EFUSE_BLK3         0              256
    135     USER_DATA.MAC_CUSTOM                    EFUSE_BLK3        200              48
    136     KEY0                                    EFUSE_BLK4         0              256
    137     KEY1"
"                                    EFUSE_BLK5         0              256
    138     KEY2                                    EFUSE_BLK6         0              256
    139     KEY3                                    EFUSE_BLK7         0              256
    140     KEY4                                    EFUSE_BLK8         0              256
    141     KEY5                                    EFUSE_BLK9         0              256

    Used bits in efuse table:
    EFUSE_BLK0
    [0 31] [0 0] [2 "
"2] ... [21 22] [22 30] [30 38] [32 38] [40 42] [44 52] [57 58] [80 117] [124 130] [132 181]
    EFUSE_BLK1
    [0 63] [114 130]
    EFUSE_BLK10
    [0 255]
    EFUSE_BLK2
    [0 127] [130 135]
    EFUSE_BLK3
    [0 255] [200 247]
    EFUSE_BLK4
    [0 255]
    EFUSE_BLK5
    [0 255]
    EFUSE_BLK6
    [0 255]
    EFUSE_BLK7
    [0 255]
    EFUSE_BLK8
    [0 255]
    EFUSE_BLK9
    [0 255]
    Note: Not printed ranges are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)

"
"
.. code-block:: none

    $ ./efuse_table_gen.py -t IDF_TARGET_PATH_NAME {IDF_TARGET_PATH_NAME}/esp_efuse_table.csv --info

    Max number of bits in BLK 256
    Parsing efuse CSV input file ../esp32p4/esp_efuse_table.csv ...
    Verifying efuse table...
    Sorted efuse table:
    #       field_name                      efuse_block     bit_start       bit_count
    1       WR_DIS                          EFUSE_BLK0         0               32
    2       WR_DIS.RD_DIS                   EFUSE_BL"
"K0         0               1
    3       WR_DIS.SPI_BOOT_CRYPT_CNT       EFUSE_BLK0         4               1
    4       WR_DIS.SECURE_BOOT_KEY_REVOKE0  EFUSE_BLK0         5               1
    5       WR_DIS.SECURE_BOOT_KEY_REVOKE1  EFUSE_BLK0         6               1
    6       WR_DIS.SECURE_BOOT_KEY_REVOKE2  EFUSE_BLK0         7               1
    7       WR_DIS.KEY_PURPOSE_0            EFUSE_BLK0         8               1
    8       WR_DIS.KEY_PURPOSE_1            EFUSE_BLK0         9  "
"             1
    9       WR_DIS.KEY_PURPOSE_2            EFUSE_BLK0         10              1
    10      WR_DIS.KEY_PURPOSE_3            EFUSE_BLK0         11              1
    11      WR_DIS.KEY_PURPOSE_4            EFUSE_BLK0         12              1
    12      WR_DIS.KEY_PURPOSE_5            EFUSE_BLK0         13              1
    13      WR_DIS.SECURE_BOOT_EN           EFUSE_BLK0         15              1
    14      WR_DIS.BLK1                     EFUSE_BLK0         20              1"
"
    15      WR_DIS.MAC                      EFUSE_BLK0         20              1
    16      WR_DIS.WAFER_VERSION_MINOR      EFUSE_BLK0         20              1
    17      WR_DIS.WAFER_VERSION_MAJOR      EFUSE_BLK0         20              1
    18      WR_DIS.DISABLE_WAFER_VERSION_MAJOR      EFUSE_BLK0         20              1
    19      WR_DIS.DISABLE_BLK_VERSION_MAJOR        EFUSE_BLK0         20              1
    20      WR_DIS.BLK_VERSION_MINOR        EFUSE_BLK0         20             "
" 1
    21      WR_DIS.BLK_VERSION_MAJOR        EFUSE_BLK0         20              1
    22      WR_DIS.FLASH_CAP                EFUSE_BLK0         20              1
    23      WR_DIS.FLASH_TEMP               EFUSE_BLK0         20              1
    24      WR_DIS.FLASH_VENDOR             EFUSE_BLK0         20              1
    25      WR_DIS.PSRAM_CAP                EFUSE_BLK0         20              1
    26      WR_DIS.PSRAM_TEMP               EFUSE_BLK0         20              1
    27     "
" WR_DIS.PSRAM_VENDOR             EFUSE_BLK0         20              1
    28      WR_DIS.PKG_VERSION              EFUSE_BLK0         20              1
    29      WR_DIS.OPTIONAL_UNIQUE_ID       EFUSE_BLK0         21              1
    30      WR_DIS.BLOCK_USR_DATA           EFUSE_BLK0         22              1
    31      WR_DIS.CUSTOM_MAC               EFUSE_BLK0         22              1
    32      WR_DIS.BLOCK_KEY0               EFUSE_BLK0         23              1
    33      WR_DIS.BLOCK_"
"KEY1               EFUSE_BLK0         24              1
    34      WR_DIS.BLOCK_KEY2               EFUSE_BLK0         25              1
    35      WR_DIS.BLOCK_KEY3               EFUSE_BLK0         26              1
    36      WR_DIS.BLOCK_KEY4               EFUSE_BLK0         27              1
    37      WR_DIS.BLOCK_KEY5               EFUSE_BLK0         28              1
    38      WR_DIS.BLOCK_SYS_DATA2          EFUSE_BLK0         29              1
    39      RD_DIS                     "
"     EFUSE_BLK0         32              7
    40      RD_DIS.BLOCK_KEY0               EFUSE_BLK0         32              1
    41      RD_DIS.BLOCK_KEY1               EFUSE_BLK0         33              1
    42      RD_DIS.BLOCK_KEY2               EFUSE_BLK0         34              1
    43      RD_DIS.BLOCK_KEY3               EFUSE_BLK0         35              1
    44      RD_DIS.BLOCK_KEY4               EFUSE_BLK0         36              1
    45      RD_DIS.BLOCK_KEY5               EFUSE_BLK"
"0         37              1
    46      RD_DIS.BLOCK_SYS_DATA2          EFUSE_BLK0         38              1
    47      USB_DEVICE_EXCHG_PINS           EFUSE_BLK0         39              1
    48      USB_OTG11_EXCHG_PINS            EFUSE_BLK0         40              1
    49      DIS_USB_JTAG                    EFUSE_BLK0         41              1
    50      POWERGLITCH_EN                  EFUSE_BLK0         42              1
    51      DIS_FORCE_DOWNLOAD              EFUSE_BLK0         44  "
"            1
    52      SPI_DOWNLOAD_MSPI_DIS           EFUSE_BLK0         45              1
    53      DIS_TWAI                        EFUSE_BLK0         46              1
    54      JTAG_SEL_ENABLE                 EFUSE_BLK0         47              1
    55      SOFT_DIS_JTAG                   EFUSE_BLK0         48              3
    56      DIS_PAD_JTAG                    EFUSE_BLK0         51              1
    57      DIS_DOWNLOAD_MANUAL_ENCRYPT     EFUSE_BLK0         52              1
"
"    58      USB_PHY_SEL                     EFUSE_BLK0         57              1
    59      KM_HUK_GEN_STATE                EFUSE_BLK0         58              9
    60      KM_RND_SWITCH_CYCLE             EFUSE_BLK0         67              2
    61      KM_DEPLOY_ONLY_ONCE             EFUSE_BLK0         69              4
    62      FORCE_USE_KEY_MANAGER_KEY       EFUSE_BLK0         73              4
    63      FORCE_DISABLE_SW_INIT_KEY       EFUSE_BLK0         77              1
    64      XT"
"S_KEY_LENGTH_256              EFUSE_BLK0         78              1
    65      WDT_DELAY_SEL                   EFUSE_BLK0         80              2
    66      SPI_BOOT_CRYPT_CNT              EFUSE_BLK0         82              3
    67      SECURE_BOOT_KEY_REVOKE0         EFUSE_BLK0         85              1
    68      SECURE_BOOT_KEY_REVOKE1         EFUSE_BLK0         86              1
    69      SECURE_BOOT_KEY_REVOKE2         EFUSE_BLK0         87              1
    70      KEY_PURPOSE_0   "
"                EFUSE_BLK0         88              4
    71      KEY_PURPOSE_1                   EFUSE_BLK0         92              4
    72      KEY_PURPOSE_2                   EFUSE_BLK0         96              4
    73      KEY_PURPOSE_3                   EFUSE_BLK0        100              4
    74      KEY_PURPOSE_4                   EFUSE_BLK0        104              4
    75      KEY_PURPOSE_5                   EFUSE_BLK0        108              4
    76      SEC_DPA_LEVEL                 "
"  EFUSE_BLK0        112              2
    77      ECDSA_ENABLE_SOFT_K             EFUSE_BLK0        114              1
    78      CRYPT_DPA_ENABLE                EFUSE_BLK0        115              1
    79      SECURE_BOOT_EN                  EFUSE_BLK0        116              1
    80      SECURE_BOOT_AGGRESSIVE_REVOKE   EFUSE_BLK0        117              1
    81      FLASH_TYPE                      EFUSE_BLK0        119              1
    82      FLASH_PAGE_SIZE                 EFUSE_BLK0  "
"      120              2
    83      FLASH_ECC_EN                    EFUSE_BLK0        122              1
    84      DIS_USB_OTG_DOWNLOAD_MODE       EFUSE_BLK0        123              1
    85      FLASH_TPUW                      EFUSE_BLK0        124              4
    86      DIS_DOWNLOAD_MODE               EFUSE_BLK0        128              1
    87      DIS_DIRECT_BOOT                 EFUSE_BLK0        129              1
    88      DIS_USB_SERIAL_JTAG_ROM_PRINT   EFUSE_BLK0        130     "
"         1
    89      LOCK_KM_KEY                     EFUSE_BLK0        131              1
    90      DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE       EFUSE_BLK0        132              1
    91      ENABLE_SECURITY_DOWNLOAD        EFUSE_BLK0        133              1
    92      UART_PRINT_CONTROL              EFUSE_BLK0        134              2
    93      FORCE_SEND_RESUME               EFUSE_BLK0        136              1
    94      SECURE_VERSION                  EFUSE_BLK0        137           "
"   16
    95      SECURE_BOOT_DISABLE_FAST_WAKE   EFUSE_BLK0        153              1
    96      HYS_EN_PAD                      EFUSE_BLK0        154              1
    97      DCDC_VSET                       EFUSE_BLK0        155              5
    98      PXA0_TIEH_SEL_0                 EFUSE_BLK0        160              2
    99      PXA0_TIEH_SEL_1                 EFUSE_BLK0        162              2
    100     PXA0_TIEH_SEL_2                 EFUSE_BLK0        164              2
    101 "
"    PXA0_TIEH_SEL_3                 EFUSE_BLK0        166              2
    102     KM_DISABLE_DEPLOY_MODE          EFUSE_BLK0        168              4
    103     HP_PWR_SRC_SEL                  EFUSE_BLK0        178              1
    104     DCDC_VSET_EN                    EFUSE_BLK0        179              1
    105     DIS_WDT                         EFUSE_BLK0        180              1
    106     DIS_SWD                         EFUSE_BLK0        181              1
    107     MAC       "
"                      EFUSE_BLK1         0               8
    108     MAC                             EFUSE_BLK1         8               8
    109     MAC                             EFUSE_BLK1         16              8
    110     MAC                             EFUSE_BLK1         24              8
    111     MAC                             EFUSE_BLK1         32              8
    112     MAC                             EFUSE_BLK1         40              8
    113     WAFER_VERSION_MINOR     "
"        EFUSE_BLK1         64              4
    114     WAFER_VERSION_MAJOR             EFUSE_BLK1         68              2
    115     DISABLE_WAFER_VERSION_MAJOR     EFUSE_BLK1         70              1
    116     DISABLE_BLK_VERSION_MAJOR       EFUSE_BLK1         71              1
    117     BLK_VERSION_MINOR               EFUSE_BLK1         72              3
    118     BLK_VERSION_MAJOR               EFUSE_BLK1         75              2
    119     FLASH_CAP                       EFUSE_"
"BLK1         77              3
    120     FLASH_TEMP                      EFUSE_BLK1         80              2
    121     FLASH_VENDOR                    EFUSE_BLK1         82              3
    122     PSRAM_CAP                       EFUSE_BLK1         85              2
    123     PSRAM_TEMP                      EFUSE_BLK1         87              2
    124     PSRAM_VENDOR                    EFUSE_BLK1         89              2
    125     PKG_VERSION                     EFUSE_BLK1         9"
"1              3
    126     SYS_DATA_PART2                  EFUSE_BLK10        0              256
    127     OPTIONAL_UNIQUE_ID              EFUSE_BLK2         0              128
    128     USER_DATA                       EFUSE_BLK3         0              256
    129     USER_DATA.MAC_CUSTOM            EFUSE_BLK3        200              48
    130     KEY0                            EFUSE_BLK4         0              256
    131     KEY1                            EFUSE_BLK5         0         "
"     256
    132     KEY2                            EFUSE_BLK6         0              256
    133     KEY3                            EFUSE_BLK7         0              256
    134     KEY4                            EFUSE_BLK8         0              256
    135     KEY5                            EFUSE_BLK9         0              256

    Used bits in efuse table:
    EFUSE_BLK0
    [0 31] [0 0] [4 13] [15 15] [20 20] [20 20] [20 29] [32 38] [32 42] [44 52] [57 78] [80 117] [119 171] [178 181]
"
"
    EFUSE_BLK1
    [0 47] [64 93]

    EFUSE_BLK10
    [0 255]

    EFUSE_BLK2
    [0 127]

    EFUSE_BLK3
    [0 255] [200 247]

    EFUSE_BLK4
    [0 255]

    EFUSE_BLK5
    [0 255]

    EFUSE_BLK6
    [0 255]

    EFUSE_BLK7
    [0 255]

    EFUSE_BLK8
    [0 255]

    EFUSE_BLK9
    [0 255]
    Note: Not printed ranges are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-C6

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Config fuses:
    WR_DIS (BLOCK0)                                    Disable programming of individual eFuses           = 0 R/W (0x00000000)
    RD_DIS (BLOCK0)                                    Disable reading from BlOCK4-10     "
"                = 0 R/W (0b0000000)
    SWAP_UART_SDIO_EN (BLOCK0)                         Represents whether pad of uart and sdio is swapped = False R/W (0b0)
                                                        or not. 1: swapped. 0: not swapped
    DIS_ICACHE (BLOCK0)                                Represents whether icache is disabled or enabled.  = False R/W (0b0)
                                                       1: disabled. 0: enabled
    DIS_TWAI (BLOCK0)                         "
"         Represents whether TWAI function is disabled or en = False R/W (0b0)
                                                       abled. 1: disabled. 0: enabled
    DIS_DIRECT_BOOT (BLOCK0)                           Represents whether direct boot mode is disabled or = False R/W (0b0)
                                                        enabled. 1: disabled. 0: enabled
    UART_PRINT_CONTROL (BLOCK0)                        Set the default UARTboot message output mode       = Enable R/W (0b0"
"0)
    BLOCK_USR_DATA (BLOCK3)                            User data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_SYS_DATA2 (BLOCK10)                          System data part 2 (reserved)
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Flash fuses:
    FLASH_TPUW (BLOCK0)                                Represents the flash waiting time after power-up;  = 0 R"
"/W (0x0)
                                                       in unit of ms. When the value less than 15; the wa
                                                       iting time is the programmed value. Otherwise; the
                                                        waiting time is 2 times the programmed value
    FORCE_SEND_RESUME (BLOCK0)                         Represents whether ROM code is forced to send a re = False R/W (0b0)
                                                      "
" sume command during SPI boot. 1: forced. 0:not for
                                                       ced
    FLASH_CAP (BLOCK1)                                                                                    = 0 R/W (0b000)
    FLASH_TEMP (BLOCK1)                                                                                   = 0 R/W (0b00)
    FLASH_VENDOR (BLOCK1)                                                                                 = 0 R/W (0b000)

    Identity fuses:
   "
" DISABLE_WAFER_VERSION_MAJOR (BLOCK0)               Disables check of wafer version major              = False R/W (0b0)
    DISABLE_BLK_VERSION_MAJOR (BLOCK0)                 Disables check of blk version major                = False R/W (0b0)
    WAFER_VERSION_MINOR (BLOCK1)                                                                          = 1 R/W (0x1)
    WAFER_VERSION_MAJOR (BLOCK1)                                                                          = 0 R/W (0b00)
    PKG_VERSIO"
"N (BLOCK1)                               Package version                                    = 1 R/W (0b001)
    BLK_VERSION_MINOR (BLOCK1)                         BLK_VERSION_MINOR of BLOCK2                        = 0 R/W (0b000)
    BLK_VERSION_MAJOR (BLOCK1)                         BLK_VERSION_MAJOR of BLOCK2                        = 0 R/W (0b00)
    OPTIONAL_UNIQUE_ID (BLOCK2)                        Optional unique 128-bit ID
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    J"
"tag fuses:
    JTAG_SEL_ENABLE (BLOCK0)                           Represents whether the selection between usb_to_jt = False R/W (0b0)
                                                       ag and pad_to_jtag through strapping gpio15 when b
                                                       oth EFUSE_DIS_PAD_JTAG and EFUSE_DIS_USB_JTAG are
                                                       equal to 0 is enabled or disabled. 1: enabled. 0:
                                                 "
"      disabled
    SOFT_DIS_JTAG (BLOCK0)                             Represents whether JTAG is disabled in soft way. O = 0 R/W (0b000)
                                                       dd number: disabled. Even number: enabled
    DIS_PAD_JTAG (BLOCK0)                              Represents whether JTAG is disabled in the hard wa = False R/W (0b0)
                                                       y(permanently). 1: disabled. 0: enabled

    Mac fuses:
    MAC (BLOCK1)               "
"                        MAC address
       = 60:55:f9:f7:52:9c (OK) R/W
    MAC_EXT (BLOCK1)                                   Stores the extended bits of MAC address            = 00:00 (OK) R/W
    CUSTOM_MAC (BLOCK3)                                Custom MAC
       = 00:00:00:00:00:00 (OK) R/W

    Security fuses:
    DIS_DOWNLOAD_ICACHE (BLOCK0)                       Represents whether icache is disabled or enabled i = False R/W (0b0)
                                                       n D"
"ownload mode. 1: disabled. 0: enabled
    DIS_FORCE_DOWNLOAD (BLOCK0)                        Represents whether the function that forces chip i = False R/W (0b0)
                                                       nto download mode is disabled or enabled. 1: disab
                                                       led. 0: enabled
    SPI_DOWNLOAD_MSPI_DIS (BLOCK0)                     Represents whether SPI0 controller during boot_mod = False R/W (0b0)
                                     "
"                  e_download is disabled or enabled. 1: disabled. 0:
                                                        enabled
    DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Represents whether flash encrypt function is disab = False R/W (0b0)
                                                       led or enabled(except in SPI boot mode). 1: disabl
                                                       ed. 0: enabled
    SPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables flas"
"h encryption when 1 or 3 bits are set  = Disable R/W (0b000)
                                                       and disables otherwise
    SECURE_BOOT_KEY_REVOKE0 (BLOCK0)                   Revoke 1st secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   Revoke 2nd secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE2 (BLOCK0)                   Revoke 3rd secure boot key                         = False"
" R/W (0b0)
    KEY_PURPOSE_0 (BLOCK0)                             Represents the purpose of Key0                     = USER R/W (0x0)
    KEY_PURPOSE_1 (BLOCK0)                             Represents the purpose of Key1                     = USER R/W (0x0)
    KEY_PURPOSE_2 (BLOCK0)                             Represents the purpose of Key2                     = USER R/W (0x0)
    KEY_PURPOSE_3 (BLOCK0)                             Represents the purpose of Key3                     = USER R/W (0x"
"0)
    KEY_PURPOSE_4 (BLOCK0)                             Represents the purpose of Key4                     = USER R/W (0x0)
    KEY_PURPOSE_5 (BLOCK0)                             Represents the purpose of Key5                     = USER R/W (0x0)
    SEC_DPA_LEVEL (BLOCK0)                             Represents the spa secure level by configuring the = 0 R/W (0b00)
                                                        clock random divide mode
    CRYPT_DPA_ENABLE (BLOCK0)                    "
"      Represents whether anti-dpa attack is enabled. 1:e = False R/W (0b0)
                                                       nabled. 0: disabled
    SECURE_BOOT_EN (BLOCK0)                            Represents whether secure boot is enabled or disab = False R/W (0b0)
                                                       led. 1: enabled. 0: disabled
    SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0)             Represents whether revoking aggressive secure boot = False R/W (0b0)
                  "
"                                      is enabled or disabled. 1: enabled. 0: disabled
    DIS_DOWNLOAD_MODE (BLOCK0)                         Represents whether Download mode is disabled or en = False R/W (0b0)
                                                       abled. 1: disabled. 0: enabled
    ENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Represents whether security download is enabled or = False R/W (0b0)
                                                        disabled. 1: enabled. 0:"
" disabled
    SECURE_VERSION (BLOCK0)                            Represents the version used by ESP-IDF anti-rollba = 0 R/W (0x0000)
                                                       ck feature
    SECURE_BOOT_DISABLE_FAST_WAKE (BLOCK0)             Represents whether FAST VERIFY ON WAKE is disabled = False R/W (0b0)
                                                        or enabled when Secure Boot is enabled. 1: disabl
                                                       ed. 0: enabled
 "
"   BLOCK_KEY0 (BLOCK4)
      Purpose: USER
                   Key0 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY1 (BLOCK5)
      Purpose: USER
                   Key1 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY2 (BLOCK6)
      Purpose: USER
                   Key2 or user data
       = 00 00 00 00 00 00 00 00 00 00 0"
"0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY3 (BLOCK7)
      Purpose: USER
                   Key3 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY4 (BLOCK8)
      Purpose: USER
                   Key4 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY5 (BLOCK9)
      Purpose: USER
       "
"            Key5 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Usb fuses:
    DIS_USB_JTAG (BLOCK0)                              Represents whether the function of usb switch to j = False R/W (0b0)
                                                       tag is disabled or enabled. 1: disabled. 0: enable
                                                       d
    DIS_USB_SERIAL_JTAG (BLOCK0)                       Rep"
"resents whether USB-Serial-JTAG is disabled or  = False R/W (0b0)
                                                       enabled. 1: disabled. 0: enabled
    USB_EXCHG_PINS (BLOCK0)                            Represents whether the D+ and D- pins is exchanged = False R/W (0b0)
                                                       . 1: exchanged. 0: not exchanged
    DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0)             Represents whether print from USB-Serial-JTAG is d = False R/W (0b0)
          "
"                                             isabled or enabled. 1: disabled. 0: enabled
    DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0)         Represents whether the USB-Serial-JTAG download fu = False R/W (0b0)
                                                       nction is disabled or enabled. 1: disabled. 0: ena
                                                       bled

    Vdd fuses:
    VDD_SPI_AS_GPIO (BLOCK0)                           Represents whether vdd spi pin is functioned as gp"
" = False R/W (0b0)
                                                       io. 1: functioned. 0: not functioned

    Wdt fuses:
    WDT_DELAY_SEL (BLOCK0)                             Represents whether RTC watchdog timeout threshold  = 0 R/W (0b00)
                                                       is selected at startup. 1: selected. 0: not select
                                                       ed


To get a dump for all eFuse registers.

.. code-block:: none

    espefuse.py -p PORT "
"dump

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-C6
    BLOCK0          (                ) [0 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000
    MAC_SPI_8M_0    (BLOCK1          ) [1 ] read_regs: f9f7529c 00006055 00000000 01040000 00000000 00000000
    BLOCK_SYS_DATA  (BLOCK2          ) [2 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_USR_DATA  (BLOCK3          ) [3 ] read_regs: 00000000 00000"
"000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY0      (BLOCK4          ) [4 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY1      (BLOCK5          ) [5 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY2      (BLOCK6          ) [6 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY3      (BLOCK7          ) [7 ] read_regs: 000000"
"00 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY4      (BLOCK8          ) [8 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY5      (BLOCK9          ) [9 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA2 (BLOCK10         ) [10] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

    BLOCK0          (                ) [0 ] err__reg"
"s: 00000000 00000000 00000000 00000000 00000000 00000000
    EFUSE_RD_RS_ERR0_REG        0x00000000
    EFUSE_RD_RS_ERR1_REG        0x00000000

    === Run ""dump"" command ===
"
".. code-block:: none

    To be updated for C5
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
|      240      | | Any of ``ESP_PM_CPU_FREQ_MAX``      |                                     |
|               | | or ``ESP_PM_APB_FREQ_MAX`` acquired | | CPU: 240 MHz                      |
|               |                                       | | APB: 80 MHz                       |
+         "
"      +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|      160      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 160 MHz                      |
|               |                                       | | APB: 80 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz          "
"             |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       80      | | Any of ``ESP_PM_CPU_FREQ_MAX``      | | CPU: 80 MHz                       |
|               | | or ``ESP_PM_APB_FREQ_MAX`` acquired | | APB: 80 MHz     "
"                  |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-C2

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Calibration fuses:
    OCODE (BLOCK2)                                     OCode                                              = 78 R/W (0b1001110)
    TEMP_CALIB (BLOCK2)                                Temperature calibration data  "
"                     = -7.4 R/W (0b101001010)
    ADC1_INIT_CODE_ATTEN0 (BLOCK2)                     ADC1 init code at atten0                           = 28 R/W (0x07)
    ADC1_INIT_CODE_ATTEN3 (BLOCK2)                     ADC1 init code at atten3                           = 0 R/W (0b10000)
    ADC1_CAL_VOL_ATTEN0 (BLOCK2)                       ADC1 calibration voltage at atten0                 = -44 R/W (0x8b)
    ADC1_CAL_VOL_ATTEN3 (BLOCK2)                       ADC1 calibration voltage at at"
"ten3                 = 16 R/W (0b000100)
    DIG_DBIAS_HVT (BLOCK2)                             BLOCK2 digital dbias when hvt                      = -16 R/W (0b10100)
    DIG_LDO_SLP_DBIAS2 (BLOCK2)                        BLOCK2 DIG_LDO_DBG0_DBIAS2                         = -8 R/W (0b1000010)
    DIG_LDO_SLP_DBIAS26 (BLOCK2)                       BLOCK2 DIG_LDO_DBG0_DBIAS26                        = 24 R/W (0x06)
    DIG_LDO_ACT_DBIAS26 (BLOCK2)                       BLOCK2 DIG_LDO_ACT_DBIAS26   "
"                      = 16 R/W (0b000100)
    DIG_LDO_ACT_STEPD10 (BLOCK2)                       BLOCK2 DIG_LDO_ACT_STEPD10                         = 12 R/W (0x3)
    RTC_LDO_SLP_DBIAS13 (BLOCK2)                       BLOCK2 DIG_LDO_SLP_DBIAS13                         = 88 R/W (0b0010110)
    RTC_LDO_SLP_DBIAS29 (BLOCK2)                       BLOCK2 DIG_LDO_SLP_DBIAS29                         = 96 R/W (0b000011000)
    RTC_LDO_SLP_DBIAS31 (BLOCK2)                       BLOCK2 DIG_LDO_SLP_DBIAS31"
"                         = 4 R/W (0b000001)
    RTC_LDO_ACT_DBIAS31 (BLOCK2)                       BLOCK2 DIG_LDO_ACT_DBIAS31                         = 24 R/W (0b000110)
    RTC_LDO_ACT_DBIAS13 (BLOCK2)                       BLOCK2 DIG_LDO_ACT_DBIAS13                         = 72 R/W (0x12)

    Config fuses:
    WR_DIS (BLOCK0)                                    Disable programming of individual eFuses           = 0 R/W (0x00)
    RD_DIS (BLOCK0)                                    Disable readi"
"ng from BlOCK3                        = 0 R/W (0b00)
    UART_PRINT_CONTROL (BLOCK0)                        Set the default UARTboot message output mode       = Enable R/W (0b00)
    DIS_DIRECT_BOOT (BLOCK0)                           This bit set means disable direct_boot mode        = False R/W (0b0)

    Flash fuses:
    FORCE_SEND_RESUME (BLOCK0)                         Set this bit to force ROM code to send a resume co = False R/W (0b0)
                                                       "
"mmand during SPI boot
    FLASH_TPUW (BLOCK0)                                Configures flash waiting time after power-up; in u = 0 R/W (0x0)
                                                       nit of ms. If the value is less than 15; the waiti
                                                       ng time is the configurable value.  Otherwise; the
                                                        waiting time is twice the configurable value

    Identity fuses:
    DISABLE_WAFER_VERSIO"
"N_MAJOR (BLOCK0)               Disables check of wafer version major              = False R/W (0b0)
    DISABLE_BLK_VERSION_MAJOR (BLOCK0)                 Disables check of blk version major                = False R/W (0b0)
    WAFER_VERSION_MINOR (BLOCK2)                       WAFER_VERSION_MINOR                                = 2 R/W (0x2)
    WAFER_VERSION_MAJOR (BLOCK2)                       WAFER_VERSION_MAJOR                                = 1 R/W (0b01)
    PKG_VERSION (BLOCK2)           "
"                    EFUSE_PKG_VERSION                                  = 1 R/W (0b001)
    BLK_VERSION_MINOR (BLOCK2)                         Minor version of BLOCK2                            = With calib R/W (0b001)
    BLK_VERSION_MAJOR (BLOCK2)                         Major version of BLOCK2                            = 0 R/W (0b00)

    Jtag fuses:
    DIS_PAD_JTAG (BLOCK0)                              Set this bit to disable pad jtag                   = False R/W (0b0)

    Mac fuses:
    "
"CUSTOM_MAC_USED (BLOCK0)                           True if MAC_CUSTOM is burned                       = False R/W (0b0)
    CUSTOM_MAC (BLOCK1)                                Custom MAC address
       = 00:00:00:00:00:00 (OK) R/W
    MAC (BLOCK2)                                       MAC address
       = 08:3a:8d:5c:4b:94 (OK) R/W

    Security fuses:
    DIS_DOWNLOAD_ICACHE (BLOCK0)                       The bit be set to disable icache in download mode  = False R/W (0b0)
    DIS_DOWNLOAD_MANUA"
"L_ENCRYPT (BLOCK0)               The bit be set to disable manual encryption        = False R/W (0b0)
    SPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables flash encryption when 1 or 3 bits are set  = Disable R/W (0b000)
                                                       and disables otherwise
    XTS_KEY_LENGTH_256 (BLOCK0)                        Flash encryption key length                        = 128 bits key R/W (0b0)
    DIS_DOWNLOAD_MODE (BLOCK0)                         Set th"
"is bit to disable download mode (boot_mode[3 = False R/W (0b0)
                                                       :0] = 0; 1; 2; 4; 5; 6; 7)
    ENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Set this bit to enable secure UART download mode   = False R/W (0b0)
    SECURE_BOOT_EN (BLOCK0)                            The bit be set to enable secure boot               = False R/W (0b0)
    SECURE_VERSION (BLOCK0)                            Secure version for anti-rollback                   ="
" 0 R/W (0x0)
    BLOCK_KEY0 (BLOCK3)                                BLOCK_KEY0 - 256-bits. 256-bit key of Flash Encryp
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
                                                       tion
    BLOCK_KEY0_LOW_128 (BLOCK3)                        BLOCK_KEY0 - lower 128-bits. 128-bit key of Flash
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
                                              "
"         Encryption
    BLOCK_KEY0_HI_128 (BLOCK3)                         BLOCK_KEY0 - higher 128-bits. 128-bits key of Secu
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
                                                       re Boot

    Wdt fuses:
    WDT_DELAY_SEL (BLOCK0)                             RTC watchdog timeout threshold; in unit of slow cl = 40000 R/W (0b00)
                                                       ock cycle


To get a dump for all eFuse registers.

.."
" code-block:: none

    espefuse.py -p PORT dump

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-C2
    BLOCK0          (BLOCK0          ) [0 ] read_regs: 00000000 00000000
    BLOCK1          (BLOCK1          ) [1 ] read_regs: 00000000 00000000 00000000
    BLOCK2          (BLOCK2          ) [2 ] read_regs: 8d5c4b94 8252083a 5c01e953 80d0a824 c0860b18 00006890 00000000 4b000000
    BLOCK_KEY0      (BLOCK3          ) [3 ] read_regs: 00000000 00000000 00000000 000000"
"00 00000000 00000000 00000000 00000000

    BLOCK0          (BLOCK0          ) [0 ] err__regs: 00000000 00000000
    EFUSE_RD_RS_ERR_REG         0x00000000

    === Run ""dump"" command ===
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
|      240      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 240 MHz                      |
|               |                                       | | APB: 80 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz               "
"        |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|      160      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 160 MHz                      |
|               |                                       | | APB: 80 MHz          "
"             |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz                       |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       80      | | Any of ``ESP_PM_CPU_FREQ_MAX``      "
"| | CPU: 80 MHz                       |
|               | | or ``ESP_PM_APB_FREQ_MAX`` acquired | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
"
"++++
| Max CPU       |            Lock Acquisition           | CPU and APB Frequencies             |
| Frequency Set |                                       |                                     |
++++
|      240      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 240 MHz                      |
|               |                                       | | APB: 80 MHz                       |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz               "
"        |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|      160      | ``ESP_PM_CPU_FREQ_MAX`` acquired      | | CPU: 160 MHz                      |
|               |                                       | | APB: 80 MHz          "
"             |
+               +++
|               | ``ESP_PM_APB_FREQ_MAX`` acquired,     | | CPU: 80 MHz                       |
|               | ``ESP_PM_CPU_FREQ_MAX`` not acquired  | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
|       80      | | Any of ``ESP_PM_CPU_FREQ_MAX``      "
"| | CPU: 80 MHz                       |
|               | | or ``ESP_PM_APB_FREQ_MAX`` acquired | | APB: 80 MHz                       |
+               +++
|               |                  None                 | Min values for both frequencies set |
|               |                                       | with :cpp:func:`esp_pm_configure`   |
++++
"
".. code-block:: none

    espefuse.py -p PORT summary

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-C3

    === Run ""summary"" command ===
    EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
    
    Calibration fuses:
    K_RTC_LDO (BLOCK1)                                 BLOCK1 K_RTC_LDO                                   = -36 R/W (0b1001001)
    K_DIG_LDO (BLOCK1)                                 BLOCK1 K_DIG_LDO             "
"                      = -64 R/W (0b1010000)
    V_RTC_DBIAS20 (BLOCK1)                             BLOCK1 voltage of rtc dbias20                      = -40 R/W (0x8a)
    V_DIG_DBIAS20 (BLOCK1)                             BLOCK1 voltage of digital dbias20                  = -76 R/W (0x93)
    DIG_DBIAS_HVT (BLOCK1)                             BLOCK1 digital dbias when hvt                      = -28 R/W (0b10111)
    THRES_HVT (BLOCK1)                                 BLOCK1 pvt threshold when hvt"
"                      = 2000 R/W (0b0111110100)
    TEMP_CALIB (BLOCK2)                                Temperature calibration data                       = -7.2 R/W (0b101001000)
    OCODE (BLOCK2)                                     ADC OCode                                          = 78 R/W (0x4e)
    ADC1_INIT_CODE_ATTEN0 (BLOCK2)                     ADC1 init code at atten0                           = 1560 R/W (0b0110000110)
    ADC1_INIT_CODE_ATTEN1 (BLOCK2)                     ADC1 init co"
"de at atten1                           = -108 R/W (0b1000011011)
    ADC1_INIT_CODE_ATTEN2 (BLOCK2)                     ADC1 init code at atten2                           = -232 R/W (0b1000111010)
    ADC1_INIT_CODE_ATTEN3 (BLOCK2)                     ADC1 init code at atten3                           = -696 R/W (0b1010101110)
    ADC1_CAL_VOL_ATTEN0 (BLOCK2)                       ADC1 calibration voltage at atten0                 = -212 R/W (0b1000110101)
    ADC1_CAL_VOL_ATTEN1 (BLOCK2)       "
"                ADC1 calibration voltage at atten1                 = 52 R/W (0b0000001101)
    ADC1_CAL_VOL_ATTEN2 (BLOCK2)                       ADC1 calibration voltage at atten2                 = -152 R/W (0b1000100110)
    ADC1_CAL_VOL_ATTEN3 (BLOCK2)                       ADC1 calibration voltage at atten3                 = -284 R/W (0b1001000111)

    Config fuses:
    WR_DIS (BLOCK0)                                    Disable programming of individual eFuses           = 0 R/W (0x00000000)"
"
    RD_DIS (BLOCK0)                                    Disable reading from BlOCK4-10                     = 0 R/W (0b0000000)
    DIS_ICACHE (BLOCK0)                                Set this bit to disable Icache                     = False R/W (0b0)
    DIS_TWAI (BLOCK0)                                  Set this bit to disable CAN function               = False R/W (0b0)
    DIS_DIRECT_BOOT (BLOCK0)                           Disable direct boot mode                           = False R/W (0b0)
 "
"   UART_PRINT_CONTROL (BLOCK0)                        Set the default UARTboot message output mode       = Enable R/W (0b00)
    ERR_RST_ENABLE (BLOCK0)                            Use BLOCK0 to check error record registers         = with check R/W (0b1)
    BLOCK_USR_DATA (BLOCK3)                            User data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_SYS_DATA2 (BLOCK10)                          System data part "
"2 (reserved)
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Flash fuses:
    FLASH_TPUW (BLOCK0)                                Configures flash waiting time after power-up; in u = 0 R/W (0x0)
                                                       nit of ms. If the value is less than 15; the waiti
                                                       ng time is the configurable value; Otherwise; the
                             "
"                          waiting time is twice the configurable value
    FORCE_SEND_RESUME (BLOCK0)                         Set this bit to force ROM code to send a resume co = False R/W (0b0)
                                                       mmand during SPI boot

    Identity fuses:
    DISABLE_WAFER_VERSION_MAJOR (BLOCK0)               Disables check of wafer version major              = False R/W (0b0)
    DISABLE_BLK_VERSION_MAJOR (BLOCK0)                 Disables check of blk versio"
"n major                = False R/W (0b0)
    WAFER_VERSION_MINOR_LO (BLOCK1)                    WAFER_VERSION_MINOR least significant bits         = 3 R/W (0b011)
    PKG_VERSION (BLOCK1)                               Package version                                    = 0 R/W (0b000)
    BLK_VERSION_MINOR (BLOCK1)                         BLK_VERSION_MINOR                                  = 2 R/W (0b010)
    WAFER_VERSION_MINOR_HI (BLOCK1)                    WAFER_VERSION_MINOR most significant b"
"it           = False R/W (0b0)
    WAFER_VERSION_MAJOR (BLOCK1)                       WAFER_VERSION_MAJOR                                = 0 R/W (0b00)
    OPTIONAL_UNIQUE_ID (BLOCK2)                        Optional unique 128-bit ID
       = 25 60 04 96 c3 fd 41 6f be ed 2c 51 1d e3 7e 21 R/W
    BLK_VERSION_MAJOR (BLOCK2)                         BLK_VERSION_MAJOR of BLOCK2                        = With calibration R/W (0b01)
    WAFER_VERSION_MINOR (BLOCK0)                       calc WAFER VER"
"SION MINOR = WAFER_VERSION_MINOR_HI  = 3 R/W (0x3)
                                                       << 3 + WAFER_VERSION_MINOR_LO (read only)

    Jtag fuses:
    SOFT_DIS_JTAG (BLOCK0)                             Set these bits to disable JTAG in the soft way (od = 0 R/W (0b000)
                                                       d number 1 means disable ). JTAG can be enabled in
                                                        HMAC module
    DIS_PAD_JTAG (BLOCK0)              "
"                Set this bit to disable JTAG in the hard way. JTAG = False R/W (0b0)
                                                        is disabled permanently

    Mac fuses:
    MAC (BLOCK1)                                       MAC address
       = 58:cf:79:0f:96:8c (OK) R/W
    CUSTOM_MAC (BLOCK3)                                Custom MAC address
       = 00:00:00:00:00:00 (OK) R/W

    Security fuses:
    DIS_DOWNLOAD_ICACHE (BLOCK0)                       Set this bit to disable Icache"
" in download mode (b = False R/W (0b0)
                                                       oot_mode[3:0] is 0; 1; 2; 3; 6; 7)
    DIS_FORCE_DOWNLOAD (BLOCK0)                        Set this bit to disable the function that forces c = False R/W (0b0)
                                                       hip into download mode
    DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Set this bit to disable flash encryption when in d = False R/W (0b0)
                                             "
"          ownload boot modes
    SPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables flash encryption when 1 or 3 bits are set  = Disable R/W (0b000)
                                                       and disables otherwise
    SECURE_BOOT_KEY_REVOKE0 (BLOCK0)                   Revoke 1st secure boot key                         = False R/W (0b0)
    SECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   Revoke 2nd secure boot key                         = False R/W (0b0)
    SECURE_BOOT_K"
"EY_REVOKE2 (BLOCK0)                   Revoke 3rd secure boot key                         = False R/W (0b0)
    KEY_PURPOSE_0 (BLOCK0)                             Purpose of Key0                                    = USER R/W (0x0)
    KEY_PURPOSE_1 (BLOCK0)                             Purpose of Key1                                    = USER R/W (0x0)
    KEY_PURPOSE_2 (BLOCK0)                             Purpose of Key2                                    = USER R/W (0x0)
    KEY_PURPOSE_3 (BLOCK"
"0)                             Purpose of Key3                                    = USER R/W (0x0)
    KEY_PURPOSE_4 (BLOCK0)                             Purpose of Key4                                    = USER R/W (0x0)
    KEY_PURPOSE_5 (BLOCK0)                             Purpose of Key5                                    = USER R/W (0x0)
    SECURE_BOOT_EN (BLOCK0)                            Set this bit to enable secure boot                 = False R/W (0b0)
    SECURE_BOOT_AGGRESSIVE_REVO"
"KE (BLOCK0)             Set this bit to enable revoking aggressive secure  = False R/W (0b0)
                                                       boot
    DIS_DOWNLOAD_MODE (BLOCK0)                         Set this bit to disable download mode (boot_mode[3 = False R/W (0b0)
                                                       :0] = 0; 1; 2; 3; 6; 7)
    ENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Set this bit to enable secure UART download mode   = False R/W (0b0)
    SECURE_VERSION ("
"BLOCK0)                            Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000)
                                                       ure)
    BLOCK_KEY0 (BLOCK4)
      Purpose: USER
                   Key0 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY1 (BLOCK5)
      Purpose: USER
                   Key1 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
"00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY2 (BLOCK6)
      Purpose: USER
                   Key2 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY3 (BLOCK7)
      Purpose: USER
                   Key3 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY4 (BLOCK8)
      Purpose: USER
                   Key4 or user d"
"ata
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
    BLOCK_KEY5 (BLOCK9)
      Purpose: USER
                   Key5 or user data
       = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

    Spi Pad fuses:
    SPI_PAD_CONFIG_CLK (BLOCK1)                        SPI PAD CLK                                        = 0 R/W (0b000000)
    SPI_PAD_CONFIG_Q (BLOCK1)                       "
"   SPI PAD Q(D1)                                      = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D (BLOCK1)                          SPI PAD D(D0)                                      = 0 R/W (0b000000)
    SPI_PAD_CONFIG_CS (BLOCK1)                         SPI PAD CS                                         = 0 R/W (0b000000)
    SPI_PAD_CONFIG_HD (BLOCK1)                         SPI PAD HD(D3)                                     = 0 R/W (0b000000)
    SPI_PAD_CONFIG_WP (BLOCK1)                      "
"   SPI PAD WP(D2)                                     = 0 R/W (0b000000)
    SPI_PAD_CONFIG_DQS (BLOCK1)                        SPI PAD DQS                                        = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D4 (BLOCK1)                         SPI PAD D4                                         = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D5 (BLOCK1)                         SPI PAD D5                                         = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D6 (BLOCK1)                      "
"   SPI PAD D6                                         = 0 R/W (0b000000)
    SPI_PAD_CONFIG_D7 (BLOCK1)                         SPI PAD D7                                         = 0 R/W (0b000000)

    Usb fuses:
    DIS_USB_JTAG (BLOCK0)                              Set this bit to disable function of usb switch to  = False R/W (0b0)
                                                       jtag in module of usb device
    DIS_USB_SERIAL_JTAG (BLOCK0)                       USB-Serial-JTAG        "
"                            = Enable R/W (0b0)
    USB_EXCHG_PINS (BLOCK0)                            Set this bit to exchange USB D+ and D- pins        = False R/W (0b0)
    DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0)             USB printing                                       = Enable R/W (0b0)
    DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0)         Disable UART download mode through USB-Serial-JTAG = False R/W (0b0)

    Vdd fuses:
    VDD_SPI_AS_GPIO (BLOCK0)                           Set this "
"bit to vdd spi pin function as gpio       = False R/W (0b0)

    Wdt fuses:
    WDT_DELAY_SEL (BLOCK0)                             RTC watchdog timeout threshold; in unit of slow cl = 40000 R/W (0b00)
                                                       ock cycle


To get a dump for all eFuse registers.

.. code-block:: none

    espefuse.py -p PORT dump

    espefuse.py v4.6-dev
    Connecting....
    Detecting chip type... ESP32-C3
    BLOCK0          (                ) [0 ] read_regs: 00000"
"000 00000000 00000000 00000000 80000000 00000000
    MAC_SPI_8M_0    (BLOCK1          ) [1 ] read_regs: 790f968c 000058cf 00000000 020c0000 715424e0 0047d2f2
    BLOCK_SYS_DATA  (BLOCK2          ) [2 ] read_regs: 96046025 6f41fdc3 512cedbe 217ee31d d864ea41 5aba3a86 1e260363 00000009
    BLOCK_USR_DATA  (BLOCK3          ) [3 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY0      (BLOCK4          ) [4 ] read_regs: 00000000 00000000 00000000 000000"
"00 00000000 00000000 00000000 00000000
    BLOCK_KEY1      (BLOCK5          ) [5 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY2      (BLOCK6          ) [6 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY3      (BLOCK7          ) [7 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY4      (BLOCK8          ) [8 ] read_regs: 00000000 00000000 0000000"
"0 00000000 00000000 00000000 00000000 00000000
    BLOCK_KEY5      (BLOCK9          ) [9 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    BLOCK_SYS_DATA2 (BLOCK10         ) [10] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

    BLOCK0          (                ) [0 ] err__regs: 00000000 00000000 00000000 00000000 00000000 00000000
    EFUSE_RD_RS_ERR0_REG        0x00000000
    EFUSE_RD_RS_ERR1_REG        0x00000000

  "
"  === Run ""dump"" command ===
"
"Bluetooth® API




.. toctree::
    :maxdepth: 2

    bt_common
    bt_le
    :SOC_BT_CLASSIC_SUPPORTED: classic_bt
    controller_vhci
    :SOC_BLE_MESH_SUPPORTED: esp-ble-mesh
    nimble/index

ESP-IDF currently supports two host stacks. The Bluedroid based stack (default) supports classic Bluetooth as well as Bluetooth Low Energy (Bluetooth LE). On the other hand, Apache NimBLE based stack is Bluetooth Low Energy only. For users to make a choice:

.. only:: esp32

    For the overview of the "
"ESP32 Bluetooth stack architecture, follow the links below:

Code examples for this API section are provided in the :example:`bluetooth/bluedroid` directory of ESP-IDF examples.

The following examples contain detailed walkthroughs:
"
"GAP API




Application Example


Check the :example:`bluetooth/bluedroid/ble` folder in ESP-IDF examples, which contains the following demos and their tutorials:

    - :example:`bluetooth/bluedroid/ble/gatt_security_client`
    - :example_file:`GATT Security Client Example Walkthrough `

    - :example:`bluetooth/bluedroid/ble/gatt_security_server`
    - :example_file:`GATT Security Server Example Walkthrough `

API Reference


.. include-build-file:: inc/esp_gap_ble_api.inc

"
"Bluetooth® Device APIs


Overview


Bluetooth device reference APIs.

API Reference


.. include-build-file:: inc/esp_bt_device.inc
"
"Controller && VHCI


Application Example


Check :example:`bluetooth/hci` folder in ESP-IDF examples, which contains the following application:

.. only:: esp32s3

    Please note that ESP32-S3 shares the same :component_file:`bt/include/esp32c3/include/esp_bt.h` and :component_file:`bt/controller/esp32c3/bt.c` files with ESP32-C3.

API Reference


.. include-build-file:: inc/esp_bt.inc
"
"Bluetooth® Low Energy (Bluetooth LE)


.. toctree::
   :caption: Bluetooth Low Energy

   Bluetooth Low Energy GAP 
   Bluetooth Low Energy GATT Define 
   Bluetooth Low Energy GATT Server 
   Bluetooth Low Energy GATT Client 
   :SOC_BLUFI_SUPPORTED: Bluetooth Low Energy BluFi 
"
"HFP Defines


API Reference


.. include-build-file:: inc/esp_hf_defs.inc


"
"Bluetooth® HID Host API


Overview


A Bluetooth HID host is a device or software that is capable of connecting and communicating with Bluetooth HID devices, such as keyboards, mice. Users can use the Bluetooth HID Host APIs to send output data or control commands to the HID devices, enabling them to control the behavior or settings of the devices.

Application Example


Check :example:`bluetooth` folder in ESP-IDF examples, which contains the following application:


API Reference


.. include-"
"build-file:: inc/esp_hidh_api.inc
"
"GATT Server API




Application Examples


Check :example:`bluetooth/bluedroid/ble` folder in ESP-IDF examples, which contains the following demos and their tutorials:

    - :example:`bluetooth/bluedroid/ble/gatt_server_service_table`
    - :example_file:`GATT Server Service Table Example Walkthrough `

    - :example:`bluetooth/bluedroid/ble/gatt_server`
    - :example_file:`GATT Server Example Walkthrough `

    - :example:`bluetooth/bluedroid/ble/ble_spp_server`

API Reference


.. include-b"
"uild-file:: inc/esp_gatts_api.inc

"
"Bluetooth® Common


.. toctree::
   :caption: Bluetooth Common Defines and APIs

   Bluetooth Define 
   Bluetooth Main 
   Bluetooth Device 
"
"GATT Client API


Application Example


Check :example:`bluetooth/bluedroid/ble` folder in ESP-IDF examples, which contains the following demos and their tutorials:

    - :example:`bluetooth/bluedroid/ble/gatt_client`
    - :example_file:`GATT Client Example Walkthrough `

    - :example:`bluetooth/bluedroid/ble/gattc_multi_connect`
    - :example_file:`GATT Client Multi-connection Example Walkthrough `

    - :example:`bluetooth/bluedroid/ble/ble_spp_client`

API Reference


.. include-build-f"
"ile:: inc/esp_gattc_api.inc

"
"Bluetooth® Generic Defines


API Reference


.. include-build-file:: inc/esp_bt_defs.inc

"
"Bluetooth® A2DP API


Application Example


Check :example:`bluetooth/bluedroid/classic_bt` folder in ESP-IDF examples, which contains the following application:

API Reference


.. include-build-file:: inc/esp_a2dp_api.inc

"
"Bluetooth® Main API


API Reference


.. include-build-file:: inc/esp_bt_main.inc


"
"GATT Defines


API Reference


.. include-build-file:: inc/esp_gatt_defs.inc


"
"ESP-BLE-MESH


.. note::

  The current ESP-BLE-MESH v1.1 related code is a preview version, so the Mesh Protocol v1.1 related Structures, MACROs, and APIs involved in the code may be changed.

With various features of ESP-BLE-MESH, users can create a managed flooding mesh network for several scenarios, such as lighting, sensor and etc.

For an ESP32 to join and work on a ESP-BLE-MESH network, it must be provisioned firstly. By provisioning, the ESP32, as an unprovisioned device, will join the E"
"SP-BLE-MESH network and become a ESP-BLE-MESH node, communicating with other nodes within or beyond the radio range.

Apart from ESP-BLE-MESH nodes, inside ESP-BLE-MESH network, there is also ESP32 that works as ESP-BLE-MESH provisioner, which could provision unprovisioned devices into ESP-BLE-MESH nodes and configure the nodes with various features.

For information how to start using ESP32 and ESP-BLE-MESH, please see the Section :ref:`getting-started-with-ble-mesh`. If you are interested in i"
"nformation on ESP-BLE-MESH architecture, including some details of software implementation, please see Section :doc:`../../api-guides/esp-ble-mesh/ble-mesh-architecture`.


Application Examples and Demos


Please refer to Sections :ref:`esp-ble-mesh-examples` and :ref:`esp-ble-mesh-demo-videos`.


API Reference


ESP-BLE-MESH APIs are divided into the following parts:


ESP-BLE-MESH Definitions


This section contains only one header file, which lists the following items of ESP-BLE-MESH.

.. inc"
"lude-build-file:: inc/esp_ble_mesh_defs.inc


ESP-BLE-MESH Core API Reference


This section contains ESP-BLE-MESH Core related APIs, which can be used to initialize ESP-BLE-MESH stack, provision, send/publish messages, etc.

This API reference covers six components:


ESP-BLE-MESH Stack Initialization


.. include-build-file:: inc/esp_ble_mesh_common_api.inc


Reading of Local Data Information


.. include-build-file:: inc/esp_ble_mesh_local_data_operation_api.inc


Low Power Operation (Updatin"
"g)


.. include-build-file:: inc/esp_ble_mesh_low_power_api.inc


Send/Publish Messages, Add Local AppKey, Etc.


.. include-build-file:: inc/esp_ble_mesh_networking_api.inc


ESP-BLE-MESH Node/Provisioner Provisioning


.. include-build-file:: inc/esp_ble_mesh_provisioning_api.inc


ESP-BLE-MESH GATT Proxy Server


.. include-build-file:: inc/esp_ble_mesh_proxy_api.inc


ESP-BLE-MESH Models API Reference


This section contains ESP-BLE-MESH Model related APIs, event types, event parameters, etc"
".

There are six categories of models:


.. note::

    Definitions related to Server Models are being updated, and will be released soon.


Configuration Client/Server Models


.. include-build-file:: inc/esp_ble_mesh_config_model_api.inc


Health Client/Server Models


.. include-build-file:: inc/esp_ble_mesh_health_model_api.inc


Generic Client/Server Models


.. include-build-file:: inc/esp_ble_mesh_generic_model_api.inc


Sensor Client/Server Models


.. include-build-file:: inc/esp_ble_me"
"sh_sensor_model_api.inc


Time and Scenes Client/Server Models


.. include-build-file:: inc/esp_ble_mesh_time_scene_model_api.inc


Lighting Client/Server Models


.. include-build-file:: inc/esp_ble_mesh_lighting_model_api.inc


ESP-BLE-MESH (v1.1) Core API Reference


.. note::

  This section is a preview version, so the related structures, macros, and APIs may be changed.

This section contains ESP-BLE-MESH v1.1 Core related APIs, event types, event parameters, etc.

This API reference cove"
"rs 10 components:


Remote Provisioning


.. include-build-file:: inc/esp_ble_mesh_rpr_model_api.inc


Directed Forwarding


.. include-build-file:: inc/esp_ble_mesh_df_model_api.inc

Subnet Bridge Configuration


.. include-build-file:: inc/esp_ble_mesh_brc_model_api.inc

Mesh Private Beacon


.. include-build-file:: inc/esp_ble_mesh_prb_model_api.inc

On-Demand Private Proxy


.. include-build-file:: inc/esp_ble_mesh_odp_model_api.inc

SAR Configuration


.. include-build-file:: inc/esp_ble_me"
"sh_sar_model_api.inc

Solicitation PDU RPL Configuration


.. include-build-file:: inc/esp_ble_mesh_srpl_model_api.inc

Opcodes Aggregator


.. include-build-file:: inc/esp_ble_mesh_agg_model_api.inc

Large Composition Data


.. include-build-file:: inc/esp_ble_mesh_lcd_model_api.inc

Composition and Metadata


.. include-build-file:: inc/esp_ble_mesh_cm_data_api.inc

"
"Bluetooth® HID Device API


Overview


A Bluetooth HID device is a device providing the service of human or other data input and output to and from a Bluetooth HID Host. Users can use the Bluetooth HID Device APIs to make devices like keyboards, mice, joysticks and so on.

Application Example


Check :example:`bluetooth/bluedroid/classic_bt` folder in ESP-IDF examples, which contains the following application:

API Reference


.. include-build-file:: inc/esp_hidd_api.inc
"
"Classic Bluetooth® L2CAP API


Application Example


Check :example:`bluetooth/bluedroid/classic_bt` folder in ESP-IDF examples, which contains the following application:

API Reference


.. include-build-file:: inc/esp_l2cap_bt_api.inc

"
"HFP AG API


API Reference


.. include-build-file:: inc/esp_hf_ag_api.inc
"
"HFP Client API


API Reference


.. include-build-file:: inc/esp_hf_client_api.inc
"
"Bluetooth® AVRCP APIs


Overview


Bluetooth AVRCP reference APIs.

API Reference


.. include-build-file:: inc/esp_avrc_api.inc


"
"SPP API


Application Example


Check :example:`bluetooth/bluedroid/classic_bt` folder in ESP-IDF examples, which contains the following application:

API Reference


.. include-build-file:: inc/esp_spp_api.inc

"
"Classic Bluetooth® GAP API


API Reference


.. include-build-file:: inc/esp_gap_bt_api.inc

"
"Classic Bluetooth®


.. toctree::
   :caption: Classic Bluetooth

   Bluetooth GAP 
   Bluetooth A2DP 
   Bluetooth AVRC 
   Bluetooth SPP 
   Bluetooth HFP Define 
   Bluetooth HFP Client 
   Bluetooth HFP AG 
   Bluetooth HID Device 
   Bluetooth HID Host 
   Bluetooth L2CAP 
   Bluetooth SDP 
"
"Bluetooth® SDP APIs


Overview


Bluetooth SDP reference APIs.

API Reference


.. include-build-file:: inc/esp_sdp_api.inc


"
"BluFi API


Overview


BluFi is a profile based GATT to config ESP32 Wi-Fi to connect/disconnect AP or setup a softap and etc.

Use should concern these things:

Application Example


Check :example:`bluetooth` folder in ESP-IDF examples, which contains the following application:

API Reference


.. include-build-file:: inc/esp_blufi_api.inc

"
"NimBLE-based Host APIs


Overview


Apache MyNewt NimBLE is a highly configurable and Bluetooth® SIG qualifiable Bluetooth Low Energy (Bluetooth LE) stack providing both host and controller functionalities. ESP-IDF supports NimBLE host stack which is specifically ported for ESP32 platform and FreeRTOS. The underlying controller is still the same (as in case of Bluedroid) providing VHCI interface. Refer to  `NimBLE user guide `_ for a complete list of features and additional information on NimBLE"
" stack. Most features of NimBLE including Bluetooth Low Energy Mesh are supported by ESP-IDF. The porting layer is kept cleaner by maintaining all the existing APIs of NimBLE along with a single ESP-NimBLE API for initialization, making it simpler for the application developers.

Architecture


Currently, NimBLE host and controller support different transports such as UART and RAM between them. However, RAM transport cannot be used as is in case of ESP as ESP controller supports VHCI interface a"
"nd buffering schemes used by NimBLE host is incompatible with that used by ESP controller. Therefore, a new transport between NimBLE host and ESP controller has been added. This is depicted in the figure below. This layer is responsible for maintaining pool of transport buffers and formatting buffers exchanges between host and controller as per the requirements.

.. figure:: ../../../../_static/esp32_nimble_stack.png
    :align: center
    :alt: ESP NimBLE Stack.
    :scale: 50

    ESP NimBLE S"
"tack


Threading Model


The NimBLE host can run inside the application thread or can have its own independent thread. This flexibility is inherently provided by NimBLE design. By default, a thread is spawned by the porting function ``nimble_port_freertos_init``. This behavior can be changed by overriding the same function. For Bluetooth Low Energy Mesh, additional thread (advertising thread) is used which keeps on feeding advertisement events to the main thread.

Programming Sequence


To begin"
" with, make sure that the NimBLE stack is enabled from menuconfig :ref:`choose NimBLE for the Bluetooth host `.

Typical programming sequence with NimBLE stack consists of the following steps:

This documentation does not cover NimBLE APIs. Refer to `NimBLE tutorial `_ for more details on the programming sequence/NimBLE APIs for different scenarios.

API Reference


.. include-build-file:: inc/esp_nimble_hci.inc
"
"General Purpose Timer (GPTimer)


Introduction


GPTimer (General Purpose Timer) is the driver of {IDF_TARGET_NAME} Timer Group peripheral. The hardware timer features high resolution and flexible alarm action. The behavior when the internal counter of a timer reaches a specific target value is called a timer alarm. When a timer alarms, a user registered per-timer callback would be called.

Typically, a general purpose timer can be used in scenarios like:

- Free running as a wall clock, fetchin"
"g a high-resolution timestamp at any time and any places
- Generate period alarms, trigger events periodically
- Generate one-shot alarm, respond in target time

Functional Overview


The following sections of this document cover the typical steps to install and operate a timer:

.. list::

    - :ref:`gptimer-resource-allocation` - covers which parameters should be set up to get a timer handle and how to recycle the resources when GPTimer finishes working.
    - :ref:`set-and-get-count-value` -"
" covers how to force the timer counting from a start point and how to get the count value at anytime.
    - :ref:`set-up-alarm-action` - covers the parameters that should be set up to enable the alarm event.
    - :ref:`gptimer-register-event-callbacks` - covers how to hook user specific code to the alarm event callback function.
    - :ref:`enable-and-disable-timer` - covers how to enable and disable the timer.
    - :ref:`start-and-stop-timer` - shows some typical use cases that start the time"
"r with different alarm behavior.
    :SOC_ETM_SUPPORTED and SOC_TIMER_SUPPORT_ETM: - :ref:`gptimer-etm-event-and-task` - describes what the events and tasks can be connected to the ETM channel.
    - :ref:`gptimer-power-management` - describes how different source clock selections can affect power consumption.
    - :ref:`gptimer-iram-safe` - describes tips on how to make the timer interrupt and IO control functions work better along with a disabled cache.
    - :ref:`gptimer-thread-safety` - li"
"sts which APIs are guaranteed to be thread safe by the driver.
    - :ref:`gptimer-kconfig-options` - lists the supported Kconfig options that can be used to make a different effect on driver behavior.

.. _gptimer-resource-allocation:

Resource Allocation


Different ESP chips might have different numbers of independent timer groups, and within each group, there could also be several independent timers. [1]_

A GPTimer instance is represented by :cpp:type:`gptimer_handle_t`. The driver behind m"
"anages all available hardware resources in a pool, so that you do not need to care about which timer and which group it belongs to.

To install a timer instance, there is a configuration structure that needs to be given in advance: :cpp:type:`gptimer_config_t`:

- :cpp:member:`gptimer_config_t::clk_src` selects the source clock for the timer. The available clocks are listed in :cpp:type:`gptimer_clock_source_t`, you can only pick one of them. For the effect on power consumption of different cloc"
"k source, please refer to Section :ref:`gptimer-power-management`.

- :cpp:member:`gptimer_config_t::direction` sets the counting direction of the timer, supported directions are listed in :cpp:type:`gptimer_count_direction_t`, you can only pick one of them.

- :cpp:member:`gptimer_config_t::resolution_hz` sets the resolution of the internal counter. Each count step is equivalent to **1 / resolution_hz** seconds.

-  :cpp:member:`gptimer_config::intr_priority` sets the priority of the timer inte"
"rrupt. If it is set to ``0``, the driver will allocate an interrupt with a default priority. Otherwise, the driver will use the given priority.

-  Optional :cpp:member:`gptimer_config_t::intr_shared` sets whether or not mark the timer interrupt source as a shared one. For the pros/cons of a shared interrupt, you can refer to :doc:`Interrupt Handling `.

With all the above configurations set in the structure, the structure can be passed to :cpp:func:`gptimer_new_timer` which will instantiate the"
" timer instance and return a handle of the timer.

The function can fail due to various errors such as insufficient memory, invalid arguments, etc. Specifically, when there are no more free timers (i.e., all hardware resources have been used up), then :c:macro:`ESP_ERR_NOT_FOUND` will be returned. The total number of available timers is represented by the :c:macro:`SOC_TIMER_GROUP_TOTAL_TIMERS` and its value depends on the ESP chip.

If a previously created GPTimer instance is no longer required"
", you should recycle the timer by calling :cpp:func:`gptimer_del_timer`. This allows the underlying HW timer to be used for other purposes. Before deleting a GPTimer handle, please disable it by :cpp:func:`gptimer_disable` in advance or make sure it has not enabled yet by :cpp:func:`gptimer_enable`.

Creating a GPTimer Handle with Resolution of 1 MHz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: c

   gptimer_handle_t gptimer = NULL;
   gptimer_config_t timer_config = {
       .c"
"lk_src = GPTIMER_CLK_SRC_DEFAULT,
       .direction = GPTIMER_COUNT_UP,
       .resolution_hz = 1 * 1000 * 1000, // 1MHz, 1 tick = 1us
   };
   ESP_ERROR_CHECK(gptimer_new_timer(&timer_config, &gptimer));

.. _set-and-get-count-value:

Set and Get Count Value


When the GPTimer is created, the internal counter will be reset to zero by default. The counter value can be updated asynchronously by :cpp:func:`gptimer_set_raw_count`. The maximum count value is dependent on the bit width of the hardwar"
"e timer, which is also reflected by the SOC macro :c:macro:`SOC_TIMER_GROUP_COUNTER_BIT_WIDTH`. When updating the raw count of an active timer, the timer will immediately start counting from the new value.

Count value can be retrieved by :cpp:func:`gptimer_get_raw_count`, at any time.

.. _set-up-alarm-action:

Set up Alarm Action


For most of the use cases of GPTimer, you should set up the alarm action before starting the timer, except for the simple wall-clock scenario, where a free running "
"timer is enough. To set up the alarm action, you should configure several members of :cpp:type:`gptimer_alarm_config_t` based on how you make use of the alarm event:

- :cpp:member:`gptimer_alarm_config_t::alarm_count` sets the target count value that triggers the alarm event. You should also take the counting direction into consideration when setting the alarm value. Specially, :cpp:member:`gptimer_alarm_config_t::alarm_count` and :cpp:member:`gptimer_alarm_config_t::reload_count` cannot be set"
" to the same value when :cpp:member:`gptimer_alarm_config_t::auto_reload_on_alarm` is true, as keeping reload with a target alarm count is meaningless.

- :cpp:member:`gptimer_alarm_config_t::reload_count` sets the count value to be reloaded when the alarm event happens. This configuration only takes effect when :cpp:member:`gptimer_alarm_config_t::auto_reload_on_alarm` is set to true.

- :cpp:member:`gptimer_alarm_config_t::auto_reload_on_alarm` flag sets whether to enable the auto-reload featu"
"re. If enabled, the hardware timer will reload the value of :cpp:member:`gptimer_alarm_config_t::reload_count` into counter immediately when an alarm event happens.

To make the alarm configurations take effect, you should call :cpp:func:`gptimer_set_alarm_action`. Especially, if :cpp:type:`gptimer_alarm_config_t` is set to ``NULL``, the alarm function will be disabled.

.. note::

    If an alarm value is set and the timer has already exceeded this value, the alarm will be triggered immediately"
".

.. _gptimer-register-event-callbacks:

Register Event Callbacks


After the timer starts up, it can generate a specific event (e.g., the ""Alarm Event"") dynamically. If you have some functions that should be called when the event happens, please hook your function to the interrupt service routine by calling :cpp:func:`gptimer_register_event_callbacks`. All supported event callbacks are listed in :cpp:type:`gptimer_event_callbacks_t`:

-  :cpp:member:`gptimer_event_callbacks_t::on_alarm` sets a"
" callback function for alarm events. As this function is called within the ISR context, you must ensure that the function does not attempt to block (e.g., by making sure that only FreeRTOS APIs with ``ISR`` suffix are called from within the function). The function prototype is declared in :cpp:type:`gptimer_alarm_cb_t`.

You can save your own context to :cpp:func:`gptimer_register_event_callbacks` as well, via the parameter ``user_data``. The user data will be directly passed to the callback fun"
"ction.

This function lazy installs the interrupt service for the timer but not enable it. So please call this function before :cpp:func:`gptimer_enable`, otherwise the :c:macro:`ESP_ERR_INVALID_STATE` error will be returned. See Section :ref:`enable-and-disable-timer` for more information.

.. _enable-and-disable-timer:

Enable and Disable Timer


Before doing IO control to the timer, you needs to enable the timer first, by calling :cpp:func:`gptimer_enable`. This function:

Calling :cpp:func:`"
"gptimer_disable` does the opposite, that is, put the timer driver back to the **init** state, disable the interrupts service and release the power management lock.

.. _start-and-stop-timer:

Start and Stop Timer


The basic IO operation of a timer is to start and stop. Calling :cpp:func:`gptimer_start` can make the internal counter work, while calling :cpp:func:`gptimer_stop` can make the counter stop working. The following illustrates how to start a timer with or without an alarm event.

Calli"
"ng :cpp:func:`gptimer_start` transits the driver state from **enable** to **run**, and vice versa. You need to make sure the start and stop functions are used in pairs, otherwise, the functions may return :c:macro:`ESP_ERR_INVALID_STATE`. Most of the time, this error means that the timer is already stopped or in the ""start protection"" state (i.e., :cpp:func:`gptimer_start` is called but not finished).

Start Timer as a Wall Clock
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: c

    ESP_ERROR_CHECK(gpti"
"mer_enable(gptimer));
    ESP_ERROR_CHECK(gptimer_start(gptimer));
    // Retrieve the timestamp at any time
    uint64_t count;
    ESP_ERROR_CHECK(gptimer_get_raw_count(gptimer, &count));

Trigger Period Events
~~~~~~~~~~~~~~~~~~~~~

.. code:: c

    typedef struct {
        uint64_t event_count;
    } example_queue_element_t;

    static bool example_timer_on_alarm_cb(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_ctx)
    {
        BaseType_t high_task_awoken = p"
"dFALSE;
        QueueHandle_t queue = (QueueHandle_t)user_ctx;
        // Retrieve the count value from event data
        example_queue_element_t ele = {
            .event_count = edata->count_value
        };
        // Optional: send the event data to other task by OS queue
        // Do not introduce complex logics in callbacks
        // Suggest dealing with event data in the main loop, instead of in this callback
        xQueueSendFromISR(queue, &ele, &high_task_awoken);
        // return"
" whether we need to yield at the end of ISR
        return high_task_awoken == pdTRUE;
    }

    gptimer_alarm_config_t alarm_config = {
        .reload_count = 0, // counter will reload with 0 on alarm event
        .alarm_count = 1000000, // period = 1s @resolution 1MHz
        .flags.auto_reload_on_alarm = true, // enable auto-reload
    };
    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &alarm_config));

    gptimer_event_callbacks_t cbs = {
        .on_alarm = example_timer_on_alarm_"
"cb, // register user callback
    };
    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &cbs, queue));
    ESP_ERROR_CHECK(gptimer_enable(gptimer));
    ESP_ERROR_CHECK(gptimer_start(gptimer));

Trigger One-Shot Event
~~~~~~~~~~~~~~~~~~~~~~

.. code:: c

    typedef struct {
        uint64_t event_count;
    } example_queue_element_t;

    static bool example_timer_on_alarm_cb(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_ctx)
    {
        BaseType_t hig"
"h_task_awoken = pdFALSE;
        QueueHandle_t queue = (QueueHandle_t)user_ctx;
        // Stop timer the sooner the better
        gptimer_stop(timer);
        // Retrieve the count value from event data
        example_queue_element_t ele = {
            .event_count = edata->count_value
        };
        // Optional: send the event data to other task by OS queue
        xQueueSendFromISR(queue, &ele, &high_task_awoken);
        // return whether we need to yield at the end of ISR
        ret"
"urn high_task_awoken == pdTRUE;
    }

    gptimer_alarm_config_t alarm_config = {
        .alarm_count = 1 * 1000 * 1000, // alarm target = 1s @resolution 1MHz
    };
    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &alarm_config));

    gptimer_event_callbacks_t cbs = {
        .on_alarm = example_timer_on_alarm_cb, // register user callback
    };
    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &cbs, queue));
    ESP_ERROR_CHECK(gptimer_enable(gptimer));
    ESP_ERROR_CHECK"
"(gptimer_start(gptimer));

Dynamic Alarm Update
~~~~~~~~~~~~~~~~~~~~

Alarm value can be updated dynamically inside the ISR handler callback, by changing :cpp:member:`gptimer_alarm_event_data_t::alarm_value`. Then the alarm value will be updated after the callback function returns.

.. code:: c

    typedef struct {
        uint64_t event_count;
    } example_queue_element_t;

    static bool example_timer_on_alarm_cb(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_ct"
"x)
    {
        BaseType_t high_task_awoken = pdFALSE;
        QueueHandle_t queue = (QueueHandle_t)user_data;
        // Retrieve the count value from event data
        example_queue_element_t ele = {
            .event_count = edata->count_value
        };
        // Optional: send the event data to other task by OS queue
        xQueueSendFromISR(queue, &ele, &high_task_awoken);
        // reconfigure alarm value
        gptimer_alarm_config_t alarm_config = {
            .alarm_count = eda"
"ta->alarm_value + 1000000, // alarm in next 1s
        };
        gptimer_set_alarm_action(timer, &alarm_config);
        // return whether we need to yield at the end of ISR
        return high_task_awoken == pdTRUE;
    }

    gptimer_alarm_config_t alarm_config = {
        .alarm_count = 1000000, // initial alarm target = 1s @resolution 1MHz
    };
    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &alarm_config));

    gptimer_event_callbacks_t cbs = {
        .on_alarm = example_timer_on"
"_alarm_cb, // register user callback
    };
    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &cbs, queue));
    ESP_ERROR_CHECK(gptimer_enable(gptimer));
    ESP_ERROR_CHECK(gptimer_start(gptimer, &alarm_config));


.. only:: SOC_ETM_SUPPORTED and SOC_TIMER_SUPPORT_ETM

    .. _gptimer-etm-event-and-task:

    ETM Event and Task
    

    GPTimer is able to generate various events that can interact with the :doc:`ETM ` module. The supported events are listed in the :cpp:type:`gptime"
"r_etm_event_type_t`. You can call :cpp:func:`gptimer_new_etm_event` to get the corresponding ETM event handle. Likewise, GPTimer exposes several tasks that can be triggered by other ETM events. The supported tasks are listed in the :cpp:type:`gptimer_etm_task_type_t`. You can call :cpp:func:`gptimer_new_etm_task` to get the corresponding ETM task handle.

    For how to connect the event and task to an ETM channel, please refer to the :doc:`ETM ` documentation.

    .. _gptimer-power-management:"
"

.. only:: not SOC_ETM_SUPPORTED or not SOC_TIMER_SUPPORT_ETM

    .. _gptimer-power-management:

Power Management


There are some power management strategies, which might turn off or change the frequency of GPTimer's source clock to save power consumption. For example, during DFS, APB clock will be scaled down. If light-sleep is also enabled, PLL and XTAL clocks will be powered off. Both of them can result in an inaccurate time keeping.

The driver can prevent the above situation from happeni"
"ng by creating different power management lock according to different clock source. The driver increases the reference count of that power management lock in the :cpp:func:`gptimer_enable` and decrease it in the :cpp:func:`gptimer_disable`. So we can ensure the clock source is stable between :cpp:func:`gptimer_enable` and :cpp:func:`gptimer_disable`.

.. _gptimer-iram-safe:

IRAM Safe


By default, the GPTimer interrupt will be deferred when the cache is disabled because of writing or erasing th"
"e flash. Thus the alarm interrupt will not get executed in time, which is not expected in a real-time application.

There is a Kconfig option :ref:`CONFIG_GPTIMER_ISR_IRAM_SAFE` that:

-  Enables the interrupt being serviced even when the cache is disabled
-  Places all functions that used by the ISR into IRAM [2]_
-  Places driver object into DRAM (in case it is mapped to PSRAM by accident)

This allows the interrupt to run while the cache is disabled, but comes at the cost of increased IRAM co"
"nsumption.

There is another Kconfig option :ref:`CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM` that can put commonly used IO control functions into IRAM as well. So, these functions can also be executable when the cache is disabled. These IO control functions are as follows:

- :cpp:func:`gptimer_start`
- :cpp:func:`gptimer_stop`
- :cpp:func:`gptimer_get_raw_count`
- :cpp:func:`gptimer_set_raw_count`
- :cpp:func:`gptimer_set_alarm_action`

.. _gptimer-thread-safety:

Thread Safety


All the APIs provided b"
"y the driver are guaranteed to be thread safe, which means you can call them from different RTOS tasks without protection by extra locks. The following functions are allowed to run under ISR context.

- :cpp:func:`gptimer_start`
- :cpp:func:`gptimer_stop`
- :cpp:func:`gptimer_get_raw_count`
- :cpp:func:`gptimer_set_raw_count`
- :cpp:func:`gptimer_get_captured_count`
- :cpp:func:`gptimer_set_alarm_action`

.. _gptimer-kconfig-options:

Kconfig Options


- :ref:`CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM` c"
"ontrols where to place the GPTimer control functions (IRAM or flash).
- :ref:`CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM` controls where to place the GPTimer ISR handler (IRAM or flash).
- :ref:`CONFIG_GPTIMER_ISR_IRAM_SAFE` controls whether the default ISR handler should be masked when the cache is disabled, see Section :ref:`gptimer-iram-safe` for more information.
- :ref:`CONFIG_GPTIMER_ENABLE_DEBUG_LOG` is used to enabled the debug log output. Enable this option will increase the firmware binary siz"
"e.

Application Examples


.. list::

    - Typical use cases of GPTimer are listed in the example :example:`peripherals/timer_group/gptimer`.
    :SOC_TIMER_SUPPORT_ETM: - GPTimer capture external event's timestamp, with the help of ETM module: :example:`peripherals/timer_group/gptimer_capture_hc_sr04`.

API Reference


.. include-build-file:: inc/gptimer.inc
.. include-build-file:: inc/gptimer_etm.inc
.. include-build-file:: inc/gptimer_types.inc
.. include-build-file:: inc/timer_types.inc

.."
" [1]
   Different ESP chip series might have different numbers of GPTimer instances. For more details, please refer to **{IDF_TARGET_NAME} Technical Reference Manual** > Chapter **Timer Group (TIMG)** [`PDF `__]. The driver does forbid you from applying for more timers, but it returns error when all available hardware resources are used up. Please always check the return value when doing resource allocation (e.g., :cpp:func:`gptimer_new_timer`).

.. [2]
   :cpp:member:`gptimer_event_callbacks_t:"
":on_alarm` callback and the functions invoked by the callback should also be placed in IRAM, please take care of them by yourself.
"
"Peripherals API




.. toctree::
    :maxdepth: 1

    :SOC_ADC_SUPPORTED: adc_oneshot
    :SOC_ADC_DMA_SUPPORTED: adc_continuous
    :SOC_ADC_SUPPORTED: adc_calibration
    :SOC_ANA_CMPR_SUPPORTED: ana_cmpr
    :SOC_CLK_TREE_SUPPORTED: clk_tree
    :SOC_DAC_SUPPORTED: dac
    :SOC_ECDSA_SUPPORTED: ecdsa
    :SOC_ETM_SUPPORTED: etm
    gpio
    gptimer
    :SOC_DEDICATED_GPIO_SUPPORTED: dedic_gpio
    :SOC_HMAC_SUPPORTED: hmac
    :SOC_DIG_SIGN_SUPPORTED: ds
    i2c
    :SOC_I2S_SUPPORTED: i2s
 "
"   lcd
    ledc
    :SOC_MCPWM_SUPPORTED: mcpwm
    :SOC_PARLIO_SUPPORTED: parlio
    :SOC_PCNT_SUPPORTED: pcnt
    :SOC_RMT_SUPPORTED: rmt
    :SOC_SDMMC_HOST_SUPPORTED or SOC_SDIO_SLAVE_SUPPORTED: sd_pullup_requirements
    :SOC_SDMMC_HOST_SUPPORTED: sdmmc_host
    sdspi_host
    :SOC_SDIO_SLAVE_SUPPORTED: sdio_slave
    :SOC_SDM_SUPPORTED: sdm
    spi_flash/index
    spi_master
    spi_slave
    :SOC_SPI_SUPPORT_SLAVE_HD_VER2: spi_slave_hd
    :SOC_JPEG_CODEC_SUPPORTED: jpeg
    :SOC_TEMP_SEN"
"SOR_SUPPORTED: temp_sensor
    :SOC_TOUCH_SENSOR_SUPPORTED: touch_pad
    :esp32s2: touch_element
    :SOC_TWAI_SUPPORTED: twai
    uart
    :SOC_USB_OTG_SUPPORTED: usb_device
    :SOC_USB_OTG_SUPPORTED: usb_host

Code examples for this API section are provided in the :example:`peripherals` directory of ESP-IDF examples.
"
"SDIO Card Slave Driver




Overview


.. only:: esp32

    The ESP32 SDIO Card host and slave peripherals share two sets of pins, as shown in the table below. The first set is usually occupied by the SPI0 bus, which is responsible for the SPI flash holding the code to run. This means the SDIO slave driver can only run on the second set of pins while the SDIO host is not using it.

The SDIO slave can run under three modes: SPI, 1-bit SD, and 4-bit SD modes. Based on the signals on the interface, "
"the device can determine the current mode and configure itself to adapt to that mode. Later, the slave driver can communicate with the slave device to properly handle commands and data transfers. According to the SDIO specification, the CMD and DAT0-3 signal lines should be pulled up whether in 1-bit SD, 4-bit SD or SPI mode.

Connections


.. only:: esp32

    .. list-table::
        :header-rows: 1
        :widths: 25 25 25 25
        :align: center
          - Corresponding Pins in SPI Mode
 "
"         - GPIO Number (Slot 1)
          - GPIO Number (Slot 2)
          - SCLK
          - 6
          - 14
          - MOSI
          - 11
          - 15
          - MISO
          - 7
          - 2
          - Interrupt
          - 8
          - 4
          - N.C. (pullup)
          - 9
          - 12
          - #CS
          - 10
          - 13

.. only:: esp32c6

    .. list-table::
        :header-rows: 1
        :widths: 30 40 30
        :align: center
          - Corresponding Pins in"
" SPI Mode
          - GPIO Number
          - SCLK
          - 19
          - MOSI
          - 18
          - MISO
          - 20
          - Interrupt
          - 21
          - N.C. (pullup)
          - 22
          - #CS
          - 23

- 1-bit SD mode: Connect CLK, CMD, DAT0, DAT1 pins, and the ground.
- 4-bit SD mode: Connect all pins, and the ground.
- SPI mode: Connect SCLK, MOSI, MISO, Interrupt, #CS pins, and the ground.

.. note::

  Please check if CMD and DATA lines DAT0-DAT3 of the "
"card are properly pulled up by 10 KOhm - 90 KOhm resistors, which should be ensured even in 1-bit mode or SPI mode. Most official modules do not offer these pullups internally. If you are using official development boards, check :ref:`compatibility_overview_espressif_hw_sdio` to see whether your development boards have such pullups.

.. only:: esp32

    .. note::

      Most official modules have conflicts on strapping pins with the SDIO slave function. If you are using an ESP32 module with 3.3"
" V flash inside, when you are developing on the module for the first time, you will need to perform an eFuse burn-in prior to development. This will adjust the pin configuration of the module to make the module compatible with SDIO functionality. See :ref:`compatibility_overview_espressif_hw_sdio` for details on how to configure this.

        Here is a list of modules/kits with 3.3 V flash:

        - Modules: All modules except ESP32-WROVER, ESP32-WROVER-I, ESP32-S3-WROOM-2, and please check `"
"Modules Overview `__ for module list
        - Kits: ESP32-PICO-KIT, ESP32-DevKitC (up to v4), ESP32-WROVER-KIT (v4.1 [also known as ESP32-WROVER-KIT-VB], v2, v1 [also known as DevKitJ v1])

        You can tell the version of your ESP23-WROVER-KIT version from the module on it: v4.1 are with ESP32-WROVER-B modules, v3 are with ESP32-WROVER modules, while v2 and v1 are with ESP32-WROOM-32 modules.

Refer to :doc:`sd_pullup_requirements` for more technical details of the pullups.

.. toctree::
  "
"  :hidden:

    sd_pullup_requirements

The host initializes the slave into SD mode by sending the CMD0 command with the DAT3 pin set to a high level. Alternatively, the host initializes the SPI mode by sending CMD0 with CS pin low, which is the same pin as DAT3.

After the initialization, the host can enable the 4-bit SD mode by writing CCCR register 0x07 by CMD52. All the bus detection processes are handled by the slave peripheral.

The host has to communicate with the slave by an ESP-slave-sp"
"ecific protocol.

The slave driver offers three services over Function 1 access by CMD52 and CMD53:

(1) sending and receiving FIFO
(2) 52 R/W registers (8-bit) shared by host and slave
(3) 16 interrupt sources (8 from host to slave, and 8 from slave to host)

Terminology


The SDIO slave driver uses the following terms:

- A transfer is initiated by a command token from the host and may consist of a response and multiple data blocks. The core mechanism of the {IDF_TARGET_NAME} SDIO slave driver"
" involves data exchange and communication through transfers.
- Sending: slave to host transfers.
- Receiving: host to slave transfers.

.. note::

  The register names in **{IDF_TARGET_NAME} Technical Reference Manual** > **SDIO Slave Controller** [`PDF `__] are organized from the host's perspective. For instance, ``RX`` registers indicate sending, while ``TX`` registers denote receiving. In our driver implementation, we've chosen not to utilize the terms ``TX`` or ``RX`` to prevent any potentia"
"l ambiguities.

- FIFO: A designated address within Function 1 that can be accessed using CMD53 commands for reading or writing substantial volumes of data. The address corresponds to the length intended for reading from or writing to the slave in a single transfer: **requested length** = 0x1F800 – address.
- Ownership: When the driver assumes ownership of a buffer, it means that the driver has the capability to perform random read/write operations on the buffer (often via DMA). The application "
"should not read/write the buffer until the ownership is returned to the application. If the application reads from a buffer owned by a receiving driver, the data read can be random; similarly, if the application writes to a buffer owned by a sending driver, the data sent may be corrupted.
- Requested length: The length requested in one transfer determined by the FIFO address.
- Transfer length: The length requested in one transfer determined by the CMD53 byte/block count field.

.. note::

  Req"
"uested length is different from the transfer length. In the context of {IDF_TARGET_NAME} SDIO slave DMA, the operation is based on the **requested length** rather than the **transfer length**. This means the DMA controller will process the data transfer according to the **requested length**, ensuring that only data within the **requested length** is transferred. The **transfer length** should be no shorter than the **requested length**, and the rest part is filled with 0 during sending or discar"
"d during receiving.

- Receiving buffer size: The buffer size is pre-defined between the host and the slave before communication starts. The slave application has to set the buffer size during initialization by the ``recv_buffer_size`` parameter in the ``sdio_slave_config_t`` structure.
- Interrupts: The {IDF_TARGET_NAME} SDIO slave supports interrupts in two directions: from host to slave (referred to as slave interrupts) and from slave to host (referred to as host interrupts). For more details"
", refer to :ref:`interrupts`.
- Registers: Specific addresses in Function 1 accessed by CMD52 or CMD53.

Communication with ESP SDIO Slave


The host should initialize the {IDF_TARGET_NAME} SDIO slave according to the standard SDIO initialization process (Sector 3.1.2 of `SDIO Simplified Specification `_), which is described briefly in :ref:`esp_slave_init`.

Furthermore, there is an {IDF_TARGET_NAME}-specific upper-level communication protocol built upon the foundation of CMD52/CMD53 to Functio"
"n 1. Within this particular communication protocol, the master and slave engage in data exchange and communication through the utilization of CMD52/CMD53 commands. For more detailed information, please consult the :ref:`esp_slave_protocol_layer` section.

There is also a component :doc:`/api-reference/protocols/esp_serial_slave_link` designed for {IDF_TARGET_NAME} master to communicate with {IDF_TARGET_NAME} SDIO slave. See example :example:`peripherals/sdio` when programming your host.


.. _in"
"terrupts:

Interrupts


There are interrupts from host to slave, and from slave to host to help communicating conveniently.

Slave Interrupts
""""""""""""""""""""""""""""""""

The host can trigger an interruption in the slave by writing a single bit to the 0x08D register. As soon as any bit within the register is set, an interrupt is generated, prompting the SDIO slave driver to invoke the callback function specified in the ``slave_intr_cb`` member of the ``sdio_slave_config_t`` structure.

.. note::

  The cal"
"lback function is called in the ISR. Do not use any delay, loop or blocking function in the callback, e.g., mutex.

Similar to the previous information, there's an alternative set of functions available. You can call ``sdio_slave_wait_int`` to wait for an interrupt within a certain time, or call ``sdio_slave_clear_int`` to clear interrupts from host. The callback function can work with the wait functions perfectly.

Host Interrupts
""""""""""""""""""""""""""""""

The slave can interrupt the host by an interrup"
"t line at certain time, which is level-sensitive, i.e., the interrupt signal can be triggered by detecting the level change of the interrupt line. When the host see the interrupt line pulled down, it may read the slave interrupt status register, to see the interrupt source. Host can clear interrupt bits, or choose to disable a interrupt source. The interrupt line holds active until all the sources are cleared or disabled.

There are several dedicated interrupt sources as well as general-purpose "
"sources. see ``sdio_slave_hostint_t`` for more information.

Shared Registers


There are 52 R/W shared registers (8-bit) to share information between host and slave. The slave can write or read the registers at any time by ``sdio_slave_read_reg`` and ``sdio_slave_write_reg``. The host can access (R/W) the register by CMD52 or CMD53.

Receiving FIFO


When the host is going to send the slave some packets, it has to check whether the slave is ready to receive by reading the buffer number of slave"
".

To allow the host sending data to the slave, the application has to load buffers to the slave driver by the following steps:

   The difference between two APIs is that, ``sdio_slave_recv_packet`` gives more information about packet, which can consist of several buffers.

   When ``ESP_ERR_NOT_FINISHED`` is returned by this API, you should call this API iteratively until the return value is ``ESP_OK``. All the continuous buffers returned with ``ESP_ERR_NOT_FINISHED``, together with the last b"
"uffer returned with ``ESP_OK``, belong to one packet from the host.

   Call ``sdio_slave_recv_get_buf`` to get the address of the received data, and the actual length received in each buffer. The packet length is the sum of received length of all the buffers in the packet.

   If the host never send data longer than the Receiving buffer size, or you do not care about the packet boundary (e.g., the data is only a byte stream), you can call the simpler version ``sdio_slave_recv`` instead.

.. not"
"e::

  To minimize data copying overhead, the driver itself does not maintain any internal buffer; it is the responsibility of the application to promptly provide new buffers. The DMA system automatically stores received data into these buffers.

Sending FIFO


Each time the slave has data to send, it raises an interrupt, and the host requests the packet length. There are two sending modes:

- Stream Mode: When a buffer is loaded into the driver, the buffer length is included into the packet len"
"gth requested by host in the incoming communications. This is irrespective of whether previous packets have been sent or not. In other words, the length of the newly loaded buffer is included into the length of the packet requested by the host, even if there are previously unsent packets. This enables the host to receive data from several buffers in a single transfer.
- Packet Mode: The packet length is updated packet by packet, and only when previous packet is sent. This means that the host can"
" only get data of one buffer in one transfer.

.. note::

  To avoid overhead from copying data, the driver itself does not have any buffer inside. Namely, the DMA takes data directly from the buffer provided by the application. The application should not touch the buffer until the sending is finished, so as to ensure that the data is transferred correctly.

The sending mode can be set in the ``sending_mode`` member of ``sdio_slave_config_t``, and the buffer numbers can be set in the ``send_queu"
"e_size``. All the buffers are restricted to be no larger than 4092 bytes. Though in the stream mode, several buffers can be sent in one transfer, each buffer is still counted as one in the queue.

The application can call ``sdio_slave_transmit`` to send packets. In this case, the function returns when the transfer is successfully done, so the queue is not fully used. When higher efficiency is required, the application can use the following functions instead:

   - If non-blocking call is needed,"
" set ``wait=0``.
   - If the ``wait`` is not ``portMAX_DELAY`` (wait until success), application has to check the result to know whether the data is put in to the queue or discard.

There are several ways to use the ``arg`` in the queue parameter:

          typedef struct {
              uint8_t* buffer;
              size_t   size;
              int      id;
          }sdio_transfer_t;

          //and send as:
          sdio_transfer_t trans = {
              .buffer = ADDRESS_TO_SEND,
      "
"        .size = 8,
              .id = 3,  //the 3rd transfer so far
          };
          sdio_slave_send_queue(trans.buffer, trans.size, &trans, portMAX_DELAY);

          //... maybe more transfers are sent here

          //and deal with finished transfer as:
          sdio_transfer_t* arg = NULL;
          sdio_slave_send_get_finished((void**)&arg, portMAX_DELAY);
          ESP_LOGI(""tag"", ""(%d) successfully send %d bytes of %p"", arg->id, arg->size, arg->buffer);
          some_post_callba"
"ck(arg); //do more things

           uint8_t buffer[256]={1,2,3,4,5,6,7,8};
           sdio_slave_buf_handle_t handle = sdio_slave_recv_register_buf(buffer);
           sdio_slave_send_queue(buffer, 8, handle, portMAX_DELAY);

           //... maybe more transfers are sent here

           //and load finished buffer to receive as
           sdio_slave_buf_handle_t handle = NULL;
           sdio_slave_send_get_finished((void**)&handle, portMAX_DELAY);
           sdio_slave_recv_load_buf(handle);"
"

       For more about this, see :example:`peripherals/sdio`.


Application Example


Slave/master communication: :example:`peripherals/sdio`.

API Reference


.. include-build-file:: inc/sdio_slave_types.inc
.. include-build-file:: inc/sdio_slave.inc
"
"SPI Master Driver




SPI Master driver is a program that controls {IDF_TARGET_NAME}'s General Purpose SPI (GP-SPI) peripheral(s) when it functions as a master.

.. only:: esp32

    .. note::

        SPI1 is not a GP-SPI. SPI Master driver also supports SPI1 but with quite a few limitations, see :ref:`spi_master_on_spi1_bus`.

For more hardware information about the GP-SPI peripheral(s), see **{IDF_TARGET_NAME} Technical Reference Manual** > **SPI Controller** [`PDF `__].

Terminology


The te"
"rms used in relation to the SPI Master driver are given in the table below.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Definition
     - The SPI controller peripheral inside {IDF_TARGET_NAME} initiates SPI transmissions over the bus and acts as an SPI Master.
     - SPI slave Device. An SPI bus may be connected to one or more Devices. Each Device shares the MOSI, MISO, and SCLK signals but is only active on the bus when the Host asserts the Device's individual CS line.
     - A"
" signal bus, common to all Devices connected to one Host. In general, a bus includes the following lines: MISO, MOSI, SCLK, one or more CS lines, and, optionally, QUADWP and QUADHD. So Devices are connected to the same lines, with the exception that each Device has its own CS line. Several Devices can also share one CS line if connected in a daisy-chain manner.
     - Master Out, Slave In, a.k.a. D. Data transmission from a Host to Device. Also data0 signal in Octal/OPI mode.
     - Master In, S"
"lave Out, a.k.a. Q. Data transmission from a Device to Host. Also data1 signal in Octal/OPI mode.
     - Serial Clock. The oscillating signal generated by a Host keeps the transmission of data bits in sync.
     - Chip Select. Allows a Host to select individual Device(s) connected to the bus in order to send or receive data.
     - Write Protect signal. Used for 4-bit (qio/qout) transactions. Also for the data2 signal in Octal/OPI mode.
     - Hold signal. Used for 4-bit (qio/qout) transactions."
" Also for the data3 signal in Octal/OPI mode.
     - Data4 signal in Octal/OPI mode.
     - Data5 signal in Octal/OPI mode.
     - Data6 signal in Octal/OPI mode.
     - Data7 signal in Octal/OPI mode.
     - The action of activating a line.
     - The action of returning the line back to inactive (back to idle) status.
     - One instance of a Host asserting a CS line, transferring data to and from a Device, and de-asserting the CS line. Transactions are atomic, which means they can never be in"
"terrupted by another transaction.
     - Edge of the clock at which the source register **launches** the signal onto the line.
     - Edge of the clock at which the destination register **latches in** the signal.


Driver Features


The SPI Master driver governs the communications between Hosts and Devices. The driver supports the following features:

- Multi-threaded environments
- Transparent handling of DMA transfers while reading and writing data
- Automatic time-division multiplexing of dat"
"a coming from different Devices on the same signal bus, see :ref:`spi_bus_lock`.

.. warning::

    The SPI Master driver allows multiple Devices to be connected on a same SPI bus (sharing a single {IDF_TARGET_NAME} SPI peripheral). As long as each Device is accessed by only one task, the driver is thread-safe. However, if multiple tasks try to access the same SPI Device, the driver is **not thread-safe**. In this case, it is recommended to either:

    - Refactor your application so that each S"
"PI peripheral is only accessed by a single task at a time. You can use :cpp:member:`spi_bus_config_t::isr_cpu_id` to register the SPI ISR to the same core as SPI peripheral-related tasks to ensure thread safety.
    - Add a mutex lock around the shared Device using :c:macro:`xSemaphoreCreateMutex`.

.. toctree::
   :hidden:

   SPI Features 

SPI Transactions


An SPI bus transaction consists of five phases which can be found in the table below. Any of these phases can be skipped.

{IDF_TARGET_A"
"DDR_LEN:default=""32"", esp32=""64""}

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - In this phase, a command (0-16 bit) is written to the bus by the Host.
     - In this phase, an address (0-{IDF_TARGET_ADDR_LEN} bit) is transmitted over the bus by the Host.
     - This phase is configurable and is used to meet the timing requirements.
     - Host sends data to a Device. This data follows the optional command and address phases and is indistinguishable from them at "
"the electrical level.
     - Device sends data to its Host.

.. todo::

   Add a package diagram.


The attributes of a transaction are determined by the bus configuration structure :cpp:type:`spi_bus_config_t`, Device configuration structure :cpp:type:`spi_device_interface_config_t`, and transaction configuration structure :cpp:type:`spi_transaction_t`.

An SPI Host can send full-duplex transactions, during which the Read and Write phases occur simultaneously. The total transaction length is de"
"termined by the sum of the following members:

- :cpp:member:`spi_device_interface_config_t::command_bits`
- :cpp:member:`spi_device_interface_config_t::address_bits`
- :cpp:member:`spi_transaction_t::length`

While the member :cpp:member:`spi_transaction_t::rxlength` only determines the length of data received into the buffer.

In half-duplex transactions, the Read and Write phases are not simultaneous (one direction at a time). The lengths of the Write and Read phases are determined by :cpp:me"
"mber:`spi_transaction_t::length` and :cpp:member:`spi_transaction_t::rxlength` respectively.

The Command and Address phases are optional, as not every SPI Device requires a command and/or address. This is reflected in the Device's configuration: if :cpp:member:`spi_device_interface_config_t::command_bits` and/or :cpp:member:`spi_device_interface_config_t::address_bits` are set to zero, no Command or Address phase will occur.

The Read and Write phases can also be optional, as not every transact"
"ion requires both writing and reading data. If :cpp:member:`spi_transaction_t::rx_buffer` is ``NULL`` and :c:macro:`SPI_TRANS_USE_RXDATA` is not set, the Read phase is skipped. If :cpp:member:`spi_transaction_t::tx_buffer` is ``NULL`` and :c:macro:`SPI_TRANS_USE_TXDATA` is not set, the Write phase is skipped.

The driver supports two types of transactions: interrupt transactions and polling transactions. The programmer can choose to use a different transaction type per Device. If your Device req"
"uires both transaction types, see :ref:`mixed_transactions`.


.. _interrupt_transactions:

Interrupt Transactions


Interrupt transactions blocks the transaction routine until the transaction completes, thus allowing the CPU to run other tasks.

An application task can queue multiple transactions, and the driver automatically handles them one by one in the interrupt service routine (ISR). It allows the task to switch to other procedures until all the transactions are complete.


.. _polling_tra"
"nsactions:

Polling Transactions


Polling transactions do not use interrupts. The routine keeps polling the SPI Host's status bit until the transaction is finished.

All the tasks that use interrupt transactions can be blocked by the queue. At this point, they need to wait for the ISR to run twice before the transaction is finished. Polling transactions save time otherwise spent on queue handling and context switching, which results in smaller transaction duration. The disadvantage is that the "
"CPU is busy while these transactions are in progress.

The :cpp:func:`spi_device_polling_end` routine needs an overhead of at least 1 µs to unblock other tasks when the transaction is finished. It is strongly recommended to wrap a series of polling transactions using the functions :cpp:func:`spi_device_acquire_bus` and :cpp:func:`spi_device_release_bus` to avoid the overhead. For more information, see :ref:`bus_acquiring`.

.. _transaction-line-mode:

Transaction Line Mode


Supported line modes"
" for {IDF_TARGET_NAME} are listed as follows, to make use of these modes, set the member ``flags`` in the struct :cpp:type:`spi_transaction_t` as shown in the ``Transaction Flag`` column. If you want to check if corresponding IO pins are set or not, set the member ``flags`` in the :cpp:type:`spi_bus_config_t` as shown in the ``Bus IO setting Flag`` column.


.. only:: not SOC_SPI_SUPPORT_OCT

    .. list-table::
       :widths: 30 40 40 40 50 50
       :header-rows: 1
         - Command Line Wid"
"th
         - Address Line Width
         - Data Line Width
         - Transaction Flag
         - Bus IO Setting Flag
         - 1
         - 1
         - 1
         - 0
         - 0
         - 1
         - 1
         - 2
         - SPI_TRANS_MODE_DIO
         - SPICOMMON_BUSFLAG_DUAL
         - 1
         - 2
         - 2
         - SPI_TRANS_MODE_DIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_DUAL
         - 1
         - 1
         - 4
         - SPI_TRANS_MODE_QIO
     "
"    - SPICOMMON_BUSFLAG_QUAD
         - 1
         - 4
         - 4
         - SPI_TRANS_MODE_QIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_QUAD

.. only:: SOC_SPI_SUPPORT_OCT

    .. list-table::
       :widths: 30 40 40 40 50 50
       :header-rows: 1
         - Command Line Width
         - Address Line Width
         - Data Line Width
         - Transaction Flag
         - Bus IO Setting Flag
         - 1
         - 1
         - 1
         - 0
         - 0
         - 1"
"
         - 1
         - 2
         - SPI_TRANS_MODE_DIO
         - SPICOMMON_BUSFLAG_DUAL
         - 1
         - 2
         - 2
         - SPI_TRANS_MODE_DIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_DUAL
         - 1
         - 1
         - 4
         - SPI_TRANS_MODE_QIO
         - SPICOMMON_BUSFLAG_QUAD
         - 1
         - 4
         - 4
         - SPI_TRANS_MODE_QIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_QUAD
         - 1
         - 1
  "
"       - 8
         - SPI_TRANS_MODE_OCT
         - SPICOMMON_BUSFLAG_OCTAL
         - 8
         - 8
         - 8
         - SPI_TRANS_MODE_OCT
           SPI_TRANS_MULTILINE_ADDR
           SPI_TRANS_MULTILINE_CMD
         - SPICOMMON_BUSFLAG_OCTAL

Command and Address Phases


During the Command and Address phases, the members :cpp:member:`spi_transaction_t::cmd` and :cpp:member:`spi_transaction_t::addr` are sent to the bus, nothing is read at this time. The default lengths of the Command and"
" Address phases are set in :cpp:type:`spi_device_interface_config_t` by calling :cpp:func:`spi_bus_add_device`. If the flags :c:macro:`SPI_TRANS_VARIABLE_CMD` and :c:macro:`SPI_TRANS_VARIABLE_ADDR` in the member :cpp:member:`spi_transaction_t::flags` are not set, the driver automatically sets the length of these phases to default values during Device initialization.

If the lengths of the Command and Address phases need to be variable, declare the struct :cpp:type:`spi_transaction_ext_t`, set th"
"e flags :c:macro:`SPI_TRANS_VARIABLE_CMD` and/or :c:macro:`SPI_TRANS_VARIABLE_ADDR` in the member :cpp:member:`spi_transaction_ext_t::base` and configure the rest of base as usual. Then the length of each phase will be equal to :cpp:member:`spi_transaction_ext_t::command_bits` and :cpp:member:`spi_transaction_ext_t::address_bits` set in the struct :cpp:type:`spi_transaction_ext_t`.

If the Command and Address phase need to have the same number of lines as the data phase, you need to set ``SPI_TR"
"ANS_MULTILINE_CMD`` and/or ``SPI_TRANS_MULTILINE_ADDR`` to the ``flags`` member in the struct :cpp:type:`spi_transaction_t`. Also see :ref:`transaction-line-mode`.


Write and Read Phases


Normally, the data that needs to be transferred to or from a Device is read from or written to a chunk of memory indicated by the members :cpp:member:`spi_transaction_t::rx_buffer` and :cpp:member:`spi_transaction_t::tx_buffer`. If DMA is enabled for transfers, the buffers are required to be:

If these requir"
"ements are not satisfied, the transaction efficiency will be affected due to the allocation and copying of temporary buffers.

If using more than one data line to transmit, please set ``SPI_DEVICE_HALFDUPLEX`` flag for the member ``flags`` in the struct :cpp:type:`spi_device_interface_config_t`. And the member ``flags`` in the struct :cpp:type:`spi_transaction_t` should be set as described in :ref:`transaction-line-mode`.

.. only:: esp32

    .. note::

        Half-duplex transactions with bot"
"h Read and Write phases are not supported when using DMA. For details and workarounds, see :ref:`spi_known_issues`.

.. only:: not SOC_SPI_HD_BOTH_INOUT_SUPPORTED

    .. note::

        Half-duplex transactions with both Read and Write phases are not supported. Please use full duplex mode.

.. _bus_acquiring:

Bus Acquiring


Sometimes you might want to send SPI transactions exclusively and continuously so that it takes as little time as possible. For this, you can use bus acquiring, which help"
"s to suspend transactions (both polling or interrupt) to other Devices until the bus is released. To acquire and release a bus, use the functions :cpp:func:`spi_device_acquire_bus` and :cpp:func:`spi_device_release_bus`.


Driver Usage


.. todo::

   Organize the Driver Usage into subsections that will reflect the general user experience of the users, e.g.,

   Configuration

   Add stuff about the configuration API here, the various options in configuration (e.g., configure for interrupt vs. p"
"olling), and optional configuration

   Transactions

   Describe how to execute a normal transaction (i.e., where data is larger than 32 bits). Describe how to configure between big and little-endian.

   - Add a sub-sub section on how to optimize when transmitting less than 32 bits
   - Add a sub-sub section on how to transmit mixed transactions to the same Device


- Initialize an SPI bus by calling the function :cpp:func:`spi_bus_initialize`. Make sure to set the correct I/O pins in the stru"
"ct :cpp:type:`spi_bus_config_t`. Set the signals that are not needed to ``-1``.

- Register a Device connected to the bus with the driver by calling the function :cpp:func:`spi_bus_add_device`. Make sure to configure any timing requirements the Device might need with the parameter ``dev_config``. You should now have obtained the Device's handle which will be used when sending a transaction to it.

- To interact with the Device, fill one or more :cpp:type:`spi_transaction_t` structs with any tran"
"saction parameters required. Then send the structs either using a polling transaction or an interrupt transaction:

    - :ref:`Interrupt `
        Either queue all transactions by calling the function :cpp:func:`spi_device_queue_trans` and, at a later time, query the result using the function :cpp:func:`spi_device_get_trans_result`, or handle all requests synchronously by feeding them into :cpp:func:`spi_device_transmit`.

    - :ref:`Polling `
        Call the function :cpp:func:`spi_device_po"
"lling_transmit` to send polling transactions. Alternatively, if you want to insert something in between, send the transactions by using :cpp:func:`spi_device_polling_start` and :cpp:func:`spi_device_polling_end`.

- (Optional) To perform back-to-back transactions with a Device, call the function :cpp:func:`spi_device_acquire_bus` before sending transactions and :cpp:func:`spi_device_release_bus` after the transactions have been sent.

- (Optional) To remove a certain Device from the bus, call :c"
"pp:func:`spi_bus_remove_device` with the Device handle as an argument.

- (Optional) To remove the driver from the bus, make sure no more devices are attached and call :cpp:func:`spi_bus_free`.

The example code for the SPI Master driver can be found in the :example:`peripherals/spi_master` directory of ESP-IDF examples.


Transactions with Data Not Exceeding 32 Bits


When the transaction data size is equal to or less than 32 bits, it will be sub-optimal to allocate a buffer for the data. The d"
"ata can be directly stored in the transaction struct instead. For transmitted data, it can be achieved by using the :cpp:member:`spi_transaction_t::tx_data` member and setting the :c:macro:`SPI_TRANS_USE_TXDATA` flag on the transmission. For received data, use :cpp:member:`spi_transaction_t::rx_data` and set :c:macro:`SPI_TRANS_USE_RXDATA`. In both cases, do not touch the :cpp:member:`spi_transaction_t::tx_buffer` or :cpp:member:`spi_transaction_t::rx_buffer` members, because they use the same m"
"emory locations as :cpp:member:`spi_transaction_t::tx_data` and :cpp:member:`spi_transaction_t::rx_data`.


Transactions with Integers Other than ``uint8_t``


An SPI Host reads and writes data into memory byte by byte. By default, data is sent with the most significant bit (MSB) first, as LSB is first used in rare cases. If a value of fewer than 8 bits needs to be sent, the bits should be written into memory in the MSB first manner.

For example, if ``0b00010`` needs to be sent, it should be wr"
"itten into a ``uint8_t`` variable, and the length for reading should be set to 5 bits. The Device will still receive 8 bits with 3 additional ""random"" bits, so the reading must be performed correctly.

On top of that, {IDF_TARGET_NAME} is a little-endian chip, which means that the least significant byte of ``uint16_t`` and ``uint32_t`` variables is stored at the smallest address. Hence, if ``uint16_t`` is stored in memory, bits [7:0] are sent first, followed by bits [15:8].

For cases when the d"
"ata to be transmitted has a size differing from ``uint8_t`` arrays, the following macros can be used to transform data to the format that can be sent by the SPI driver directly:

- :c:macro:`SPI_SWAP_DATA_TX` for data to be transmitted
- :c:macro:`SPI_SWAP_DATA_RX` for data received


.. _mixed_transactions:

Notes on Sending Mixed Transactions to the Same Device


To reduce coding complexity, send only one type of transaction (interrupt or polling) to one Device. However, you still can send bot"
"h interrupt and polling transactions alternately. The notes below explain how to do this.

The polling transactions should be initiated only after all the polling and interrupt transactions are finished.

Since an unfinished polling transaction blocks other transactions, please do not forget to call the function :cpp:func:`spi_device_polling_end` after :cpp:func:`spi_device_polling_start` to allow other transactions or to allow other Devices to use the bus. Remember that if there is no need to s"
"witch to other tasks during your polling transaction, you can initiate a transaction with :cpp:func:`spi_device_polling_transmit` so that it will be ended automatically.

In-flight polling transactions are disturbed by the ISR operation to accommodate interrupt transactions. Always make sure that all the interrupt transactions sent to the ISR are finished before you call :cpp:func:`spi_device_polling_start`. To do that, you can keep calling :cpp:func:`spi_device_get_trans_result` until all the t"
"ransactions are returned.

To have better control of the calling sequence of functions, send mixed transactions to the same Device only within a single task.

.. only:: esp32

    .. _spi_master_on_spi1_bus:

    Notes on Using the SPI Master Driver on SPI1 Bus
    

    .. note::

        Though the :ref:`spi_bus_lock` feature makes it possible to use SPI Master driver on the SPI1 bus, it is still tricky and needs a lot of special treatment. It is a feature for advanced developers.

    To use "
"SPI Master driver on SPI1 bus, you have to take care of two problems:

       SPI1 bus is shared among Devices and the cache for data (code) in the flash as well as the PSRAM. The cache should be disabled when other drivers are operating on the SPI1 bus. Hence the data (code) in the flash as well as the PSRAM cannot be fetched while the driver acquires the SPI1 bus by:

       - Explicit bus acquiring between :cpp:func:`spi_device_acquire_bus` and :cpp:func:`spi_device_release_bus`.
       - Imp"
"licit bus acquiring between :cpp:func:`spi_device_polling_start` and :cpp:func:`spi_device_polling_end` (or inside :cpp:func:`spi_device_polling_transmit`).

       During the time above, all other tasks and most ISRs will be disabled (see :ref:`iram-safe-interrupt-handlers`). Application code and data used by the current task should be placed in internal memory (DRAM or IRAM), or already in the ROM. Access to external memory (flash code, const data in the flash, and static/heap data in the PSRA"
"M) will cause a ``Cache disabled but cached memory region accessed`` exception. For differences between IRAM, DRAM, and flash cache, please refer to the :ref:`application memory layout ` documentation.

       To place functions into the IRAM, you can either:

              IRAM_ATTR void foo(void) { }

          Please note that when a function is inlined, it will follow its caller's segment, and the attribute will not take effect. You may need to use ``NOLINE_ATTR`` to avoid this. Please also "
"note that the compiler may transform some code into a lookup table in the const data, so ``noflash_text`` is not safe.

       Please do take care that the optimization level may affect the compiler behavior of inline, or transform some code into a lookup table in the const data, etc.

       To place data into the DRAM, you can either:

              DRAM_ATTR int g_foo = 3;

    Please also see the example :example:`peripherals/spi_master/hd_eeprom`.


GPIO Matrix and IO_MUX


.. only:: esp32
"
"
    Most of ESP32's peripheral signals have a direct connection to their dedicated IO_MUX pins. However, the signals can also be routed to any other available pins using the less direct GPIO matrix. If at least one signal is routed through the GPIO matrix, then all signals will be routed through it.

    The GPIO matrix introduces flexibility of routing but also brings the following disadvantages:

    - Increases the input delay of the MISO signal, which makes MISO setup time violations more l"
"ikely. If SPI needs to operate at high speeds, use dedicated IO_MUX pins.
    - Allows signals with clock frequencies only up to 40 MHz, as opposed to 80 MHz if IO_MUX pins are used.

    .. note::

        For more details about the influence of the MISO input delay on the maximum clock frequency, see :ref:`timing_considerations`.

    The IO_MUX pins for SPI buses are given below.

    .. list-table::
       :widths: 40 20 20
       :header-rows: 1
         - SPI 2 (GPIO Number)
         - SPI"
" 3 (GPIO Number)
         - 15
         - 5
         - 14
         - 18
         - 12
         - 19
         - 13
         - 23
         - 2
         - 22
         - 4
         - 21

.. only:: not esp32

    {IDF_TARGET_SPI2_IOMUX_PIN_CS:default=""N/A"",   esp32s2=""10"", esp32s3=""10"", esp32c2=""10"", esp32c3=""10"", esp32c6=""16"", esp32h2=""1"", esp32p4=""7"",  esp32c5=""12""}
    {IDF_TARGET_SPI2_IOMUX_PIN_CLK:default=""N/A"",  esp32s2=""12"", esp32s3=""12"", esp32c2=""6"",  esp32c3=""6"",  esp32c6=""6"",  esp32h2=""4"", "
"esp32p4=""9"",  esp32c5=""6""}
    {IDF_TARGET_SPI2_IOMUX_PIN_MOSI:default=""N/A"", esp32s2=""11""  esp32s3=""11"", esp32c2=""7""   esp32c3=""7"",  esp32c6=""7"",  esp32h2=""5"", esp32p4=""8"",  esp32c5=""7""}
    {IDF_TARGET_SPI2_IOMUX_PIN_MISO:default=""N/A"", esp32s2=""13""  esp32s3=""13"", esp32c2=""2""   esp32c3=""2"",  esp32c6=""2"",  esp32h2=""0"", esp32p4=""10"", esp32c5=""2""}
    {IDF_TARGET_SPI2_IOMUX_PIN_HD:default=""N/A"",   esp32s2=""9""   esp32s3=""9"",  esp32c2=""4""   esp32c3=""4"",  esp32c6=""4"",  esp32h2=""3"", esp32p4=""6"",  esp"
"32c5=""4""}
    {IDF_TARGET_SPI2_IOMUX_PIN_WP:default=""N/A"",   esp32s2=""14""  esp32s3=""14"", esp32c2=""5""   esp32c3=""5"",  esp32c6=""5"",  esp32h2=""2"", esp32p4=""11"", esp32c5=""5""}

    Most of the chip's peripheral signals have a direct connection to their dedicated IO_MUX pins. However, the signals can also be routed to any other available pins using the less direct GPIO matrix. If at least one signal is routed through the GPIO matrix, then all signals will be routed through it.

    When an SPI Host is"
" set to 80 MHz or lower frequencies, routing SPI pins via the GPIO matrix will behave the same compared to routing them via IOMUX.

    The IO_MUX pins for SPI buses are given below.

    .. list-table::
       :widths: 40 30
       :header-rows: 1
         - GPIO Number (SPI2)
         - {IDF_TARGET_SPI2_IOMUX_PIN_CS}
         - {IDF_TARGET_SPI2_IOMUX_PIN_CLK}
         - {IDF_TARGET_SPI2_IOMUX_PIN_MISO}
         - {IDF_TARGET_SPI2_IOMUX_PIN_MOSI}
         - {IDF_TARGET_SPI2_IOMUX_PIN_WP}
      "
"   - {IDF_TARGET_SPI2_IOMUX_PIN_HD}

.. [1] Only the first Device attached to the bus can use the CS0 pin.

.. _speed_considerations:

Transfer Speed Considerations


There are three factors limiting the transfer speed:

- Transaction interval
- SPI clock frequency
- Cache miss of SPI functions, including callbacks

The main parameter that determines the transfer speed for large transactions is clock frequency. For multiple small transactions, the transfer speed is mostly determined by the lengt"
"h of transaction intervals.


Transaction Duration


{IDF_TARGET_TRANS_TIME_INTR_DMA:default=""N/A"", esp32=""28"", esp32s2=""23"", esp32c3=""28"", esp32s3=""26"", esp32c2=""42"", esp32c6=""34"", esp32h2=""58"", esp32c5=""27""}
{IDF_TARGET_TRANS_TIME_POLL_DMA:default=""N/A"", esp32=""10"", esp32s2=""9"",  esp32c3=""10"", esp32s3=""11"", esp32c2=""17"", esp32c6=""17"", esp32h2=""28"", esp32c5=""16""}
{IDF_TARGET_TRANS_TIME_INTR_CPU:default=""N/A"", esp32=""25"", esp32s2=""22"", esp32c3=""27"", esp32s3=""24"", esp32c2=""40"", esp32c6=""32"", esp3"
"2h2=""54"", esp32c5=""24""}
{IDF_TARGET_TRANS_TIME_POLL_CPU:default=""N/A"", esp32=""8"",  esp32s2=""8"",  esp32c3=""9"",  esp32s3=""9"",  esp32c2=""15"", esp32c6=""15"", esp32h2=""24"", esp32c5=""13""}

Transaction duration includes setting up SPI peripheral registers, copying data to FIFOs or setting up DMA links, and the time for SPI transactions.

Interrupt transactions allow appending extra overhead to accommodate the cost of FreeRTOS queues and the time needed for switching between tasks and the ISR.

For **int"
"errupt transactions**, the CPU can switch to other tasks when a transaction is in progress. This saves CPU time but increases the transaction duration. See :ref:`interrupt_transactions`. For **polling transactions**, it does not block the task but allows to do polling when the transaction is in progress. For more information, see :ref:`polling_transactions`.

If DMA is enabled, setting up the linked list requires about 2 µs per transaction. When a master is transferring data, it automatically re"
"ads the data from the linked list. If DMA is not enabled, the CPU has to write and read each byte from the FIFO by itself. Usually, this is faster than 2 µs, but the transaction length is limited to 64 bytes for both write and read.

The typical transaction duration for one byte of data is given below.

- Interrupt Transaction via DMA: {IDF_TARGET_TRANS_TIME_INTR_DMA} µs.
- Interrupt Transaction via CPU: {IDF_TARGET_TRANS_TIME_INTR_CPU} µs.
- Polling Transaction via DMA: {IDF_TARGET_TRANS_TIME_P"
"OLL_DMA} µs.
- Polling Transaction via CPU: {IDF_TARGET_TRANS_TIME_POLL_CPU} µs.

Note that these data are tested with :ref:`CONFIG_SPI_MASTER_ISR_IN_IRAM` enabled. SPI transaction related code are placed in the internal memory. If this option is turned off (for example, for internal memory optimization), the transaction duration may be affected.

SPI Clock Frequency


The clock source of the GPSPI peripherals can be selected by setting :cpp:member:`spi_device_handle_t::cfg::clock_source`. You c"
"an refer to :cpp:type:`spi_clock_source_t` to know the supported clock sources.

By default driver sets :cpp:member:`spi_device_handle_t::cfg::clock_source` to ``SPI_CLK_SRC_DEFAULT``. This usually stands for the highest frequency among GPSPI clock sources. Its value is different among chips.

The actual clock frequency of a Device may not be exactly equal to the number you set, it is re-calculated by the driver to the nearest hardware-compatible number, and not larger than the clock frequency o"
"f the clock source. You can call :cpp:func:`spi_device_get_actual_freq` to know the actual frequency computed by the driver.

The theoretical maximum transfer speed of the Write or Read phase can be calculated according to the table below:

.. only:: not SOC_SPI_SUPPORT_OCT

    .. list-table::
       :widths: 40 30
       :header-rows: 1
         - Speed (Bps)
         - *SPI Frequency / 8*
         - *SPI Frequency / 4*
         - *SPI Frequency / 2*

.. only:: SOC_SPI_SUPPORT_OCT

    .. list"
"-table::
       :widths: 40 30
       :header-rows: 1
         - Speed (Bps)
         - *SPI Frequency / 8*
         - *SPI Frequency / 4*
         - *SPI Frequency / 2*
         - *SPI Frequency*

The transfer speed calculation of other phases (Command, Address, Dummy) is similar.

.. only:: esp32

    If the clock frequency is too high, the use of some functions might be limited. See :ref:`timing_considerations`.

Cache Missing


The default config puts only the ISR into the IRAM. Other SPI-re"
"lated functions, including the driver itself and the callback, might suffer from cache misses and need to wait until the code is read from flash. Select :ref:`CONFIG_SPI_MASTER_IN_IRAM` to put the whole SPI driver into IRAM and put the entire callback(s) and its callee functions into IRAM to prevent cache missing.

.. note::

    SPI driver implementation is based on FreeRTOS APIs, to use :ref:`CONFIG_SPI_MASTER_IN_IRAM`, you should not enable :ref:`CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH`.

"
"For an interrupt transaction, the overall cost is **20+8n/Fspi[MHz]** [µs] for n bytes transferred in one transaction. Hence, the transferring speed is: **n/(20+8n/Fspi)**. An example of transferring speed at 8 MHz clock speed is given in the following table.

.. list-table::
   :widths: 30 45 40 30 30
   :header-rows: 1
     - Transaction Interval (µs)
     - Transaction Length (bytes)
     - Total Time (µs)
     - Total Speed (KBps)
     - 25
     - 1
     - 26
     - 38.5
     - 25
     - 8
 "
"    - 33
     - 242.4
     - 25
     - 16
     - 41
     - 490.2
     - 25
     - 64
     - 89
     - 719.1
     - 25
     - 128
     - 153
     - 836.6

When a transaction length is short, the cost of the transaction interval is high. If possible, try to squash several short transactions into one transaction to achieve a higher transfer speed.

Please note that the ISR is disabled during flash operation by default. To keep sending transactions during flash operations, enable :ref:`CONFIG_SPI_MA"
"STER_ISR_IN_IRAM` and set :c:macro:`ESP_INTR_FLAG_IRAM` in the member :cpp:member:`spi_bus_config_t::intr_flags`. In this case, all the transactions queued before starting flash operations are handled by the ISR in parallel. Also note that the callback of each Device and their ``callee`` functions should be in IRAM, or your callback will crash due to cache missing. For more details, see :ref:`iram-safe-interrupt-handlers`.


.. only:: esp32

    .. _timing_considerations:

    Timing Considerati"
"ons
    

    As shown in the figure below, there is a delay on the MISO line after the SCLK launch edge and before the signal is latched by the internal register. As a result, the MISO pin setup time is the limiting factor for the SPI clock speed. When the delay is too long, the setup slack is `.


Application Example


The code example for using the SPI master half duplex mode to read/write an AT93C46D EEPROM (8-bit mode) can be found in the :example:`peripherals/spi_master/hd_eeprom` director"
"y of ESP-IDF examples.

The code example for using the SPI master full duplex mode to drive a SPI_LCD (e.g. ST7789V or ILI9341) can be found in the :example:`peripherals/spi_master/lcd` directory of ESP-IDF examples.

API Reference - SPI Common


.. include-build-file:: inc/spi_types.inc
.. include-build-file:: inc/spi_common.inc


API Reference - SPI Master


.. include-build-file:: inc/spi_master.inc
"
"SPI Slave Half Duplex




Introduction


The Half Duplex (HD) Mode is a special mode provided by ESP SPI Slave peripheral. Under this mode, the hardware provides more services than the Full Duplex (FD) Mode (the mode for general-purpose SPI transactions, see :doc:`spi_slave`). These services reduce the CPU load and the response time of SPI Slave. However, it is important to note that the communication format is determined by the hardware and is always in a half-duplex configuration, allowing onl"
"y one-way data transfer at any given time. Hence, the mode is named Half Duplex Mode due to this characteristic.

When conducting an SPI transaction, transactions can be classified into several types based on the **command** phase of the transaction. Each transaction may consist of the following phases: command, address, dummy, and data. The command phase is mandatory, while the other phases may be determined by the command field. During the command, address, and dummy phases, the bus is always "
"controlled by the master (usually the host), while the direction of the data phase depends on the command. The data phase can be either an input phase, where the master writes data to the slave (e.g., the host sends data to the slave), or an output phase, where the master reads data from the slave (e.g., the host receives data from the slave).

Protocol


About the details of how master should communicate with the SPI Slave, see :doc:`/api-reference/protocols/esp_spi_slave_protocol`.

Through th"
"ese different transactions, the slave provides these services to the master:

- A DMA channel for the master to write a great amount of data to the slave.
- A DMA channel for the master to read a great amount of data from the slave.
- Several general purpose registers, shared between the master and the slave.
- Several general purpose interrupts, for the master to interrupt the SW of the slave.

Terminology


- Transaction
- Channel
- Sending
- Receiving
- Data Descriptor

Driver Feature


- Tra"
"nsaction read/write by master in segments

- Queues for data to send and received

Driver Usage


Slave Initialization


Call :cpp:func:`spi_slave_hd_init` to initialize the SPI bus as well as the peripheral and the driver. The SPI Slave exclusively uses the SPI peripheral, pins of the bus before it is deinitialized, which means other devices are unable to use the above resources during initialization. Thus, to ensure SPI resources are correctly occupied and the connections work properly, most c"
"onfigurations of the slave should be done as soon as the slave is initialized.

The :cpp:type:`spi_bus_config_t` specifies how the bus should be initialized, while :cpp:type:`spi_slave_hd_slot_config_t` specifies how the SPI Slave driver should work.

Deinitialization (Optional)


Call :cpp:func:`spi_slave_hd_deinit` to uninstall the driver. The resources, including the pins, SPI peripheral, internal memory used by the driver, and interrupt sources, are released by the ``deinit()`` function.

Se"
"nd/Receive Data by DMA Channels


To send data to the master through the sending DMA channel, the application should properly wrap the data in an :cpp:type:`spi_slave_hd_data_t` descriptor structure before calling :cpp:func:`spi_slave_hd_queue_trans` with the data descriptor and the channel argument of :cpp:enumerator:`SPI_SLAVE_CHAN_TX`. The pointers to descriptors are stored in the queue, and the data is sent to the master in the same order they are enqueued using :cpp:func:`spi_slave_hd_queue"
"_trans`, upon receiving the master's ``Rd_DMA`` command.

The application should check the result of data sending by calling :cpp:func:`spi_slave_hd_get_trans_res` with the channel set as :cpp:enumerator:`SPI_SLAVE_CHAN_TX`. This function blocks until the transaction with the command ``Rd_DMA`` from the master successfully completes (or timeout). The ``out_trans`` argument of the function outputs the pointer of the data descriptor which is just finished, providing information about the sending.
"
"
Receiving data from the master through the receiving DMA channel is quite similar. The application calls :cpp:func:`spi_slave_hd_queue_trans` with proper data descriptor and the channel argument of :cpp:enumerator:`SPI_SLAVE_CHAN_RX`. And the application calls the :cpp:func:`spi_slave_hd_get_trans_res` later to get the descriptor to the receiving buffer before it handles the data in the receiving buffer.

.. note::

    This driver itself does not have an internal buffer for the data to send or"
" just received. The application should provide data buffer for driver via data descriptors to send to the master, or to receive data from the master.

    The application has to properly keep the data descriptor as well as the buffer it points, after the descriptor is successfully sent into the driver internal queue by :cpp:func:`spi_slave_hd_queue_trans`, and before returned by :cpp:func:`spi_slave_hd_get_trans_res`. During this period, the hardware as well as the driver may read or write to th"
"e buffer and the descriptor when required at any time.

Please note that, when using this driver for data transfer, the buffer does not have to be fully sent or filled before it is terminated. For example, in the segment transaction mode, the master has to send ``CMD7`` to terminate a ``Wr_DMA`` transaction or send ``CMD8`` to terminate an ``Rd_DMA`` transaction (in segments), no matter whether the send (receive) buffer is used up (full) or not.

.. _spi_slave_hd_data_arguments:

Using Data Desc"
"riptor with Customized User Arguments


Sometimes you may have initiator (sending data descriptor) and closure (handling returned descriptors) functions in different places. When you get the returned data descriptor in the closure, you may need some extra information when handling the finished data descriptor. For example, you may want to know which round it is for the returned descriptor when you send the same piece of data several times.

Set the ``arg`` member in the data descriptor to a vari"
"able indicating the transaction by force casting, or point it to a structure that wraps all the information you may need when handling the sending/receiving data. Then you can get what you need in your closure.

.. _spi_slave_hd_callbacks:

Using Callbacks


.. note::

    These callbacks are called in the ISR, so the required operations need to be processed quickly and returned as soon as possible to ensure that the system is functioning properly. You may need to be very careful to write the co"
"de in the ISR.

    Since the interrupt handling is executed concurrently with the application, long delays or blocking may cause the system to respond slower or lead to unpredictable behavior. Therefore, when writing callback functions, avoid using operations that may cause delays or blocking, e.g., waiting, sleeping, resource locking, etc.

The :cpp:type:`spi_slave_hd_callback_config_t` member in the :cpp:type:`spi_slave_hd_slot_config_t` configuration structure passed when initializing the SP"
"I Slave HD driver, allows you to have callbacks for each event you may concern.

The corresponding interrupt for each callback that is not **NULL** is enabled, so that the callbacks can be called immediately when the events happen. You do not need to provide callbacks for the unconcerned events.

The ``arg`` member in the configuration structure can help you pass some context to the callback or indicate the specific SPI Slave instance when using the same callbacks for multiple SPI Slave peripher"
"als. You can set the arg member to a variable that indicates the SPI Slave instance by performing a forced type casting or point it to a context structure. All the callbacks are called with this ``arg`` argument you set when the callbacks are initialized.

There are two other arguments: the ``event`` and the ``awoken``.

    - The ``event`` passes the information of the current event to the callback. The :cpp:type:`spi_slave_hd_event_t` type contains the information of the event, for example, ev"
"ent type, the data descriptor just finished (The :ref:`data argument ` is very useful in this case!).
    - The ``awoken`` argument serves as an output parameter. It informs the ISR that tasks have been awakened after the callback function, and the ISR should call `portYIELD_FROM_ISR()` to schedule these tasks. Simply pass the ``awoken`` argument to all FreeRTOS APIs that may unblock tasks, and the value of ``awoken`` will be returned to the ISR.

Writing/Reading Shared Registers


Call :cpp:fun"
"c:`spi_slave_hd_write_buffer` to write the shared buffer, and :cpp:func:`spi_slave_hd_read_buffer` to read the shared buffer.

.. note::

    On {IDF_TARGET_NAME}, the shared registers are read/written in words by the application but read/written in bytes by the master. There is no guarantee four continuous bytes read from the master are from the same word written by the slave's application. It is also possible that if the slave reads a word while the master is writing bytes of the word, the sla"
"ve may get one word with half of them just written by the master, and the other half has not been written into.

    The master can confirm that the word is not in transition by reading the word twice and comparing the values.

    For the slave, it is more difficult to ensure the word is not in transition because the process of master writing four bytes can be very long (32 SPI clocks). You can put some CRC in the last (largest address) byte of a word so that when the byte is written, the word "
"is sure to be all written.

    Due to the conflicts that may be among read/write from SW (worse if there are multi-cores) and master, it is suggested that a word is only used in one direction (only written by the master or only written by the slave).

Receiving General Purpose Interrupts from the Master


When the master sends ``CMD8``, ``CMD9`` or ``CMDA``, the slave corresponding is triggered. Currently the ``CMD8`` is permanently used to indicate the termination of ``Rd_DMA`` segments. To re"
"ceive general-purpose interrupts, register callbacks for ``CMD9`` and ``CMDA`` when the slave is initialized, see :ref:`spi_slave_hd_callbacks`.


Application Example


The code example for Device/Host communication can be found in the :example:`peripherals/spi_slave_hd` directory of ESP-IDF examples.


API Reference


.. include-build-file:: inc/spi_slave_hd.inc
"
"Universal Asynchronous Receiver/Transmitter (UART)


{IDF_TARGET_UART_EXAMPLE_PORT:default = ""UART_NUM_1"", esp32 = ""UART_NUM_2"", esp32s3 = ""UART_NUM_2""}

Introduction


A Universal Asynchronous Receiver/Transmitter (UART) is a hardware feature that handles communication (i.e., timing requirements and data framing) using widely-adopted asynchronous serial communication interfaces, such as RS232, RS422, and RS485. A UART provides a widely adopted and cheap method to realize full-duplex or half-dup"
"lex data exchange among different devices.

The {IDF_TARGET_NAME} chip has {IDF_TARGET_SOC_UART_HP_NUM} UART controllers (also referred to as port), each featuring an identical set of registers to simplify programming and for more flexibility.

Each UART controller is independently configurable with parameters such as baud rate, data bit length, bit ordering, number of stop bits, parity bit, etc. All the regular UART controllers are compatible with UART-enabled devices from various manufacturers"
" and can also support Infrared Data Association (IrDA) protocols.

.. only:: SOC_UART_HAS_LP_UART

    Additionally, the {IDF_TARGET_NAME} chip has one low-power (LP) UART controller. It is the cut-down version of regular UART. Usually, the LP UART controller only support basic UART functionality with a much smaller RAM size, and does not support IrDA or RS485 protocols. For a full list of difference between UART and LP UART, please refer to the **{IDF_TARGET_NAME} Technical Reference Manual** >"
" **UART Controller (UART)** > **Features** [`PDF `__]).

Functional Overview


The overview describes how to establish communication between an {IDF_TARGET_NAME} and other UART devices using the functions and data types of the UART driver. A typical programming workflow is broken down into the sections provided below:

Steps 1 to 3 comprise the configuration stage. Step 4 is where the UART starts operating. Steps 5 and 6 are optional.

.. only:: SOC_UART_HAS_LP_UART

    Additionally, when using"
" the LP UART Controller you need to pay attention to :ref:`uart-api-lp-uart-driver`.

The UART driver's functions identify each of the UART controllers using :cpp:type:`uart_port_t`. This identification is needed for all the following function calls.


.. _uart-api-setting-communication-parameters:

Set Communication Parameters


UART communication parameters can be configured all in a single step or individually in multiple steps.


Single Step
""""""""""""""""""""""

Call the function :cpp:func:`uart_par"
"am_config` and pass to it a :cpp:type:`uart_config_t` structure. The :cpp:type:`uart_config_t` structure should contain all the required parameters. See the example below.

.. code-block:: c

    const uart_port_t uart_num = {IDF_TARGET_UART_EXAMPLE_PORT};
    uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_CTS_RTS,
        .rx_flow"
"_ctrl_thresh = 122,
    };
    // Configure UART parameters
    ESP_ERROR_CHECK(uart_param_config(uart_num, &uart_config));

For more information on how to configure the hardware flow control options, please refer to :example:`peripherals/uart/uart_echo`.

Multiple Steps
""""""""""""""""""""""""""""

Configure specific parameters individually by calling a dedicated function from the table given below. These functions are also useful if re-configuring a single parameter.

.. list-table:: Functions for Configur"
"ing specific parameters individually
   :widths: 30 70
   :header-rows: 1
     - Function
     - :cpp:func:`uart_set_baudrate`
     - :cpp:func:`uart_set_word_length` selected out of :cpp:type:`uart_word_length_t`
     - :cpp:func:`uart_set_parity` selected out of :cpp:type:`uart_parity_t`
     - :cpp:func:`uart_set_stop_bits` selected out of :cpp:type:`uart_stop_bits_t`
     - :cpp:func:`uart_set_hw_flow_ctrl` selected out of :cpp:type:`uart_hw_flowcontrol_t`
     - :cpp:func:`uart_set_mode` se"
"lected out of :cpp:type:`uart_mode_t`

Each of the above functions has a ``_get_`` counterpart to check the currently set value. For example, to check the current baud rate value, call :cpp:func:`uart_get_baudrate`.


.. _uart-api-setting-communication-pins:

Set Communication Pins


After setting communication parameters, configure the physical GPIO pins to which the other UART device will be connected. For this, call the function :cpp:func:`uart_set_pin` and specify the GPIO pin numbers to whi"
"ch the driver should route the TX, RX, RTS, and CTS signals. If you want to keep a currently allocated pin number for a specific signal, pass the macro :c:macro:`UART_PIN_NO_CHANGE`.

The same macro :c:macro:`UART_PIN_NO_CHANGE` should be specified for pins that will not be used.

.. code-block:: c

  // Set UART pins(TX: IO4, RX: IO5, RTS: IO18, CTS: IO19)
  ESP_ERROR_CHECK(uart_set_pin({IDF_TARGET_UART_EXAMPLE_PORT}, 4, 5, 18, 19));

.. _uart-api-driver-installation:

Install Drivers


Once th"
"e communication pins are set, install the driver by calling :cpp:func:`uart_driver_install` and specify the following parameters:

- Size of TX ring buffer
- Size of RX ring buffer
- Event queue handle and size
- Flags to allocate an interrupt

The function allocates the required internal resources for the UART driver.

.. code-block:: c

    // Setup UART buffered IO with event queue
    const int uart_buffer_size = (1024 * 2);
    QueueHandle_t uart_queue;
    // Install UART driver using an e"
"vent queue here
    ESP_ERROR_CHECK(uart_driver_install({IDF_TARGET_UART_EXAMPLE_PORT}, uart_buffer_size, \
                                            uart_buffer_size, 10, &uart_queue, 0));

Once this step is complete, you can connect the external UART device and check the communication.


.. _uart-api-running-uart-communication:

Run UART Communication


Serial communication is controlled by each UART controller's finite state machine (FSM).

The process of sending data involves the following"
" steps:

The process of receiving data is similar, but the steps are reversed:

Therefore, an application only writes and reads data from a specific buffer using :cpp:func:`uart_write_bytes` and :cpp:func:`uart_read_bytes` respectively, and the FSM does the rest.


Transmit Data
""""""""""""""""""""""""""

After preparing the data for transmission, call the function :cpp:func:`uart_write_bytes` and pass the data buffer's address and data length to it. The function copies the data to the TX ring buffer (eithe"
"r immediately or after enough space is available), and then exit. When there is free space in the TX FIFO buffer, an interrupt service routine (ISR) moves the data from the TX ring buffer to the TX FIFO buffer in the background. The code below demonstrates the use of this function.

.. code-block:: c

    // Write data to UART.
    char* test_str = ""This is a test string.\n"";
    uart_write_bytes(uart_num, (const char*)test_str, strlen(test_str));

The function :cpp:func:`uart_write_bytes_with_b"
"reak` is similar to :cpp:func:`uart_write_bytes` but adds a serial break signal at the end of the transmission. A 'serial break signal' means holding the TX line low for a period longer than one data frame.

.. code-block:: c

    // Write data to UART, end with a break signal.
    uart_write_bytes_with_break(uart_num, ""test break\n"",strlen(""test break\n""), 100);

Another function for writing data to the TX FIFO buffer is :cpp:func:`uart_tx_chars`. Unlike :cpp:func:`uart_write_bytes`, this funct"
"ion does not block until space is available. Instead, it writes all data which can immediately fit into the hardware TX FIFO, and then return the number of bytes that were written.

There is a 'companion' function :cpp:func:`uart_wait_tx_done` that monitors the status of the TX FIFO buffer and returns once it is empty.

.. code-block:: c

    // Wait for packet to be sent
    const uart_port_t uart_num = {IDF_TARGET_UART_EXAMPLE_PORT};
    ESP_ERROR_CHECK(uart_wait_tx_done(uart_num, 100)); // wa"
"it timeout is 100 RTOS ticks (TickType_t)


Receive Data
""""""""""""""""""""""""

Once the data is received by the UART and saved in the RX FIFO buffer, it needs to be retrieved using the function :cpp:func:`uart_read_bytes`. Before reading data, you can check the number of bytes available in the RX FIFO buffer by calling :cpp:func:`uart_get_buffered_data_len`. An example of using these functions is given below.

.. code-block:: c

    // Read data from UART.
    const uart_port_t uart_num = {IDF_TARGET_UA"
"RT_EXAMPLE_PORT};
    uint8_t data[128];
    int length = 0;
    ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num, (size_t*)&length));
    length = uart_read_bytes(uart_num, data, length, 100);

If the data in the RX FIFO buffer is no longer needed, you can clear the buffer by calling :cpp:func:`uart_flush`.


Software Flow Control
""""""""""""""""""""""""""""""""""""""""""

If the hardware flow control is disabled, you can manually set the RTS and DTR signal levels by using the functions :cpp:func:`uart_set_rts`"
" and :cpp:func:`uart_set_dtr` respectively.


Communication Mode Selection
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The UART controller supports a number of communication modes. A mode can be selected using the function :cpp:func:`uart_set_mode`. Once a specific mode is selected, the UART driver handles the behavior of a connected UART device accordingly. As an example, it can control the RS485 driver chip using the RTS line to allow half-duplex RS485 communication.

.. code-block:: bash

    // Setup UART"
" in rs485 half duplex mode
    ESP_ERROR_CHECK(uart_set_mode(uart_num, UART_MODE_RS485_HALF_DUPLEX));


.. _uart-api-using-interrupts:

Use Interrupts


There are many interrupts that can be generated depending on specific UART states or detected errors. The full list of available interrupts is provided in *{IDF_TARGET_NAME} Technical Reference Manual* > *UART Controller (UART)* > *UART Interrupts* and *UHCI Interrupts* [`PDF `__]. You can enable or disable specific interrupts by calling :cpp:fu"
"nc:`uart_enable_intr_mask` or :cpp:func:`uart_disable_intr_mask` respectively.

The :cpp:func:`uart_driver_install` function installs the driver's internal interrupt handler to manage the TX and RX ring buffers and provides high-level API functions like events (see below).

The API provides a convenient way to handle specific interrupts discussed in this document by wrapping them into dedicated functions:

- **Event detection**: There are several events defined in :cpp:type:`uart_event_type_t` t"
"hat may be reported to a user application using the FreeRTOS queue functionality. You can enable this functionality when calling :cpp:func:`uart_driver_install` described in :ref:`uart-api-driver-installation`. An example of using Event detection can be found in :example:`peripherals/uart/uart_events`.

- **FIFO space threshold or transmission timeout reached**: The TX and RX FIFO buffers can trigger an interrupt when they are filled with a specific number of characters, or on a timeout of sendi"
"ng or receiving data. To use these interrupts, do the following:

    - Configure respective threshold values of the buffer length and timeout by entering them in the structure :cpp:type:`uart_intr_config_t` and calling :cpp:func:`uart_intr_config`
    - Enable the interrupts using the functions :cpp:func:`uart_enable_tx_intr` and :cpp:func:`uart_enable_rx_intr`
    - Disable these interrupts using the corresponding functions :cpp:func:`uart_disable_tx_intr` or :cpp:func:`uart_disable_rx_intr`

"
"- **Pattern detection**: An interrupt triggered on detecting a 'pattern' of the same character being received/sent repeatedly. This functionality is demonstrated in the example :example:`peripherals/uart/uart_events`. It can be used, e.g., to detect a command string with a specific number of identical characters (the 'pattern') at the end. The following functions are available:

    - Configure and enable this interrupt using :cpp:func:`uart_enable_pattern_det_baud_intr`
    - Disable the interr"
"upt using :cpp:func:`uart_disable_pattern_det_intr`


.. _uart-api-deleting-driver:

Deleting a Driver


If the communication established with :cpp:func:`uart_driver_install` is no longer required, the driver can be removed to free allocated resources by calling :cpp:func:`uart_driver_delete`.


Macros


The API also defines several macros. For example, :c:macro:`UART_HW_FIFO_LEN` defines the length of hardware FIFO buffers; :c:macro:`UART_BITRATE_MAX` gives the maximum baud rate supported by th"
"e UART controllers, etc.

.. only:: SOC_UART_HAS_LP_UART

    .. _uart-api-lp-uart-driver:

    Use LP UART Controller with HP Core
    

    The UART driver also supports to control the LP UART controller when the chip is in active mode. The configuration steps for the LP UART are the same as the steps for a normal UART controller, except:

    .. list::

        - The port number for the LP UART controller is defined by :c:macro:`LP_UART_NUM_0`.
        - The available clock sources for the LP"
" UART controller can be found in :cpp:type:`lp_uart_sclk_t`.
        - The size of the hardware FIFO for the LP UART controller is much smaller, which is defined in :c:macro:`SOC_LP_UART_FIFO_LEN`.
        :SOC_LP_GPIO_MATRIX_SUPPORTED: - The GPIO pins for the LP UART controller can only be selected from the LP GPIO pins.
        :not SOC_LP_GPIO_MATRIX_SUPPORTED: - The GPIO pins for the LP UART controller are unalterable, because there is no LP GPIO matrix on the target. Please see **{IDF_TARGE"
"T_NAME} Technical Reference Manual** > **IO MUX and GPIO Matrix (GPIO, IO MUX)** > **LP IO MUX Functions List** [`PDF `__] for the specific pin numbers.


Overview of RS485 Specific Communication 0ptions


.. note::

    The following section uses ``[UART_REGISTER_NAME].[UART_FIELD_BIT]`` to refer to UART register fields/bits. For more information on a specific option bit, see **{IDF_TARGET_NAME} Technical Reference Manual** > **UART Controller (UART)** > **Register Summary** [`PDF `__]. Use the"
" register name to navigate to the register description and then find the field/bit.

- ``UART_RS485_CONF_REG.UART_RS485_EN``: setting this bit enables RS485 communication mode support.
- ``UART_RS485_CONF_REG.UART_RS485TX_RX_EN``: if this bit is set, the transmitter's output signal loops back to the receiver's input signal.
- ``UART_RS485_CONF_REG.UART_RS485RXBY_TX_EN``: if this bit is set, the transmitter will still be sending data if the receiver is busy (remove collisions automatically by har"
"dware).

The {IDF_TARGET_NAME}'s RS485 UART hardware can detect signal collisions during transmission of a datagram and generate the interrupt ``UART_RS485_CLASH_INT`` if this interrupt is enabled. The term collision means that a transmitted datagram is not equal to the one received on the other end. Data collisions are usually associated with the presence of other active devices on the bus or might occur due to bus errors.

The collision detection feature allows handling collisions when their i"
"nterrupts are activated and triggered. The interrupts ``UART_RS485_FRM_ERR_INT`` and ``UART_RS485_PARITY_ERR_INT`` can be used with the collision detection feature to control frame errors and parity bit errors accordingly in RS485 mode. This functionality is supported in the UART driver and can be used by selecting the :cpp:enumerator:`UART_MODE_RS485_APP_CTRL` mode (see the function :cpp:func:`uart_set_mode`).

The collision detection feature can work with circuit A and circuit C (see Section `"
"Interface Connection Options`_). In the case of using circuit A or B, the RTS pin connected to the DE pin of the bus driver should be controlled by the user application. Use the function :cpp:func:`uart_get_collision_flag` to check if the collision detection flag has been raised.

The {IDF_TARGET_NAME} UART controllers themselves do not support half-duplex communication as they cannot provide automatic control of the RTS pin connected to the RE/DE input of RS485 bus driver. However, half-duplex "
"communication can be achieved via software control of the RTS pin by the UART driver. This can be enabled by selecting the :cpp:enumerator:`UART_MODE_RS485_HALF_DUPLEX` mode when calling :cpp:func:`uart_set_mode`.

Once the host starts writing data to the TX FIFO buffer, the UART driver automatically asserts the RTS pin (logic 1); once the last bit of the data has been transmitted, the driver de-asserts the RTS pin (logic 0). To use this mode, the software would have to disable the hardware flow"
" control function. This mode works with all the used circuits shown below.


Interface Connection Options


This section provides example schematics to demonstrate the basic aspects of {IDF_TARGET_NAME}'s RS485 interface connection.

.. note::

    - The schematics below do **not** necessarily contain **all required elements**.

    - The **analog devices** ADM483 & ADM2483 are examples of common RS485 transceivers and **can be replaced** with other similar transceivers.


Circuit A: Collision D"
"etection Circuit
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: none

         VCC +
                            |
                    +x+
         RXD  B
         TXD >| D    ADM483   |
 ESP                |               |     RS485 bus side
         RTS >| DE            |
                    |              A|<> A
               +| /RE           |
               |    +x+
               |            |
              GND          GND

This circuit is preferable because it allows for coll"
"ision detection and is quite simple at the same time. The receiver in the line driver is constantly enabled, which allows the UART to monitor the RS485 bus. Echo suppression is performed by the UART peripheral when the bit ``UART_RS485_CONF_REG.UART_RS485TX_RX_EN`` is enabled.


Circuit B: Manual Switching Transmitter/Receiver Without Collision Detection
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


.. code-block:: none

         VCC +
                           "
" |
                    +x+
         RXD  B
         TXD >| D    ADM483   |
 ESP                |               |     RS485 bus side
         RTS --+--->| DE            |
               |    |              A|<> A
               +| /RE           |
                    +x+
                            |
                           GND

This circuit does not allow for collision detection. It suppresses the null bytes that the hardware receives when the bit ``UART_RS485_CONF_REG.UART_RS485TX_RX_EN`` is "
"set. The bit ``UART_RS485_CONF_REG.UART_RS485RXBY_TX_EN`` is not applicable in this case.


Circuit C: Auto Switching Transmitter/Receiver
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: none

   VCC1  VCC2
                 10K ____   |           |           |                   |
                +---|____|--+       +---xx---+    10K ____   |
                |                   |                   |   +---|____|--+
  RX  A (+)
                +|____|| PV    ADM2483     |   |    __"
"__  120
                |   ____            |                   |   +---|____|---+  RS485 bus side
        VCC1 | DE                |                |
                10K        |        |                  B|---++--<> B (-)
                        ---+    +-->| /RE               |   |    ____
           10K          |       |   |                   |   +---|____|---+
          ____       | /-C      +---| TXD               |    10K         |
  TX >---|____|--+_B_|/   NPN   |   |                   "
"|                |
                     |\         |   +---xx---+                |
                     | \-E      |       |           |                    |
                        |       |       |           |                    |
                       GND1    GND1    GND1        GND2                 GND2

This galvanically isolated circuit does not require RTS pin control by a software application or driver because it controls the transceiver direction automatically. However, it requires sup"
"pressing null bytes during transmission by setting ``UART_RS485_CONF_REG.UART_RS485RXBY_TX_EN`` to 1 and ``UART_RS485_CONF_REG.UART_RS485TX_RX_EN`` to 0. This setup can work in any RS485 UART mode or even in :cpp:enumerator:`UART_MODE_UART`.


Application Examples


The table below describes the code examples available in the directory :example:`peripherals/uart/`.

.. list-table::
   :widths: 35 65
   :header-rows: 1
     - Description
     - Configuring UART settings, installing the UART drive"
"r, and reading/writing over the UART1 interface.
     - Reporting various communication events, using pattern detection interrupts.
     - Transmitting and receiving data in two separate FreeRTOS tasks over the same UART.
     - Using synchronous I/O multiplexing for UART file descriptors.
     - Setting up UART driver to communicate over RS485 interface in half-duplex mode. This example is similar to :example:`peripherals/uart/uart_echo` but allows communication through an RS485 interface chip "
"connected to {IDF_TARGET_NAME} pins.
     - Obtaining GPS information by parsing NMEA0183 statements received from GPS via the UART peripheral.


API Reference


.. include-build-file:: inc/uart.inc
.. include-build-file:: inc/uart_types.inc


GPIO Lookup Macros


The UART peripherals have dedicated IO_MUX pins to which they are connected directly. However, signals can also be routed to other pins using the less direct GPIO matrix. To use direct routes, you need to know which pin is a dedicated "
"IO_MUX pin for a UART channel. GPIO Lookup Macros simplify the process of finding and assigning IO_MUX pins. You choose a macro based on either the IO_MUX pin number, or a required UART channel name, and the macro returns the matching counterpart for you. See some examples below.

.. note::

    These macros are useful if you need very high UART baud rates (over 40 MHz), which means you will have to use IO_MUX pins only. In other cases, these macros can be ignored, and you can use the GPIO Matri"
"x as it allows you to configure any GPIO pin for any UART function.

.. include-build-file:: inc/uart_channel.inc

"
"SD SPI Host Driver




Overview


The SD SPI host driver allows communication with one or more SD cards using the SPI Master driver, which utilizes the SPI host. Each card is accessed through an SD SPI device, represented by an SD SPI handle :cpp:type:`sdspi_dev_handle_t`, which returns when the device is attached to an SPI bus by calling :cpp:func:`sdspi_host_init_device`. It is important to note that the SPI bus should be initialized beforehand by :cpp:func:`spi_bus_initialize`.

.. only:: esp"
"32

    This driver's naming pattern was adopted from the :doc:`sdmmc_host` due to their similarity. Likewise, the APIs of both drivers are also very similar.

    SD SPI driver that accesses the SD card in SPI mode offers lower throughput but makes pin selection more flexible. With the help of the GPIO matrix, an SPI peripheral's signals can be routed to any {IDF_TARGET_NAME} pin. Otherwise, if an SDMMC host driver is used (see :doc:`sdmmc_host`) to access the card in SD 1-bit/4-bit mode, highe"
"r throughput can be reached while requiring routing the signals through their dedicated IO_MUX pins only.

With the help of :doc:`spi_master` the SD SPI host driver based on, the SPI bus can be shared among SD cards and other SPI devices. The SPI Master driver will handle exclusive access from different tasks.

The SD SPI driver uses software-controlled CS signal.

How to Use


Firstly, use the macro :c:macro:`SDSPI_DEVICE_CONFIG_DEFAULT` to initialize the structure :cpp:type:`sdspi_device_confi"
"g_t`, which is used to initialize an SD SPI device. This macro will also fill in the default pin mappings, which are the same as the pin mappings of the SDMMC host driver. Modify the host and pins of the structure to desired value. Then call ``sdspi_host_init_device`` to initialize the SD SPI device and attach to its bus.

Then use the :c:macro:`SDSPI_HOST_DEFAULT` macro to initialize the :cpp:type:`sdmmc_host_t` structure, which is used to store the state and configurations of the upper layer ("
"SD/SDIO/MMC driver). Modify the ``slot`` parameter of the structure to the SD SPI device SD SPI handle just returned from ``sdspi_host_init_device``. Call ``sdmmc_card_init`` with the :cpp:type:`sdmmc_host_t` to probe and initialize the SD card.

Now you can use SD/SDIO/MMC driver functions to access your card!

Other Details


Only the following driver's API functions are normally used by most applications:

- :cpp:func:`sdspi_host_init`
- :cpp:func:`sdspi_host_init_device`
- :cpp:func:`sdspi_h"
"ost_remove_device`
- :cpp:func:`sdspi_host_deinit`

Other functions are mostly used by the protocol level SD/SDIO/MMC driver via function pointers in the :cpp:type:`sdmmc_host_t` structure. For more details, see :doc:`../storage/sdmmc`.

.. note::

    SD over SPI does not support speeds above :c:macro:`SDMMC_FREQ_DEFAULT` due to the limitations of the SPI driver.

.. warning::

    If you want to share the SPI bus among SD card and other SPI devices, there are some restrictions, see :doc:`sdspi"
"_share`.

.. todo

..    The SD SPI API reference could use more detail such as:
..    - Configuration. What are some key points of concern regarding slot configuration.
..    - Which function/how is a transaction done?
..    - Are there code snippets or corresponding application examples?

Related Docs


.. toctree::
   :maxdepth: 1

   sdspi_share


API Reference


.. include-build-file:: inc/sdspi_host.inc
"
"Dedicated GPIO




Overview


The dedicated GPIO is designed for CPU interaction with GPIO matrix and IO MUX. Any GPIO that is configured as ""dedicated"" can be access by CPU instructions directly, which makes it easy to achieve a high GPIO flip speed, and simulate serial/parallel interface in a bit-banging way. As toggling a GPIO in this ""CPU Dedicated"" way costs few overhead, it would be great for cases like performance measurement using an oscilloscope.


Create/Destroy GPIO Bundle


A GPIO bu"
"ndle is a group of GPIOs, which can be manipulated at the same time in one CPU cycle. The maximal number of GPIOs that a bundle can contain is limited by each CPU. What's more, the GPIO bundle has a strong relevance to the CPU which it derives from. **Any operations on the GPIO bundle should be put inside a task which is running on the same CPU core to the GPIO bundle belongs to.** Likewise, only those ISRs who are installed on the same CPU core are allowed to do operations on that GPIO bundle.
"
"
.. note::

    Dedicated GPIO is more of a CPU peripheral, so it has a strong relationship with CPU core. It's highly recommended to install and operate GPIO bundle in a pin-to-core task. For example, if GPIOA is connected to CPU0, and the dedicated GPIO instruction is issued from CPU1, then it's impossible to control GPIOA.

To install a GPIO bundle, one needs to call :cpp:func:`dedic_gpio_new_bundle` to allocate the software resources and connect the dedicated channels to user selected GPIOs."
" Configurations for a GPIO bundle are covered in :cpp:type:`dedic_gpio_bundle_config_t` structure:

- :cpp:member:`gpio_array`: An array that contains GPIO number.
- :cpp:member:`array_size`: Element number of :cpp:member:`gpio_array`.
- :cpp:member:`flags`: Extra flags to control the behavior of GPIO Bundle.

  - :cpp:member:`in_en` and :cpp:member:`out_en` are used to select whether to enable the input and output function (note, they can be enabled together).
  - :cpp:member:`in_invert` and :c"
"pp:member:`out_invert` are used to select whether to invert the GPIO signal.

The following code shows how to install a output only GPIO bundle:

.. highlight:: c

::

    // configure GPIO
    const int bundleA_gpios[] = {0, 1};
    gpio_config_t io_conf = {
        .mode = GPIO_MODE_OUTPUT,
    };
    for (int i = 0; i `.


GPIO Bundle Operations


.. list-table::
   :widths: 50 50
   :header-rows: 1
     - Functions
     - :cpp:func:`dedic_gpio_bundle_write`
     - :cpp:func:`dedic_gpio_bundl"
"e_read_out`
     - :cpp:func:`dedic_gpio_bundle_read_in`

.. note::

    Using the above functions might not get a high GPIO flip speed because of the overhead of function calls and the bit operations involved inside. Users can try :ref:`manipulate_gpios_by_writing_assembly_code` instead to reduce the overhead but should take care of the thread safety by themselves.

.. _manipulate_gpios_by_writing_assembly_code:

Manipulate GPIOs by Writing Assembly Code


For advanced users, they can always ma"
"nipulate the GPIOs by writing assembly code or invoking CPU Low Level APIs. The usual procedure could be:

    .. only:: esp32s2 or esp32s3

        - Set bits of GPIO: ``set_bit_gpio_out imm[7:0]``
        - Clear bits of GPIO: ``clr_bit_gpio_out imm[7:0]``
        - Note: Immediate value width depends on the number of dedicated GPIO channels

    .. only:: esp32c2 or esp32c3 or esp32c6 or esp32h2

        - Set bits of GPIO: ``csrrsi rd, csr, imm[4:0]``
        - Clear bits of GPIO: ``csrrci r"
"d, csr, imm[4:0]``
        - Note: Can only control the lowest 4 GPIO channels

.. only:: esp32s2

    For details of supported dedicated GPIO instructions, please refer to **{IDF_TARGET_NAME} Technical Reference Manual** > **IO MUX and GPIO Matrix (GPIO, IO_MUX)** [`PDF `__].

.. only:: esp32s3

    For details of supported dedicated GPIO instructions, please refer to **{IDF_TARGET_NAME} Technical Reference Manual** > **Processor Instruction Extensions (PIE) (to be added later)** [`PDF `__].

."
". only:: esp32c2 or esp32c3 or esp32c6 or esp32h2

    Code examples for manipulating dedicated GPIOs from assembly are provided in the :example:`peripherals/dedicated_gpio` directory of ESP-IDF examples. These examples show how to emulate a UART, an I2C and an SPI bus in assembly thanks to dedicated GPIOs.

    For details of supported dedicated GPIO instructions, please refer to **{IDF_TARGET_NAME} Technical Reference Manual** > **ESP-RISC-V CPU** [`PDF `__].

Some of the dedicated CPU instruc"
"tions are also wrapped inside ``hal/dedic_gpio_cpu_ll.h`` as helper inline functions.

.. note::

    Writing assembly code in application could make your code hard to port between targets, because those customized instructions are not guaranteed to remain the same format on different targets.

.. only:: SOC_DEDIC_GPIO_HAS_INTERRUPT

    Interrupt Handling
    

    Dedicated GPIO can also trigger interrupt on specific input event. All supported events are defined in :cpp:type:`dedic_gpio_intr_t"
"ype_t`.

    One can enable and register interrupt callback by calling :cpp:func:`dedic_gpio_bundle_set_interrupt_and_callback`. The prototype of the callback function is defined in :cpp:type:`dedic_gpio_isr_callback_t`. Keep in mind, the callback should return true if there's some high priority task woken up.

    .. highlight:: c

    ::

        // user defined ISR callback
        IRAM_ATTR bool dedic_gpio_isr_callback(dedic_gpio_bundle_handle_t bundle, uint32_t index, void *args)
        {
"
"            SemaphoreHandle_t sem = (SemaphoreHandle_t)args;
            BaseType_t high_task_wakeup = pdFALSE;
            xSemaphoreGiveFromISR(sem, &high_task_wakeup);
            return high_task_wakeup == pdTRUE;
        }

        // enable positive edge interrupt on the second GPIO in the bundle (i.e., index 1)
        ESP_ERROR_CHECK(dedic_gpio_bundle_set_interrupt_and_callback(bundle, BIT(1), DEDIC_GPIO_INTR_POS_EDGE, dedic_gpio_isr_callback, sem));

        // wait for done semaphore
 "
"       xSemaphoreTake(sem, portMAX_DELAY);

.. only:: SOC_DEDIC_GPIO_HAS_INTERRUPT

    Application Example
    

    Matrix keyboard example based on dedicated GPIO: :example:`peripherals/gpio/matrix_keyboard`.


API Reference


.. include-build-file:: inc/dedic_gpio.inc
"
"Temperature Sensor




Introduction


The {IDF_TARGET_NAME} has a built-in sensor used to measure the chip's internal temperature. The temperature sensor module contains an 8-bit Sigma-Delta analog-to-digital converter (ADC) and a digital-to-analog converter (DAC) to compensate for the temperature measurement.

Due to restrictions of hardware, the sensor has predefined measurement ranges with specific measurement errors. See the table below for details.

.. list-table::
    :header-rows: 1
    :"
"widths: 50 50
    :align: center
      - Error (°C)
      - celsius_value);
            return false;
        }

        // Callback configurations
        temperature_sensor_abs_threshold_config_t threshold_cfg = {
            .high_threshold = 50,
            .low_threshold = -10,
        };
        // Set absolute value monitor threshold.
        temperature_sensor_set_absolute_threshold(temp_sensor, &threshold_cfg);
        // Register interrupt callback
        temperature_sensor_event_call"
"backs_t cbs = {
            .on_threshold = temp_sensor_monitor_cbs,
        };
        // Install temperature callback.
        temperature_sensor_register_callbacks(temp_sensor, &cbs, NULL);

    .. _temp-power-management:

.. only:: not SOC_TEMPERATURE_SENSOR_INTR_SUPPORT

    .. _temp-power-management:

Power Management


As the temperature sensor does not use the APB clock, it will keep working no matter if the power management is enabled with ``CONFIG_PM_ENABLE``.

.. only:: SOC_TEMPERATUR"
"E_SENSOR_INTR_SUPPORT

    .. _temp-iram-safe:

    IRAM Safe
    

    By default, the temperature sensor interrupt will be deferred when the cache is disabled for reasons like writing/erasing flash. Thus the event callback functions will not get executed in time, which is not expected in a real-time application.

    There is a Kconfig option :ref:`CONFIG_TEMP_SENSOR_ISR_IRAM_SAFE` that will:

    This allows the interrupt to run while the cache is disabled but comes at the cost of increased I"
"RAM consumption.

    .. _temp-thread-safety:

.. only:: not SOC_TEMPERATURE_SENSOR_INTR_SUPPORT

    .. _temp-thread-safety:

Thread Safety


In the temperature sensor driver, we do not add any protection to ensure the thread safety, because typically this driver is only supposed to be used in one task. If you have to use this driver in different tasks, please add extra locks to protect it.

.. only:: SOC_TEMPERATURE_SENSOR_SUPPORT_ETM

    .. _temperature-sensor-etm-event-and-task:

    ETM Ev"
"ent and Task
    

    Temperature Sensor is able to generate events that can interact with the :doc:`ETM ` module. The supported events are listed in the :cpp:type:`temperature_sensor_etm_event_type_t`. You can call :cpp:func:`temperature_sensor_new_etm_event` to get the corresponding ETM event handle. The supported tasks are listed in the :cpp:type:`temperature_sensor_etm_task_type_t`. You can call :cpp:func:`temperature_sensor_new_etm_task` to get the corresponding ETM event handle.

    .. n"
"ote::

        - :cpp:enumerator:`TEMPERATURE_SENSOR_EVENT_OVER_LIMIT` for :cpp:member:`temperature_sensor_etm_event_type_t::event_type` depends on what kind of threshold you set first. If you set the absolute threshold by :cpp:func:`temperature_sensor_set_absolute_threshold`, then the :cpp:enumerator:`TEMPERATURE_SENSOR_EVENT_OVER_LIMIT` refers to absolute threshold. Likewise, if you set the delta threshold by :cpp:func:`temperature_sensor_set_delta_threshold`, then the :cpp:enumerator:`TEMPERA"
"TURE_SENSOR_EVENT_OVER_LIMIT` refers to delta threshold.

    For how to connect the event and task to an ETM channel, please refer to the :doc:`ETM ` documentation.

Unexpected Behaviors


    (1) Totally out of range, like 200 °C ~ 300 °C.
    (2) Cross the boundary of each predefined measurement. like 40 °C ~ 110 °C.

Application Example


.. list::
    :SOC_TEMPERATURE_SENSOR_INTR_SUPPORT: * Temperature sensor value monitor example: :example:`peripherals/temperature_sensor/temp_sensor_monito"
"r`.

API Reference


.. include-build-file:: inc/temperature_sensor.inc
.. include-build-file:: inc/temperature_sensor_types.inc

.. only:: SOC_TEMPERATURE_SENSOR_SUPPORT_ETM

    .. include-build-file:: inc/temperature_sensor_etm.inc
"
"LED Control (LEDC)


{IDF_TARGET_LEDC_MAX_FADE_RANGE_NUM: default=""1"", esp32c6=""16"", esp32h2=""16"", esp32p4=""16""}



Introduction


The LED control (LEDC) peripheral is primarily designed to control the intensity of LEDs, although it can also be used to generate PWM signals for other purposes. It has {IDF_TARGET_SOC_LEDC_CHANNEL_NUM} channels which can generate independent waveforms that can be used, for example, to drive RGB LED devices.

.. only:: esp32

    LEDC channels are divided into two g"
"roups of 8 channels each. One group of LEDC channels operates in high speed mode. This mode is implemented in hardware and offers automatic and glitch-free changing of the PWM duty cycle. The other group of channels operate in low speed mode, the PWM duty cycle must be changed by the driver in software. Each group of channels is also able to use different clock sources.

The PWM controller can automatically increase or decrease the duty cycle gradually, allowing for fades without any processor i"
"nterference.


Functionality Overview


.. only:: esp32

    Setting up a channel of the LEDC in either :ref:`high or low speed mode ` is done in three steps:


.. only:: not esp32

    Setting up a channel of the LEDC is done in three steps. Note that unlike ESP32, {IDF_TARGET_NAME} only supports configuring channels in ""low speed"" mode.

As an optional step, it is also possible to set up an interrupt on fade end.

.. figure:: ../../../_static/ledc-api-settings.jpg
    :align: center
    :alt: "
"Key Settings of LED PWM Controller's API
    :figclass: align-center

    Key Settings of LED PWM Controller's API

.. note::

    For an initial setup, it is recommended to configure for the timers first (by calling :cpp:func:`ledc_timer_config`), and then for the channels (by calling :cpp:func:`ledc_channel_config`). This ensures the PWM frequency is at the desired value since the appearance of the PWM signal from the IO pad.


.. _ledc-api-configure-timer:

Timer Configuration


Setting the t"
"imer is done by calling the function :cpp:func:`ledc_timer_config` and passing the data structure :cpp:type:`ledc_timer_config_t` that contains the following configuration settings:

.. list::

    :esp32:     - Speed mode :cpp:type:`ledc_mode_t`
    :not esp32: - Speed mode (value must be ``LEDC_LOW_SPEED_MODE``)
    - Timer number :cpp:type:`ledc_timer_t`
    - PWM signal frequency in Hz
    - Resolution of PWM duty
    - Source clock :cpp:type:`ledc_clk_cfg_t`

The frequency and the duty reso"
"lution are interdependent. The higher the PWM frequency, the lower the duty resolution which is available, and vice versa. This relationship might be important if you are planning to use this API for purposes other than changing the intensity of LEDs. For more details, see Section :ref:`ledc-api-supported-range-frequency-duty-resolution`.

The source clock can also limit the PWM frequency. The higher the source clock frequency, the higher the maximum PWM frequency can be configured.

.. only:: e"
"sp32

    .. list-table:: Characteristics of {IDF_TARGET_NAME} LEDC source clocks
       :widths: 5 5 5 20
       :header-rows: 1
         - Clock freq
         - Speed mode
         - Clock capabilities
         - 80 MHz
         - High / Low
         - /
         - 1 MHz
         - High / Low
         - Dynamic Frequency Scaling compatible
         - ~ 8 MHz
         - Low
         - Dynamic Frequency Scaling compatible, Light sleep compatible

.. only:: esp32s2

    .. list-table:: Characteri"
"stics of {IDF_TARGET_NAME} LEDC source clocks
       :widths: 15 15 30
       :header-rows: 1
         - Clock freq
         - Clock capabilities
         - 80 MHz
         - /
         - 1 MHz
         - Dynamic Frequency Scaling compatible
         - ~ 8 MHz
         - Dynamic Frequency Scaling compatible, Light sleep compatible
         - 40 MHz
         - Dynamic Frequency Scaling compatible

.. only:: esp32s3 or esp32c3

    .. list-table:: Characteristics of {IDF_TARGET_NAME} LEDC source c"
"locks
       :widths: 15 15 30
       :header-rows: 1
         - Clock freq
         - Clock capabilities
         - 80 MHz
         - /
         - ~ 20 MHz
         - Dynamic Frequency Scaling compatible, Light sleep compatible
         - 40 MHz
         - Dynamic Frequency Scaling compatible

.. only:: esp32c2

    .. list-table:: Characteristics of {IDF_TARGET_NAME} LEDC source clocks
       :widths: 15 15 30
       :header-rows: 1
         - Clock freq
         - Clock capabilities
         "
"- 60 MHz
         - /
         - ~ 20 MHz
         - Dynamic Frequency Scaling compatible, Light sleep compatible
         - 40 MHz
         - Dynamic Frequency Scaling compatible

.. only:: esp32c6 or esp32p4

    .. list-table:: Characteristics of {IDF_TARGET_NAME} LEDC source clocks
       :widths: 15 15 30
       :header-rows: 1
         - Clock freq
         - Clock capabilities
         - 80 MHz
         - /
         - ~ 20 MHz
         - Dynamic Frequency Scaling compatible, Light sleep c"
"ompatible
         - 40 MHz
         - Dynamic Frequency Scaling compatible

.. only:: esp32h2

    .. list-table:: Characteristics of {IDF_TARGET_NAME} LEDC source clocks
       :widths: 15 15 30
       :header-rows: 1
         - Clock freq
         - Clock capabilities
         - 96 MHz
         - /
         - ~ 8 MHz
         - Dynamic Frequency Scaling compatible, Light sleep compatible
         - 32 MHz
         - Dynamic Frequency Scaling compatible

.. note::

    .. only:: SOC_CLK_RC_FAS"
"T_SUPPORT_CALIBRATION

    .. only:: not SOC_CLK_RC_FAST_SUPPORT_CALIBRATION

    .. only:: not SOC_LEDC_HAS_TIMER_SPECIFIC_MUX

The LEDC driver offers a helper function :cpp:func:`ledc_find_suitable_duty_resolution` to find the maximum possible resolution for the timer, given the source clock frequency and the desired PWM signal frequency.

When a timer is no longer needed by any channel, it can be deconfigured by calling the same function :cpp:func:`ledc_timer_config`. The configuration struct"
"ure :cpp:type:`ledc_timer_config_t` passes in should be:

-  :cpp:member:`ledc_timer_config_t::speed_mode` The speed mode of the timer which wants to be deconfigured belongs to (:cpp:type:`ledc_mode_t`)

-  :cpp:member:`ledc_timer_config_t::timer_num` The ID of the timers which wants to be deconfigured (:cpp:type:`ledc_timer_t`)

-  :cpp:member:`ledc_timer_config_t::deconfigure` Set this to true so that the timer specified can be deconfigured


.. _ledc-api-configure-channel:

Channel Configurat"
"ion


When the timer is set up, configure the desired channel (one out of :cpp:type:`ledc_channel_t`). This is done by calling the function :cpp:func:`ledc_channel_config`.

Similar to the timer configuration, the channel setup function should be passed a structure :cpp:type:`ledc_channel_config_t` that contains the channel's configuration parameters.

At this point, the channel should start operating and generating the PWM signal on the selected GPIO, as configured in :cpp:type:`ledc_channel_co"
"nfig_t`, with the frequency specified in the timer settings and the given duty cycle. The channel operation (signal generation) can be suspended at any time by calling the function :cpp:func:`ledc_stop`.


.. _ledc-api-change-pwm-signal:

Change PWM Signal


Once the channel starts operating and generating the PWM signal with the constant duty cycle and frequency, there are a couple of ways to change this signal. When driving LEDs, primarily the duty cycle is changed to vary the light intensity."
"

The following two sections describe how to change the duty cycle using software and hardware fading. If required, the signal's frequency can also be changed; it is covered in Section :ref:`ledc-api-change-pwm-frequency`.

.. only:: not esp32

    .. note::

        All the timers and channels in the {IDF_TARGET_NAME}'s LED PWM Controller only support low speed mode. Any change of PWM settings must be explicitly triggered by software (see below).


Change PWM Duty Cycle Using Software
"""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""

To set the duty cycle, use the dedicated function :cpp:func:`ledc_set_duty`. After that, call :cpp:func:`ledc_update_duty` to activate the changes. To check the currently set value, use the corresponding ``_get_`` function :cpp:func:`ledc_get_duty`.

Another way to set the duty cycle, as well as some other channel parameters, is by calling :cpp:func:`ledc_channel_config` covered in Section :ref:`ledc-api-configure-channel`.

The range of the duty cycle values passed "
"to functions depends on selected ``duty_resolution`` and should be from ``0`` to ``(2 ** duty_resolution)``. For example, if the selected duty resolution is 10, then the duty cycle values can range from 0 to 1024. This provides the resolution of ~ 0.1%.

.. only:: esp32 or esp32s2 or esp32s3 or esp32c3 or esp32c2 or esp32c6 or esp32h2 or esp32p4

    .. warning::

        On {IDF_TARGET_NAME}, when channel's binded timer selects its maximum duty resolution, the duty cycle value cannot be set to "
"``(2 ** duty_resolution)``. Otherwise, the internal duty counter in the hardware will overflow and be messed up.


Change PWM Duty Cycle Using Hardware
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The LEDC hardware provides the means to gradually transition from one duty cycle value to another. To use this functionality, enable fading with :cpp:func:`ledc_fade_func_install` and then configure it by calling one of the available fading functions:

.. only:: SOC_LEDC_GAMMA_CURVE_FADE_SUPPORTED

    On {ID"
"F_TARGET_NAME}, the hardware additionally allows to perform up to {IDF_TARGET_LEDC_MAX_FADE_RANGE_NUM} consecutive linear fades without CPU intervention. This feature can be useful if you want to do a fade with gamma correction.

    The luminance perceived by human eyes does not have a linear relationship with the PWM duty cycle. In order to make human feel the LED is dimming or lightening linearly, the change in duty cycle should be non-linear, which is the so-called gamma correction. The LED "
"controller can simulate a gamma curve fading by piecewise linear approximation. :cpp:func:`ledc_fill_multi_fade_param_list` is a function that can help to construct the parameters for the piecewise linear fades. First, you need to allocate a memory block for saving the fade parameters, then by providing start/end PWM duty cycle values, gamma correction function, and the total number of desired linear segments to the helper function, it will fill the calculation results into the allocated space. "
"You can also construct the array of :cpp:type:`ledc_fade_param_config_t` manually. Once the fade parameter structs are prepared, a consecutive fading can be configured by passing the pointer to the prepared :cpp:type:`ledc_fade_param_config_t` list and the total number of fade ranges to :cpp:func:`ledc_set_multi_fade`.

.. only:: esp32

    Start fading with :cpp:func:`ledc_fade_start`. A fade can be operated in blocking or non-blocking mode, please check :cpp:enum:`ledc_fade_mode_t` for the dif"
"ference between the two available fade modes. Note that with either fade mode, the next fade or fixed-duty update will not take effect until the last fade finishes. Due to hardware limitations, there is no way to stop a fade before it reaches its target duty.

.. only:: not esp32

    Start fading with :cpp:func:`ledc_fade_start`. A fade can be operated in blocking or non-blocking mode, please check :cpp:enum:`ledc_fade_mode_t` for the difference between the two available fade modes. Note that w"
"ith either fade mode, the next fade or fixed-duty update will not take effect until the last fade finishes or is stopped. :cpp:func:`ledc_fade_stop` has to be called to stop a fade that is in progress.

To get a notification about the completion of a fade operation, a fade end callback function can be registered for each channel by calling :cpp:func:`ledc_cb_register` after the fade service being installed. The fade end callback prototype is defined in :cpp:type:`ledc_cb_t`, where you should ret"
"urn a boolean value from the callback function, indicating whether a high priority task is woken up by this callback function. It is worth mentioning, the callback and the function invoked by itself should be placed in IRAM, as the interrupt service routine is in IRAM. :cpp:func:`ledc_cb_register` will print a warning message if it finds the addresses of callback and user context are incorrect.

If not required anymore, fading and an associated interrupt can be disabled with :cpp:func:`ledc_fade"
"_func_uninstall`.


.. _ledc-api-change-pwm-frequency:

Change PWM Frequency
""""""""""""""""""""""""""""""""""""""""

The LEDC API provides several ways to change the PWM frequency ""on the fly"":


More Control Over PWM
""""""""""""""""""""""""""""""""""""""""""

There are several lower level timer-specific functions that can be used to change PWM settings:

The first two functions are called ""behind the scenes"" by :cpp:func:`ledc_channel_config` to provide a startup of a timer after it is configured.


Use Interrupts


When configurin"
"g an LEDC channel, one of the parameters selected within :cpp:type:`ledc_channel_config_t` is :cpp:type:`ledc_intr_type_t` which triggers an interrupt on fade completion.

For registration of a handler to address this interrupt, call :cpp:func:`ledc_isr_register`.


.. only:: esp32

    .. _ledc-api-high_low_speed_mode:

    LEDC High and Low Speed Mode
    

    High speed mode enables a glitch-free changeover of timer settings. This means that if the timer settings are modified, the changes wi"
"ll be applied automatically on the next overflow interrupt of the timer. In contrast, when updating the low-speed timer, the change of settings should be explicitly triggered by software. The LEDC driver handles it in the background, e.g., when :cpp:func:`ledc_timer_config` or :cpp:func:`ledc_timer_set` is called.

    For additional details regarding speed modes, see **{IDF_TARGET_NAME} Technical Reference Manual** > **LED PWM Controller (LEDC)** [`PDF `__].

    .. _ledc-api-supported-range-fr"
"equency-duty-resolution:

.. only:: not esp32

    .. _ledc-api-supported-range-frequency-duty-resolution:

Supported Range of Frequency and Duty Resolutions


The LED PWM Controller is designed primarily to drive LEDs. It provides a large flexibility of PWM duty cycle settings. For instance, the PWM frequency of 5 kHz can have the maximum duty resolution of 13 bits. This means that the duty can be set anywhere from 0 to 100% with a resolution of ~ 0.012% (2 ** 13 = 8192 discrete levels of the L"
"ED intensity). Note, however, that these parameters depend on the clock signal clocking the LED PWM Controller timer which in turn clocks the channel (see :ref:`timer configuration ` and the **{IDF_TARGET_NAME} Technical Reference Manual** > **LED PWM Controller (LEDC)** [`PDF `__]).

The LEDC can be used for generating signals at much higher frequencies that are sufficient enough to clock other devices, e.g., a digital camera module. In this case, the maximum available frequency is 40 MHz with "
"duty resolution of 1 bit. This means that the duty cycle is fixed at 50% and cannot be adjusted.

The LEDC API is designed to report an error when trying to set a frequency and a duty resolution that exceed the range of LEDC's hardware. For example, an attempt to set the frequency to 20 MHz and the duty resolution to 3 bits results in the following error reported on a serial monitor:

.. highlight:: none

::

    E (196) ledc: requested frequency and duty resolution cannot be achieved, try reduc"
"ing freq_hz or duty_resolution. div_param=128

In such a situation, either the duty resolution or the frequency must be reduced. For example, setting the duty resolution to 2 resolves this issue and makes it possible to set the duty cycle at 25% steps, i.e., at 25%, 50% or 75%.

The LEDC driver also captures and reports attempts to configure frequency/duty resolution combinations that are below the supported minimum, e.g.,:

::

    E (196) ledc: requested frequency and duty resolution cannot be"
" achieved, try increasing freq_hz or duty_resolution. div_param=128000000

The duty resolution is normally set using :cpp:type:`ledc_timer_bit_t`. This enumeration covers the range from 10 to 15 bits. If a smaller duty resolution is required (from 10 down to 1), enter the equivalent numeric values directly.


Application Example


The LEDC basic example: :example:`peripherals/ledc/ledc_basic`.

The LEDC change duty cycle and fading control example: :example:`peripherals/ledc/ledc_fade`.

.. only"
":: SOC_LEDC_GAMMA_CURVE_FADE_SUPPORTED

    The LEDC color control with Gamma correction on RGB LED example: :example:`peripherals/ledc/ledc_gamma_curve_fade`.

API Reference


.. include-build-file:: inc/ledc.inc
.. include-build-file:: inc/ledc_types.inc
"
"
USB Device Driver


{IDF_TARGET_USB_DP_GPIO_NUM:default=""20""}
{IDF_TARGET_USB_DM_GPIO_NUM:default=""19""}
{IDF_TARGET_USB_EP_NUM:default=""6""}
{IDF_TARGET_USB_EP_NUM_INOUT:default=""5""}
{IDF_TARGET_USB_EP_NUM_IN:default=""1""}

Overview


The driver allows you to use {IDF_TARGET_NAME} chips to develop USB devices on a top of TinyUSB stack. TinyUSB is integrated with ESP-IDF to provide USB features of the framework. Using this driver the chip works as simple or composite device supporting several USB "
"devices simultaneously.

TinyUSB stack is distributed via `IDF Component Registry `__.

Our USB-OTG implementation is limited to {IDF_TARGET_USB_EP_NUM} USB endpoints ({IDF_TARGET_USB_EP_NUM_INOUT} IN/OUT endpoints and {IDF_TARGET_USB_EP_NUM_IN} IN endpoint) . Please note that enabling Secure Boot or flash encryption disables the USB-OTG USB stack in the ROM, disallowing updates via the serial emulation or Device Firmware Update (DFU) on that port. For more details, please refer to `technical re"
"ference manual `_.

Features


- Configuration of device and string USB descriptors
- USB Serial Device (CDC-ACM)
- Input and output streams through USB Serial Device
- Other USB classes (MIDI, MSC, HID...) support directly via TinyUSB
- USB Composite Device (MSC + CDC)
- VBUS monitoring for self-powered devices

Hardware USB Connection


- Any board with the {IDF_TARGET_NAME} chip with USB connectors or with exposed USB's D+ and D- (DATA+/DATA-) pins.

If the board has no USB connector but has "
"the pins, connect pins directly to the host (e.g., with do-it-yourself cable from any USB connection cable).

On {IDF_TARGET_NAME}, connect GPIO {IDF_TARGET_USB_DP_GPIO_NUM} and {IDF_TARGET_USB_DM_GPIO_NUM} to D+/D- respectively:


.. figure:: ../../../_static/usb-board-connection.png
    :align: center
    :alt: Connection of an ESP board to a USB host
    :figclass: align-center

Self-powered devices must also connect VBUS through voltage divider or comparator, more details in :ref:`self-power"
"ed-device` subchapter.

Driver Structure


As the basis is used the TinyUSB stack.

On top of it the driver implements:

- Customization of USB descriptors
- Serial device support
- Redirecting of standard streams through the Serial device
- Storage Media (SPI-Flash and SD-Card) for USB Device MSC Class.
- Encapsulated driver's task servicing the TinyUSB

Configuration


To use the component, you need to add it as a dependency via the following command. For more details, please refer to `IDF Com"
"ponent Registry `__.

.. code:: bash

  idf.py add-dependency esp_tinyusb

Via Menuconfig options you can specify:

- Several descriptor's parameters (see Descriptors Configuration below)
- USB Serial low-level configuration
- The verbosity of the TinyUSB's log
- Disable the TinyUSB main task (for the custom implementation)

Descriptors Configuration


The driver's descriptors are provided by :cpp:type:`tinyusb_config_t` structure's :cpp:member:`device_descriptor`, :cpp:member:`configuration_des"
"criptor` and :cpp:member:`string_descriptor` members. Therefore, you should initialize :cpp:type:`tinyusb_config_t` with your desired descriptors before calling :cpp:func:`tinyusb_driver_install` to install the driver.

However, the driver also provides default descriptors. You can install the driver with default device and string descriptors by setting the :cpp:member:`device_descriptor` and :cpp:member:`string_descriptor` members of :cpp:type:`tinyusb_config_t` to `NULL` before calling :cpp:fu"
"nc:`tinyusb_driver_install`. To lower your development effort we also provide default configuration descriptor for CDC and MSC class, as these classes rarely require custom configuration. The driver's default device descriptor is specified using Menuconfig, where the following fields should be configured:

- PID
- VID
- bcdDevice
- Manufacturer
- Product name
- Name of CDC or MSC device if it is On
- Serial number

If you want to use your own descriptors with extended modification, you can defin"
"e them during the driver installation process.

Install Driver


To initialize the driver, users should call :cpp:func:`tinyusb_driver_install`. The driver's configuration is specified in a :cpp:type:`tinyusb_config_t` structure that is passed as an argument to :cpp:func:`tinyusb_driver_install`.

 Note that the :cpp:type:`tinyusb_config_t` structure can be zero initialized (e.g., ``const tinyusb_config_t tusb_cfg = { 0 };``) or partially (as shown below). For any member that is initialized to `"
"0` or `NULL`, the driver will use its default configuration values for that member (see example below)

.. code-block:: c

    const tinyusb_config_t partial_init = {
        .device_descriptor = NULL,  // Use default device descriptor specified in Menuconfig
        .string_descriptor = NULL,  // Use default string descriptors specified in Menuconfig
        .external_phy = false,      // Use internal USB PHY
        .configuration_descriptor = NULL, // Use default configuration descriptor acco"
"rding to settings in Menuconfig
    };

.. _self-powered-device:

Self-Powered Device


USB specification mandates self-powered devices to monitor voltage level on USB's VBUS signal. As opposed to bus-powered devices, a self-powered device can be fully functional even without USB connection. The self-powered device detects connection and disconnection events by monitoring the VBUS voltage level. VBUS is considered valid if it rises above 4.75 V and invalid if it falls below 4.35 V.

No {IDF_TARG"
"ET_NAME} pin is 5 V tolerant, so you must connect the VBUS to {IDF_TARGET_NAME} via a comparator with voltage thresholds as described above, or use a simple resistor voltage divider that will output (0.75 x Vdd) if VBUS is 4.4 V (see figure below). In both cases, voltage on the sensing pin must be logic low within 3 ms after the device is unplugged from USB host.

.. figure:: ../../../_static/diagrams/usb/usb_vbus_voltage_monitor.png
    :align: center
    :alt: Simple voltage divider for VBUS m"
"onitoring
    :figclass: align-center

    Simple voltage divider for VBUS monitoring

To use this feature, in :cpp:type:`tinyusb_config_t` you must set :cpp:member:`self_powered` to ``true`` and :cpp:member:`vbus_monitor_io` to GPIO number that will be used for VBUS monitoring.

USB Serial Device (CDC-ACM)


If the CDC option is enabled in Menuconfig, the USB Serial Device can be initialized with :cpp:func:`tusb_cdc_acm_init` according to the settings from :cpp:type:`tinyusb_config_cdcacm_t` (s"
"ee example below).

.. code-block:: c

    const tinyusb_config_cdcacm_t acm_cfg = {
        .usb_dev = TINYUSB_USBDEV_0,
        .cdc_port = TINYUSB_CDC_ACM_0,
        .rx_unread_buf_sz = 64,
        .callback_rx = NULL,
        .callback_rx_wanted_char = NULL,
        .callback_line_state_changed = NULL,
        .callback_line_coding_changed = NULL
    };
    tusb_cdc_acm_init(&acm_cfg);

To specify callbacks you can either set the pointer to your :cpp:type:`tusb_cdcacm_callback_t` function in"
" the configuration structure or call :cpp:func:`tinyusb_cdcacm_register_callback` after initialization.

USB Serial Console


The driver allows to redirect all standard application streams (stdin, stdout, stderr) to the USB Serial Device and return them to UART using :cpp:func:`esp_tusb_init_console`/:cpp:func:`esp_tusb_deinit_console` functions.

USB Mass Storage Device (MSC)


If the MSC CONFIG_TINYUSB_MSC_ENABLED option is enabled in Menuconfig, the ESP Chip can be used as USB MSC Device. The"
" storage media (spi-flash or sd-card) can be initialized as shown below (see example below).

- SPI-Flash

.. code-block:: c

    static esp_err_t storage_init_spiflash(wl_handle_t *wl_handle)
    {
        ***
        esp_partition_t *data_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, NULL);
        ***
        wl_mount(data_partition, wl_handle);
        ***
    }
    storage_init_spiflash(&wl_handle);

    const tinyusb_msc_spiflash_config_t con"
"fig_spi = {
        .wl_handle = wl_handle
    };
    tinyusb_msc_storage_init_spiflash(&config_spi);


- SD-Card

.. code-block:: c

    static esp_err_t storage_init_sdmmc(sdmmc_card_t **card)
    {
        ***
        sdmmc_host_t host = SDMMC_HOST_DEFAULT();
        sdmmc_slot_config_t slot_config = SDMMC_SLOT_CONFIG_DEFAULT();
        // For SD Card, set bus width to use

        slot_config.width = 4;
        slot_config.clk = CONFIG_EXAMPLE_PIN_CLK;
        slot_config.cmd = CONFIG_EXAMPL"
"E_PIN_CMD;
        slot_config.d0 = CONFIG_EXAMPLE_PIN_D0;
        slot_config.d1 = CONFIG_EXAMPLE_PIN_D1;
        slot_config.d2 = CONFIG_EXAMPLE_PIN_D2;
        slot_config.d3 = CONFIG_EXAMPLE_PIN_D3;
        slot_config.flags |= SDMMC_SLOT_FLAG_INTERNAL_PULLUP;

        sd_card = (sdmmc_card_t *)malloc(sizeof(sdmmc_card_t));
        (*host.init)();
        sdmmc_host_init_slot(host.slot, (const sdmmc_slot_config_t *) &slot_config);
        sdmmc_card_init(&host, sd_card);
        ***
    }
  "
"  storage_init_sdmmc(&card);

    const tinyusb_msc_sdmmc_config_t config_sdmmc = {
        .card = card
    };
    tinyusb_msc_storage_init_sdmmc(&config_sdmmc);


Application Examples


The table below describes the code examples available in the directory :example:`peripherals/usb/`.

.. list-table::
   :widths: 35 65
   :header-rows: 1
     - Description
     - How to set up {IDF_TARGET_NAME} chip to get log output via Serial Device connection
     - How to set up {IDF_TARGET_NAME} chip to w"
"ork as a USB Serial Device
     - How to set up {IDF_TARGET_NAME} chip to work as a USB MIDI Device
     - How to set up {IDF_TARGET_NAME} chip to work as a USB Human Interface Device
     - How to set up {IDF_TARGET_NAME} chip to work as a USB Mass Storage Device
     - How to set up {IDF_TARGET_NAME} chip to work as a Composite USB Device (MSC + CDC)
"
"Pulse Counter (PCNT)


Introduction


The PCNT (Pulse Counter) module is designed to count the number of rising and/or falling edges of input signals. The {IDF_TARGET_NAME} contains multiple pulse counter units in the module. [1]_ Each unit is in effect an independent counter with multiple channels, where each channel can increment/decrement the counter on a rising/falling edge. Furthermore, each channel can be configured separately.

PCNT channels can react to signals of **edge** type and **lev"
"el** type, however for simple applications, detecting the edge signal is usually sufficient. PCNT channels can be configured react to both pulse edges (i.e., rising and falling edge), and can be configured to increase, decrease or do nothing to the unit's counter on each edge. The level signal is the so-called **control signal**, which is used to control the counting mode of the edge signals that are attached to the same channel. By combining the usage of both edge and level signals, a PCNT unit"
" can act as a **quadrature decoder**.

Besides that, PCNT unit is equipped with a separate glitch filter, which is helpful to remove noise from the signal.

Typically, a PCNT module can be used in scenarios like:

- Calculate periodic signal's frequency by counting the pulse numbers within a time slice
- Decode quadrature signals into speed and direction

Functional Overview


Description of the PCNT functionality is divided into the following sections:

.. list::

    - :ref:`pcnt-resource-allo"
"cation` - covers how to allocate PCNT units and channels with properly set of configurations. It also covers how to recycle the resources when they finished working.
    - :ref:`pcnt-setup-channel-actions` - covers how to configure the PCNT channel to behave on different signal edges and levels.
    - :ref:`pcnt-watch-points` - describes how to configure PCNT watch points (i.e., tell PCNT unit to trigger an event when the count reaches a certain value).
    - :ref:`pcnt-register-event-callbacks`"
" - describes how to hook your specific code to the watch point event callback function.
    - :ref:`pcnt-set-glitch-filter` - describes how to enable and set the timing parameters for the internal glitch filter.
    :SOC_PCNT_SUPPORT_CLEAR_SIGNAL: - :ref:`pcnt-set-clear-signal` - describes how to set the parameters for the external clear signal.
    - :ref:`pcnt-enable-disable-unit` - describes how to enable and disable the PCNT unit.
    - :ref:`pcnt-unit-io-control` - describes IO control func"
"tions of PCNT unit, like enable glitch filter, start and stop unit, get and clear count value.
    - :ref:`pcnt-power-management` - describes what functionality will prevent the chip from going into low power mode.
    - :ref:`pcnt-iram-safe` - describes tips on how to make the PCNT interrupt and IO control functions work better along with a disabled cache.
    - :ref:`pcnt-thread-safe` - lists which APIs are guaranteed to be thread safe by the driver.
    - :ref:`pcnt-kconfig-options` - lists t"
"he supported Kconfig options that can be used to make a different effect on driver behavior.

.. _pcnt-resource-allocation:

Resource Allocation


The PCNT unit and channel are represented by :cpp:type:`pcnt_unit_handle_t` and :cpp:type:`pcnt_channel_handle_t` respectively. All available units and channels are maintained by the driver in a resource pool, so you do not need to know the exact underlying instance ID.

Install PCNT Unit
~~~~~~~~~~~~~~~~~

To install a PCNT unit, there is a configura"
"tion structure that needs to be given in advance: :cpp:type:`pcnt_unit_config_t`:

-  :cpp:member:`pcnt_unit_config_t::low_limit` and :cpp:member:`pcnt_unit_config_t::high_limit` specify the range for the internal hardware counter. The counter will reset to zero automatically when it crosses either the high or low limit.
-  :cpp:member:`pcnt_unit_config_t::accum_count` sets whether to create an internal accumulator for the counter. This is helpful when you want to extend the counter's width, whi"
"ch by default is 16 bit at most, defined in the hardware. See also :ref:`pcnt-compensate-overflow-loss` for how to use this feature to compensate the overflow loss.
-  :cpp:member:`pcnt_unit_config_t::intr_priority` sets the priority of the interrupt. If it is set to ``0``, the driver will allocate an interrupt with a default priority. Otherwise, the driver will use the given priority.

.. note::

    Since all PCNT units share the same interrupt source, when installing multiple PCNT units make "
"sure that the interrupt priority :cpp:member:`pcnt_unit_config_t::intr_priority` is the same for each unit.

Unit allocation and initialization is done by calling a function :cpp:func:`pcnt_new_unit` with :cpp:type:`pcnt_unit_config_t` as an input parameter. The function will return a PCNT unit handle only when it runs correctly. Specifically, when there are no more free PCNT units in the pool (i.e., unit resources have been used up), then this function will return :c:macro:`ESP_ERR_NOT_FOUND` e"
"rror. The total number of available PCNT units is recorded by :c:macro:`SOC_PCNT_UNITS_PER_GROUP` for reference.

If a previously created PCNT unit is no longer needed, it is recommended to recycle the resource by calling :cpp:func:`pcnt_del_unit`. Which in return allows the underlying unit hardware to be used for other purposes. Before deleting a PCNT unit, one should ensure the following prerequisites:

- The unit is in the init state, in other words, the unit is either disabled by :cpp:func:`"
"pcnt_unit_disable` or not enabled yet.
- The attached PCNT channels are all removed by :cpp:func:`pcnt_del_channel`.

.. code:: c

    #define EXAMPLE_PCNT_HIGH_LIMIT 100
    #define EXAMPLE_PCNT_LOW_LIMIT  -100

    pcnt_unit_config_t unit_config = {
        .high_limit = EXAMPLE_PCNT_HIGH_LIMIT,
        .low_limit = EXAMPLE_PCNT_LOW_LIMIT,
    };
    pcnt_unit_handle_t pcnt_unit = NULL;
    ESP_ERROR_CHECK(pcnt_new_unit(&unit_config, &pcnt_unit));

Install PCNT Channel
~~~~~~~~~~~~~~~~~~~~

To"
" install a PCNT channel, you must initialize a :cpp:type:`pcnt_chan_config_t` structure in advance, and then call :cpp:func:`pcnt_new_channel`. The configuration fields of the :cpp:type:`pcnt_chan_config_t` structure are described below:

- :cpp:member:`pcnt_chan_config_t::edge_gpio_num` and :cpp:member:`pcnt_chan_config_t::level_gpio_num` specify the GPIO numbers used by **edge** type signal and **level** type signal. Please note, either of them can be assigned to ``-1`` if it is not actually u"
"sed, and thus it will become a **virtual IO**. For some simple pulse counting applications where one of the level/edge signals is fixed (i.e., never changes), you can reclaim a GPIO by setting the signal as a virtual IO on channel allocation. Setting the level/edge signal as a virtual IO causes that signal to be internally routed to a fixed High/Low logic level, thus allowing you to save a GPIO for other purposes.
- :cpp:member:`pcnt_chan_config_t::virt_edge_io_level` and :cpp:member:`pcnt_chan_"
"config_t::virt_level_io_level` specify the virtual IO level for **edge** and **level** input signal, to ensure a deterministic state for such control signal. Please note, they are only valid when either :cpp:member:`pcnt_chan_config_t::edge_gpio_num` or :cpp:member:`pcnt_chan_config_t::level_gpio_num` is assigned to ``-1``.
- :cpp:member:`pcnt_chan_config_t::invert_edge_input` and :cpp:member:`pcnt_chan_config_t::invert_level_input` are used to decide whether to invert the input signals before t"
"hey going into PCNT hardware. The invert is done by GPIO matrix instead of PCNT hardware.
- :cpp:member:`pcnt_chan_config_t::io_loop_back` is for debug only, which enables both the GPIO's input and output paths. This can help to simulate the pulse signals by function :cpp:func:`gpio_set_level` on the same GPIO.

Channel allocating and initialization is done by calling a function :cpp:func:`pcnt_new_channel` with the above :cpp:type:`pcnt_chan_config_t` as an input parameter plus a PCNT unit hand"
"le returned from :cpp:func:`pcnt_new_unit`. This function will return a PCNT channel handle if it runs correctly. Specifically, when there are no more free PCNT channel within the unit (i.e., channel resources have been used up), then this function will return :c:macro:`ESP_ERR_NOT_FOUND` error. The total number of available PCNT channels within the unit is recorded by :c:macro:`SOC_PCNT_CHANNELS_PER_UNIT` for reference. Note that, when install a PCNT channel for a specific unit, one should ensu"
"re the unit is in the init state, otherwise this function will return :c:macro:`ESP_ERR_INVALID_STATE` error.

If a previously created PCNT channel is no longer needed, it is recommended to recycle the resources by calling :cpp:func:`pcnt_del_channel`. Which in return allows the underlying channel hardware to be used for other purposes.

.. code:: c

    #define EXAMPLE_CHAN_GPIO_A 0
    #define EXAMPLE_CHAN_GPIO_B 2

    pcnt_chan_config_t chan_config = {
        .edge_gpio_num = EXAMPLE_CHAN_G"
"PIO_A,
        .level_gpio_num = EXAMPLE_CHAN_GPIO_B,
    };
    pcnt_channel_handle_t pcnt_chan = NULL;
    ESP_ERROR_CHECK(pcnt_new_channel(pcnt_unit, &chan_config, &pcnt_chan));

.. _pcnt-setup-channel-actions:

Set Up Channel Actions


The PCNT will increase/decrease/hold its internal count value when the input pulse signal toggles. You can set different actions for edge signal and/or level signal.

- :cpp:func:`pcnt_channel_set_edge_action` function is to set specific actions for rising and"
" falling edge of the signal attached to the :cpp:member:`pcnt_chan_config_t::edge_gpio_num`. Supported actions are listed in :cpp:type:`pcnt_channel_edge_action_t`.
- :cpp:func:`pcnt_channel_set_level_action` function is to set specific actions for high and low level of the signal attached to the :cpp:member:`pcnt_chan_config_t::level_gpio_num`. Supported actions are listed in :cpp:type:`pcnt_channel_level_action_t`. This function is not mandatory if the :cpp:member:`pcnt_chan_config_t::level_gp"
"io_num` is set to ``-1`` when allocating PCNT channel by :cpp:func:`pcnt_new_channel`.

.. code:: c

    // decrease the counter on rising edge, increase the counter on falling edge
    ESP_ERROR_CHECK(pcnt_channel_set_edge_action(pcnt_chan, PCNT_CHANNEL_EDGE_ACTION_DECREASE, PCNT_CHANNEL_EDGE_ACTION_INCREASE));
    // keep the counting mode when the control signal is high level, and reverse the counting mode when the control signal is low level
    ESP_ERROR_CHECK(pcnt_channel_set_level_action("
"pcnt_chan, PCNT_CHANNEL_LEVEL_ACTION_KEEP, PCNT_CHANNEL_LEVEL_ACTION_INVERSE));

.. _pcnt-watch-points:

Watch Points


Each PCNT unit can be configured to watch several different values that you are interested in. The value to be watched is also called **Watch Point**. The watch point itself can not exceed the range set in :cpp:type:`pcnt_unit_config_t` by :cpp:member:`pcnt_unit_config_t::low_limit` and :cpp:member:`pcnt_unit_config_t::high_limit`. When the counter reaches either watch point, a"
" watch event will be triggered and notify you by interrupt if any watch event callback has ever registered in :cpp:func:`pcnt_unit_register_event_callbacks`. See :ref:`pcnt-register-event-callbacks` for how to register event callbacks.

The watch point can be added and removed by :cpp:func:`pcnt_unit_add_watch_point` and :cpp:func:`pcnt_unit_remove_watch_point`. The commonly-used watch points are: **zero cross**, **maximum/minimum count** and other threshold values. The number of available watch"
" point is limited, :cpp:func:`pcnt_unit_add_watch_point` will return error :c:macro:`ESP_ERR_NOT_FOUND` if it can not find any free hardware resource to save the watch point. You can not add the same watch point for multiple times, otherwise it will return error :c:macro:`ESP_ERR_INVALID_STATE`.

It is recommended to remove the unused watch point by :cpp:func:`pcnt_unit_remove_watch_point` to recycle the watch point resources.

.. code:: c

    // add zero across watch point
    ESP_ERROR_CHECK("
"pcnt_unit_add_watch_point(pcnt_unit, 0));
    // add high limit watch point
    ESP_ERROR_CHECK(pcnt_unit_add_watch_point(pcnt_unit, EXAMPLE_PCNT_HIGH_LIMIT));

.. only:: not SOC_PCNT_SUPPORT_RUNTIME_THRES_UPDATE

    .. note::

        Due to the hardware limitation, after adding a watch point, you should call :cpp:func:`pcnt_unit_clear_count` to make it take effect.

.. _pcnt-register-event-callbacks:

Register Event Callbacks


When PCNT unit reaches any enabled watch point, specific event wi"
"ll be generated and notify the CPU by interrupt. If you have some function that want to get executed when event happens, you should hook your function to the interrupt service routine by calling :cpp:func:`pcnt_unit_register_event_callbacks`. All supported event callbacks are listed in the :cpp:type:`pcnt_event_callbacks_t`:

- :cpp:member:`pcnt_event_callbacks_t::on_reach` sets a callback function for watch point event. As this function is called within the ISR context, you must ensure that the"
" function does not attempt to block (e.g., by making sure that only FreeRTOS APIs with ``ISR`` suffix are called from within the function). The function prototype is declared in :cpp:type:`pcnt_watch_cb_t`.

You can save their own context to :cpp:func:`pcnt_unit_register_event_callbacks` as well, via the parameter ``user_ctx``. This user data will be directly passed to the callback functions.

In the callback function, the driver will fill in the event data of specific event. For example, the wa"
"tch point event data is declared as :cpp:type:`pcnt_watch_event_data_t`:

- :cpp:member:`pcnt_watch_event_data_t::watch_point_value` saves the watch point value that triggers the event.
- :cpp:member:`pcnt_watch_event_data_t::zero_cross_mode` saves how the PCNT unit crosses the zero point in the latest time. The possible zero cross modes are listed in the :cpp:type:`pcnt_unit_zero_cross_mode_t`. Usually different zero cross mode means different **counting direction** and **counting step size**.
"
"
Registering callback function results in lazy installation of interrupt service, thus this function should only be called before the unit is enabled by :cpp:func:`pcnt_unit_enable`. Otherwise, it can return :c:macro:`ESP_ERR_INVALID_STATE` error.

.. code:: c

    static bool example_pcnt_on_reach(pcnt_unit_handle_t unit, const pcnt_watch_event_data_t *edata, void *user_ctx)
    {
        BaseType_t high_task_wakeup;
        QueueHandle_t queue = (QueueHandle_t)user_ctx;
        // send watch p"
"oint to queue, from this interrupt callback
        xQueueSendFromISR(queue, &(edata->watch_point_value), &high_task_wakeup);
        // return whether a high priority task has been waken up by this function
        return (high_task_wakeup == pdTRUE);
    }

    pcnt_event_callbacks_t cbs = {
        .on_reach = example_pcnt_on_reach,
    };
    QueueHandle_t queue = xQueueCreate(10, sizeof(int));
    ESP_ERROR_CHECK(pcnt_unit_register_event_callbacks(pcnt_unit, &cbs, queue));

.. _pcnt-set-gli"
"tch-filter:

Set Glitch Filter


The PCNT unit features filters to ignore possible short glitches in the signals. The parameters that can be configured for the glitch filter are listed in :cpp:type:`pcnt_glitch_filter_config_t`:

- :cpp:member:`pcnt_glitch_filter_config_t::max_glitch_ns` sets the maximum glitch width, in nano seconds. If a signal pulse's width is smaller than this value, then it will be treated as noise and will not increase/decrease the internal counter.

You can enable the gli"
"tch filter for PCNT unit by calling :cpp:func:`pcnt_unit_set_glitch_filter` with the filter configuration provided above. Particularly, you can disable the glitch filter later by calling :cpp:func:`pcnt_unit_set_glitch_filter` with a ``NULL`` filter configuration.

This function should be called when the unit is in the init state. Otherwise, it will return :c:macro:`ESP_ERR_INVALID_STATE` error.

.. note::

    The glitch filter is clocked from APB. For the counter not to miss any pulses, the ma"
"ximum glitch width should be longer than one APB_CLK cycle (usually 12.5 ns if APB equals 80 MHz). As the APB frequency would be changed after DFS (Dynamic Frequency Scaling) enabled, which means the filter does not work as expect in that case. So the driver installs a PM lock for PCNT unit during the first time you enable the glitch filter. For more information related to power management strategy used in PCNT driver, please see :ref:`pcnt-power-management`.

.. code:: c

    pcnt_glitch_filter"
"_config_t filter_config = {
        .max_glitch_ns = 1000,
    };
    ESP_ERROR_CHECK(pcnt_unit_set_glitch_filter(pcnt_unit, &filter_config));

.. only:: SOC_PCNT_SUPPORT_CLEAR_SIGNAL

    .. _pcnt-set-clear-signal:

    Use External Clear Signal
    

    The PCNT unit can receive a clear signal from the GPIO. The parameters that can be configured for the clear signal are listed in :cpp:type:`pcnt_clear_signal_config_t`:

        -  :cpp:member:`pcnt_clear_signal_config_t::clear_signal_gpio_num"
"` specify the GPIO numbers used by **clear** signal. The default active level is high, and the input mode is pull-down enabled.
        -  :cpp:member:`pcnt_clear_signal_config_t::invert_clear_signal` is used to decide whether to invert the input signal before it going into PCNT hardware. The invert is done by GPIO matrix instead of PCNT hardware. The input mode is pull-up enabled when the input signal is inverted.
        -  :cpp:member:`pcnt_clear_signal_config_t::io_loop_back` is for debug on"
"ly, which enables both the GPIO's input and output paths. This can help to simulate the clear signal by function :cpp:func:`gpio_set_level` for the same GPIO.

    This signal acts in the same way as calling :cpp:func:`pcnt_unit_clear_count`, but is not subject to software latency, and is suitable for use in situations with low latency requirements. Also please note, the flip frequency of this signal can not be too high.

    .. code:: c

        pcnt_clear_signal_config_t clear_signal_config = "
"{
            .clear_signal_gpio_num = PCNT_CLEAR_SIGNAL_GPIO,
        };
        ESP_ERROR_CHECK(pcnt_unit_set_clear_signal(pcnt_unit, &clear_signal_config));

    .. _pcnt-enable-disable-unit:

.. only:: not SOC_PCNT_SUPPORT_CLEAR_SIGNAL

    .. _pcnt-enable-disable-unit:

Enable and Disable Unit


Before doing IO control to the PCNT unit, you need to enable it first, by calling :cpp:func:`pcnt_unit_enable`. Internally, this function:

On the contrary, calling :cpp:func:`pcnt_unit_disable` wil"
"l do the opposite, that is, put the PCNT driver back to the **init** state, disable the interrupts service and release the power management lock.

.. code::c

    ESP_ERROR_CHECK(pcnt_unit_enable(pcnt_unit));

.. _pcnt-unit-io-control:

Unit IO Control


Start/Stop and Clear
~~~~~~~~~~~~~~~~~~~~

Calling :cpp:func:`pcnt_unit_start` makes the PCNT unit start to work, increase or decrease counter according to pulse signals. On the contrary, calling :cpp:func:`pcnt_unit_stop` will stop the PCNT uni"
"t but retain current count value. Instead, clearing counter can only be done by calling :cpp:func:`pcnt_unit_clear_count`.

Note, :cpp:func:`pcnt_unit_start` and :cpp:func:`pcnt_unit_stop` should be called when the unit has been enabled by :cpp:func:`pcnt_unit_enable`. Otherwise, it will return :c:macro:`ESP_ERR_INVALID_STATE` error.

.. code::c

    ESP_ERROR_CHECK(pcnt_unit_clear_count(pcnt_unit));
    ESP_ERROR_CHECK(pcnt_unit_start(pcnt_unit));

Get Count Value
~~~~~~~~~~~~~~~

You can read "
"current count value at any time by calling :cpp:func:`pcnt_unit_get_count`. The returned count value is a **signed** integer, where the sign can be used to reflect the direction.

.. code:: c

    int pulse_count = 0;
    ESP_ERROR_CHECK(pcnt_unit_get_count(pcnt_unit, &pulse_count));

.. _pcnt-compensate-overflow-loss:

Compensate Overflow Loss
~~~~~~~~~~~~~~~~~~~~~~~~

The internal hardware counter will be cleared to zero automatically when it reaches high or low limit. If you want to compensat"
"e for that count loss and extend the counter's bit-width, you can:

.. note::

    :cpp:func:`pcnt_unit_clear_count` resets the accumulated count value as well.

.. _pcnt-power-management:

Power Management


When power management is enabled (i.e., :ref:`CONFIG_PM_ENABLE` is on), the system will adjust the APB frequency before going into light sleep, thus potentially changing the behavior of PCNT glitch filter and leading to valid signal being treated as noise.

However, the driver can prevent t"
"he system from changing APB frequency by acquiring a power management lock of type :cpp:enumerator:`ESP_PM_APB_FREQ_MAX`. Whenever you enable the glitch filter by :cpp:func:`pcnt_unit_set_glitch_filter`, the driver guarantees that the power management lock is acquired after the PCNT unit is enabled by :cpp:func:`pcnt_unit_enable`. Likewise, the driver releases the lock after :cpp:func:`pcnt_unit_disable` is called.

.. _pcnt-iram-safe:

IRAM Safe


By default, the PCNT interrupt will be deferred"
" when the Cache is disabled for reasons like writing/erasing Flash. Thus the alarm interrupt will not get executed in time, which is not expected in a real-time application.

There is a Kconfig option :ref:`CONFIG_PCNT_ISR_IRAM_SAFE` that:

This allows the interrupt to run while the cache is disabled but comes at the cost of increased IRAM consumption.

There is another Kconfig option :ref:`CONFIG_PCNT_CTRL_FUNC_IN_IRAM` that can put commonly used IO control functions into IRAM as well. So that "
"these functions can also be executable when the cache is disabled. These IO control functions are as follows:

- :cpp:func:`pcnt_unit_start`
- :cpp:func:`pcnt_unit_stop`
- :cpp:func:`pcnt_unit_clear_count`
- :cpp:func:`pcnt_unit_get_count`

.. _pcnt-thread-safe:

Thread Safety


The factory functions :cpp:func:`pcnt_new_unit`  and :cpp:func:`pcnt_new_channel` are guaranteed to be thread safe by the driver, which means, you can call them from different RTOS tasks without protection by extra locks"
".

The following functions are allowed to run under ISR context, the driver uses a critical section to prevent them being called concurrently in both task and ISR.

- :cpp:func:`pcnt_unit_start`
- :cpp:func:`pcnt_unit_stop`
- :cpp:func:`pcnt_unit_clear_count`
- :cpp:func:`pcnt_unit_get_count`

Other functions that take the :cpp:type:`pcnt_unit_handle_t` and :cpp:type:`pcnt_channel_handle_t` as the first positional parameter, are not treated as thread safe. This means you should avoid calling the"
"m from multiple tasks.

.. _pcnt-kconfig-options:

Kconfig Options


- :ref:`CONFIG_PCNT_CTRL_FUNC_IN_IRAM` controls where to place the PCNT control functions (IRAM or Flash), see :ref:`pcnt-iram-safe` for more information.
- :ref:`CONFIG_PCNT_ISR_IRAM_SAFE` controls whether the default ISR handler can work when cache is disabled, see :ref:`pcnt-iram-safe` for more information.
- :ref:`CONFIG_PCNT_ENABLE_DEBUG_LOG` is used to enabled the debug log output. Enabling this option increases the firmw"
"are binary size.

Application Examples



API Reference


.. include-build-file:: inc/pulse_cnt.inc
.. include-build-file:: inc/pcnt_types.inc

.. [1]
   Different ESP chip series might have different number of PCNT units and channels. Please refer to the [`TRM `__] for details. The driver does not forbid you from applying for more PCNT units and channels, but it returns error when all available hardware resources are used up. Please always check the return value when doing resource allocation ("
"e.g., :cpp:func:`pcnt_new_unit`).

.. [2]
   :cpp:member:`pcnt_event_callbacks_t::on_reach` callback and the functions invoked by itself should also be placed in IRAM, you need to take care of them by themselves.
"
"Hash-Based Message Authentication Code (HMAC)




Hash-based Message Authentication Code (HMAC) is a secure authentication technique that verifies the authenticity and integrity of a message with a pre-shared key. This module provides hardware acceleration for SHA256-HMAC generation using a key burned into an eFuse block.

For more detailed information on the application workflow and the HMAC calculation process, see **{IDF_TARGET_NAME} Technical Reference Manual** > **HMAC Accelerator (HMAC)** "
"[`PDF `__].

Generalized Application Scheme


Let there be two parties, A and B. They want to verify the authenticity and integrity of messages sent between each other. Before they can start sending messages, they need to exchange the secret key via a secure channel.

To verify A's messages, B can do the following:

- A calculates the HMAC of the message it wants to send.
- A sends the message and the HMAC to B.
- B calculates the HMAC of the received message itself.
- B checks whether the recei"
"ved and calculated HMACs match.

If they do match, the message is authentic.

However, the HMAC itself is not bound to this use case. It can also be used for challenge-response protocols supporting HMAC or as a key input for further security modules (see below), etc.

HMAC on {IDF_TARGET_NAME}


On {IDF_TARGET_NAME}, the HMAC module works with a secret key burnt into the eFuses. This eFuse key can be made completely inaccessible for any resources outside the cryptographic modules, thus avoiding "
"key leakage.

Furthermore, {IDF_TARGET_NAME} has three different application scenarios for its HMAC module:

#. HMAC is generated for software use
#. HMAC is used as a key for the Digital Signature (DS) module
#. HMAC is used for enabling the soft-disabled JTAG interface

The first mode is called **Upstream** mode, while the last two modes are called **Downstream** modes.

eFuse Keys for HMAC


Six physical eFuse blocks can be used as keys for the HMAC module: block 4 ~ block 9. The enum :cpp:en"
"um:`hmac_key_id_t` in the API maps them to ``HMAC_KEY0`` ~ ``HMAC_KEY5``.

Each key has a corresponding eFuse parameter **key purpose** determining for which of the three HMAC application scenarios (see below) the key may be used:

.. list-table::
   :widths: 15 70
   :header-rows: 1
     - Application Scenario
     - HMAC generated for software use
     - HMAC used as a key for the Digital Signature (DS) module
     - HMAC used for enabling the soft-disabled JTAG interface
     - HMAC both as a"
" key for the DS module and for enabling JTAG

This is to prevent the usage of a key for a different function than originally intended.

To calculate an HMAC, the software has to provide the ID of the key block containing the secret key as well as the **key purpose** (see **{IDF_TARGET_NAME} Technical Reference Manual** > **eFuse Controller (eFuse)** [`PDF `__]).

Before the HMAC key calculation, the HMAC module looks up the purpose of the provided key block. The calculation only proceeds if the "
"purpose of the provided key block matches the purpose stored in the eFuses of the key block provided by the ID.

HMAC Generation for Software


Key purpose value: 8

In this case, the HMAC is given out to the software, e.g., to authenticate a message.

The API to calculate the HMAC is :cpp:func:`esp_hmac_calculate`. The input arguments for the function are the message, message length, and the eFuse key block ID which contains the secret and has the efuse key purpose set to Upstream mode.

HMAC f"
"or Digital Signature


Key purpose values: 7, 5

The HMAC can be used as a key derivation function to decrypt private key parameters which are used by the Digital Signature module. A standard message is used by the hardware in that case. You only need to provide the eFuse key block and purpose on the HMAC side, additional parameters are required for the Digital Signature component in that case.

Neither the key nor the actual HMAC is ever exposed outside the HMAC module and DS component. The cal"
"culation of the HMAC and its handover to the DS component happen internally.

For more details, see **{IDF_TARGET_NAME} Technical Reference Manual** > **Digital Signature (DS)** [`PDF `__].

.. _hmac_for_enabling_jtag:

HMAC for Enabling JTAG


Key purpose values: 6, 5

The third application is using the HMAC as a key to enable JTAG if it was soft-disabled before.

Following is the procedure to re-enable the JTAG:

**Stage 1: Setup**

.. only:: esp32s2

    .. note::

      The API **esp_efuse_w"
"rite_field_bit(ESP_EFUSE_SOFT_DIS_JTAG)** can be used to burn ``soft JTAG disable`` bit on {IDF_TARGET_NAME}.

.. only:: not esp32s2

    .. note::

      The API **esp_efuse_write_field_cnt(ESP_EFUSE_SOFT_DIS_JTAG, ESP_EFUSE_SOFT_DIS_JTAG[0]->bit_count)** can be used to burn ``soft JTAG disable`` bits on {IDF_TARGET_NAME}.

.. only:: esp32s2 or esp32s3

    .. note::

      If ``HARD_DIS_JTAG`` eFuse is set, then ``SOFT_DIS_JTAG`` functionality does not work because JTAG is permanently disabled"
".

.. only:: not esp32s2 and not esp32s3

    .. note::

      If ``DIS_PAD_JTAG`` eFuse is set, then ``SOFT_DIS_JTAG`` functionality does not work because JTAG is permanently disabled.

JTAG enables

End-to-end example of soft disable and re-enable JTAG workflow: :example:`security/hmac_soft_jtag`

For more details, see **{IDF_TARGET_NAME} Technical Reference Manual** > **HMAC Accelerator (HMAC)** [`PDF `__].


Application Outline


The following code is an outline of how to set an eFuse key an"
"d then use it to calculate an HMAC for software usage.

We use ``esp_efuse_write_key`` to set physical key block 4 in the eFuse for the HMAC module together with its purpose. ``ESP_EFUSE_KEY_PURPOSE_HMAC_UP`` (8) means that this key can only be used for HMAC generation for software usage:

.. code-block:: c

    #include ""esp_efuse.h""

    const uint8_t key_data[32] = { ... };

    esp_err_t status = esp_efuse_write_key(EFUSE_BLK_KEY4,
                        ESP_EFUSE_KEY_PURPOSE_HMAC_UP,
     "
"                   key_data, sizeof(key_data));

    if (status == ESP_OK) {
        // written key
    } else {
        // writing key failed, maybe written already
    }

Now we can use the saved key to calculate an HMAC for software usage.

.. code-block:: c

    #include ""esp_hmac.h""

    uint8_t hmac[32];

    const char *message = ""Hello, HMAC!"";
    const size_t msg_len = 12;

    esp_err_t result = esp_hmac_calculate(HMAC_KEY4, message, msg_len, hmac);

    if (result == ESP_OK) {
      "
"  // HMAC written to hmac now
    } else {
        // failure calculating HMAC
    }

API Reference


.. include-build-file:: inc/esp_hmac.inc
"
"Elliptic Curve Digital Signature Algorithm (ECDSA)


The Elliptic Curve Digital Signature Algorithm (ECDSA) offers a variant of the Digital Signature Algorithm (DSA) which uses elliptic-curve cryptography.

{IDF_TARGET_NAME}'s ECDSA peripheral provides a secure and efficient environment for computing ECDSA signatures. It offers fast computations while ensuring the confidentiality of the signing process to prevent information leakage. ECDSA private key used in the signing process is accessible on"
"ly to the hardware peripheral, and it is not readable by software.

ECDSA peripheral can help to establish **Secure Device Identity** for TLS mutual authentication and similar use-cases.

Supported Features


- ECDSA digital signature generation and verification
- Two different elliptic curves, namely P-192 and P-256 (FIPS 186-3 specification)
- Two hash algorithms for message hash in the ECDSA operation, namely SHA-224 and SHA-256 (FIPS PUB 180-4 specification)


ECDSA on {IDF_TARGET_NAME}


On"
" {IDF_TARGET_NAME}, the ECDSA module works with a secret key burnt into an eFuse block. This eFuse key is made completely inaccessible (default mode) for any resources outside the cryptographic modules, thus avoiding key leakage.

ECDSA key can be programmed externally through ``espefuse.py`` script using:

.. code:: bash

   espefuse.py burn_key   ECDSA_KEY

.. only:: SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK

    .. note::

        Five physical eFuse blocks can be used as keys for the ECDSA module: "
"block 4 ~ block 8. E.g., for block 4 (which is the first key block) , the argument should be ``BLOCK_KEY0``.

.. only:: not SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK

    .. note::

        Six physical eFuse blocks can be used as keys for the ECDSA module: block 4 ~ block 9. E.g., for block 4 (which is the first key block) , the argument should be ``BLOCK_KEY0``.


Alternatively the ECDSA key can also be programmed through the application running on the target.

Following code snippet uses :cpp:func:`"
"esp_efuse_write_key` to set physical key block 0 in the eFuse with key purpose as :cpp:enumerator:`esp_efuse_purpose_t::ESP_EFUSE_KEY_PURPOSE_ECDSA_KEY`:

.. code-block:: c

    #include ""esp_efuse.h""

    const uint8_t key_data[32] = { ... };

    esp_err_t status = esp_efuse_write_key(EFUSE_BLK_KEY0,
                        ESP_EFUSE_KEY_PURPOSE_ECDSA_KEY,
                        key_data, sizeof(key_data));

    if (status == ESP_OK) {
        // written key
    } else {
        // writing ke"
"y failed, maybe written already
    }


Dependency on TRNG


ECDSA peripheral relies on the hardware True Random Number Generator (TRNG) for its internal entropy requirement. During ECDSA signature creation, the algorithm requires a random integer to be generated as specified in the `RFC 6090 `_ section 5.3.2.

Please ensure that hardware :doc:`RNG ` is enabled before starting ECDSA computations (primarily signing) in the application.

Application Outline


Please refer to the :ref:`ecdsa-peri-w"
"ith-esp-tls` guide for details on how-to use ECDSA peripheral for establishing a mutually authenticated TLS connection.

The ECDSA peripheral in mbedTLS stack is integrated by overriding the ECDSA sign and verify APIs. Please note that, the ECDSA peripheral does not support all curves or hash algorithms and hence for cases where the requirements do not meet the hardware, implementation falls back to the software.

For a particular TLS context, additional APIs have been supplied to populate certa"
"in fields (e.g., private key ctx) to differentiate routing to hardware. ESP-TLS layer integrates these APIs internally and hence no additional work is required at the application layer. However, for custom use-cases please refer to API details below.

API Reference


.. include-build-file:: inc/ecdsa_alt.inc
"
"Event Task Matrix (ETM)




Introduction


Normally, if a peripheral X needs to notify peripheral Y of a particular event, this could only be done via a CPU interrupt from peripheral X, where the CPU notifies peripheral Y on behalf of peripheral X. However, in time-critical applications, the latency introduced by CPU interrupts is non-negligible.

With the help of the Event Task Matrix (ETM) module, some peripherals can directly notify other peripherals of events through pre-set connections with"
"out the intervention of CPU interrupts. This allows precise and low latency synchronization between peripherals, and lessens the CPU's workload as the CPU no longer needs to handle these events.

.. blockdiag:: /../_static/diagrams/etm/etm_channel.diag
    :caption: ETM channels Overview
    :align: center

The ETM module has multiple programmable channels, they are used to connect a particular **Event** to a particular **Task**. When an event is activated, the ETM channel will trigger the corre"
"sponding task automatically.

Peripherals that support ETM functionality provide their or unique set of events and tasks to be connected by the ETM. An ETM channel can connect any event to any task, even looping back an event to a task on the same peripheral. However, an ETM channel can only connect one event to one task at a time (i.e., 1 to 1 relation). If you want to use different events to trigger the same task, you can set up more ETM channels.

Typically, with the help of the ETM module, y"
"ou can implement features like:

-  Toggle the GPIO when a timer alarm event happens
-  Start an ADC conversion when a pulse edge is detected on a GPIO

Functional Overview


The following sections of this document cover the typical steps to configure and use the ETM module.

- :ref:`etm-channel-allocation` - describes how to install and uninstall the ETM channel.
- :ref:`etm-event` - describes how to allocate a new ETM event handle or fetch an existing handle from various peripherals.
- :ref:`e"
"tm-task` - describes how to allocate a new ETM task handle or fetch an existing handle from various peripherals.
- :ref:`etm-channel-control` - describes common ETM channel control functions.
- :ref:`etm-thread-safety` - lists which APIs are guaranteed to be thread-safe by the driver.
- :ref:`etm-kconfig-options` - lists the supported Kconfig options that can be used to make a different effect on driver behavior.

.. _etm-channel-allocation:

ETM Channel Allocation


There are many identical ETM"
" channels in {IDF_TARGET_NAME} [1]_, and each channel is represented by :cpp:type:`esp_etm_channel_handle_t` in the software. The ETM core driver manages all available hardware resources in a pool so that you do not need to care about which channel is in use and which is not. The ETM core driver will allocate a channel for you when you call :cpp:func:`esp_etm_new_channel` and delete it when you call :cpp:func:`esp_etm_del_channel`. All requirements needed for allocating a channel are provided in"
" :cpp:type:`esp_etm_channel_config_t`.

Before deleting an ETM channel, please disable it by :cpp:func:`esp_etm_channel_disable` in advance or make sure it has not been enabled yet by :cpp:func:`esp_etm_channel_enable`.

.. _etm-event:

ETM Event


ETM Event abstracts the event source, masking the details of specific event sources, and is represented by :cpp:type:`esp_etm_event_handle_t` in the software, allowing applications to handle different types of events more easily. ETM events can be gen"
"erated from a variety of peripherals, thus the way to get the event handle differs from peripherals. When an ETM event is no longer used, you should call :cpp:func:`esp_etm_channel_connect` with a ``NULL`` event handle to disconnect it and then call :cpp:func:`esp_etm_del_event` to free the event resource.

GPIO Events
~~~~~~~~~~~

GPIO **edge** event is the most common event type, it can be generated by any GPIO pin. You can call :cpp:func:`gpio_new_etm_event` to create a GPIO event handle, wit"
"h the configurations provided in :cpp:type:`gpio_etm_event_config_t`:

- :cpp:member:`gpio_etm_event_config_t::edge` decides which edge to trigger the event, supported edge types are listed in the :cpp:type:`gpio_etm_event_edge_t`.

You need to build a connection between the GPIO ETM event handle and the GPIO number. So you should call :cpp:func:`gpio_etm_event_bind_gpio` afterwards. Please note, only the ETM event handle that created by :cpp:func:`gpio_new_etm_event` can set a GPIO number. Call"
"ing this function with other kinds of ETM events returns :c:macro:`ESP_ERR_INVALID_ARG` error. Needless to say, this function does not help with the GPIO initialization, you still need to call :cpp:func:`gpio_config` to set the property like direction, pull up/down mode separately.

Other Peripheral Events
~~~~~~~~~~~~~~~~~~~~~~~

.. list::

    :SOC_SYSTIMER_SUPPORT_ETM: - You can call :cpp:func:`esp_systick_new_etm_alarm_event` to get the ETM event from RTOS Systick, one per CPU core.
    :SOC"
"_SYSTIMER_SUPPORT_ETM: - Refer to :doc:`/api-reference/system/esp_timer` for how to get the ETM event handle from esp_timer.
    :SOC_TIMER_SUPPORT_ETM: - Refer to :doc:`/api-reference/peripherals/gptimer` for how to get the ETM event handle from GPTimer.
    :SOC_GDMA_SUPPORT_ETM: - Refer to :doc:`/api-reference/system/async_memcpy` for how to get the ETM event handle from async memcpy.
    :SOC_MCPWM_SUPPORT_ETM: - Refer to :doc:`/api-reference/peripherals/mcpwm` for how to get the ETM event h"
"andle from MCPWM.
    :SOC_ANA_CMPR_SUPPORT_ETM: - Refer to :doc:`/api-reference/peripherals/ana_cmpr` for how to get the ETM event handle from analog comparator.
    :SOC_TEMPERATURE_SENSOR_SUPPORT_ETM: - Refer to :doc:`/api-reference/peripherals/temp_sensor` for how to get the ETM event handle from temperature sensor.

.. _etm-task:

ETM Task


ETM Task abstracts the task action and is represented by :cpp:type:`esp_etm_task_handle_t` in the software, allowing tasks to be managed and represente"
"d in the same way. ETM tasks can be assigned to a variety of peripherals, thus the way to get the task handle differs from peripherals. When an ETM task is no longer used, you should call :cpp:func:`esp_etm_channel_connect` with a ``NULL`` task handle to disconnect it and then call :cpp:func:`esp_etm_del_task` to free the task resource.

GPIO Tasks
~~~~~~~~~~

GPIO task is the most common task type, one GPIO task can even manage multiple GPIOs. When the task gets activated by the ETM channel, al"
"l managed GPIOs can set/clear/toggle at the same time. You can call :cpp:func:`gpio_new_etm_task` to create a GPIO task handle, with the configurations provided in :cpp:type:`gpio_etm_task_config_t`:

- :cpp:member:`gpio_etm_task_config_t::action` decides what GPIO action would be taken by the ETM task. Supported actions are listed in the :cpp:type:`gpio_etm_task_action_t`.

To build a connection between the GPIO ETM task and the GPIO number, you should call :cpp:func:`gpio_etm_task_add_gpio`. Y"
"ou can call this function by several times if you want the task handle to manage more GPIOs. Please note, only the ETM task handle that created by :cpp:func:`gpio_new_etm_task` can manage a GPIO. Calling this function with other kinds of ETM tasks returns :c:macro:`ESP_ERR_INVALID_ARG` error. Needless to say, this function does not help with the GPIO initialization, you still need to call :cpp:func:`gpio_config` to set the property like direction, pull up/down mode separately.

Before you call :"
"cpp:func:`esp_etm_del_task` to delete the GPIO ETM task, make sure that all previously added GPIOs are removed by :cpp:func:`gpio_etm_task_rm_gpio` in advance.

Other Peripheral Tasks
~~~~~~~~~~~~~~~~~~~~~~

.. list::

    :SOC_TIMER_SUPPORT_ETM: - Refer to :doc:`GPTimer ` for how to get the ETM task handle from GPTimer.
    :SOC_TEMPERATURE_SENSOR_SUPPORT_ETM: - Refer to :doc:`/api-reference/peripherals/temp_sensor` for how to get the ETM task handle from temperature sensor.

.. _etm-channel-co"
"ntrol:

ETM Channel Control


Connect Event and Task
~~~~~~~~~~~~~~~~~~~~~~

An ETM event has no association with an ETM task, until they are connected to the same ETM channel by calling :cpp:func:`esp_etm_channel_connect`. Especially, calling the function with a ``NULL`` task/event handle means disconnecting the channel from any task or event. Note that, this function can be called either before or after the channel is enabled. But calling this function at runtime to change the connection can b"
"e dangerous, because the channel may be in the middle of a cycle, and the new connection may not take effect immediately.

Enable and Disable Channel
~~~~~~~~~~~~~~~~~~~~~~~~~~

You can call :cpp:func:`esp_etm_channel_enable` and :cpp:func:`esp_etm_channel_disable` to enable and disable the ETM channel from working.

ETM Channel Profiling
~~~~~~~~~~~~~~~~~~~~~

To check if the ETM channels are set with proper events and tasks, you can call :cpp:func:`esp_etm_dump` to dump all working ETM channel"
"s with their associated events and tasks. The dumping format is like:

::

    ETM Dump Start
    channel 0: event 48 ==> task 17
    channel 1: event 48 ==> task 90
    channel 2: event 48 ==> task 94
    ETM Dump End

The digital ID printed in the dump information is defined in the ``soc/soc_etm_source.h`` file.

.. _etm-thread-safety:

Thread Safety


The factory functions like :cpp:func:`esp_etm_new_channel` and :cpp:func:`gpio_new_etm_task` are guaranteed to be thread-safe by the driver, wh"
"ich means, you can call them from different RTOS tasks without protection by extra locks.

No functions are allowed to run within the ISR environment.

Other functions that take :cpp:type:`esp_etm_channel_handle_t`, :cpp:type:`esp_etm_task_handle_t` and :cpp:type:`esp_etm_event_handle_t` as the first positional parameter, are not treated as thread-safe, which means you should avoid calling them from multiple tasks.

.. _etm-kconfig-options:

Kconfig Options


- :ref:`CONFIG_ETM_ENABLE_DEBUG_LOG`"
" is used to enable the debug log output. Enabling this option increases the firmware binary size as well.

API Reference


.. include-build-file:: inc/esp_etm.inc
.. include-build-file:: inc/gpio_etm.inc
.. include-build-file:: inc/esp_systick_etm.inc

.. [1]
   Different ESP chip series might have different numbers of ETM channels. For more details, please refer to *{IDF_TARGET_NAME} Technical Reference Manual* > Chapter **Event Task Matrix (ETM)** [`PDF `__]. The driver does not forbid you fro"
"m applying for more channels, but it will return an error when all available hardware resources are used up. Please always check the return value when doing channel allocation (i.e., :cpp:func:`esp_etm_new_channel`).
"
"Sigma-Delta Modulation (SDM)




Introduction


{IDF_TARGET_NAME} has a second-order sigma-delta modulator, which can generate independent PDM pulses to multiple channels. Please refer to the TRM to check how many hardware channels are available. [1]_

Delta-sigma modulation converts an analog voltage signal into a pulse frequency, or pulse density, which can be understood as pulse-density modulation (PDM) (refer to |wiki_ref|_).

The main differences comparing to I2S PDM mode and DAC peripheral"
" are:

Typically, a Sigma-Delta modulated channel can be used in scenarios like:

-  LED dimming
-  Simple DAC (8-bit), with the help of an active RC low-pass filter
-  Class D amplifier, with the help of a half-bridge or full-bridge circuit plus an LC low-pass filter

Functional Overview


The following sections of this document cover the typical steps to install and operate an SDM channel:

- :ref:`sdm-resource-allocation` - covers how to initialize and configure an SDM channel and how to recy"
"cle the resources when it finishes working.
- :ref:`sdm-enable-and-disable-channel` - covers how to enable and disable the channel.
- :ref:`sdm-set-equivalent-duty-cycle` - describes how to set the equivalent duty cycle of the PDM pulses.
- :ref:`sdm-power-management` - describes how different source clock selections can affect power consumption.
- :ref:`sdm-iram-safe` - lists which functions are supposed to work even when the cache is disabled.
- :ref:`sdm-thread-safety` - lists which APIs are "
"guaranteed to be thread-safe by the driver.
- :ref:`sdm-kconfig-options` - lists the supported Kconfig options that can be used to make a different effect on driver behavior.

.. _sdm-resource-allocation:

Resource Allocation


In ESP-IDF, the information and attributes of SDM channels are managed and accessed through specific data structures, where the data structure is called :cpp:type:`sdm_channel_handle_t`. Each channel is capable to output the binary, hardware-generated signal with the sigm"
"a-delta modulation. The driver manages all available channels in a pool so that there is no need to manually assign a fixed channel to a GPIO.

To install an SDM channel, you should call :cpp:func:`sdm_new_channel` to get a channel handle. Channel-specific configurations are passed in the :cpp:type:`sdm_config_t` structure:

- :cpp:member:`sdm_config_t::gpio_num` sets the GPIO that the PDM pulses output from.
- :cpp:member:`sdm_config_t::clk_src` selects the source clock for the SDM module. Note"
" that, all channels should select the same clock source.
- :cpp:member:`sdm_config_t::sample_rate_hz` sets the sample rate of the SDM module.
- :cpp:member:`sdm_config_t::invert_out` sets whether to invert the output signal.
- :cpp:member:`sdm_config_t::io_loop_back` is for debugging purposes only. It enables both the GPIO's input and output ability through the GPIO matrix peripheral.

The function :cpp:func:`sdm_new_channel` can fail due to various errors such as insufficient memory, invalid ar"
"guments, etc. Specifically, when there are no more free channels (i.e., all hardware SDM channels have been used up), :c:macro:`ESP_ERR_NOT_FOUND` will be returned.

If a previously created SDM channel is no longer required, you should recycle it by calling :cpp:func:`sdm_del_channel`. It allows the underlying HW channel to be used for other purposes. Before deleting an SDM channel handle, you should disable it by :cpp:func:`sdm_channel_disable` in advance or make sure it has not been enabled ye"
"t by :cpp:func:`sdm_channel_enable`.

Creating an SDM Channel with a Sample Rate of 1 MHz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: c

    sdm_channel_handle_t chan = NULL;
    sdm_config_t config = {
        .clk_src = SDM_CLK_SRC_DEFAULT,
        .sample_rate_hz = 1 * 1000 * 1000,
        .gpio_num = 0,
    };
   ESP_ERROR_CHECK(sdm_new_channel(&config, &chan));

.. _sdm-enable-and-disable-channel:

Enable and Disable Channel


Before doing further IO control to the SDM c"
"hannel, you should enable it first, by calling :cpp:func:`sdm_channel_enable`. Internally, this function:

On the contrary, calling :cpp:func:`sdm_channel_disable` does the opposite, that is, put the channel back to the **init** state and releases the power management lock.

.. _sdm-set-equivalent-duty-cycle:

Set Pulse Density


For the output PDM signals, the pulse density decides the output analog voltage that is restored by a low-pass filter. The restored analog voltage from the channel is c"
"alculated by ``Vout = VDD_IO / 256 * duty + VDD_IO / 2``. The range of the quantized ``density`` input parameter of :cpp:func:`sdm_channel_set_pulse_density` is from -128 to 127 (8-bit signed integer). Depending on the value of the ``density`` parameter, the duty cycle of the output signal will be changed accordingly. For example, if a zero value is set, then the output signal's duty will be around 50%.

.. _sdm-power-management:

Power Management


When power management is enabled (i.e., :ref:`"
"CONFIG_PM_ENABLE` is on), the system will adjust the APB frequency before going into Light-sleep, thus potentially changing the sample rate of the sigma-delta modulator.

However, the driver can prevent the system from changing APB frequency by acquiring a power management lock of type :cpp:enumerator:`ESP_PM_APB_FREQ_MAX`. Whenever the driver creates an SDM channel instance that has selected :cpp:enumerator:`SDM_CLK_SRC_APB` as its clock source, the driver guarantees that the power management l"
"ock is acquired when enabling the channel by :cpp:func:`sdm_channel_enable`. Likewise, the driver releases the lock when :cpp:func:`sdm_channel_disable` is called for that channel.

.. _sdm-iram-safe:

IRAM Safe


There is a Kconfig option :ref:`CONFIG_SDM_CTRL_FUNC_IN_IRAM` that can put commonly-used IO control functions into IRAM as well. So that these functions can also be executable when the cache is disabled. These IO control functions are listed as follows:

- :cpp:func:`sdm_channel_set_pu"
"lse_density`

.. _sdm-thread-safety:

Thread Safety


The factory function :cpp:func:`sdm_new_channel` is guaranteed to be thread-safe by the driver, which means, the user can call it from different RTOS tasks without protection by extra locks.

The following functions are allowed to run under ISR context, the driver uses a critical section to prevent them being called concurrently in both task and ISR.

- :cpp:func:`sdm_channel_set_pulse_density`

Other functions that take the :cpp:type:`sdm_ch"
"annel_handle_t` as the first positional parameter, are not treated as thread-safe. This means the user should avoid calling them from multiple tasks.

.. _sdm-kconfig-options:

Kconfig Options


- :ref:`CONFIG_SDM_CTRL_FUNC_IN_IRAM` controls where to place the SDM channel control functions (IRAM or Flash), see :ref:`sdm-iram-safe` for more information.
- :ref:`CONFIG_SDM_ENABLE_DEBUG_LOG` is used to enable the debug log output. Enabling this option increases the firmware binary size.

.. _conver"
"t_to_analog_signal:

Convert to an Analog Signal (Optional)


Typically, if a Sigma-Delta signal is connected to an LED to adjust the brightness, you do not have to add any filter between them, because our eyes have their own low-pass filters for changes in light intensity. However, if you want to check the real voltage or watch the analog waveform, you need to design an analog low-pass filter. Also, it is recommended to use an active filter instead of a passive filter to gain better isolation a"
"nd not lose too much voltage.

For example, you can take the following `Sallen-Key topology Low Pass Filter`_ as a reference.

.. figure:: ../../../_static/typical_sallenkey_LP_filter.png
    :align: center
    :alt: Sallen-Key Low Pass Filter
    :figclass: align-center

    Sallen-Key Low Pass Filter


Application Example


API Reference


.. include-build-file:: inc/sdm.inc
.. include-build-file:: inc/sdm_types.inc

.. [1]
   Different ESP chip series might have different numbers of SDM chann"
"els. Please refer to Chapter `GPIO and IOMUX `__ in {IDF_TARGET_NAME} Technical Reference Manual for more details. The driver does not forbid you from applying for more channels, but it will return an error when all available hardware resources are used up. Please always check the return value when doing resource allocation (e.g., :cpp:func:`sdm_new_channel`).

.. _Sallen-Key topology Low Pass Filter: https://en.wikipedia.org/wiki/Sallen%E2%80%93Key_topology

.. |wiki_ref| replace:: Delta-sigma "
"modulation on Wikipedia
.. _wiki_ref: https://en.wikipedia.org/wiki/Delta-sigma_modulation
"
"Touch Sensor




{IDF_TARGET_TOUCH_SENSOR_VERSION:default=""v2"", esp32=""v1""}

Introduction


A touch sensor system is built on a substrate which carries electrodes and relevant connections under a protective flat surface. When the surface is touched, the capacitance variation is used to evaluate if the touch was valid.

The sensing pads can be arranged in different combinations (e.g., matrix, slider), so that a larger area or more points can be detected. The touch pad sensing process is under the"
" control of a hardware-implemented finite-state machine (FSM) which is initiated by software or a dedicated hardware timer.

For design, operation, and control registers of a touch sensor, see **{IDF_TARGET_NAME} Technical Reference Manual** > **On-Chip Sensors and Analog Signal Processing** [`PDF `__].

In-depth design details of touch sensors and firmware development guidelines for {IDF_TARGET_NAME} are available in `Touch Sensor Application Note `_.

.. only:: esp32

    For more information "
"about testing touch sensors in various configurations, please check the `Guide for ESP32-Sense-Kit `_.

Functionality Overview


Description of API is broken down into groups of functions to provide a quick overview of the following features:

- Initialization of touch pad driver
- Configuration of touch pad GPIO pins
- Taking measurements
- Adjusting parameters of measurements
- Filtering measurements
- Touch detection methods
- Setting up interrupts to report touch detection
- Waking up from S"
"leep mode on interrupt

For detailed description of a particular function, please go to Section :ref:`touch_pad-api-reference`. Practical implementation of this API is covered in Section :ref:`Application Examples `.

Initialization


Before using a touch pad, you need to initialize the touch pad driver by calling the function :cpp:func:`touch_pad_init`. This function sets several ``.._DEFAULT`` driver parameters listed in :ref:`touch_pad-api-reference` under **Macros**. It also removes the info"
"rmation about which pads have been touched before, if any, and disables interrupts.

If the driver is not required anymore, deinitialize it by calling :cpp:func:`touch_pad_deinit`.

Configuration


.. only:: esp32

    Enabling the touch sensor functionality for a particular GPIO is done with :cpp:func:`touch_pad_config()`. The following 10 capacitive touch pads are supported for {IDF_TARGET_NAME}.

    .. list-table::
        :align: center
        :widths: 50 50
        :header-rows: 1
       "
"   - GPIO Pin
          - GPIO4
          - GPIO0
          - GPIO2
          - MTDO
          - MTCK
          - MTDI
          - MTMS
          - GPIO27
          - 32K_XN
          - 32K_XP

.. only:: esp32s2 or esp32s3

    Enabling the touch sensor functionality for a particular GPIO is done with :cpp:func:`touch_pad_config()`. The following 14 capacitive touch pads are supported for {IDF_TARGET_NAME}.

    .. list-table::
        :align: center
        :widths: 50 50
        :header-rows: "
"1
          - GPIO Pin
          - Internal channel, not connect to a GPIO
          - GPIO1
          - GPIO2
          - GPIO3
          - GPIO4
          - GPIO5
          - GPIO6
          - GPIO7
          - GPIO8
          - GPIO9
          - GPIO10
          - GPIO11
          - GPIO12
          - GPIO13
          - GPIO14

Use the function :cpp:func:`touch_pad_set_fsm_mode` to select if touch pad measurement (operated by FSM) should be started automatically by a hardware timer, or by sof"
"tware. If software mode is selected, use :cpp:func:`touch_pad_sw_start` to start the FSM.

Touch State Measurements


.. only:: esp32

    The following two functions come in handy to read raw or filtered measurements from the sensor:

    They can also be used, for example, to evaluate a particular touch pad design by checking the range of sensor readings when a pad is touched or released. This information can be then used to establish a touch threshold.

    .. note::

        Before using :cp"
"p:func:`touch_pad_read_filtered`, you need to initialize and configure the filter by calling specific filter functions described in Section `Filtering of Measurements`_.

.. only:: esp32s2 or esp32s3

    The following function come in handy to read raw measurements from the sensor:

    It can also be used, for example, to evaluate a particular touch pad design by checking the range of sensor readings when a pad is touched or released. This information can be then used to establish a touch thre"
"shold.

For the demonstration of how to read the touch pad data, check the application example :example:`peripherals/touch_sensor/touch_sensor_{IDF_TARGET_TOUCH_SENSOR_VERSION}/touch_pad_read`.

Method of Measurements


.. only:: esp32

    The touch sensor counts the number of charge/discharge cycles over a fixed period of time (specified by :cpp:func:`touch_pad_set_measurement_clock_cycles`). The count result is the raw data that read from :cpp:func:`touch_pad_read_raw_data`. After finishing o"
"ne measurement, the touch sensor sleeps until the next measurement start, this interval between two measurements can be set by :cpp:func:`touch_pad_set_measurement_interval`.

    .. note::

        If the specified clock cycles for measurement is too samll, the result may be inaccurate, but increasing clock cycles will increase the power consumption as well. Additionally, the response of the touch sensor will slow down if the total time of the inverval and measurement is too long.

.. only:: es"
"p32s2 or esp32s3

    The touch sensor records the period of time (i.e., the number of clock cycles) over a fixed charge/discharge cycles (specified by :cpp:func:`touch_pad_set_charge_discharge_times`). The count result is the raw data that read from :cpp:func:`touch_pad_read_raw_data`. After finishing one measurement, the touch sensor sleeps until the next measurement start, this interval between two measurements can be set by :cpp:func:`touch_pad_set_measurement_interval`.

    .. note::

    "
"    If the specified charge and discharge cycles for measurement is too samll, the result may be inaccurate, but increasing charge and discharge cycles will increase the power consumption as well. Additionally, the response of the touch sensor will slow down if the total time of the inverval and measurement is too long.

Optimization of Measurements


A touch sensor has several configurable parameters to match the characteristics of a particular touch pad design. For instance, to sense smaller c"
"apacity changes, it is possible to narrow down the reference voltage range within which the touch pads are charged/discharged. The high and low reference voltages are set using the function :cpp:func:`touch_pad_set_voltage`.

.. only:: esp32

    Besides the ability to discern smaller capacity changes, a positive side effect is reduction of power consumption for low power applications. A likely negative effect is an increase in measurement noise. If the dynamic range of obtained readings is stil"
"l satisfactory, then further reduction of power consumption might be done by reducing the measurement time with :cpp:func:`touch_pad_set_measurement_clock_cycles`.

.. only:: esp32s2 or esp32s3

    Besides the ability to discern smaller capacity changes, a positive side effect is reduction of power consumption for low power applications. A likely negative effect is an increase in measurement noise. If the dynamic range of obtained readings is still satisfactory, then further reduction of power "
"consumption might be done by reducing the measurement time with :cpp:func:`touch_pad_set_charge_discharge_times`.

The following list summarizes available measurement parameters and corresponding 'set' functions:

.. only:: esp32

.. only:: esp32s2 or esp32s3

Relationship between the voltage range (high/low reference voltages), speed (slope), and measurement time is shown in the figure below.

.. only:: esp32

    .. figure:: ../../../_static/touch_pad-measurement-parameters.jpg
        :align:"
" center
        :alt: Touch Pad - relationship between measurement parameters
        :figclass: align-center

        Touch pad - relationship between measurement parameters

    The last chart **Output** represents the touch sensor reading, i.e., the count of pulses collected within the measurement time.

.. only:: esp32s2 or esp32s3

    .. figure:: ../../../_static/touch_pad-measurement-parameters-version2.png
        :align: center
        :alt: Touch Pad - relationship between measurement "
"parameters
        :figclass: align-center

        Touch pad - relationship between measurement parameters

    The last chart **Output** represents the touch sensor reading, i.e., the time taken to accumulate the fixed number of cycles.

All functions are provided in pairs to **set** a specific parameter and to **get** the current parameter's value, e.g., :cpp:func:`touch_pad_set_voltage` and :cpp:func:`touch_pad_get_voltage`.

.. _touch_pad-api-filtering-of-measurements:

Filtering of Measure"
"ments

.. only:: esp32

    If measurements are noisy, you can filter them with provided API functions. Before using the filter, please start it by calling :cpp:func:`touch_pad_filter_start`.

    The filter type is IIR (infinite impulse response), and it has a configurable period that can be set with the function :cpp:func:`touch_pad_set_filter_period`.

    You can stop the filter with :cpp:func:`touch_pad_filter_stop`. If not required anymore, the filter can be deleted by invoking :cpp:func:`"
"touch_pad_filter_delete`.

.. only:: esp32s2 or esp32s3

    If measurements are noisy, you can filter them with provided API functions. The {IDF_TARGET_NAME}'s touch functionality provide two sets of APIs for doing this.

    There is an internal touch channel that is not connected to any external GPIO. The measurements from this denoise pad can be used to filters out interference introduced on all channels, such as noise introduced by the power supply and external EMI.

    The denoise paramat"
"ers are set with the function :cpp:func:`touch_pad_denoise_set_config` and started by with :cpp:func:`touch_pad_denoise_enable`

    There is also a configurable hardware implemented IIR-filter (infinite impulse response). This IIR-filter is configured with the function :cpp:func:`touch_pad_filter_set_config` and enabled by calling :cpp:func:`touch_pad_filter_enable`

Touch Detection


Touch detection is implemented in ESP32's hardware based on the user-configured threshold and raw measurements "
"executed by FSM. Use the functions :cpp:func:`touch_pad_get_status` to check which pads have been touched and :cpp:func:`touch_pad_clear_status` to clear the touch status information.

Hardware touch detection can also be wired to interrupts. This is described in the next section.

If measurements are noisy and capacity changes are small, hardware touch detection might be unreliable. To resolve this issue, instead of using hardware detection/provided interrupts, implement measurement filtering a"
"nd perform touch detection in your own application. For sample implementation of both methods of touch detection, see :example:`peripherals/touch_sensor/touch_sensor_{IDF_TARGET_TOUCH_SENSOR_VERSION}/touch_pad_interrupt`.

Touch Triggered Interrupts


Before enabling an interrupt on a touch detection, you should establish a touch detection threshold. Use the functions described in `Touch State Measurements`_ to read and display sensor measurements when a pad is touched and released. Apply a filt"
"er if measurements are noisy and relative capacity changes are small. Depending on your application and environment conditions, test the influence of temperature and power supply voltage changes on measured values.

Once a detection threshold is established, it can be set during initialization with :cpp:func:`touch_pad_config` or at the runtime with :cpp:func:`touch_pad_set_thresh`.

.. only:: esp32

    In the next step, configure how interrupts are triggered. They can be triggered below or abo"
"ve the threshold, which is set with the function :cpp:func:`touch_pad_set_trigger_mode`.

Finally, configure and manage interrupt calls using the following functions:

When interrupts are operational, you can obtain the information from which particular pad an interrupt came by invoking :cpp:func:`touch_pad_get_status` and clear the pad status with :cpp:func:`touch_pad_clear_status`.

.. only:: esp32

    .. note::

        Interrupts on touch detection operate on raw/unfiltered measurements che"
"cked against user established threshold and are implemented in hardware. Enabling the software filtering API (see :ref:`touch_pad-api-filtering-of-measurements`) does not affect this process.

.. only:: esp32

    Wakeup from Sleep Mode
    

    If touch pad interrupts are used to wake up the chip from a sleep mode, you can select a certain configuration of pads (SET1 or both SET1 and SET2) that should be touched to trigger the interrupt and cause the subsequent wakeup. To do so, use the functi"
"on :cpp:func:`touch_pad_set_trigger_source`.

    Configuration of required bit patterns of pads may be managed for each 'SET' with:

.. _touch_pad-api-examples:

Application Examples


- Touch sensor read example: :example:`peripherals/touch_sensor/touch_sensor_{IDF_TARGET_TOUCH_SENSOR_VERSION}/touch_pad_read`.
- Touch sensor interrupt example: :example:`peripherals/touch_sensor/touch_sensor_{IDF_TARGET_TOUCH_SENSOR_VERSION}/touch_pad_interrupt`.

.. _touch_pad-api-reference:

API Reference


."
". include-build-file:: inc/touch_sensor.inc
.. include-build-file:: inc/touch_sensor_common.inc

GPIO Lookup Macros


Some useful macros can be used to specified the GPIO number of a touch pad channel, or vice versa. e.g.,

.. include-build-file:: inc/touch_sensor_channel.inc
.. include-build-file:: inc/touch_sensor_types.inc
"
"SPI Slave Driver




SPI Slave driver is a program that controls {IDF_TARGET_NAME}'s General Purpose SPI (GP-SPI) peripheral(s) when it functions as a slave.

For more hardware information about the GP-SPI peripheral(s), see **{IDF_TARGET_NAME} Technical Reference Manual** > **SPI Controller** [`PDF `__].

Terminology


The terms used in relation to the SPI slave driver are given in the table below.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Definition
     - The SPI controller"
" peripheral external to {IDF_TARGET_NAME} that initiates SPI transmissions over the bus, and acts as an SPI Master.
     - SPI slave device (general purpose SPI controller). Each Device shares the MOSI, MISO and SCLK signals but is only active on the bus when the Host asserts the Device's individual CS line.
     - A signal bus, common to all Devices connected to one Host. In general, a bus includes the following lines: MISO, MOSI, SCLK, one or more CS lines, and, optionally, QUADWP and QUADHD. "
"So Devices are connected to the same lines, with the exception that each Device has its own CS line. Several Devices can also share one CS line if connected in the daisy-chain manner.
     - Master In, Slave Out, a.k.a. Q. Data transmission from a Device to Host.
     - Master Out, Slave In, a.k.a. D. Data transmission from a Host to Device.
     - Serial Clock. Oscillating signal generated by a Host that keeps the transmission of data bits in sync.
     - Chip Select. Allows a Host to select in"
"dividual Device(s) connected to the bus in order to send or receive data.
     - Write Protect signal. Only used for 4-bit (qio/qout) transactions.
     - Hold signal. Only used for 4-bit (qio/qout) transactions.
     - The action of activating a line. The opposite action of returning the line back to inactive (back to idle) is called **de-assertion**.
     - One instance of a Host asserting a CS line, transferring data to and from a Device, and de-asserting the CS line. Transactions are atomic,"
" which means they can never be interrupted by another transaction.
     - Edge of the clock at which the source register **launches** the signal onto the line.
     - Edge of the clock at which the destination register **latches in** the signal.


Driver Features


{IDF_TARGET_MAX_DATA_BUF:default=""64"", esp32s2=""72""}

The SPI slave driver allows using the SPI peripherals as full-duplex Devices. The driver can send/receive transactions up to {IDF_TARGET_MAX_DATA_BUF} bytes in length, or utilize D"
"MA to send/receive longer transactions. However, there are some :ref:`known issues ` related to DMA.

The SPI slave driver supports registering the SPI ISR to a certain CPU core. If multiple tasks try to access the same SPI Device simultaneously, it is recommended that your application be refactored so that each SPI peripheral is only accessed by a single task at a time. Please also use :cpp:member:`spi_bus_config_t::isr_cpu_id` to register the SPI ISR to the same core as SPI peripheral related "
"tasks to ensure thread safety.

SPI Transactions


A full-duplex SPI transaction begins when the Host asserts the CS line and starts sending out clock pulses on the SCLK line. Every clock pulse, a data bit is shifted from the Host to the Device on the MOSI line and back on the MISO line at the same time. At the end of the transaction, the Host de-asserts the CS line.

The attributes of a transaction are determined by the configuration structure for an SPI peripheral acting as a slave device :cpp"
":type:`spi_slave_interface_config_t`, and transaction configuration structure :cpp:type:`spi_slave_transaction_t`.

As not every transaction requires both writing and reading data, you can choose to configure the :cpp:type:`spi_transaction_t` structure for TX only, RX only, or TX and RX transactions. If :cpp:member:`spi_slave_transaction_t::rx_buffer` is set to ``NULL``, the read phase will be skipped. Similarly, if :cpp:member:`spi_slave_transaction_t::tx_buffer` is set to ``NULL``, the write p"
"hase will be skipped.

.. note::

    A Host should not start a transaction before its Device is ready for receiving data. It is recommended to use another GPIO pin for a handshake signal to sync the Devices. For more details, see :ref:`transaction_interval`.


Driver Usage


- Initialize an SPI peripheral as a Device by calling the function :cpp:func:`spi_slave_initialize`. Make sure to set the correct I/O pins in the struct `bus_config`. Set the unused signals to ``-1``.

.. only:: esp32

    "
"If transactions are expected to be longer than 32 bytes, set the parameter ``dma_chan`` to ``1`` or ``2`` to allow a DMA channel 1 or 2 respectively. Otherwise, set ``dma_chan`` to ``0``.

.. only:: esp32s2

    If transactions will be longer than 32 bytes, allow a DMA channel by setting the parameter ``dma_chan`` to the host device. Otherwise, set ``dma_chan`` to ``0``.

- Before initiating transactions, fill one or more :cpp:type:`spi_slave_transaction_t` structs with the transaction parameter"
"s required. Either queue all transactions by calling the function :cpp:func:`spi_slave_queue_trans` and, at a later time, query the result by using the function :cpp:func:`spi_slave_get_trans_result`, or handle all requests individually by feeding them into :cpp:func:`spi_slave_transmit`. The latter two functions will be blocked until the Host has initiated and finished a transaction, causing the queued data to be sent and received.

- (Optional) To unload the SPI slave driver, call :cpp:func:`s"
"pi_slave_free`.


Transaction Data and Master/Slave Length Mismatches


Normally, the data that needs to be transferred to or from a Device is read or written to a chunk of memory indicated by the :cpp:member:`spi_slave_transaction_t::rx_buffer` and :cpp:member:`spi_slave_transaction_t::tx_buffer`. The SPI driver can be configured to use DMA for transfers, in which case these buffers must be allocated in DMA-capable memory using ``pvPortMallocCaps(size, MALLOC_CAP_DMA)``.

The amount of data tha"
"t the driver can read or write to the buffers is limited by :cpp:member:`spi_slave_transaction_t::length`. However, this member does not define the actual length of an SPI transaction. A transaction's length is determined by the clock and CS lines driven by the Host. The actual length of the transmission can be read only after a transaction is finished from the member :cpp:member:`spi_slave_transaction_t::trans_len`.

If the length of the transmission is greater than the buffer length, only the "
"initial number of bits specified in the :cpp:member:`spi_slave_transaction_t::length` member will be sent and received. In this case, :cpp:member:`spi_slave_transaction_t::trans_len` is set to :cpp:member:`spi_slave_transaction_t::length` instead of the actual transaction length. To meet the actual transaction length requirements, set :cpp:member:`spi_slave_transaction_t::length` to a value greater than the maximum :cpp:member:`spi_slave_transaction_t::trans_len` expected. If the transmission le"
"ngth is shorter than the buffer length, only the data equal to the length of the buffer will be transmitted.

GPIO Matrix and IO_MUX


.. only:: esp32

    Most of {IDF_TARGET_NAME}'s peripheral signals have direct connection to their dedicated IO_MUX pins. However, the signals can also be routed to any other available pins using the less direct GPIO matrix.

    If at least one signal is routed through the GPIO matrix, then all signals will be routed through it. If the driver is configured so t"
"hat all SPI signals are either routed to their dedicated IO_MUX pins or are not connected at all, the GPIO matrix will be bypassed.

    The GPIO matrix introduces flexibility of routing but also increases the input delay of the MISO signal, which makes MISO setup time violations more likely. If SPI needs to operate at high speeds, use dedicated IO_MUX pins.

    .. note::

        For more details about the influence of the MISO input delay on the maximum clock frequency, see :ref:`timing_consi"
"derations`.

    The IO_MUX pins for SPI buses are given below.

    .. list-table::
       :widths: 40 30 30
       :header-rows: 1
         - GPIO Number (SPI2)
         - GPIO Number (SPI3)
         - 15
         - 5
         - 14
         - 18
         - 12
         - 19
         - 13
         - 23
         - 2
         - 22
         - 4
         - 21

.. only:: not esp32

    {IDF_TARGET_SPI2_IOMUX_PIN_CS:default=""N/A"",   esp32s2=""10"", esp32s3=""10"", esp32c2=""10"", esp32c3=""10"", esp32c6=""16"","
" esp32h2=""1"", esp32p4=""7""}
    {IDF_TARGET_SPI2_IOMUX_PIN_CLK:default=""N/A"",  esp32s2=""12"", esp32s3=""12"", esp32c2=""6"",  esp32c3=""6"",  esp32c6=""6"",  esp32h2=""4"", esp32p4=""9""}
    {IDF_TARGET_SPI2_IOMUX_PIN_MOSI:default=""N/A"", esp32s2=""11""  esp32s3=""11"", esp32c2=""7""   esp32c3=""7"",  esp32c6=""7"",  esp32h2=""5"", esp32p4=""8""}
    {IDF_TARGET_SPI2_IOMUX_PIN_MISO:default=""N/A"", esp32s2=""13""  esp32s3=""13"", esp32c2=""2""   esp32c3=""2"",  esp32c6=""2"",  esp32h2=""0"", esp32p4=""10""}
    {IDF_TARGET_SPI2_IOMUX_PIN_"
"HD:default=""N/A"",   esp32s2=""9""   esp32s3=""9"",  esp32c2=""4""   esp32c3=""4"",  esp32c6=""4"",  esp32h2=""3"", esp32p4=""6""}
    {IDF_TARGET_SPI2_IOMUX_PIN_WP:default=""N/A"",   esp32s2=""14""  esp32s3=""14"", esp32c2=""5""   esp32c3=""5"",  esp32c6=""5"",  esp32h2=""2"", esp32p4=""11""}

    Most of chip's peripheral signals have direct connection to their dedicated IO_MUX pins. However, the signals can also be routed to any other available pins using the less direct GPIO matrix. If at least one signal is routed throug"
"h the GPIO matrix, then all signals will be routed through it.

    When an SPI Host is set to 80 MHz or lower frequencies, routing SPI pins via GPIO matrix will behave the same compared to routing them via IO_MUX.

    The IO_MUX pins for SPI buses are given below.

    .. list-table::
       :widths: 40 30
       :header-rows: 1
         - GPIO Number (SPI2)
         - {IDF_TARGET_SPI2_IOMUX_PIN_CS}
         - {IDF_TARGET_SPI2_IOMUX_PIN_CLK}
         - {IDF_TARGET_SPI2_IOMUX_PIN_MISO}
        "
" - {IDF_TARGET_SPI2_IOMUX_PIN_MOSI}
         - {IDF_TARGET_SPI2_IOMUX_PIN_WP}
         - {IDF_TARGET_SPI2_IOMUX_PIN_HD}


Speed and Timing Considerations


.. _transaction_interval:

Transaction Interval


The {IDF_TARGET_NAME} SPI slave peripherals are designed as general purpose Devices controlled by a CPU. As opposed to dedicated slaves, CPU-based SPI Devices have a limited number of pre-defined registers. All transactions must be handled by the CPU, which means that the transfers and respons"
"es are not real-time, and there might be noticeable latency.

As a solution, a Device's response rate can be doubled by using the functions :cpp:func:`spi_slave_queue_trans` and then :cpp:func:`spi_slave_get_trans_result` instead of using :cpp:func:`spi_slave_transmit`.

You can also configure a GPIO pin through which the Device will signal to the Host when it is ready for a new transaction. A code example of this can be found in :example:`peripherals/spi_slave`.


SCLK Frequency Requirements


"
"{IDF_TARGET_MAX_FREQ:default=""60"", esp32=""10"", esp32s2=""40"", esp32c6=""40"", esp32h2=""32""}

The SPI slaves are designed to operate at up to {IDF_TARGET_MAX_FREQ} MHz. The data cannot be recognized or received correctly if the clock is too fast or does not have a 50% duty cycle.

.. only:: esp32

    On top of that, there are additional requirements for the data to meet the timing constraints:

    - Read (MOSI):
        The Device can read data correctly only if the data is already set at the laun"
"ch edge. Although it is usually the case for most masters.

    - Write (MISO):
        The output delay of the MISO signal needs to be shorter than half of a clock cycle period so that the MISO line is stable before the next latch edge. Given that the clock is balanced, the output delay and frequency limitations in different cases are given below.

        .. list-table::
           :widths: 30 40 40
           :header-rows: 1
             - Output delay of MISO (ns)
             - Freq. limit "
"(MHz)
             - 43.75
             - < 11.4
             - 68.75
             - < 7.2

        Note:

        Exception: The frequency is allowed to be higher if the master has more tolerance for the MISO setup time, e.g., latch data at the next edge, or configurable latching time.


.. _spi_dma_known_issues:

Restrictions and Known Issues


   Also, a Host should write lengths that are multiples of 4 bytes. The data with inappropriate lengths will be discarded.

.. only:: esp32

    .. wav"
"edrom:: /../_static/diagrams/spi/spi_slave_miso_dma.json

    If DMA is enabled, a Device's launch edge is half of an SPI clock cycle ahead of the normal time, shifting to the Master's actual latch edge. In this case, if the GPIO matrix is bypassed, the hold time for data sampling is 68.75 ns and no longer a half of an SPI clock cycle. If the GPIO matrix is used, the hold time will increase to 93.75 ns. The Host should sample the data immediately at the latch edge or communicate in SPI modes 1 o"
"r 3. If your Host cannot meet these timing requirements, initialize your Device without DMA.


Application Example


The code example for Device/Host communication can be found in the :example:`peripherals/spi_slave` directory of ESP-IDF examples.


API Reference


.. include-build-file:: inc/spi_slave.inc
"
"Remote Control Transceiver (RMT)




Introduction


The RMT (Remote Control Transceiver) peripheral was designed to act as an infrared transceiver. However, due to the flexibility of its data format, RMT can be extended to a versatile and general-purpose transceiver, transmitting or receiving many other types of signals. From the perspective of network layering, the RMT hardware contains both physical and data link layers. The physical layer defines the communication media and bit signal represe"
"ntation. The data link layer defines the format of an RMT frame. The minimal data unit in the frame is called the **RMT symbol**, which is represented by :cpp:type:`rmt_symbol_word_t` in the driver.

{IDF_TARGET_NAME} contains multiple channels in the RMT peripheral [1]_. Each channel can be independently configured as either transmitter or receiver.

Typically, the RMT peripheral can be used in the following scenarios:

- Transmit or receive infrared signals, with any IR protocols, e.g., NEC
- "
"General-purpose sequence generator
- Transmit signals in a hardware-controlled loop, with a finite or infinite number of times
- Multi-channel simultaneous transmission
- Modulate the carrier to the output signal or demodulate the carrier from the input signal

Layout of RMT Symbols


The RMT hardware defines data in its own pattern -- the **RMT symbol**. The diagram below illustrates the bit fields of an RMT symbol. Each symbol consists of two pairs of two values. The first value in the pair is"
" a 15-bit value representing the signal's duration in units of RMT ticks. The second in the pair is a 1-bit value representing the signal's logic level, i.e., high or low.

.. packetdiag:: /../_static/diagrams/rmt/rmt_symbols.diag
    :caption: Structure of RMT symbols (L - signal level)
    :align: center

RMT Transmitter Overview


The data path and control path of an RMT TX channel is illustrated in the figure below:

.. blockdiag:: /../_static/diagrams/rmt/rmt_tx.diag
    :caption: RMT Trans"
"mitter Overview
    :align: center

The driver encodes the user's data into RMT data format, then the RMT transmitter can generate the waveforms according to the encoding artifacts. It is also possible to modulate a high-frequency carrier signal before being routed to a GPIO pad.

RMT Receiver Overview


The data path and control path of an RMT RX channel is illustrated in the figure below:

.. blockdiag:: /../_static/diagrams/rmt/rmt_rx.diag
    :caption: RMT Receiver Overview
    :align: cente"
"r

The RMT receiver can sample incoming signals into RMT data format, and store the data in memory. It is also possible to tell the receiver the basic characteristics of the incoming signal, so that the signal's stop condition can be recognized, and signal glitches and noise can be filtered out. The RMT peripheral also supports demodulating the high-frequency carrier from the base signal.

Functional Overview


The description of the RMT functionality is divided into the following sections:

- :"
"ref:`rmt-resource-allocation` - covers how to allocate and properly configure RMT channels. It also covers how to recycle channels and other resources when they are no longer used.
- :ref:`rmt-carrier-modulation-and demodulation` - describes how to modulate and demodulate the carrier signals for TX and RX channels respectively.
- :ref:`rmt-register-event-callbacks` - covers how to register user-provided event callbacks to receive RMT channel events.
- :ref:`rmt-enable-and-disable-channel` - show"
"s how to enable and disable the RMT channel.
- :ref:`rmt-initiate-tx-transaction` - describes the steps to initiate a transaction for a TX channel.
- :ref:`rmt-initiate-rx-transaction` - describes the steps to initiate a transaction for an RX channel.
- :ref:`rmt-multiple-channels-simultaneous-transmission` - describes how to collect multiple channels into a sync group so that their transmissions can be started simultaneously.
- :ref:`rmt-rmt-encoder` - focuses on how to write a customized encod"
"er by combining multiple primitive encoders that are provided by the driver.
- :ref:`rmt-power-management` - describes how different clock sources affects power consumption.
- :ref:`rmt-iram-safe` - describes how disabling the cache affects the RMT driver, and tips to mitigate it.
- :ref:`rmt-thread-safety` - lists which APIs are guaranteed to be thread-safe by the driver.
- :ref:`rmt-kconfig-options` - describes the various Kconfig options supported by the RMT driver.

.. _rmt-resource-allocati"
"on:

Resource Allocation


Both RMT TX and RX channels are represented by :cpp:type:`rmt_channel_handle_t` in the driver. The driver internally manages which channels are available and hands out a free channel on request.

Install RMT TX Channel
~~~~~~~~~~~~~~~~~~~~~~

To install an RMT TX channel, there is a configuration structure that needs to be given in advance :cpp:type:`rmt_tx_channel_config_t`. The following list describes each member of the configuration structure.

- :cpp:member:`rmt_t"
"x_channel_config_t::gpio_num` sets the GPIO number used by the transmitter.
- :cpp:member:`rmt_tx_channel_config_t::clk_src` selects the source clock for the RMT channel. The available clocks are listed in :cpp:type:`rmt_clock_source_t`. Note that, the selected clock is also used by other channels, which means the user should ensure this configuration is the same when allocating other channels, regardless of TX or RX. For the effect on the power consumption of different clock sources, please ref"
"er to the :ref:`rmt-power-management` section.
- :cpp:member:`rmt_tx_channel_config_t::resolution_hz` sets the resolution of the internal tick counter. The timing parameter of the RMT signal is calculated based on this **tick**.
- :cpp:member:`rmt_tx_channel_config_t::mem_block_symbols` has a slightly different meaning based on if the DMA backend is enabled or not.

    - If the DMA is enabled via :cpp:member:`rmt_tx_channel_config_t::with_dma`, then this field controls the size of the internal "
"DMA buffer. To achieve a better throughput and smaller CPU overhead, you can set a larger value, e.g., ``1024``.
    - If DMA is not used, this field controls the size of the dedicated memory block owned by the channel, which should be at least {IDF_TARGET_SOC_RMT_MEM_WORDS_PER_CHANNEL}.

- :cpp:member:`rmt_tx_channel_config_t::trans_queue_depth` sets the depth of the internal transaction queue, the deeper the queue, the more transactions can be prepared in the backlog.
- :cpp:member:`rmt_tx_cha"
"nnel_config_t::invert_out` is used to decide whether to invert the RMT signal before sending it to the GPIO pad.
- :cpp:member:`rmt_tx_channel_config_t::with_dma` enables the DMA backend for the channel. Using the DMA allows a significant amount of the channel's workload to be offloaded from the CPU. However, the DMA backend is not available on all ESP chips, please refer to [`TRM `__] before you enable this option. Or you might encounter a :c:macro:`ESP_ERR_NOT_SUPPORTED` error.
- :cpp:member:`"
"rmt_tx_channel_config_t::io_loop_back` enables both input and output capabilities on the channel's assigned GPIO. Thus, by binding a TX and RX channel to the same GPIO, loopback can be achieved.
- :cpp:member:`rmt_tx_channel_config_t::io_od_mode` configures the channel's assigned GPIO as open-drain. When combined with :cpp:member:`rmt_tx_channel_config_t::io_loop_back`, a bi-directional bus (e.g., 1-wire) can be achieved.
- :cpp:member:`rmt_tx_channel_config_t::intr_priority` Set the priority of"
" the interrupt. If set to ``0`` , then the driver will use a interrupt with low or medium priority (priority level may be one of 1,2 or 3), otherwise use the priority indicated by :cpp:member:`rmt_tx_channel_config_t::intr_priority`. Please use the number form (1,2,3) , not the bitmask form ((1`__] before you enable this option. Or you might encounter a :c:macro:`ESP_ERR_NOT_SUPPORTED` error.
- :cpp:member:`rmt_rx_channel_config_t::io_loop_back` enables both input and output capabilities on the "
"channel's assigned GPIO. Thus, by binding a TX and RX channel to the same GPIO, loopback can be achieved.
- :cpp:member:`rmt_rx_channel_config_t::intr_priority` Set the priority of the interrupt. If set to ``0`` , then the driver will use a interrupt with low or medium priority (priority level may be one of 1,2 or 3), otherwise use the priority indicated by :cpp:member:`rmt_rx_channel_config_t::intr_priority`. Please use the number form (1,2,3) , not the bitmask form ((1`__] before configuring t"
"he carrier, or you might encounter a :c:macro:`ESP_ERR_NOT_SUPPORTED` error.

Carrier-related configurations lie in :cpp:type:`rmt_carrier_config_t`:

- :cpp:member:`rmt_carrier_config_t::frequency_hz` sets the carrier frequency, in Hz.
- :cpp:member:`rmt_carrier_config_t::duty_cycle` sets the carrier duty cycle.
- :cpp:member:`rmt_carrier_config_t::polarity_active_low` sets the carrier polarity, i.e., on which level the carrier is applied.
- :cpp:member:`rmt_carrier_config_t::always_on` sets wh"
"ether to output the carrier even when the data transmission has finished. This configuration is only valid for the TX channel.

.. note::

    For the RX channel, we should not set the carrier frequency exactly to the theoretical value. It is recommended to leave a tolerance for the carrier frequency. For example, in the snippet below, we set the frequency to 25 KHz, instead of the 38 KHz configured on the TX side. The reason is that reflection and refraction occur when a signal travels through "
"the air, leading to distortion on the receiver side.

.. code-block:: c

    rmt_carrier_config_t tx_carrier_cfg = {
        .duty_cycle = 0.33,                 // duty cycle 33%
        .frequency_hz = 38000,              // 38 KHz
        .flags.polarity_active_low = false, // carrier should be modulated to high level
    };
    // modulate carrier to TX channel
    ESP_ERROR_CHECK(rmt_apply_carrier(tx_chan, &tx_carrier_cfg));

    rmt_carrier_config_t rx_carrier_cfg = {
        .duty_cycle = "
"0.33,                 // duty cycle 33%
        .frequency_hz = 25000,              // 25 KHz carrier, should be smaller than the transmitter's carrier frequency
        .flags.polarity_active_low = false, // the carrier is modulated to high level
    };
    // demodulate carrier from RX channel
    ESP_ERROR_CHECK(rmt_apply_carrier(rx_chan, &rx_carrier_cfg));

.. _rmt-register-event-callbacks:

Register Event Callbacks


When an event occurs on an RMT channel (e.g., transmission or receiving is"
" completed), the CPU is notified of this event via an interrupt. If you have some function that needs to be called when a particular events occur, you can register a callback for that event to the RMT driver's ISR (Interrupt Service Routine) by calling :cpp:func:`rmt_tx_register_event_callbacks` and :cpp:func:`rmt_rx_register_event_callbacks` for TX and RX channel respectively. Since the registered callback functions are called in the interrupt context, the user should ensure the callback functi"
"on does not block, e.g., by making sure that only FreeRTOS APIs with the ``FromISR`` suffix are called from within the function. The callback function has a boolean return value used to indicate whether a higher priority task has been unblocked by the callback.

The TX channel-supported event callbacks are listed in the :cpp:type:`rmt_tx_event_callbacks_t`:

- :cpp:member:`rmt_tx_event_callbacks_t::on_trans_done` sets a callback function for the ""trans-done"" event. The function prototype is decl"
"ared in :cpp:type:`rmt_tx_done_callback_t`.

The RX channel-supported event callbacks are listed in the :cpp:type:`rmt_rx_event_callbacks_t`:

- :cpp:member:`rmt_rx_event_callbacks_t::on_recv_done` sets a callback function for ""receive-done"" event. The function prototype is declared in :cpp:type:`rmt_rx_done_callback_t`.

.. note::

    The ""receive-done"" is not equivalent to ""receive-finished"". This callback can also be called at a ""partial-receive-done"" time, for many times during one receive "
"transaction.

Users can save their own context in :cpp:func:`rmt_tx_register_event_callbacks` and :cpp:func:`rmt_rx_register_event_callbacks` as well, via the parameter ``user_data``. The user data is directly passed to each callback function.

In the callback function, users can fetch the event-specific data that is filled by the driver in the ``edata``. Note that the ``edata`` pointer is **only** valid during the callback, please do not try to save this pointer and use that outside of the call"
"back function.

The TX-done event data is defined in :cpp:type:`rmt_tx_done_event_data_t`:

- :cpp:member:`rmt_tx_done_event_data_t::num_symbols` indicates the number of transmitted RMT symbols. This also reflects the size of the encoding artifacts. Please note, this value accounts for the ``EOF`` symbol as well, which is appended by the driver to mark the end of one transaction.

The RX-complete event data is defined in :cpp:type:`rmt_rx_done_event_data_t`:

- :cpp:member:`rmt_rx_done_event_dat"
"a_t::received_symbols` points to the received RMT symbols. These symbols are saved in the ``buffer`` parameter of the :cpp:func:`rmt_receive` function. Users should not free this receive buffer before the callback returns. If you also enabled the partial receive feature, then the user buffer will be used as a ""second level buffer"", where its content can be overwritten by data comes in afterwards. In this case, you should copy the received data to another place if you want to keep it or process i"
"t later.
- :cpp:member:`rmt_rx_done_event_data_t::num_symbols` indicates the number of received RMT symbols. This value is not larger than the ``buffer_size`` parameter of :cpp:func:`rmt_receive` function. If the ``buffer_size`` is not sufficient to accommodate all the received RMT symbols, the driver only keeps the maximum number of symbols that the buffer can hold, and excess symbols are discarded or ignored.
- :cpp:member:`rmt_rx_done_event_data_t::is_last` indicates whether the current recei"
"ved buffer is the last one in the transaction. This is useful when you enable the partial reception feature by :cpp:member:`rmt_receive_config_t::extra_flags::en_partial_rx`.

.. _rmt-enable-and-disable-channel:

Enable and Disable Channel


:cpp:func:`rmt_enable` must be called in advance before transmitting or receiving RMT symbols. For TX channels, enabling a channel enables a specific interrupt and prepares the hardware to dispatch transactions. For RX channels, enabling a channel enables an"
" interrupt, but the receiver is not started during this time, as the characteristics of the incoming signal have yet to be specified. The receiver is started in :cpp:func:`rmt_receive`.

:cpp:func:`rmt_disable` does the opposite by disabling the interrupt and clearing any pending interrupts. The transmitter and receiver are disabled as well.

.. code:: c

    ESP_ERROR_CHECK(rmt_enable(tx_chan));
    ESP_ERROR_CHECK(rmt_enable(rx_chan));

.. _rmt-initiate-tx-transaction:

Initiate TX Transaction"
"


RMT is a special communication peripheral, as it is unable to transmit raw byte streams like SPI and I2C. RMT can only send data in its own format :cpp:type:`rmt_symbol_word_t`. However, the hardware does not help to convert the user data into RMT symbols, this can only be done in software by the so-called **RMT Encoder**. The encoder is responsible for encoding user data into RMT symbols and then writing to the RMT memory block or the DMA buffer. For how to create an RMT encoder, please refe"
"r to :ref:`rmt-rmt-encoder`.

Once you created an encoder, you can initiate a TX transaction by calling :cpp:func:`rmt_transmit`. This function takes several positional parameters like channel handle, encoder handle, and payload buffer. Besides, you also need to provide a transmission-specific configuration in :cpp:type:`rmt_transmit_config_t`:

- :cpp:member:`rmt_transmit_config_t::loop_count` sets the number of transmission loops. After the transmitter has finished one round of transmission, i"
"t can restart the same transmission again if this value is not set to zero. As the loop is controlled by hardware, the RMT channel can be used to generate many periodic sequences with minimal CPU intervention.

    - Setting :cpp:member:`rmt_transmit_config_t::loop_count` to `-1` means an infinite loop transmission. In this case, the channel does not stop until :cpp:func:`rmt_disable` is called. The ""trans-done"" event is not generated as well.
    - Setting :cpp:member:`rmt_transmit_config_t::lo"
"op_count` to a positive number means finite number of iterations. In this case, the ""trans-done"" event is when the specified number of iterations have completed.

    .. note::

        The **loop transmit** feature is not supported on all ESP chips, please refer to [`TRM `__] before you configure this option, or you might encounter :c:macro:`ESP_ERR_NOT_SUPPORTED` error.

- :cpp:member:`rmt_transmit_config_t::eot_level` sets the output level when the transmitter finishes working or stops workin"
"g by calling :cpp:func:`rmt_disable`.
- :cpp:member:`rmt_transmit_config_t::queue_nonblocking` sets whether to wait for a free slot in the transaction queue when it is full. If this value is set to ``true``, then the function will return with an error code :c:macro:`ESP_ERR_INVALID_STATE` when the queue is full. Otherwise, the function will block until a free slot is available in the queue.

.. note::

    There is a limitation in the transmission size if the :cpp:member:`rmt_transmit_config_t::"
"loop_count` is set to non-zero, i.e., to enable the loop feature. The encoded RMT symbols should not exceed the capacity of the RMT hardware memory block size, or you might see an error message like ``encoding artifacts can't exceed hw memory block for loop transmission``. If you have to start a large transaction by loop, you can try either of the following methods.

    - Increase the :cpp:member:`rmt_tx_channel_config_t::mem_block_symbols`. This approach does not work if the DMA backend is als"
"o enabled.
    - Customize an encoder and construct an infinite loop in the encoding function. See also :ref:`rmt-rmt-encoder`.

Internally, :cpp:func:`rmt_transmit` constructs a transaction descriptor and sends it to a job queue, which is dispatched in the ISR. So it is possible that the transaction is not started yet when :cpp:func:`rmt_transmit` returns. To ensure all pending transactions to complete, the user can use :cpp:func:`rmt_tx_wait_all_done`.

.. _rmt-multiple-channels-simultaneous-t"
"ransmission:

Multiple Channels Simultaneous Transmission


In some real-time control applications (e.g., to make two robotic arms move simultaneously), you do not want any time drift between different channels. The RMT driver can help to manage this by creating a so-called **Sync Manager**. The sync manager is represented by :cpp:type:`rmt_sync_manager_handle_t` in the driver. The procedure of RMT sync transmission is shown as follows:

.. figure:: /../_static/rmt_tx_sync.png
    :align: center"
"
    :alt: RMT TX Sync

    RMT TX Sync

Install RMT Sync Manager
~~~~~~~~~~~~~~~~~~~~~~~~

To create a sync manager, the user needs to tell which channels are going to be managed in the :cpp:type:`rmt_sync_manager_config_t`:

- :cpp:member:`rmt_sync_manager_config_t::tx_channel_array` points to the array of TX channels to be managed.
- :cpp:member:`rmt_sync_manager_config_t::array_size` sets the number of channels to be managed.

:cpp:func:`rmt_new_sync_manager` can return a manager handle on s"
"uccess. This function could also fail due to various errors such as invalid arguments, etc. Especially, when the sync manager has been installed before, and there are no hardware resources to create another manager, this function reports :c:macro:`ESP_ERR_NOT_FOUND` error. In addition, if the sync manager is not supported by the hardware, it reports a :c:macro:`ESP_ERR_NOT_SUPPORTED` error. Please refer to [`TRM `__] before using the sync manager feature.

Start Transmission Simultaneously
~~~~~"
"~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For any managed TX channel, it does not start the machine until :cpp:func:`rmt_transmit` has been called on all channels in :cpp:member:`rmt_sync_manager_config_t::tx_channel_array`. Before that, the channel is just put in a waiting state. TX channels will usually complete their transactions at different times due to differing transactions, thus resulting in a loss of sync. So before restarting a simultaneous transmission, the user needs to call :cpp:func:`rmt_sync_"
"reset` to synchronize all channels again.

Calling :cpp:func:`rmt_del_sync_manager` can recycle the sync manager and enable the channels to initiate transactions independently afterward.

.. code:: c

    rmt_channel_handle_t tx_channels[2] = {NULL}; // declare two channels
    int tx_gpio_number[2] = {0, 2};
    // install channels one by one
    for (int i = 0; i  9000 µs, the receive does not stop early
    };

    rmt_symbol_word_t raw_symbols[64]; // 64 symbols should be sufficient for a st"
"andard NEC frame
    // ready to receive
    ESP_ERROR_CHECK(rmt_receive(rx_channel, raw_symbols, sizeof(raw_symbols), &receive_config));
    // wait for the RX-done signal
    rmt_rx_done_event_data_t rx_data;
    xQueueReceive(receive_queue, &rx_data, portMAX_DELAY);
    // parse the received symbols
    example_parse_nec_frame(rx_data.received_symbols, rx_data.num_symbols);

.. _rmt-rmt-encoder:

RMT Encoder


An RMT encoder is part of the RMT TX transaction, whose responsibility is to genera"
"te and write the correct RMT symbols into hardware memory or DMA buffer at a specific time. There are some special restrictions for an encoding function:

- During a single transaction, the encoding function may be called multiple times. This is necessary because the target RMT memory block cannot hold all the artifacts at once. To overcome this limitation, the driver utilizes a **ping-pong** approach, where the encoding session is divided into multiple parts. This means that the encoder needs t"
"o **keep track of its state** to continue encoding from where it left off in the previous part.
- The encoding function is running in the ISR context. To speed up the encoding session, it is highly recommended to put the encoding function into IRAM. This can also avoid the cache miss during encoding.

To help get started with the RMT driver faster, some commonly used encoders are provided out-of-the-box. They can either work alone or be chained together into a new encoder. See also `Composite Pa"
"ttern `__ for the principle behind it. The driver has defined the encoder interface in :cpp:type:`rmt_encoder_t`, it contains the following functions:

- :cpp:member:`rmt_encoder_t::encode` is the fundamental function of an encoder. This is where the encoding session happens.

    - The function might be called multiple times within a single transaction. The encode function should return the state of the current encoding session.
    - The supported states are listed in the :cpp:type:`rmt_encode"
"_state_t`. If the result contains :cpp:enumerator:`RMT_ENCODING_COMPLETE`, it means the current encoder has finished work.
    - If the result contains :cpp:enumerator:`RMT_ENCODING_MEM_FULL`, the program needs to yield from the current session, as there is no space to save more encoding artifacts.

- :cpp:member:`rmt_encoder_t::reset` should reset the encoder state back to the initial state (the RMT encoder is stateful).

    - If the RMT transmitter is manually stopped without resetting its co"
"rresponding encoder, subsequent encoding session can be erroneous.
    - This function is also called implicitly in :cpp:func:`rmt_disable`.

- :cpp:member:`rmt_encoder_t::del` should free the resources allocated by the encoder.

Copy Encoder
~~~~~~~~~~~~

A copy encoder is created by calling :cpp:func:`rmt_new_copy_encoder`. A copy encoder's main functionality is to copy the RMT symbols from user space into the driver layer. It is usually used to encode ``const`` data, i.e., data does not chang"
"e at runtime after initialization such as the leading code in the IR protocol.

A configuration structure :cpp:type:`rmt_copy_encoder_config_t` should be provided in advance before calling :cpp:func:`rmt_new_copy_encoder`. Currently, this configuration is reserved for future expansion, and has no specific use or setting items for now.

Bytes Encoder
~~~~~~~~~~~~~

A bytes encoder is created by calling :cpp:func:`rmt_new_bytes_encoder`. The bytes encoder's main functionality is to convert the use"
"r space byte stream into RMT symbols dynamically. It is usually used to encode dynamic data, e.g., the address and command fields in the IR protocol.

A configuration structure :cpp:type:`rmt_bytes_encoder_config_t` should be provided in advance before calling :cpp:func:`rmt_new_bytes_encoder`:

- :cpp:member:`rmt_bytes_encoder_config_t::bit0` and :cpp:member:`rmt_bytes_encoder_config_t::bit1` are necessary to specify the encoder how to represent bit zero and bit one in the format of :cpp:type:`"
"rmt_symbol_word_t`.
- :cpp:member:`rmt_bytes_encoder_config_t::msb_first` sets the bit endianess of each byte. If it is set to true, the encoder encodes the **Most Significant Bit** first. Otherwise, it encodes the **Least Significant Bit** first.

Besides the primitive encoders provided by the driver, the user can implement his own encoder by chaining the existing encoders together. A common encoder chain is shown as follows:

.. blockdiag:: /../_static/diagrams/rmt/rmt_encoder_chain.diag
    :"
"caption: RMT Encoder Chain
    :align: center

Customize RMT Encoder for NEC Protocol
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This section demonstrates how to write an NEC encoder. The NEC IR protocol uses pulse distance encoding of the message bits. Each pulse burst is ``562.5 µs`` in length, logical bits are transmitted as follows. It is worth mentioning that the least significant bit of each byte is sent first.

- Logical ``0``: a ``562.5 µs`` pulse burst followed by a ``562.5 µs`` space, wit"
"h a total transmit time of ``1.125 ms``
- Logical ``1``: a ``562.5 µs`` pulse burst followed by a ``1.6875 ms`` space, with a total transmit time of ``2.25 ms``

When a key is pressed on the remote controller, the transmitted message includes the following elements in the specified order:

.. figure:: /../_static/ir_nec.png
    :align: center
    :alt: IR NEC Frame

    IR NEC Frame

- ``9 ms`` leading pulse burst, also called the ""AGC pulse""
- ``4.5 ms`` space
- 8-bit address for the receiving "
"device
- 8-bit logical inverse of the address
- 8-bit command
- 8-bit logical inverse of the command
- a final ``562.5 µs`` pulse burst to signify the end of message transmission

Then you can construct the NEC :cpp:member:`rmt_encoder_t::encode` function in the same order, for example:

.. code:: c

    // IR NEC scan code representation
    typedef struct {
        uint16_t address;
        uint16_t command;
    } ir_nec_scan_code_t;

    // construct an encoder by combining primitive encoders"
"
    typedef struct {
        rmt_encoder_t base;           // the base ""class"" declares the standard encoder interface
        rmt_encoder_t *copy_encoder;  // use the copy_encoder to encode the leading and ending pulse
        rmt_encoder_t *bytes_encoder; // use the bytes_encoder to encode the address and command data
        rmt_symbol_word_t nec_leading_symbol; // NEC leading code with RMT representation
        rmt_symbol_word_t nec_ending_symbol;  // NEC ending code with RMT representatio"
"n
        int state; // record the current encoding state, i.e., we are in which encoding phase
    } rmt_ir_nec_encoder_t;

    static size_t rmt_encode_ir_nec(rmt_encoder_t *encoder, rmt_channel_handle_t channel, const void *primary_data, size_t data_size, rmt_encode_state_t *ret_state)
    {
        rmt_ir_nec_encoder_t *nec_encoder = __containerof(encoder, rmt_ir_nec_encoder_t, base);
        rmt_encode_state_t session_state = RMT_ENCODING_RESET;
        rmt_encode_state_t state = RMT_ENCODI"
"NG_RESET;
        size_t encoded_symbols = 0;
        ir_nec_scan_code_t *scan_code = (ir_nec_scan_code_t *)primary_data;
        rmt_encoder_handle_t copy_encoder = nec_encoder->copy_encoder;
        rmt_encoder_handle_t bytes_encoder = nec_encoder->bytes_encoder;
        switch (nec_encoder->state) {
        case 0: // send leading code
            encoded_symbols += copy_encoder->encode(copy_encoder, channel, &nec_encoder->nec_leading_symbol,
                                                  "
"  sizeof(rmt_symbol_word_t), &session_state);
            if (session_state & RMT_ENCODING_COMPLETE) {
                nec_encoder->state = 1; // we can only switch to the next state when the current encoder finished
            }
            if (session_state & RMT_ENCODING_MEM_FULL) {
                state |= RMT_ENCODING_MEM_FULL;
                goto out; // yield if there is no free space to put other encoding artifacts
            }
        // fall-through
        case 1: // send address
 "
"           encoded_symbols += bytes_encoder->encode(bytes_encoder, channel, &scan_code->address, sizeof(uint16_t), &session_state);
            if (session_state & RMT_ENCODING_COMPLETE) {
                nec_encoder->state = 2; // we can only switch to the next state when the current encoder finished
            }
            if (session_state & RMT_ENCODING_MEM_FULL) {
                state |= RMT_ENCODING_MEM_FULL;
                goto out; // yield if there is no free space to put other enco"
"ding artifacts
            }
        // fall-through
        case 2: // send command
            encoded_symbols += bytes_encoder->encode(bytes_encoder, channel, &scan_code->command, sizeof(uint16_t), &session_state);
            if (session_state & RMT_ENCODING_COMPLETE) {
                nec_encoder->state = 3; // we can only switch to the next state when the current encoder finished
            }
            if (session_state & RMT_ENCODING_MEM_FULL) {
                state |= RMT_ENCODING_ME"
"M_FULL;
                goto out; // yield if there is no free space to put other encoding artifacts
            }
        // fall-through
        case 3: // send ending code
            encoded_symbols += copy_encoder->encode(copy_encoder, channel, &nec_encoder->nec_ending_symbol,
                                                    sizeof(rmt_symbol_word_t), &session_state);
            if (session_state & RMT_ENCODING_COMPLETE) {
                nec_encoder->state = RMT_ENCODING_RESET; // back"
" to the initial encoding session
                state |= RMT_ENCODING_COMPLETE; // telling the caller the NEC encoding has finished
            }
            if (session_state & RMT_ENCODING_MEM_FULL) {
                state |= RMT_ENCODING_MEM_FULL;
                goto out; // yield if there is no free space to put other encoding artifacts
            }
        }
    out:
        *ret_state = state;
        return encoded_symbols;
    }

A full sample code can be found in :example:`peripheral"
"s/rmt/ir_nec_transceiver`. In the above snippet, we use a ``switch-case`` and several ``goto`` statements to implement a `Finite-state machine `__ . With this pattern, users can construct much more complex IR protocols.

.. _rmt-power-management:

Power Management


When power management is enabled, i.e., :ref:`CONFIG_PM_ENABLE` is on, the system adjusts the APB frequency before going into Light-sleep, thus potentially changing the resolution of the RMT internal counter.

However, the driver can"
" prevent the system from changing APB frequency by acquiring a power management lock of type :cpp:enumerator:`ESP_PM_APB_FREQ_MAX`. Whenever the user creates an RMT channel that has selected :cpp:enumerator:`RMT_CLK_SRC_APB` as the clock source, the driver guarantees that the power management lock is acquired after the channel enabled by :cpp:func:`rmt_enable`. Likewise, the driver releases the lock after :cpp:func:`rmt_disable` is called for the same channel. This also reveals that the :cpp:fun"
"c:`rmt_enable` and :cpp:func:`rmt_disable` should appear in pairs.

If the channel clock source is selected to others like :cpp:enumerator:`RMT_CLK_SRC_XTAL`, then the driver does not install a power management lock for it, which is more suitable for a low-power application as long as the source clock can still provide sufficient resolution.

.. _rmt-iram-safe:

IRAM Safe


By default, the RMT interrupt is deferred when the Cache is disabled for reasons like writing or erasing the main Flash. Th"
"us the transaction-done interrupt does not get handled in time, which is not acceptable in a real-time application. What is worse, when the RMT transaction relies on **ping-pong** interrupt to successively encode or copy RMT symbols, a delayed interrupt can lead to an unpredictable result.

There is a Kconfig option :ref:`CONFIG_RMT_ISR_IRAM_SAFE` that has the following features:

This Kconfig option allows the interrupt handler to run while the cache is disabled but comes at the cost of increas"
"ed IRAM consumption.

Another Kconfig option :ref:`CONFIG_RMT_RECV_FUNC_IN_IRAM` can place :cpp:func:`rmt_receive` into the IRAM as well. So that the receive function can be used even when the flash cache is disabled.

.. _rmt-thread-safety:

Thread Safety


The factory function :cpp:func:`rmt_new_tx_channel`, :cpp:func:`rmt_new_rx_channel` and :cpp:func:`rmt_new_sync_manager` are guaranteed to be thread-safe by the driver, which means, user can call them from different RTOS tasks without protec"
"tion by extra locks.
Other functions that take the :cpp:type:`rmt_channel_handle_t` and :cpp:type:`rmt_sync_manager_handle_t` as the first positional parameter, are not thread-safe. which means the user should avoid calling them from multiple tasks.

The following functions are allowed to use under ISR context as well.

- :cpp:func:`rmt_receive`

.. _rmt-kconfig-options:

Kconfig Options


- :ref:`CONFIG_RMT_ISR_IRAM_SAFE` controls whether the default ISR handler can work when cache is disabled,"
" see also :ref:`rmt-iram-safe` for more information.
- :ref:`CONFIG_RMT_ENABLE_DEBUG_LOG` is used to enable the debug log at the cost of increased firmware binary size.
- :ref:`CONFIG_RMT_RECV_FUNC_IN_IRAM` controls where to place the RMT receive function (IRAM or Flash), see :ref:`rmt-iram-safe` for more information.

Application Examples


FAQ
---

The RMT encoding takes place in the ISR context. If your RMT encoding session takes a long time (e.g., by logging debug information) or the encodin"
"g session is deferred somehow because of interrupt latency, then it is possible the transmitting becomes **faster** than the encoding. As a result, the encoder can not prepare the next data in time, leading to the transmitter sending the previous data again. There is no way to ask the transmitter to stop and wait. You can mitigate the issue by combining the following ways:

    - Increase the :cpp:member:`rmt_tx_channel_config_t::mem_block_symbols`, in steps of {IDF_TARGET_SOC_RMT_MEM_WORDS_PER_"
"CHANNEL}.
    - Place the encoding function in the IRAM.
    - Enables the :cpp:member:`rmt_tx_channel_config_t::with_dma` if it is available for your chip.

API Reference


.. include-build-file:: inc/rmt_tx.inc
.. include-build-file:: inc/rmt_rx.inc
.. include-build-file:: inc/rmt_common.inc
.. include-build-file:: inc/rmt_encoder.inc
.. include-build-file:: inc/components/esp_driver_rmt/include/driver/rmt_types.inc
.. include-build-file:: inc/components/hal/include/hal/rmt_types.inc


.. [1]
"
"   Different ESP chip series might have different numbers of RMT channels. Please refer to [`TRM `__] for details. The driver does not forbid you from applying for more RMT channels, but it returns an error when there are no hardware resources available. Please always check the return value when doing `Resource Allocation `__.

.. [2]
   The callback function, e.g., :cpp:member:`rmt_tx_event_callbacks_t::on_trans_done`, and the functions invoked by itself should also reside in IRAM, users need t"
"o take care of this by themselves.
"
"Two-Wire Automotive Interface (TWAI)


..  Overview 

Overview


The Two-Wire Automotive Interface (TWAI) is a real-time serial communication protocol suited for automotive and industrial applications. It is compatible with ISO11898-1 Classical frames, thus can support Standard Frame Format (11-bit ID) and Extended Frame Format (29-bit ID). The {IDF_TARGET_NAME} contains {IDF_TARGET_CONFIG_SOC_TWAI_CONTROLLER_NUM} TWAI controller(s) that can be configured to communicate on a TWAI bus via an exte"
"rnal transceiver.

.. warning::

    The TWAI controller is not compatible with ISO11898-1 FD Format frames, and will interpret such frames as errors.

This programming guide is split into the following sections:

.. contents:: Sections
  :depth: 2

..  Basic TWAI Concepts 

TWAI Protocol Summary


The TWAI is a multi-master, multi-cast, asynchronous, serial communication protocol. TWAI also supports error detection and signalling, and inbuilt message prioritization.

**Multi-master:** Any node "
"on the bus can initiate the transfer of a message.

**Multi-cast:** When a node transmits a message, all nodes on the bus will receive the message (i.e., broadcast) thus ensuring data consistency across all nodes. However, some nodes can selectively choose which messages to accept via the use of acceptance filtering (multi-cast).

**Asynchronous:** The bus does not contain a clock signal. All nodes on the bus operate at the same bit rate and synchronize using the edges of the bits transmitted on"
" the bus.

**Error Detection and Signaling:** Every node constantly monitors the bus. When any node detects an error, it signals the detection by transmitting an error frame. Other nodes will receive the error frame and transmit their own error frames in response. This results in an error detection being propagated to all nodes on the bus.

**Message Priorities:** Messages contain an ID field. If two or more nodes attempt to transmit simultaneously, the node transmitting the message with the low"
"er ID value will win arbitration of the bus. All other nodes will become receivers ensuring that there is at most one transmitter at any time.

TWAI Messages


TWAI Messages are split into Data Frames and Remote Frames. Data Frames are used to deliver a data payload to other nodes, whereas a Remote Frame is used to request a Data Frame from other nodes (other nodes can optionally respond with a Data Frame). Data and Remote Frames have two frame formats known as **Extended Frame** and **Standard "
"Frame** which contain a 29-bit ID and an 11-bit ID respectively. A TWAI message consists of the following fields:

    - 29-bit or 11-bit ID: Determines the priority of the message (lower value has higher priority).
    - Data Length Code (DLC) between 0 to 8: Indicates the size (in bytes) of the data payload for a Data Frame, or the amount of data to request for a Remote Frame.
    - Up to 8 bytes of data for a Data Frame (should match DLC).

Error States and Counters


The TWAI protocol implem"
"ents a feature known as ""fault confinement"" where a persistently erroneous node will eventually eliminate itself from the bus. This is implemented by requiring every node to maintain two internal error counters known as the **Transmit Error Counter (TEC)** and the **Receive Error Counter (REC)**. The two error counters are incremented and decremented according to a set of rules (where the counters increase on an error, and decrease on a successful message transmission/reception). The values of t"
"he counters are used to determine a node's **error state**, namely **Error Active**, **Error Passive**, and **Bus-Off**.

**Error Active:** A node is Error Active when **both TEC and REC are less than 128** and indicates that the node is operating normally. Error Active nodes are allowed to participate in bus communications, and will actively signal the detection of any errors by automatically transmitting an **Active Error Flag** over the bus.

**Error Passive:** A node is Error Passive when **"
"either the TEC or REC becomes greater than or equal to 128**. Error Passive nodes are still able to take part in bus communications, but will instead transmit a **Passive Error Flag** upon detection of an error.

**Bus-Off:** A node becomes Bus-Off when the **TEC becomes greater than or equal to 256**. A Bus-Off node is unable influence the bus in any manner (essentially disconnected from the bus) thus eliminating itself from the bus. A node will remain in the Bus-Off state until it undergoes bu"
"s-off recovery.

..  Signal Lines and Transceiver 

Signals Lines and Transceiver


The TWAI controller does not contain a integrated transceiver. Therefore, to connect the TWAI controller to a TWAI bus, **an external transceiver is required**. The type of external transceiver used should depend on the application's physical layer specification (e.g., using SN65HVD23x transceivers for ISO 11898-2 compatibility).

The TWAI controller's interface consists of 4 signal lines known as **TX, RX, BUS-O"
"FF, and CLKOUT**. These four signal lines can be routed through the GPIO Matrix to the {IDF_TARGET_NAME}'s GPIO pads.

.. blockdiag:: ../../../_static/diagrams/twai/controller_signals.diag
    :caption: Signal lines of the TWAI controller
    :align: center

**TX and RX:** The TX and RX signal lines are required to interface with an external transceiver. Both signal lines represent/interpret a dominant bit as a low logic level (0 V), and a recessive bit as a high logic level (3.3 V).

**BUS-OFF:"
"** The BUS-OFF signal line is **optional** and is set to a low logic level (0 V) whenever the TWAI controller reaches a bus-off state. The BUS-OFF signal line is set to a high logic level (3.3 V) otherwise.

**CLKOUT:** The CLKOUT signal line is **optional** and outputs a prescaled version of the controller's source clock.

.. note::

    An external transceiver **must internally loopback the TX to RX** such that a change in logic level to the TX signal line can be observed on the RX line. Faili"
"ng to do so will cause the TWAI controller to interpret differences in logic levels between the two signal lines as a loss in arbitration or a bit error.


..  Configuration 

API Naming Conventions


.. note::

  The TWAI driver provides two sets of API. One is handle-free and is widely used in IDF versions earlier than v5.2, but it can only support one TWAI hardware controller. The other set is with handles, and the function name is usually suffixed with ""v2"", which can support any number of T"
"WAI controllers. These two sets of API can be used at the same time, but it is recommended to use the ""v2"" version in your new projects.

Driver Configuration


This section covers how to configure the TWAI driver.

Operating Modes


The TWAI driver supports the following modes of operations:

**Normal Mode:** The normal operating mode allows the TWAI controller to take part in bus activities such as transmitting and receiving messages/error frames. Acknowledgement from another node is required "
"when transmitting a message.

**No Ack Mode:** The No Acknowledgement mode is similar to normal mode, however acknowledgements are not required for a message transmission to be considered successful. This mode is useful when self testing the TWAI controller (loopback of transmissions).

**Listen Only Mode:** This mode prevents the TWAI controller from influencing the bus. Therefore, transmission of messages/acknowledgement/error frames will be disabled. However the TWAI controller is still able "
"to receive messages but will not acknowledge the message. This mode is suited for bus monitor applications.

Alerts


The TWAI driver contains an alert feature that is used to notify the application layer of certain TWAI controller or TWAI bus events. Alerts are selectively enabled when the TWAI driver is installed, but can be reconfigured during runtime by calling :cpp:func:`twai_reconfigure_alerts`. The application can then wait for any enabled alerts to occur by calling :cpp:func:`twai_read_a"
"lerts`. The TWAI driver supports the following alerts:

.. list-table:: TWAI Driver Alerts
    :widths: 40 60
    :header-rows: 1
      - Description
      - No more messages queued for transmission
      - The previous transmission was successful
      - A frame has been received and added to the RX queue
      - Both error counters have dropped below error warning limit
      - TWAI controller has become error active
      - TWAI controller is undergoing bus recovery
      - TWAI controller ha"
"s successfully completed bus recovery
      - The previous transmission lost arbitration
      - One of the error counters have exceeded the error warning limit
      - A (Bit, Stuff, CRC, Form, ACK) error has occurred on the bus
      - The previous transmission has failed
      - The RX queue is full causing a received frame to be lost
      - TWAI controller has become error passive
      - Bus-off condition occurred. TWAI controller can no longer influence bus

.. note::

    The TWAI contro"
"ller's **error warning limit** is used to preemptively warn the application of bus errors before the error passive state is reached. By default, the TWAI driver sets the **error warning limit** to **96**. The ``TWAI_ALERT_ABOVE_ERR_WARN`` is raised when the TEC or REC becomes larger then or equal to the error warning limit. The ``TWAI_ALERT_BELOW_ERR_WARN`` is raised when both TEC and REC return back to values below **96**.

.. note::

    When enabling alerts, the ``TWAI_ALERT_AND_LOG`` flag ca"
"n be used to cause the TWAI driver to log any raised alerts to UART. However, alert logging is disabled and ``TWAI_ALERT_AND_LOG`` if the :ref:`CONFIG_TWAI_ISR_IN_IRAM` option is enabled (see :ref:`placing-isr-into-iram`).

.. note::

    The ``TWAI_ALERT_ALL`` and ``TWAI_ALERT_NONE`` macros can also be used to enable/disable all alerts during configuration/reconfiguration.

Bit Timing


The operating bit rate of the TWAI driver is configured using the :cpp:type:`twai_timing_config_t` structure."
" The period of each bit is made up of multiple **time quanta**, and the period of a **time quantum** is determined by a pre-scaled version of the TWAI controller's source clock. A single bit contains the following segments in the following order:

{IDF_TARGET_MAX_BRP:default=""32768"", esp32=""128"", esp32s3=""16384"", esp32c3=""16384""}

The **Baudrate Prescaler** is used to determine the period of each time quantum by dividing the TWAI controller's source clock. On the {IDF_TARGET_NAME}, the ``brp`` c"
"an be **any even number from 2 to {IDF_TARGET_MAX_BRP}**. Alternatively, you can decide the resolution of each quantum, by setting :cpp:member:`twai_timing_config_t::quanta_resolution_hz` to a non-zero value. In this way, the driver can calculate the underlying ``brp`` value for you. It is useful when you set different clock sources but want the bitrate to keep the same.

Supported clock source for a TWAI controller is listed in the :cpp:type:`twai_clock_source_t` and can be specified in :cpp:me"
"mber:`twai_timing_config_t::clk_src`.

.. only:: esp32

    If the ESP32 is a revision 2 or later chip, the ``brp`` will **also support any multiple of 4 from 132 to 256**, and can be enabled by setting the :ref:`CONFIG_ESP32_REV_MIN` to revision 2 or higher.

.. packetdiag:: ../../../_static/diagrams/twai/bit_timing.diag
    :caption: Bit timing configuration for 500kbit/s given BRP = 8, clock source frequency is 80MHz
    :align: center

The sample point of a bit is located on the intersection"
" of Timing Segment 1 and 2. Enabling **Triple Sampling** causes 3 time quanta to be sampled per bit instead of 1 (extra samples are located at the tail end of Timing Segment 1).

The **Synchronization Jump Width** is used to determine the maximum number of time quanta a single bit time can be lengthened/shortened for synchronization purposes. ``sjw`` can **range from 1 to 4**.

.. note::

    Multiple combinations of ``brp``, ``tseg_1``, ``tseg_2``, and ``sjw`` can achieve the same bit rate. Use"
"rs should tune these values to the physical characteristics of their bus by taking into account factors such as **propagation delay, node information processing time, and phase errors**.

Bit timing **macro initializers** are also available for commonly used bit rates. The following macro initializers are provided by the TWAI driver.

.. list::

    - :c:macro:`TWAI_TIMING_CONFIG_1MBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_800KBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_500KBITS`
    - :c:macro:`TWA"
"I_TIMING_CONFIG_250KBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_125KBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_100KBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_50KBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_25KBITS`
    :not esp32: - :c:macro:`TWAI_TIMING_CONFIG_20KBITS`
    :not esp32: - :c:macro:`TWAI_TIMING_CONFIG_16KBITS`
    :not esp32: - :c:macro:`TWAI_TIMING_CONFIG_12_5KBITS`
    :not esp32: - :c:macro:`TWAI_TIMING_CONFIG_10KBITS`
    :not esp32: - :c:macro:`TWAI_TIMING_CONFIG_5KBITS`
    :not esp32:"
" - :c:macro:`TWAI_TIMING_CONFIG_1KBITS`

.. only:: esp32

    Revision 2 or later of the ESP32 also supports the following bit rates:

    - :c:macro:`TWAI_TIMING_CONFIG_20KBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_16KBITS`
    - :c:macro:`TWAI_TIMING_CONFIG_12_5KBITS`

Acceptance Filter


The TWAI controller contains a hardware acceptance filter which can be used to filter messages of a particular ID. A node that filters out a message **does not receive the message, but will still acknowledge it"
"**. Acceptance filters can make a node more efficient by filtering out messages sent over the bus that are irrelevant to the node. The acceptance filter is configured using two 32-bit values within :cpp:type:`twai_filter_config_t` known as the **acceptance code** and the **acceptance mask**.

The **acceptance code** specifies the bit sequence which a message's ID, RTR, and data bytes must match in order for the message to be received by the TWAI controller. The **acceptance mask** is a bit seque"
"nce specifying which bits of the acceptance code can be ignored. This allows for a messages of different IDs to be accepted by a single acceptance code.

The acceptance filter can be used under **Single or Dual Filter Mode**. Single Filter Mode uses the acceptance code and mask to define a single filter. This allows for the first two data bytes of a standard frame to be filtered, or the entirety of an extended frame's 29-bit ID. The following diagram illustrates how the 32-bit acceptance code an"
"d mask are interpreted under Single Filter Mode (Note: The yellow and blue fields represent standard and extended frame formats respectively).

.. packetdiag:: ../../../_static/diagrams/twai/acceptance_filter_single.diag
    :caption: Bit layout of single filter mode (Right side MSBit)
    :align: center

**Dual Filter Mode** uses the acceptance code and mask to define two separate filters allowing for increased flexibility of ID's to accept, but does not allow for all 29-bits of an extended ID "
"to be filtered. The following diagram illustrates how the 32-bit acceptance code and mask are interpreted under **Dual Filter Mode** (Note: The yellow and blue fields represent standard and extended frame formats respectively).

.. packetdiag:: ../../../_static/diagrams/twai/acceptance_filter_dual.diag
    :caption: Bit layout of dual filter mode (Right side MSBit)
    :align: center

Disabling TX Queue


The TX queue can be disabled during configuration by setting the ``tx_queue_len`` member of"
" :cpp:type:`twai_general_config_t` to ``0``. This allows applications that do not require message transmission to save a small amount of memory when using the TWAI driver.

.. _placing-isr-into-iram:

Placing ISR into IRAM


The TWAI driver's ISR (Interrupt Service Routine) can be placed into IRAM so that the ISR can still run whilst the cache is disabled. Placing the ISR into IRAM may be necessary to maintain the TWAI driver's functionality during lengthy cache disabling operations (such as SPI"
" Flash writes, OTA updates etc). Whilst the cache is disabled, the ISR continues to:

- Read received messages from the RX buffer and place them into the driver's RX queue.
- Load messages pending transmission from the driver's TX queue and write them into the TX buffer.

To place the TWAI driver's ISR, users must do the following:

- Enable the :ref:`CONFIG_TWAI_ISR_IN_IRAM` option using ``idf.py menuconfig``.
- When calling :cpp:func:`twai_driver_install`, the ``intr_flags`` member of :cpp:typ"
"e:`twai_general_config_t` should set the :c:macro:`ESP_INTR_FLAG_IRAM` set.

.. note::

    When the :ref:`CONFIG_TWAI_ISR_IN_IRAM` option is enabled, the TWAI driver will no longer log any alerts (i.e., the ``TWAI_ALERT_AND_LOG`` flag will not have any effect).

.. only:: esp32

    ESP32 Errata Workarounds
    

    The ESP32's TWAI controller contains multiple hardware errata (more details about the errata can be found in the `ESP32's ECO document `_). Some of these errata are critical, and u"
"nder specific circumstances, can place the TWAI controller into an unrecoverable state (i.e., the controller gets stuck until it is reset by the CPU).

    The TWAI driver contains software workarounds for these critical errata. With these workarounds, the ESP32 TWAI driver can operate normally, albeit with degraded performance. The degraded performance will affect users in the following ways depending on what particular errata conditions are encountered:

    - The TWAI driver can occasionally "
"drop some received messages.
    - The TWAI driver can be unresponsive for a short period of time (i.e., will not transmit or ACK for 11 bit times or longer).
    - If :ref:`CONFIG_TWAI_ISR_IN_IRAM` is enabled, the workarounds will increase IRAM usage by approximately 1 KB.

    The software workarounds are enabled by default and it is recommended that users keep this workarounds enabled.

..  TWAI Driver 

Driver Operation


The TWAI driver is designed with distinct states and strict rules rega"
"rding the functions or conditions that trigger a state transition. The following diagram illustrates the various states and their transitions.

.. blockdiag:: ../../../_static/diagrams/twai/state_transition.diag
    :caption: State transition diagram of the TWAI driver (see table below)
    :align: center

.. list-table::
    :widths: 20 40 40
    :header-rows: 1
      - Transition
      - Action/Condition
      - Uninstalled > Stopped
      - :cpp:func:`twai_driver_install`
      - Stopped > Un"
"installed
      - :cpp:func:`twai_driver_uninstall`
      - Stopped > Running
      - :cpp:func:`twai_start`
      - Running > Stopped
      - :cpp:func:`twai_stop`
      - Running > Bus-Off
      - Transmit Error Counter >= 256
      - Bus-Off > Uninstalled
      - :cpp:func:`twai_driver_uninstall`
      - Bus-Off > Recovering
      - :cpp:func:`twai_initiate_recovery`
      - Recovering > Stopped
      - 128 occurrences of 11 consecutive recessive bits.


Driver States


**Uninstalled**: In th"
"e uninstalled state, no memory is allocated for the driver and the TWAI controller is powered OFF.

**Stopped**: In this state, the TWAI controller is powered ON and the TWAI driver has been installed. However the TWAI controller is unable to take part in any bus activities such as transmitting, receiving, or acknowledging messages.

**Running**: In the running state, the TWAI controller is able to take part in bus activities. Therefore messages can be transmitted/received/acknowledged. Furtherm"
"ore, the TWAI controller is able to transmit error frames upon detection of errors on the bus.

**Bus-Off**: The bus-off state is automatically entered when the TWAI controller's Transmit Error Counter becomes greater than or equal to 256. The bus-off state indicates the occurrence of severe errors on the bus or in the TWAI controller. Whilst in the bus-off state, the TWAI controller is unable to take part in any bus activities. To exit the bus-off state, the TWAI controller must undergo the bus"
" recovery process.

**Recovering**: The recovering state is entered when the TWAI controller undergoes bus recovery. The TWAI controller/TWAI driver remains in the recovering state until the 128 occurrences of 11 consecutive recessive bits is observed on the bus.

Message Fields and Flags


The TWAI driver distinguishes different types of messages by using the various bit field members of the :cpp:type:`twai_message_t` structure. These bit field members determine whether a message is in standard"
" or extended format, a remote frame, and the type of transmission to use when transmitting such a message.

These bit field members can also be toggled using the ``flags`` member of :cpp:type:`twai_message_t` and the following message flags:

.. list-table::
    :widths: 30 70
    :header-rows: 1
      - Description
      - Message is in Extended Frame Format (29bit ID)
      - Message is a Remote Frame (Remote Transmission Request)
      - Transmit message using Single Shot Transmission (Messag"
"e will not be retransmitted upon error or loss of arbitration). Unused for received message.
      - Transmit message using Self Reception Request (Transmitted message will also received by the same node). Unused for received message.
      - Message's Data length code is larger than 8. This will break compliance with TWAI
      - Clears all bit fields. Equivalent to a Standard Frame Format (11bit ID) Data Frame.

..  Examples 

Examples


Configuration & Installation


The following code snippe"
"t demonstrates how to configure, install, and start the TWAI driver via the use of the various configuration structures, macro initializers, the :cpp:func:`twai_driver_install` function, and the :cpp:func:`twai_start` function.

.. code-block:: c

    #include ""driver/gpio.h""
    #include ""driver/twai.h""

    void app_main()
    {
        //Initialize configuration structures using macro initializers
        twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(GPIO_NUM_21, GPIO_NUM_22, T"
"WAI_MODE_NORMAL);
        twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();
        twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

        //Install TWAI driver
        if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK) {
            printf(""Driver installed\n"");
        } else {
            printf(""Failed to install driver\n"");
            return;
        }

        //Start TWAI driver
        if (twai_start() == ESP_OK) {
            printf(""Dri"
"ver started\n"");
        } else {
            printf(""Failed to start driver\n"");
            return;
        }

        ...

    }

The usage of macro initializers is not mandatory and each of the configuration structures can be manually.

Install Multiple TWAI Instances


The following code snippet demonstrates how to install multiple TWAI instances via the use of the :cpp:func:`twai_driver_install_v2` function.

.. code-block:: c

    #include ""driver/gpio.h""
    #include ""driver/twai.h""

   "
" void app_main()
    {
        twai_handle_t twai_bus_0;
        twai_handle_t twai_bus_1;
        //Initialize configuration structures using macro initializers
        twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(GPIO_NUM_0, GPIO_NUM_1, TWAI_MODE_NORMAL);
        twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();
        twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

        //Install driver for TWAI bus 0
        g_config.controller_id = 0;
     "
"   if (twai_driver_install_v2(&g_config, &t_config, &f_config, &twai_bus_0) == ESP_OK) {
            printf(""Driver installed\n"");
        } else {
            printf(""Failed to install driver\n"");
            return;
        }
        //Start TWAI driver
        if (twai_start_v2(twai_bus_0) == ESP_OK) {
            printf(""Driver started\n"");
        } else {
            printf(""Failed to start driver\n"");
            return;
        }

        //Install driver for TWAI bus 1
        g_config."
"controller_id = 1;
        g_config.tx_io = GPIO_NUM_2;
        g_config.rx_io = GPIO_NUM_3;
        if (twai_driver_install_v2(&g_config, &t_config, &f_config, &twai_bus_1) == ESP_OK) {
            printf(""Driver installed\n"");
        } else {
            printf(""Failed to install driver\n"");
            return;
        }
        //Start TWAI driver
        if (twai_start_v2(twai_bus_1) == ESP_OK) {
            printf(""Driver started\n"");
        } else {
            printf(""Failed to start dr"
"iver\n"");
            return;
        }

        //Other Driver operations must use version 2 API as well
        ...

    }

Message Transmission


The following code snippet demonstrates how to transmit a message via the usage of the :cpp:type:`twai_message_t` type and :cpp:func:`twai_transmit` function.

.. code-block:: c

    #include ""driver/twai.h""

    ...

    // Configure message to transmit
    twai_message_t message = {
        // Message type and format settings
        .extd = 1,   "
"           // Standard vs extended format
        .rtr = 0,               // Data vs RTR frame
        .ss = 0,                // Whether the message is single shot (i.e., does not repeat on error)
        .self = 0,              // Whether the message is a self reception request (loopback)
        .dlc_non_comp = 0,      // DLC is less than 8
        // Message ID and payload
        .identifier = 0xAAAA,
        .data_length_code = 4,
        .data = {0, 1, 2, 3},
    };

    //Queue message f"
"or transmission
    if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
        printf(""Message queued for transmission\n"");
    } else {
        printf(""Failed to queue message for transmission\n"");
    }

Message Reception


The following code snippet demonstrates how to receive a message via the usage of the :cpp:type:`twai_message_t` type and :cpp:func:`twai_receive` function.

.. code-block:: c

    #include ""driver/twai.h""

    ...

    //Wait for message to be received
    twai_"
"message_t message;
    if (twai_receive(&message, pdMS_TO_TICKS(10000)) == ESP_OK) {
        printf(""Message received\n"");
    } else {
        printf(""Failed to receive message\n"");
        return;
    }

    //Process received message
    if (message.extd) {
        printf(""Message is in Extended Format\n"");
    } else {
        printf(""Message is in Standard Format\n"");
    }
    printf(""ID is %d\n"", message.identifier);
    if (!(message.rtr)) {
        for (int i = 0; i < message.data_lengt"
"h_code; i++) {
            printf(""Data byte %d = %d\n"", i, message.data[i]);
        }
    }

Reconfiguring and Reading Alerts


The following code snippet demonstrates how to reconfigure and read TWAI driver alerts via the use of the :cpp:func:`twai_reconfigure_alerts` and :cpp:func:`twai_read_alerts` functions.

.. code-block:: c

    #include ""driver/twai.h""

    ...

    //Reconfigure alerts to detect Error Passive and Bus-Off error states
    uint32_t alerts_to_enable = TWAI_ALERT_ERR_PASS"
" | TWAI_ALERT_BUS_OFF;
    if (twai_reconfigure_alerts(alerts_to_enable, NULL) == ESP_OK) {
        printf(""Alerts reconfigured\n"");
    } else {
        printf(""Failed to reconfigure alerts"");
    }

    //Block indefinitely until an alert occurs
    uint32_t alerts_triggered;
    twai_read_alerts(&alerts_triggered, portMAX_DELAY);

Stop and Uninstall


The following code demonstrates how to stop and uninstall the TWAI driver via the use of the :cpp:func:`twai_stop` and :cpp:func:`twai_driver_u"
"ninstall` functions.

.. code-block:: c

    #include ""driver/twai.h""

    ...

    //Stop the TWAI driver
    if (twai_stop() == ESP_OK) {
        printf(""Driver stopped\n"");
    } else {
        printf(""Failed to stop driver\n"");
        return;
    }

    //Uninstall the TWAI driver
    if (twai_driver_uninstall() == ESP_OK) {
        printf(""Driver uninstalled\n"");
    } else {
        printf(""Failed to uninstall driver\n"");
        return;
    }

Multiple ID Filter Configuration


The accep"
"tance mask in :cpp:type:`twai_filter_config_t` can be configured such that two or more IDs are accepted for a single filter. For a particular filter to accept multiple IDs, the conflicting bit positions amongst the IDs must be set in the acceptance mask. The acceptance code can be set to any one of the IDs.

The following example shows how the calculate the acceptance mask given multiple IDs::

    ID1 =  11'b101 1010 0000
    ID2 =  11'b101 1010 0001
    ID3 =  11'b101 1010 0100
    ID4 =  11'b"
"101 1010 1000
    //Acceptance Mask
    MASK = 11'b000 0000 1101

Application Examples


**Network Example:** The TWAI Network example demonstrates communication between two {IDF_TARGET_NAME}s using the TWAI driver API. One TWAI node acts as a network master that initiates and ceases the transfer of a data from another  node acting as a network slave. The example can be found via :example:`peripherals/twai/twai_network`.

**Alert and Recovery Example:** This example demonstrates how to use the T"
"WAI driver's alert and bus-off recovery API. The example purposely introduces errors on the bus to put the TWAI controller into the Bus-Off state. An alert is used to detect the Bus-Off state and trigger the bus recovery process. The example can be found via :example:`peripherals/twai/twai_alert_and_recovery`.

**Self Test Example:** This example uses the No Acknowledge Mode and Self Reception Request to cause the TWAI controller to send and simultaneously receive a series of messages. This exam"
"ple can be used to verify if the connections between the TWAI controller and the external transceiver are working correctly. The example can be found via :example:`peripherals/twai/twai_self_test`.


..  API Reference 

API Reference


.. include-build-file:: inc/twai_types.inc
.. include-build-file:: inc/twai.inc
"
"Motor Control Pulse Width Modulator (MCPWM)





The MCPWM peripheral is a versatile PWM generator, which contains various submodules to make it a key element in power electronic applications like motor control, digital power, and so on. Typically, the MCPWM peripheral can be used in the following scenarios:

- Digital motor control, e.g., brushed/brushless DC motor, RC servo motor
- Switch mode-based digital power conversion
- Power DAC, where the duty cycle is equivalent to a DAC analog value
"
"- Calculate external pulse width, and convert it into other analog values like speed, distance
- Generate Space Vector PWM (SVPWM) signals for Field Oriented Control (FOC)

The main submodules are listed in the following diagram:

.. blockdiag:: /../_static/diagrams/mcpwm/mcpwm_overview.diag
    :caption: MCPWM Overview
    :align: center

- **MCPWM Timer**: The time base of the final PWM signal. It also determines the event timing of other submodules.
- **MCPWM Operator**: The key module that i"
"s responsible for generating the PWM waveforms. It consists of other submodules, like comparator, PWM generator, dead time, and carrier modulator.
- **MCPWM Comparator**: The compare module takes the time-base count value as input, and continuously compares it to the threshold value configured. When the timer is equal to any of the threshold values, a compare event will be generated and the MCPWM generator can update its level accordingly.
- **MCPWM Generator**: One MCPWM generator can generate "
"a pair of PWM waves, complementarily or independently, based on various events triggered by other submodules like MCPWM Timer and MCPWM Comparator.
- **MCPWM Fault**: The fault module is used to detect the fault condition from outside, mainly via the GPIO matrix. Once the fault signal is active, MCPWM Operator will force all the generators into a predefined state to protect the system from damage.
- **MCPWM Sync**: The sync module is used to synchronize the MCPWM timers, so that the final PWM si"
"gnals generated by different MCPWM generators can have a fixed phase difference. The sync signal can be routed from the GPIO matrix or from an MCPWM Timer event.
- **Dead Time**: This submodule is used to insert extra delay to the existing PWM edges generated in the previous steps.
- **Carrier Modulation**: The carrier submodule can modulate a high-frequency carrier signal into PWM waveforms by the generator and dead time submodules. This capability is mandatory for controlling the power-switchi"
"ng elements.
- **Brake**: MCPWM operator can set how to brake the generators when a particular fault is detected. You can shut down the PWM output immediately or regulate the PWM output cycle by cycle, depending on how critical the fault is.
- **MCPWM Capture**: This is a standalone submodule that can work even without the above MCPWM operators. The capture consists one dedicated timer and several independent channels, with each channel connected to the GPIO. A pulse on the GPIO triggers the cap"
"ture timer to store the time-base count value and then notify you by an interrupt. Using this feature, you can measure a pulse width precisely. What is more, the capture timer can also be synchronized by the MCPWM Sync submodule.

Functional Overview


Description of the MCPWM functionality is divided into the following sections:

.. list::

    - :ref:`mcpwm-resource-allocation-and-initialization` - covers how to allocate various MCPWM objects, like timers, operators, comparators, generators an"
"d so on. These objects are the basis of the following IO setting and control functions.
    - :ref:`mcpwm-timer-operations-and-events` - describes control functions and event callbacks supported by the MCPWM timer.
    - :ref:`mcpwm-comparator-operations-and-events` - describes control functions and event callbacks supported by the MCPWM comparator.
    - :ref:`mcpwm-generator-actions-on-events` - describes how to set actions for MCPWM generators on particular events that are generated by the MC"
"PWM timer and comparators.
    - :ref:`mcpwm-classical-pwm-waveforms-and-generator-configurations` - demonstrates some classical PWM waveforms that can be achieved by configuring generator actions.
    - :ref:`mcpwm-dead-time` - describes how to set dead time for MCPWM generators.
    - :ref:`mcpwm-classical-pwm-waveforms-and-dead-time-configurations` - demonstrates some classical PWM waveforms that can be achieved by configuring dead time.
    - :ref:`mcpwm-carrier-modulation` - describes how t"
"o set and modulate a high frequency onto the final PWM waveforms.
    - :ref:`mcpwm-faults-and-brake-actions` - describes how to set brake actions for MCPWM operators on particular fault events.
    - :ref:`mcpwm-generator-force-actions` - describes how to control the generator output level asynchronously in a forceful way.
    - :ref:`mcpwm-synchronization` - describes how to synchronize the MCPWM timers and get a fixed phase difference between the generated PWM signals.
    - :ref:`mcpwm-captu"
"re` - describes how to use the MCPWM capture module to measure the pulse width of a signal.
    :SOC_MCPWM_SUPPORT_ETM: - :ref:`mcpwm-etm-event-and-task` - describes what the events and tasks can be connected to the ETM channel.
    - :ref:`mcpwm-power-management` - describes how different source clocks affects power consumption.
    - :ref:`mcpwm-iram-safe` - describes tips on how to make the RMT interrupt work better along with a disabled cache.
    - :ref:`mcpwm-thread-safety` - lists which A"
"PIs are guaranteed to be thread-safe by the driver.
    - :ref:`mcpwm-kconfig-options` - lists the supported Kconfig options that can bring different effects to the driver.

.. _mcpwm-resource-allocation-and-initialization:

Resource Allocation and Initialization


As displayed in the diagram above, the MCPWM peripheral consists of several submodules. Each submodule has its own resource allocation, which is described in the following sections.

MCPWM Timers
~~~~~~~~~~~~

You can allocate a MCPWM"
" timer object by calling :cpp:func:`mcpwm_new_timer` function, with a configuration structure :cpp:type:`mcpwm_timer_config_t` as the parameter. The configuration structure is defined as:

- :cpp:member:`mcpwm_timer_config_t::group_id` specifies the MCPWM group ID. The ID should belong to [0, :c:macro:`SOC_MCPWM_GROUPS` - 1] range. Please note, timers located in different groups are totally independent.
- :cpp:member:`mcpwm_timer_config_t::intr_priority` sets the priority of the interrupt. If it"
" is set to ``0``, the driver will allocate an interrupt with a default priority. Otherwise, the driver will use the given priority.
- :cpp:member:`mcpwm_timer_config_t::clk_src` sets the clock source of the timer.
- :cpp:member:`mcpwm_timer_config_t::resolution_hz` sets the expected resolution of the timer. The driver internally sets a proper divider based on the clock source and the resolution.
- :cpp:member:`mcpwm_timer_config_t::count_mode` sets the count mode of the timer.
- :cpp:member:`mcp"
"wm_timer_config_t::period_ticks` sets the period of the timer, in ticks (the tick resolution is set in the :cpp:member:`mcpwm_timer_config_t::resolution_hz`).
- :cpp:member:`mcpwm_timer_config_t::update_period_on_empty` sets whether to update the period value when the timer counts to zero.
- :cpp:member:`mcpwm_timer_config_t::update_period_on_sync` sets whether to update the period value when the timer takes a sync signal.

The :cpp:func:`mcpwm_new_timer` will return a pointer to the allocated t"
"imer object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there are no more free timers in the MCPWM group, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

On the contrary, calling the :cpp:func:`mcpwm_del_timer` function will free the allocated timer object.

MCPWM Operators
~~~~~~~~~~~~~~~

You can allocate a MCPWM operator object by calling :cpp:func:`mcpwm_new_operator` function, with a configuration structure :cpp:type:`mcpwm"
"_operator_config_t` as the parameter. The configuration structure is defined as:

- :cpp:member:`mcpwm_operator_config_t::group_id` specifies the MCPWM group ID. The ID should belong to [0, :c:macro:`SOC_MCPWM_GROUPS` - 1] range. Please note, operators located in different groups are totally independent.
- :cpp:member:`mcpwm_operator_config_t::intr_priority` sets the priority of the interrupt. If it is set to ``0``, the driver will allocate an interrupt with a default priority. Otherwise, the dr"
"iver will use the given priority.
- :cpp:member:`mcpwm_operator_config_t::update_gen_action_on_tez` sets whether to update the generator action when the timer counts to zero. Here and below, the timer refers to the one that is connected to the operator by :cpp:func:`mcpwm_operator_connect_timer`.
- :cpp:member:`mcpwm_operator_config_t::update_gen_action_on_tep` sets whether to update the generator action when the timer counts to peak.
- :cpp:member:`mcpwm_operator_config_t::update_gen_action_on_"
"sync` sets whether to update the generator action when the timer takes a sync signal.
- :cpp:member:`mcpwm_operator_config_t::update_dead_time_on_tez` sets whether to update the dead time when the timer counts to zero.
- :cpp:member:`mcpwm_operator_config_t::update_dead_time_on_tep` sets whether to update the dead time when the timer counts to the peak.
- :cpp:member:`mcpwm_operator_config_t::update_dead_time_on_sync` sets whether to update the dead time when the timer takes a sync signal.

The "
":cpp:func:`mcpwm_new_operator` will return a pointer to the allocated operator object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there are no more free operators in the MCPWM group, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

On the contrary, calling :cpp:func:`mcpwm_del_operator` function will free the allocated operator object.

MCPWM Comparators
~~~~~~~~~~~~~~~~~

You can allocate a MCPWM comparator object by calling the"
" :cpp:func:`mcpwm_new_comparator` function, with a MCPWM operator handle and configuration structure :cpp:type:`mcpwm_comparator_config_t` as the parameter. The operator handle is created by :cpp:func:`mcpwm_new_operator`. The configuration structure is defined as:

- :cpp:member:`mcpwm_comparator_config_t::intr_priority` sets the priority of the interrupt. If it is set to ``0``, the driver will allocate an interrupt with a default priority. Otherwise, the driver will use the given priority.
- :"
"cpp:member:`mcpwm_comparator_config_t::update_cmp_on_tez` sets whether to update the compare threshold when the timer counts to zero.
- :cpp:member:`mcpwm_comparator_config_t::update_cmp_on_tep` sets whether to update the compare threshold when the timer counts to the peak.
- :cpp:member:`mcpwm_comparator_config_t::update_cmp_on_sync` sets whether to update the compare threshold when the timer takes a sync signal.

The :cpp:func:`mcpwm_new_comparator` will return a pointer to the allocated compa"
"rator object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there are no more free comparators in the MCPWM operator, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

On the contrary, calling the :cpp:func:`mcpwm_del_comparator` function will free the allocated comparator object.

.. only:: SOC_MCPWM_SUPPORT_EVENT_COMPARATOR

    There's another kind of comparator called ""Event Comparator"", which **can not** control the final PWM di"
"rectly but only generates the ETM events at a configurable time stamp. You can allocate an event comparator by calling the :cpp:func:`mcpwm_new_event_comparator` function. This function will return the same handle type as :cpp:func:`mcpwm_new_comparator`, but with a different configuration structure :cpp:type:`mcpwm_event_comparator_config_t`. For more information, please refer to :ref:`mcpwm-etm-event-and-task`.

MCPWM Generators
~~~~~~~~~~~~~~~~

You can allocate a MCPWM generator object by ca"
"lling the :cpp:func:`mcpwm_new_generator` function, with a MCPWM operator handle and configuration structure :cpp:type:`mcpwm_generator_config_t` as the parameter. The operator handle is created by :cpp:func:`mcpwm_new_operator`. The configuration structure is defined as:

- :cpp:member:`mcpwm_generator_config_t::gen_gpio_num` sets the GPIO number used by the generator.
- :cpp:member:`mcpwm_generator_config_t::invert_pwm` sets whether to invert the PWM signal.
- :cpp:member:`mcpwm_generator_conf"
"ig_t::io_loop_back` sets whether to enable the Loop-back mode. It is for debugging purposes only. It enables both the GPIO's input and output ability through the GPIO matrix peripheral.
- :cpp:member:`mcpwm_generator_config_t::io_od_mode` configures the PWM GPIO as open-drain output.
- :cpp:member:`mcpwm_generator_config_t::pull_up` and :cpp:member:`mcpwm_generator_config_t::pull_down` controls whether to enable the internal pull-up and pull-down resistors accordingly.

The :cpp:func:`mcpwm_new_"
"generator` will return a pointer to the allocated generator object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there are no more free generators in the MCPWM operator, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

On the contrary, calling the :cpp:func:`mcpwm_del_generator` function will free the allocated generator object.

MCPWM Faults
~~~~~~~~~~~~

There are two types of faults: A fault signal reflected from the GPIO and a "
"fault generated by software.

To allocate a GPIO fault object, you can call the :cpp:func:`mcpwm_new_gpio_fault` function, with the configuration structure :cpp:type:`mcpwm_gpio_fault_config_t` as the parameter. The configuration structure is defined as:

- :cpp:member:`mcpwm_gpio_fault_config_t::group_id` sets the MCPWM group ID. The ID should belong to [0, :c:macro:`SOC_MCPWM_GROUPS` - 1] range. Please note, GPIO faults located in different groups are totally independent, i.e., GPIO faults in "
"group 0 can not be detected by the operator in group 1.
- :cpp:member:`mcpwm_gpio_fault_config_t::intr_priority` sets the priority of the interrupt. If it is set to ``0``, the driver will allocate an interrupt with a default priority. Otherwise, the driver will use the given priority.
- :cpp:member:`mcpwm_gpio_fault_config_t::gpio_num` sets the GPIO number used by the fault.
- :cpp:member:`mcpwm_gpio_fault_config_t::active_level` sets the active level of the fault signal.
- :cpp:member:`mcpwm_gp"
"io_fault_config_t::pull_up` and :cpp:member:`mcpwm_gpio_fault_config_t::pull_down` set whether to pull up and/or pull down the GPIO internally.
- :cpp:member:`mcpwm_gpio_fault_config_t::io_loop_back` sets whether to enable the loopback mode. It is for debugging purposes only. It enables both the GPIO's input and output ability through the GPIO matrix peripheral.

The :cpp:func:`mcpwm_new_gpio_fault` will return a pointer to the allocated fault object if the allocation succeeds. Otherwise, it wil"
"l return an error code. Specifically, when there are no more free GPIO faults in the MCPWM group, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

Software fault object can be used to trigger a fault by calling the function :cpp:func:`mcpwm_soft_fault_activate` instead of waiting for a real fault signal on the GPIO. A software fault object can be allocated by calling the  :cpp:func:`mcpwm_new_soft_fault` function, with configuration structure :cpp:type:`mcpwm_soft_fault_co"
"nfig_t` as the parameter. Currently, this configuration structure is left for future purposes.

The :cpp:func:`mcpwm_new_soft_fault` function will return a pointer to the allocated fault object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there is no memory left for the fault object, this function will return the :c:macro:`ESP_ERR_NO_MEM` error. Although the software fault and GPIO fault are of different types, the returned fault handle is of the same t"
"ype.

On the contrary, calling the :cpp:func:`mcpwm_del_fault` function will free the allocated fault object, this function works for both software and GPIO fault.

MCPWM Sync Sources
~~~~~~~~~~~~~~~~~~

The sync source is what can be used to synchronize the MCPWM timer and MCPWM capture timer. There are three types of sync sources: a sync source reflected from the GPIO, a sync source generated by software, and a sync source generated by an MCPWM timer event.

To allocate a GPIO sync source, you"
" can call the :cpp:func:`mcpwm_new_gpio_sync_src` function, with configuration structure :cpp:type:`mcpwm_gpio_sync_src_config_t` as the parameter. The configuration structure is defined as:

- :cpp:member:`mcpwm_gpio_sync_src_config_t::group_id` sets the MCPWM group ID. The ID should belong to [0, :c:macro:`SOC_MCPWM_GROUPS` - 1] range. Please note, the GPIO sync sources located in different groups are totally independent, i.e., GPIO sync source in group 0 can not be detected by the timers in g"
"roup 1.
- :cpp:member:`mcpwm_gpio_sync_src_config_t::gpio_num` sets the GPIO number used by the sync source.
- :cpp:member:`mcpwm_gpio_sync_src_config_t::active_neg` sets whether the sync signal is active on falling edges.
- :cpp:member:`mcpwm_gpio_sync_src_config_t::pull_up` and :cpp:member:`mcpwm_gpio_sync_src_config_t::pull_down` set whether to pull up and/or pull down the GPIO internally.
- :cpp:member:`mcpwm_gpio_sync_src_config_t::io_loop_back` sets whether to enable the Loop-back mode. It"
" is for debugging purposes only. It enables both the GPIO's input and output ability through the GPIO matrix peripheral.

The :cpp:func:`mcpwm_new_gpio_sync_src` will return a pointer to the allocated sync source object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there are no more free GPIO sync sources in the MCPWM group, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

To allocate a timer event sync source, you can call the  :c"
"pp:func:`mcpwm_new_timer_sync_src` function, with configuration structure :cpp:type:`mcpwm_timer_sync_src_config_t` as the parameter. The configuration structure is defined as:

- :cpp:member:`mcpwm_timer_sync_src_config_t::timer_event` specifies on what timer event to generate the sync signal.
- :cpp:member:`mcpwm_timer_sync_src_config_t::propagate_input_sync` sets whether to propagate the input sync signal (i.e., the input sync signal will be routed to its sync output).

The :cpp:func:`mcpwm_n"
"ew_timer_sync_src` will return a pointer to the allocated sync source object if the allocation succeeds. Otherwise, it will return an error code. Specifically, if a sync source has been allocated from the same timer before, this function will return the :c:macro:`ESP_ERR_INVALID_STATE` error.

Last but not least, to allocate a software sync source, you can call the :cpp:func:`mcpwm_new_soft_sync_src` function, with configuration structure :cpp:type:`mcpwm_soft_sync_config_t` as the parameter. Cu"
"rrently, this configuration structure is left for future purposes.

:cpp:func:`mcpwm_new_soft_sync_src` will return a pointer to the allocated sync source object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there is no memory left for the sync source object, this function will return the :c:macro:`ESP_ERR_NO_MEM` error. Please note, to make a software sync source take effect, do not forget to call :cpp:func:`mcpwm_soft_sync_activate`.

On the contrary, "
"calling the :cpp:func:`mcpwm_del_sync_src` function will free the allocated sync source object. This function works for all types of sync sources.

MCPWM Capture Timer and Channels
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The MCPWM group has a dedicated timer which is used to capture the timestamp when a specific event occurred. The capture timer is connected to several independent channels, each channel is assigned a GPIO.

To allocate a capture timer, you can call the :cpp:func:`mcpwm_new_capture_tim"
"er` function, with configuration structure :cpp:type:`mcpwm_capture_timer_config_t` as the parameter. The configuration structure is defined as:

- :cpp:member:`mcpwm_capture_timer_config_t::group_id` sets the MCPWM group ID. The ID should belong to [0, :c:macro:`SOC_MCPWM_GROUPS` - 1] range.
- :cpp:member:`mcpwm_capture_timer_config_t::clk_src` sets the clock source of the capture timer.
- :cpp:member:`mcpwm_capture_timer_config_t::resolution_hz` The driver internally will set a proper divider "
"based on the clock source and the resolution. If it is set to ``0``, the driver will pick an appropriate resolution on its own, and you can subsequently view the current timer resolution via :cpp:func:`mcpwm_capture_timer_get_resolution`.

.. only:: not SOC_MCPWM_CAPTURE_CLK_FROM_GROUP

    .. note::

        In {IDF_TARGET_NAME}, :cpp:member:`mcpwm_capture_timer_config_t::resolution_hz` parameter is invalid, the capture timer resolution is always equal to the :cpp:enumerator:`MCPWM_CAPTURE_CLK_"
"SRC_APB`.

The :cpp:func:`mcpwm_new_capture_timer` will return a pointer to the allocated capture timer object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there is no free capture timer left in the MCPWM group, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

Next, to allocate a capture channel, you can call the :cpp:func:`mcpwm_new_capture_channel` function, with a capture timer handle and configuration structure :cpp:type:`mcpw"
"m_capture_channel_config_t` as the parameter. The configuration structure is defined as:

- :cpp:member:`mcpwm_capture_channel_config_t::intr_priority` sets the priority of the interrupt. If it is set to ``0``, the driver will allocate an interrupt with a default priority. Otherwise, the driver will use the given priority.
- :cpp:member:`mcpwm_capture_channel_config_t::gpio_num` sets the GPIO number used by the capture channel.
- :cpp:member:`mcpwm_capture_channel_config_t::prescale` sets the pr"
"escaler of the input signal.
- :cpp:member:`mcpwm_capture_channel_config_t::extra_flags::pos_edge` and :cpp:member:`mcpwm_capture_channel_config_t::extra_flags::neg_edge` set whether to capture on the positive and/or falling edge of the input signal.
- :cpp:member:`mcpwm_capture_channel_config_t::extra_flags::pull_up` and :cpp:member:`mcpwm_capture_channel_config_t::extra_flags::pull_down` set whether to pull up and/or pull down the GPIO internally.
- :cpp:member:`mcpwm_capture_channel_config_t:"
":extra_flags::invert_cap_signal` sets whether to invert the capture signal.
- :cpp:member:`mcpwm_capture_channel_config_t::extra_flags::io_loop_back` sets whether to enable the Loop-back mode. It is for debugging purposes only. It enables both the GPIO's input and output ability through the GPIO matrix peripheral.
- :cpp:member:`mcpwm_capture_channel_config_t::extra_flags::keep_io_conf_at_exit` sets whether to keep the GPIO configuration when the capture channel is deleted.

The :cpp:func:`mcpwm"
"_new_capture_channel` will return a pointer to the allocated capture channel object if the allocation succeeds. Otherwise, it will return an error code. Specifically, when there is no free capture channel left in the capture timer, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error.

On the contrary, calling :cpp:func:`mcpwm_del_capture_channel` and :cpp:func:`mcpwm_del_capture_timer` will free the allocated capture channel and timer object accordingly.

MCPWM Interrupt Priority
~~"
"~~~~~~~~~~~~~~~~~~~~~~

MCPWM allows configuring interrupts separately for timer, operator, comparator, fault, and capture events. The interrupt priority is determined by the respective ``config_t::intr_priority``. Additionally, events within the same MCPWM group share a common interrupt source. When registering multiple interrupt events, the interrupt priorities need to remain consistent.

.. note::

    When registering multiple interrupt events within an MCPWM group, the driver will use the i"
"nterrupt priority of the first registered event as the MCPWM group's interrupt priority.


.. _mcpwm-timer-operations-and-events:

Timer Operations and Events


Update Period
~~~~~~~~~~~~~

The timer period is initialized by the :cpp:member:`mcpwm_timer_config_t::period_ticks` parameter in :cpp:type:`mcpwm_timer_config_t`. You can update the period at runtime by calling :cpp:func:`mcpwm_timer_set_period` function. The new period will take effect based on how you set the :cpp:member:`mcpwm_timer_"
"config_t::update_period_on_empty` and :cpp:member:`mcpwm_timer_config_t::update_period_on_sync` parameters in :cpp:type:`mcpwm_timer_config_t`. If none of them are set, the timer period will take effect immediately.

Register Timer Event Callbacks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The MCPWM timer can generate different events at runtime. If you have some function that should be called when a particular event happens, you should hook your function to the interrupt service routine by calling :cpp:fu"
"nc:`mcpwm_timer_register_event_callbacks`. The callback function prototype is declared in :cpp:type:`mcpwm_timer_event_cb_t`. All supported event callbacks are listed in the :cpp:type:`mcpwm_timer_event_callbacks_t`:

- :cpp:member:`mcpwm_timer_event_callbacks_t::on_full` sets the callback function for the timer when it counts to peak value.
- :cpp:member:`mcpwm_timer_event_callbacks_t::on_empty` sets the callback function for the timer when it counts to zero.
- :cpp:member:`mcpwm_timer_event_ca"
"llbacks_t::on_stop` sets the callback function for the timer when it is stopped.

The callback functions above are called within the ISR context, so they should **not** attempt to block. For example, you may make sure that only FreeRTOS APIs with the ``ISR`` suffix are called within the function.

The parameter ``user_data`` of the :cpp:func:`mcpwm_timer_register_event_callbacks` function is used to save your own context. It is passed to each callback function directly.

This function will lazy "
"the install interrupt service for the MCPWM timer without enabling it. It is only allowed to be called before :cpp:func:`mcpwm_timer_enable`, otherwise the :c:macro:`ESP_ERR_INVALID_STATE` error will be returned. See also `Enable and Disable timer `__ for more information.

Enable and Disable Timer
~~~~~~~~~~~~~~~~~~~~~~~~

Before doing IO control to the timer, you need to enable the timer first, by calling :cpp:func:`mcpwm_timer_enable`.  This function:

On the contrary, calling :cpp:func:`mcpw"
"m_timer_disable` will put the timer driver back to the **init** state, disable the interrupt service and release the power management lock.

Start and Stop Timer
~~~~~~~~~~~~~~~~~~~~

The basic IO operation of a timer is to start and stop. Calling :cpp:func:`mcpwm_timer_start_stop` with different :cpp:type:`mcpwm_timer_start_stop_cmd_t` commands can start the timer immediately or stop the timer at a specific event. What is more, you can even start the timer for only one round, which means, the t"
"imer will count to peak value or zero, and then stop itself.

Connect Timer with Operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The allocated MCPWM timer should be connected with an MCPWM operator by calling :cpp:func:`mcpwm_operator_connect_timer`, so that the operator can take that timer as its time base, and generate the required PWM waves. Please make sure the MCPWM timer and operator are in the same group. Otherwise, this function will return the :c:macro:`ESP_ERR_INVALID_ARG` error.


.. _mcpwm-com"
"parator-operations-and-events:

Comparator Operations and Events


Register Comparator Event Callbacks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The MCPWM comparator can inform you when the timer counter equals the compare value. If you have some function that should be called when this event happens, you should hook your function to the interrupt service routine by calling :cpp:func:`mcpwm_comparator_register_event_callbacks`. The callback function prototype is declared in :cpp:type:`mcpwm_compare_e"
"vent_cb_t`. All supported event callbacks are listed in the :cpp:type:`mcpwm_comparator_event_callbacks_t`:

- :cpp:member:`mcpwm_comparator_event_callbacks_t::on_reach` sets the callback function for the comparator when the timer counter equals the compare value.

The callback function provides event-specific data of type :cpp:type:`mcpwm_compare_event_data_t` to you. The callback function is called within the ISR context, so it should **not** attempt to block. For example, you may make sure th"
"at only FreeRTOS APIs with the ``ISR`` suffix are called within the function.

The parameter ``user_data`` of :cpp:func:`mcpwm_comparator_register_event_callbacks` function is used to save your own context. It is passed to the callback function directly.

This function will lazy the installation of interrupt service for the MCPWM comparator, whereas the service can only be removed in :cpp:type:`mcpwm_del_comparator`.

.. only:: SOC_MCPWM_SUPPORT_EVENT_COMPARATOR

    .. note::

        It is not"
" supported to register event callbacks for an **Event Comparator** because it can not generate any interrupt.

Set Compare Value
~~~~~~~~~~~~~~~~~

You can set the compare value for the MCPWM comparator at runtime by calling :cpp:func:`mcpwm_comparator_set_compare_value`. There are a few points to note:

- A new compare value might not take effect immediately. The update time for the compare value is set by :cpp:member:`mcpwm_comparator_config_t::update_cmp_on_tez` or :cpp:member:`mcpwm_comparat"
"or_config_t::update_cmp_on_tep` or :cpp:member:`mcpwm_comparator_config_t::update_cmp_on_sync`.
- Make sure the operator has connected to one MCPWM timer already by :cpp:func:`mcpwm_operator_connect_timer`. Otherwise, it will return the error code :c:macro:`ESP_ERR_INVALID_STATE`.
- The compare value should not exceed the timer's count peak, otherwise, the compare event will never get triggered.


.. _mcpwm-generator-actions-on-events:

Generator Actions on Events


Set Generator Action on Timer"
" Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One generator can set multiple actions on different timer events, by calling :cpp:func:`mcpwm_generator_set_actions_on_timer_event` with a variable number of action configurations. The action configuration is defined in :cpp:type:`mcpwm_gen_timer_event_action_t`:

- :cpp:member:`mcpwm_gen_timer_event_action_t::direction` specifies the timer direction. The supported directions are listed in :cpp:type:`mcpwm_timer_direction_t`.
- :cpp:member:`mcpwm_gen_t"
"imer_event_action_t::event` specifies the timer event. The supported timer events are listed in :cpp:type:`mcpwm_timer_event_t`.
- :cpp:member:`mcpwm_gen_timer_event_action_t::action` specifies the generator action to be taken. The supported actions are listed in :cpp:type:`mcpwm_generator_action_t`.

There is a helper macro :c:macro:`MCPWM_GEN_TIMER_EVENT_ACTION` to simplify the construction of a timer event action entry.

Please note, the argument list of :cpp:func:`mcpwm_generator_set_actions"
"_on_timer_event` **must** be terminated by :c:macro:`MCPWM_GEN_TIMER_EVENT_ACTION_END`.

You can also set the timer action one by one by calling :cpp:func:`mcpwm_generator_set_action_on_timer_event` without varargs.

Set Generator Action on Compare Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One generator can set multiple actions on different compare events, by calling :cpp:func:`mcpwm_generator_set_actions_on_compare_event` with a variable number of action configurations. The action configurat"
"ion is defined in :cpp:type:`mcpwm_gen_compare_event_action_t`:

- :cpp:member:`mcpwm_gen_compare_event_action_t::direction` specifies the timer direction. The supported directions are listed in :cpp:type:`mcpwm_timer_direction_t`.
- :cpp:member:`mcpwm_gen_compare_event_action_t::comparator` specifies the comparator handle. See `MCPWM Comparators `__ for how to allocate a comparator.
- :cpp:member:`mcpwm_gen_compare_event_action_t::action` specifies the generator action to be taken. The supporte"
"d actions are listed in :cpp:type:`mcpwm_generator_action_t`.

There is a helper macro :c:macro:`MCPWM_GEN_COMPARE_EVENT_ACTION` to simplify the construction of a compare event action entry.

Please note, the argument list of :cpp:func:`mcpwm_generator_set_actions_on_compare_event` **must** be terminated by :c:macro:`MCPWM_GEN_COMPARE_EVENT_ACTION_END`.

You can also set the compare action one by one by calling :cpp:func:`mcpwm_generator_set_action_on_compare_event` without varargs.

Set Generat"
"or Action on Fault Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One generator can set action on fault based trigger events, by calling :cpp:func:`mcpwm_generator_set_action_on_fault_event` with an action configurations. The action configuration is defined in :cpp:type:`mcpwm_gen_fault_event_action_t`:

- :cpp:member:`mcpwm_gen_fault_event_action_t::direction` specifies the timer direction. The supported directions are listed in :cpp:type:`mcpwm_timer_direction_t`.
- :cpp:member:`mcpwm_gen_fault_ev"
"ent_action_t::fault` specifies the fault used for the trigger. See `MCPWM Faults `__ for how to allocate a fault.
- :cpp:member:`mcpwm_gen_fault_event_action_t::action` specifies the generator action to be taken. The supported actions are listed in :cpp:type:`mcpwm_generator_action_t`.

When no free trigger slot is left in the operator to which the generator belongs, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

The trigger only support GPIO fault. when the input is not"
" a GPIO fault, this function will return the :c:macro:`ESP_ERR_NOT_SUPPORTED` error.

There is a helper macro :c:macro:`MCPWM_GEN_FAULT_EVENT_ACTION` to simplify the construction of a trigger event action entry.

Please note, fault event does not have variadic function like :cpp:func:`mcpwm_generator_set_actions_on_fault_event`.

Set Generator Action on Sync Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One generator can set action on sync based trigger events, by calling :cpp:func:`mcpwm_generator_"
"set_action_on_sync_event` with an action configurations. The action configuration is defined in :cpp:type:`mcpwm_gen_sync_event_action_t`:

- :cpp:member:`mcpwm_gen_sync_event_action_t::direction` specifies the timer direction. The supported directions are listed in :cpp:type:`mcpwm_timer_direction_t`.
- :cpp:member:`mcpwm_gen_sync_event_action_t::sync` specifies the sync source used for the trigger. See `MCPWM Sync Sources  `__ for how to allocate a sync source.
- :cpp:member:`mcpwm_gen_sync_ev"
"ent_action_t::action` specifies the generator action to be taken. The supported actions are listed in :cpp:type:`mcpwm_generator_action_t`.

When no free trigger slot is left in the operator to which the generator belongs, this function will return the :c:macro:`ESP_ERR_NOT_FOUND` error. [1]_

The trigger only support one sync action, regardless of the kinds. When set sync actions more than once, this function will return the :c:macro:`ESP_ERR_INVALID_STATE` error.

There is a helper macro :c:ma"
"cro:`MCPWM_GEN_SYNC_EVENT_ACTION` to simplify the construction of a trigger event action entry.

Please note, sync event does not have variadic function like :cpp:func:`mcpwm_generator_set_actions_on_sync_event`.


.. _mcpwm-classical-pwm-waveforms-and-generator-configurations:

Generator Configurations for Classical PWM Waveforms


This section will demonstrate the classical PWM waveforms that can be generated by the pair of generators. The code snippet that is used to generate the waveforms is"
" also provided below the diagram. Some general summary:

- The **Symmetric** or **Asymmetric** of the waveforms is determined by the count mode of the MCPWM timer.
- The **active level** of the waveform pair is determined by the level of the PWM with a smaller duty cycle.
- The period of the PWM waveform is determined by the timer's period and count mode.
- The duty cycle of the PWM waveform is determined by the generator's various action combinations.

Single Edge Asymmetric Waveform - Active H"
"igh
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/single_edge_asym_active_high.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERRO"
"R_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                        MCPWM_GEN_COMPARE_EVENT_ACTION"
"(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
    }

Single Edge Asymmetric Waveform - Active Low
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/single_edge_asym_active_low.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EV"
"ENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_FULL, MCPWM_GEN_ACTION_LOW)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_FULL, MCPWM_GEN_ACTION_LOW)));
        ESP_ERROR_CHECK(mcp"
"wm_generator_set_action_on_compare_event(genb,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_HIGH)));
    }

Pulse Placement Asymmetric Waveform
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/pulse_placement_asym.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generat"
"or_set_actions_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW),
                        MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
        ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_timer_event(genb,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, "
"MCPWM_GEN_ACTION_TOGGLE),
                        MCPWM_GEN_TIMER_EVENT_ACTION_END()));
    }

Dual Edge Asymmetric Waveform - Active Low
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/dual_edge_asym_active_low.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(gena,
               "
"         MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpb, MCPWM_GEN_ACTION_LOW),
                        MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
        ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_timer_event(genb,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_LOW),
                        MCPW"
"M_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, MCPWM_TIMER_EVENT_FULL, MCPWM_GEN_ACTION_HIGH),
                        MCPWM_GEN_TIMER_EVENT_ACTION_END()));
    }

Dual Edge Symmetric Waveform - Active Low
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/dual_edge_sym_active_low.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_"
"CHECK(mcpwm_generator_set_actions_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpa, MCPWM_GEN_ACTION_LOW),
                        MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
        ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(genb,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, "
"cmpb, MCPWM_GEN_ACTION_HIGH),
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpb, MCPWM_GEN_ACTION_LOW),
                        MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
    }

Dual Edge Symmetric Waveform - Complementary
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/dual_edge_sym_complementary.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa"
", mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpa, MCPWM_GEN_ACTION_LOW),
                        MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
        ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(genb,
                        MCPWM"
"_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW),
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpb, MCPWM_GEN_ACTION_HIGH),
                        MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
    }


.. _mcpwm-dead-time:

Dead Time


In power electronics, the rectifier and inverter are commonly used. This requires the use of a rectifier bridge and an inverter bridge. Each bridge arm has two power electronic devices, such as MOSFET"
", IGBT, etc. The two MOSFETs on the same arm can not conduct at the same time, otherwise there will be a short circuit. The fact is that, although the PWM wave shows it is turning off the switch, the MOSFET still needs a small time window to make that happen. This requires an extra delay to be added to the existing PWM wave generated by setting `Generator Actions on Events `__.

The dead time driver works like a **decorator**. This is also reflected in the function parameters of :cpp:func:`mcpwm"
"_generator_set_dead_time`, where it takes the primary generator handle (``in_generator``), and returns a new generator (``out_generator``) after applying the dead time. Please note, if the ``out_generator`` and ``in_generator`` are the same, it means you are adding the time delay to the PWM waveform in an ""in-place"" fashion. In turn, if the ``out_generator`` and ``in_generator`` are different, it means you are deriving a new PWM waveform from the existing ``in_generator``.

Dead time specific co"
"nfiguration is listed in the :cpp:type:`mcpwm_dead_time_config_t` structure:

- :cpp:member:`mcpwm_dead_time_config_t::posedge_delay_ticks` and :cpp:member:`mcpwm_dead_time_config_t::negedge_delay_ticks` set the number of ticks to delay the PWM waveform on the rising and falling edge. Specifically, setting both of them to zero means bypassing the dead time module. The resolution of the dead time tick is the same as the timer that is connected with the operator by :cpp:func:`mcpwm_operator_connec"
"t_timer`.
- :cpp:member:`mcpwm_dead_time_config_t::invert_output` sets whether to invert the signal after applying the dead time, which can be used to control the delay edge polarity.

.. warning::

    Due to the hardware limitation, one delay module (either ``posedge delay`` or ``negedge delay``) can not be applied to multiple MCPWM generators at the same time. e.g., the following configuration is **invalid**:

    .. code:: c

        mcpwm_dead_time_config_t dt_config = {
            .posedg"
"e_delay_ticks = 10,
        };
        // Set posedge delay to generator A
        mcpwm_generator_set_dead_time(mcpwm_gen_a, mcpwm_gen_a, &dt_config);
        // NOTE: This is invalid, you can not apply the posedge delay to another generator
        mcpwm_generator_set_dead_time(mcpwm_gen_b, mcpwm_gen_b, &dt_config);

    However, you can apply ``posedge delay`` to generator A and ``negedge delay`` to generator B. You can also set both ``posedge delay`` and ``negedge delay`` for generator A, wh"
"ile letting generator B bypass the dead time module.

.. note::

    It is also possible to generate the required dead time by setting `Generator Actions on Events `__, especially by controlling edge placement using different comparators. However, if the more classical edge delay-based dead time with polarity control is required, then the dead time submodule should be used.


.. _mcpwm-classical-pwm-waveforms-and-dead-time-configurations:

Dead Time Configurations for Classical PWM Waveforms


T"
"his section demonstrates the classical PWM waveforms that can be generated by the dead time submodule. The code snippet that is used to generate the waveforms is also provided below the diagram.

Active High Complementary
~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/deadtime_active_high_complementary.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ER"
"ROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
    }

    static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
    {
        mcpwm_dead_time_config"
"_t dead_time_config = {
            .posedge_delay_ticks = 50,
            .negedge_delay_ticks = 0
        };
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &dead_time_config));
        dead_time_config.posedge_delay_ticks = 0;
        dead_time_config.negedge_delay_ticks = 100;
        dead_time_config.flags.invert_output = true;
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &dead_time_config));
    }

Active Low Complementary
~~~~~~~~~~~~~~~~~~~~~~~~

.."
" wavedrom:: /../_static/diagrams/mcpwm/deadtime_active_low_complementary.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_ev"
"ent(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
    }

    static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
    {
        mcpwm_dead_time_config_t dead_time_config = {
            .posedge_delay_ticks = 50,
            .negedge_delay_ticks = 0,
            .flags.invert_output = true
        };
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &dead_time_config));
        dead_"
"time_config.posedge_delay_ticks = 0;
        dead_time_config.negedge_delay_ticks = 100;
        dead_time_config.flags.invert_output = false;
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &dead_time_config));
    }

Active High
~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/deadtime_active_high.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERR"
"OR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
    }

    static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
    {
        mcpwm_dead_time_config_"
"t dead_time_config = {
            .posedge_delay_ticks = 50,
            .negedge_delay_ticks = 0,
        };
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &dead_time_config));
        dead_time_config.posedge_delay_ticks = 0;
        dead_time_config.negedge_delay_ticks = 100;
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &dead_time_config));
    }

Active Low
~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/deadtime_active_low.json

.. code:: c

   "
" static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa"
", MCPWM_GEN_ACTION_LOW)));
    }

    static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
    {
        mcpwm_dead_time_config_t dead_time_config = {
            .posedge_delay_ticks = 50,
            .negedge_delay_ticks = 0,
            .flags.invert_output = true
        };
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &dead_time_config));
        dead_time_config.posedge_delay_ticks = 0;
        dead_time_config.negedge_delay_ticks = 100;
      "
"  ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &dead_time_config));
    }

Rising Delay on PWMA and Bypass Dead Time for PWMB
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/deadtime_reda_bypassb.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
             "
"           MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH"
")));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
    }

    static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
    {
        mcpwm_dead_time_config_t dead_time_config = {
            .posedge_delay_ticks = 50,
            .negedge_delay_ticks = 0,
        };
        // apply deadtime to generator_a
        ESP_ERROR_CHECK(mcpwm_"
"generator_set_dead_time(gena, gena, &dead_time_config));
        // bypass deadtime module for generator_b
        dead_time_config.posedge_delay_ticks = 0;
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(genb, genb, &dead_time_config));
    }

Falling Delay on PWMB and Bypass Dead Time for PWMA
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/deadtime_fedb_bypassa.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcp"
"wm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
        ESP_ERROR_CHECK(mcpwm_ge"
"nerator_set_action_on_timer_event(genb,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
    }

    static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
    {
        mcpwm_dead_time_config_t dead_time_confi"
"g = {
            .posedge_delay_ticks = 0,
            .negedge_delay_ticks = 0,
        };
        // generator_a bypass the deadtime module (no delay)
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &dead_time_config));
        // apply dead time to generator_b
        dead_time_config.negedge_delay_ticks = 50;
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(genb, genb, &dead_time_config));

    }

Rising and Falling Delay on PWMB and Bypass Dead Time for PWMA
~~~~~~~~"
"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. wavedrom:: /../_static/diagrams/mcpwm/deadtime_redb_fedb_bypassa.json

.. code:: c

    static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
    {
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_E"
"RROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
        ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                        MCPWM_GEN_COMPARE_EVENT_ACT"
"ION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
    }

    static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
    {
        mcpwm_dead_time_config_t dead_time_config = {
            .posedge_delay_ticks = 0,
            .negedge_delay_ticks = 0,
        };
        // generator_a bypass the deadtime module (no delay)
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &dead_time_config));
        // apply dead time on both edge for generator_"
"b
        dead_time_config.negedge_delay_ticks = 50;
        dead_time_config.posedge_delay_ticks = 50;
        ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(genb, genb, &dead_time_config));
    }


.. _mcpwm-carrier-modulation:

Carrier Modulation


The MCPWM operator has a carrier submodule that can be used if galvanic isolation from the motor driver is required (e.g., isolated digital power application) by passing the PWM output signals through transformers. Any of the PWM output signals may "
"be at 100% duty and not changing whenever a motor is required to run steadily at the full load. Coupling with non-alternating signals with a transformer is problematic, so the signals are modulated by the carrier submodule to create an AC waveform, to make the coupling possible.

To configure the carrier submodule, you can call :cpp:func:`mcpwm_operator_apply_carrier`, and provide configuration structure :cpp:type:`mcpwm_carrier_config_t`:

- :cpp:member:`mcpwm_carrier_config_t::clk_src` sets th"
"e clock source of the carrier.
- :cpp:member:`mcpwm_carrier_config_t::frequency_hz` indicates carrier frequency in Hz.
- :cpp:member:`mcpwm_carrier_config_t::duty_cycle` indicates the duty cycle of the carrier. Note that, the supported choices of the duty cycle are discrete, the driver searches for the nearest one based on your configuration.
- :cpp:member:`mcpwm_carrier_config_t::first_pulse_duration_us` indicates the duration of the first pulse in microseconds. The resolution of the first puls"
"e duration is determined by the carrier frequency you set in the :cpp:member:`mcpwm_carrier_config_t::frequency_hz`. The first pulse duration can not be zero, and it has to be at least one period of the carrier. A longer pulse width can help conduct the inductance quicker.
- :cpp:member:`mcpwm_carrier_config_t::invert_before_modulate` and :cpp:member:`mcpwm_carrier_config_t::invert_after_modulate` set whether to invert the carrier output before and after modulation.

Specifically, the carrier su"
"bmodule can be disabled by calling :cpp:func:`mcpwm_operator_apply_carrier` with a ``NULL`` configuration.


.. _mcpwm-faults-and-brake-actions:

Faults and Brake Actions


The MCPWM operator is able to sense external signals with information about the failure of the motor, the power driver or any other device connected. These failure signals are encapsulated into MCPWM fault objects.

You should determine possible failure modes of the motor and what action should be performed on detection of a "
"particular fault, e.g., drive all outputs low for a brushed motor, lock current state for a stepper motor, etc. Because of this action, the motor should be put into a safe state to reduce the likelihood of damage caused by the fault.

Set Operator Brake Mode on Fault
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The way that MCPWM operator reacts to the fault is called **Brake**. The MCPWM operator can be configured to perform different brake modes for each fault object by calling :cpp:func:`mcpwm_operator_"
"set_brake_on_fault`. Specific brake configuration is passed as a structure :cpp:type:`mcpwm_brake_config_t`:

- :cpp:member:`mcpwm_brake_config_t::fault` sets which fault the operator should react to.
- :cpp:member:`mcpwm_brake_config_t::brake_mode` sets the brake mode that should be used for the fault. The supported brake modes are listed in the :cpp:type:`mcpwm_operator_brake_mode_t`. For :cpp:enumerator:`MCPWM_OPER_BRAKE_MODE_CBC` mode, the operator recovers itself automatically as long as th"
"e fault disappears. You can specify the recovery time in :cpp:member:`mcpwm_brake_config_t::cbc_recover_on_tez` and :cpp:member:`mcpwm_brake_config_t::cbc_recover_on_tep`. For :cpp:enumerator:`MCPWM_OPER_BRAKE_MODE_OST` mode, the operator can not recover even though the fault disappears. You have to call :cpp:func:`mcpwm_operator_recover_from_fault` to manually recover it.

Set Generator Action on Brake Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One generator can set multiple actions on differen"
"t brake events, by calling :cpp:func:`mcpwm_generator_set_actions_on_brake_event` with a variable number of action configurations. The action configuration is defined in :cpp:type:`mcpwm_gen_brake_event_action_t`:

- :cpp:member:`mcpwm_gen_brake_event_action_t::direction` specifies the timer direction. The supported directions are listed in :cpp:type:`mcpwm_timer_direction_t`.
- :cpp:member:`mcpwm_gen_brake_event_action_t::brake_mode` specifies the brake mode. The supported brake modes are liste"
"d in the :cpp:type:`mcpwm_operator_brake_mode_t`.
- :cpp:member:`mcpwm_gen_brake_event_action_t::action` specifies the generator action to be taken. The supported actions are listed in :cpp:type:`mcpwm_generator_action_t`.

There is a helper macro :c:macro:`MCPWM_GEN_BRAKE_EVENT_ACTION` to simplify the construction of a brake event action entry.

Please note, the argument list of :cpp:func:`mcpwm_generator_set_actions_on_brake_event` **must** be terminated by :c:macro:`MCPWM_GEN_BRAKE_EVENT_ACTI"
"ON_END`.

You can also set the brake action one by one by calling :cpp:func:`mcpwm_generator_set_action_on_brake_event` without varargs.

Register Fault Event Callbacks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The MCPWM fault detector can inform you when it detects a valid fault or a fault signal disappears. If you have some function that should be called when such an event happens, you should hook your function to the interrupt service routine by calling :cpp:func:`mcpwm_fault_register_event_callbacks`."
" The callback function prototype is declared in :cpp:type:`mcpwm_fault_event_cb_t`. All supported event callbacks are listed in the :cpp:type:`mcpwm_fault_event_callbacks_t`:

- :cpp:member:`mcpwm_fault_event_callbacks_t::on_fault_enter` sets the callback function that will be called when a fault is detected.
- :cpp:member:`mcpwm_fault_event_callbacks_t::on_fault_exit` sets the callback function that will be called when a fault is cleared.

The callback function is called within the ISR context,"
" so it should **not** attempt to block. For example, you may make sure that only FreeRTOS APIs with the ``ISR`` suffix are called within the function.

The parameter ``user_data`` of :cpp:func:`mcpwm_fault_register_event_callbacks` function is used to save your own context. It is passed to the callback function directly.

This function will lazy the install interrupt service for the MCPWM fault, whereas the service can only be removed in :cpp:type:`mcpwm_del_fault`.

Register Brake Event Callbac"
"ks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The MCPWM operator can inform you when it is going to take a brake action. If you have some function that should be called when this event happens, you should hook your function to the interrupt service routine by calling :cpp:func:`mcpwm_operator_register_event_callbacks`. The callback function prototype is declared in :cpp:type:`mcpwm_brake_event_cb_t`. All supported event callbacks are listed in the :cpp:type:`mcpwm_operator_event_callbacks_t`:

- :cpp:membe"
"r:`mcpwm_operator_event_callbacks_t::on_brake_cbc` sets the callback function that will be called when the operator is going to take a **CBC** action.
- :cpp:member:`mcpwm_operator_event_callbacks_t::on_brake_ost` sets the callback function that will be called when the operator is going to take an **OST** action.

The callback function is called within the ISR context, so it should **not** attempt to block. For example, you may make sure that only FreeRTOS APIs with the ``ISR`` suffix are called"
" within the function.

The parameter ``user_data`` of the :cpp:func:`mcpwm_operator_register_event_callbacks` function is used to save your own context. It will be passed to the callback function directly.

This function will lazy the install interrupt service for the MCPWM operator, whereas the service can only be removed in :cpp:type:`mcpwm_del_operator`.


.. _mcpwm-generator-force-actions:

Generator Force Actions


Software can override generator output level at runtime, by calling :cpp:fun"
"c:`mcpwm_generator_set_force_level`. The software force level always has a higher priority than other event actions set in e.g., :cpp:func:`mcpwm_generator_set_actions_on_timer_event`.

- Set the ``level`` to -1 means to disable the force action, and the generator's output level will be controlled by the event actions again.
- Set the ``hold_on`` to true, and the force output level will keep alive until it is removed by assigning ``level`` to -1.
- Set the ``hole_on`` to false, the force output "
"level will only be active for a short time, and any upcoming event can override it.


.. _mcpwm-synchronization:

Synchronization


When a sync signal is taken by the MCPWM timer, the timer will be forced into a predefined **phase**, where the phase is determined by count value and count direction. You can set the sync phase by calling :cpp:func:`mcpwm_timer_set_phase_on_sync`. The sync phase configuration is defined in :cpp:type:`mcpwm_timer_sync_phase_config_t` structure:

- :cpp:member:`mcpwm"
"_timer_sync_phase_config_t::sync_src` sets the sync signal source. See `MCPWM Sync Sources `__ for how to create a sync source object. Specifically, if this is set to ``NULL``, the driver will disable the sync feature for the MCPWM timer.
- :cpp:member:`mcpwm_timer_sync_phase_config_t::count_value` sets the count value to load when the sync signal is taken.
- :cpp:member:`mcpwm_timer_sync_phase_config_t::direction` sets the count direction when the sync signal is taken.

.. note::

    When the "
"MCPWM timer is working in :cpp:enumerator:`MCPWM_TIMER_COUNT_MODE_UP_DOWN` mode, special attention needs to be taken. In this mode, counter range ``[0 -> peak-1]`` belongs to the **increment** phase, and counter range ``[peak -> 1]`` belongs to the **decrement** phase. Thus if you set the :cpp:member:`mcpwm_timer_sync_phase_config_t::count_value` to zero, you may also want to set the :cpp:member:`mcpwm_timer_sync_phase_config_t::direction` to :cpp:enumerator:`MCPWM_TIMER_DIRECTION_UP`. Otherwise"
", the timer will be continue with the decrement phase, and the count value underflows to ``peak``.

Likewise, the `MCPWM Capture Timer `__ can be synced as well. You can set the sync phase for the capture timer by calling :cpp:func:`mcpwm_capture_timer_set_phase_on_sync`. The sync phase configuration is defined in :cpp:type:`mcpwm_capture_timer_sync_phase_config_t` structure:

- :cpp:member:`mcpwm_capture_timer_sync_phase_config_t::sync_src` sets the sync signal source. See `MCPWM Sync Sources `"
"__ for how to create a sync source object. Specifically, if this is set to ``NULL``, the driver will disable the sync feature for the MCPWM capture timer.
- :cpp:member:`mcpwm_capture_timer_sync_phase_config_t::count_value` sets the count value to load when the sync signal is taken.
- :cpp:member:`mcpwm_capture_timer_sync_phase_config_t::direction` sets the count direction when the sync signal is taken. Note that, different from MCPWM Timer, the capture timer can only support one count direction"
": :cpp:enumerator:`MCPWM_TIMER_DIRECTION_UP`.

Sync Timers by GPIO
~~~~~~~~~~~~~~~~~~~

.. blockdiag::
    :caption: GPIO Sync All MCPWM Timers
    :align: center

    blockdiag {
        GPIO -> Timer0, Timer1, Timer2;
    }

.. code-block:: c

    static void example_setup_sync_strategy(mcpwm_timer_handle_t timers[])
    {
        mcpwm_sync_handle_t gpio_sync_source = NULL;
        mcpwm_gpio_sync_src_config_t gpio_sync_config = {
            .group_id = 0,              // GPIO fault should b"
"e in the same group of the above timers
            .gpio_num = EXAMPLE_SYNC_GPIO,
            .flags.pull_down = true,
            .flags.active_neg = false,  // By default, a posedge pulse can trigger a sync event
        };
        ESP_ERROR_CHECK(mcpwm_new_gpio_sync_src(&gpio_sync_config, &gpio_sync_source));

        mcpwm_timer_sync_phase_config_t sync_phase_config = {
            .count_value = 0,                      // sync phase: target count value
            .direction = MCPWM_TIMER_"
"DIRECTION_UP, // sync phase: count direction
            .sync_src = gpio_sync_source,          // sync source
        };
        for (int i = 0; i `__ for more information about resource allocation.

Register Capture Event Callbacks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The MCPWM capture channel can inform you when there is a valid edge detected on the signal. You have to register a callback function to get the timer count value of the captured moment, by calling :cpp:func:`mcpwm_capture_channel_re"
"gister_event_callbacks`. The callback function prototype is declared in :cpp:type:`mcpwm_capture_event_cb_t`. All supported capture callbacks are listed in the :cpp:type:`mcpwm_capture_event_callbacks_t`:

- :cpp:member:`mcpwm_capture_event_callbacks_t::on_cap` sets the callback function for the capture channel when a valid edge is detected.

The callback function provides event-specific data of type :cpp:type:`mcpwm_capture_event_data_t`, so that you can get the edge of the capture signal in :c"
"pp:member:`mcpwm_capture_event_data_t::cap_edge` and the count value of that moment in :cpp:member:`mcpwm_capture_event_data_t::cap_value`. To convert the capture count into a timestamp, you need to know the resolution of the capture timer by calling :cpp:func:`mcpwm_capture_timer_get_resolution`.

The callback function is called within the ISR context, so it should **not** attempt to block. For example, you may make sure that only FreeRTOS APIs with the ``ISR`` suffix are called within the func"
"tion.

The parameter ``user_data`` of :cpp:func:`mcpwm_capture_channel_register_event_callbacks` function is used to save your context. It is passed to the callback function directly.

This function will lazy install interrupt service for the MCPWM capture channel, whereas the service can only be removed in :cpp:type:`mcpwm_del_capture_channel`.

Enable and Disable Capture Channel
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The capture channel is not enabled after allocation by :cpp:func:`mcpwm_new_capt"
"ure_channel`. You should call :cpp:func:`mcpwm_capture_channel_enable` and :cpp:func:`mcpwm_capture_channel_disable` accordingly to enable or disable the channel. If the interrupt service is lazy installed during registering event callbacks for the channel in :cpp:func:`mcpwm_capture_channel_register_event_callbacks`, :cpp:func:`mcpwm_capture_channel_enable` will enable the interrupt service as well.

Enable and Disable Capture Timer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before doing IO control to t"
"he capture timer, you need to enable the timer first, by calling :cpp:func:`mcpwm_capture_timer_enable`. Internally, this function:

On the contrary, calling :cpp:func:`mcpwm_capture_timer_disable` will put the timer driver back to **init** state, and release the power management lock.

Start and Stop Capture Timer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The basic IO operation of a capture timer is to start and stop. Calling :cpp:func:`mcpwm_capture_timer_start` can start the timer and calling :cpp:func:`"
"mcpwm_capture_timer_stop` can stop the timer immediately.

Trigger a Software Capture Event
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, the software also wants to trigger a ""fake"" capture event. The :cpp:func:`mcpwm_capture_channel_trigger_soft_catch` is provided for that purpose. Please note that, even though it is a ""fake"" capture event, it can still cause an interrupt, thus your capture event callback function gets invoked as well.

.. only:: SOC_MCPWM_SUPPORT_ETM

    .. _mcpwm-etm-event-an"
"d-task:

    ETM Event and Task
    

    MCPWM comparator is able to generate events that can interact with the :doc:`ETM ` module. The supported events are listed in the :cpp:type:`mcpwm_comparator_etm_event_type_t`. You can call :cpp:func:`mcpwm_comparator_new_etm_event` to get the corresponding ETM event handle.

    For how to connect the event and task to an ETM channel, please refer to the :doc:`ETM ` documentation.

    .. _mcpwm-power-management:

.. only:: not SOC_MCPWM_SUPPORT_ETM

  "
"  .. _mcpwm-power-management:

Power Management


When power management is enabled (i.e., :ref:`CONFIG_PM_ENABLE` is on), the system will adjust the PLL and APB frequency before going into Light-sleep, thus potentially changing the period of an MCPWM timers' counting step and leading to inaccurate time-keeping.

However, the driver can prevent the system from changing APB frequency by acquiring a power management lock of type :cpp:enumerator:`ESP_PM_APB_FREQ_MAX`. Whenever the driver creates an "
"MCPWM timer instance that has selected :cpp:enumerator:`MCPWM_TIMER_CLK_SRC_PLL160M` as its clock source, the driver guarantees that the power management lock is acquired when enabling the timer by :cpp:func:`mcpwm_timer_enable`. On the contrary, the driver releases the lock when :cpp:func:`mcpwm_timer_disable` is called for that timer.

Likewise, whenever the driver creates an MCPWM capture timer instance that has selected :cpp:enumerator:`MCPWM_CAPTURE_CLK_SRC_APB` as its clock source, the dri"
"ver guarantees that the power management lock is acquired when enabling the timer by :cpp:func:`mcpwm_capture_timer_enable`. And releases the lock in  :cpp:func:`mcpwm_capture_timer_disable`.


.. _mcpwm-iram-safe:

IRAM Safe


By default, the MCPWM interrupt will be deferred when the Cache is disabled for reasons like writing/erasing Flash. Thus the event callback functions will not get executed in time, which is not expected in a real-time application.

There is a Kconfig option :ref:`CONFIG_M"
"CPWM_ISR_IRAM_SAFE` that:

This allows the interrupt to run while the cache is disabled but comes at the cost of increased IRAM consumption.

There is another Kconfig option :ref:`CONFIG_MCPWM_CTRL_FUNC_IN_IRAM` that can put commonly used IO control functions into IRAM as well. So, these functions can also be executable when the cache is disabled. The IO control function is as follows:

- :cpp:func:`mcpwm_comparator_set_compare_value`
- :cpp:func:`mcpwm_timer_set_period`


.. _mcpwm-thread-safet"
"y:

Thread Safety


The factory functions like :cpp:func:`mcpwm_new_timer` are guaranteed to be thread-safe by the driver, which means, you can call it from different RTOS tasks without protection by extra locks.

The following function is allowed to run under the ISR context, as the driver uses a critical section to prevent them from being called concurrently in the task and ISR.

- :cpp:func:`mcpwm_comparator_set_compare_value`
- :cpp:func:`mcpwm_timer_set_period`

Other functions that are not"
" related to `Resource Allocation and Initialization  `__, are not thread-safe. Thus, you should avoid calling them in different tasks without mutex protection.


.. _mcpwm-kconfig-options:

Kconfig Options


- :ref:`CONFIG_MCPWM_ISR_IRAM_SAFE` controls whether the default ISR handler can work when the cache is disabled, see :ref:`mcpwm-iram-safe` for more information.
- :ref:`CONFIG_MCPWM_CTRL_FUNC_IN_IRAM` controls where to place the MCPWM control functions (IRAM or flash), see :ref:`mcpwm-iram"
"-safe` for more information.
- :ref:`CONFIG_MCPWM_ENABLE_DEBUG_LOG` is used to enable the debug log output. Enabling this option will increase the firmware binary size.

Application Examples



API Reference


.. include-build-file:: inc/mcpwm_timer.inc
.. include-build-file:: inc/mcpwm_oper.inc
.. include-build-file:: inc/mcpwm_cmpr.inc
.. include-build-file:: inc/mcpwm_gen.inc
.. include-build-file:: inc/mcpwm_fault.inc
.. include-build-file:: inc/mcpwm_sync.inc
.. include-build-file:: inc/mcp"
"wm_cap.inc
.. include-build-file:: inc/mcpwm_etm.inc
.. include-build-file:: inc/components/esp_driver_mcpwm/include/driver/mcpwm_types.inc
.. include-build-file:: inc/components/hal/include/hal/mcpwm_types.inc


.. [1]
   Different ESP chip series might have a different number of MCPWM resources (e.g., groups, timers, comparators, operators, generators, triggers and so on). Please refer to the [`TRM `__] for details. The driver does not forbid you from applying for more MCPWM resources, but it "
"returns an error when there are no hardware resources available. Please always check the return value when doing :ref:`mcpwm-resource-allocation-and-initialization`.

.. [2]
   The callback function and the sub-functions invoked by itself should also be placed in IRAM. You need to take care of this by yourself.
"
"Analog to Digital Converter (ADC) Calibration Driver




Introduction


In {IDF_TARGET_NAME}, the digital-to-analog converter (ADC) compares the input analog voltage to the reference, and determines each bit of the output digital result. By design, the ADC reference voltage for {IDF_TARGET_NAME} is 1100 mV. However, the true reference voltage can range from 1000 mV to 1200 mV among different chips. This guide introduces the ADC calibration driver to minimize the effect of different reference vol"
"tages, and get more accurate output results.


Functional Overview


The following sections of this document cover the typical steps to install and use the ADC calibration driver:

.. list::

 - :ref:`adc-calibration-scheme-creation` - covers how to create a calibration scheme handle and delete the calibration scheme handle.
 - :ref:`adc-result-conversion` - covers how to convert ADC raw result to calibrated result.
 - :ref:`adc-thread-safety` - lists which APIs are guaranteed to be thread-safe "
"by the driver.
 - :ref:`Minimize Noise ` - describes a general way to minimize the noise.
 :esp32: - :ref:`adc-kconfig-options` - lists the supported Kconfig options that can be used to make a different effect on driver behavior.


.. _adc-calibration-scheme-creation:

Calibration Scheme Creation


The ADC calibration driver provides ADC calibration scheme(s). From the calibration driver's point of view, an ADC calibration scheme is created for an ADC calibration handle :cpp:type:`adc_cali_handl"
"e_t`.

:cpp:func:`adc_cali_check_scheme` can be used to know which calibration scheme is supported on the chip. If you already know the supported schemes, this step can be skipped. Just call the corresponding function to create the scheme handle.

If you use your custom ADC calibration schemes, you could either modify this function :cpp:func:`adc_cali_check_scheme`, or just skip this step and call your custom creation function.

.. only:: esp32 or esp32s2 or esp32c2

    ADC Calibration Line Fit"
"ting Scheme
    ```

    {IDF_TARGET_NAME} supports :c:macro:`ADC_CALI_SCHEME_VER_CURVE_FITTING` scheme. To create this scheme, set up :cpp:type:`adc_cali_curve_fitting_config_t` first.


    .. only:: esp32c3 or esp32s3

        -  :cpp:member:`adc_cali_curve_fitting_config_t::unit_id`, the ADC that your ADC raw results are from.
        -  :cpp:member:`adc_cali_curve_fitting_config_t::chan`, this member is kept here for extensibility. The calibration scheme only differs by attenuation, there i"
"s no difference among different channels.
        -  :cpp:member:`adc_cali_curve_fitting_config_t::atten`, ADC attenuation that your ADC raw results use.
        -  :cpp:member:`adc_cali_curve_fitting_config_t::bitwidth`, bit width of ADC raw result.

    .. only:: esp32c6 or esp32h2

        -  :cpp:member:`adc_cali_curve_fitting_config_t::unit_id`, the ADC that your ADC raw results are from.
        -  :cpp:member:`adc_cali_curve_fitting_config_t::chan`, the ADC channel that your ADC raw resul"
"ts are from. The calibration scheme not only differs by attenuation but is also related to the channels.
        -  :cpp:member:`adc_cali_curve_fitting_config_t::atten`, ADC attenuation that your ADC raw results use.
        -  :cpp:member:`adc_cali_curve_fitting_config_t::bitwidth`, bit width of ADC raw result.

    After setting up the configuration structure, call :cpp:func:`adc_cali_create_scheme_curve_fitting` to create a Curve Fitting calibration scheme handle. This function may fail due t"
"o reasons such as :c:macro:`ESP_ERR_INVALID_ARG` or :c:macro:`ESP_ERR_NO_MEM`.

    ADC Calibration eFuse Related Failures
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    When the function :cpp:func:`adc_cali_create_scheme_curve_fitting` returns :c:macro:`ESP_ERR_NOT_SUPPORTED`, this means the calibration scheme required eFuse bits are not correct on your board.

    The ADC calibration scheme provided by ESP-IDF is based on the values in certain ADC calibration related on-chip eFuse bits. Espre"
"ssif guarantees that these bits are burned during module manufacturing, so you don't have to burn these eFuses bits yourself.

    If you see such an error, please contact us at `Technical Inquiries `__ website.

    Create Curve Fitting Scheme
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    .. code:: c

        ESP_LOGI(TAG, ""calibration scheme version is %s"", ""Curve Fitting"");
        adc_cali_curve_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bit"
"width = ADC_BITWIDTH_DEFAULT,
        };
        ESP_ERROR_CHECK(adc_cali_create_scheme_curve_fitting(&cali_config, &handle));


    When the ADC calibration is no longer used, please delete the calibration scheme driver from the calibration handle by calling :cpp:func:`adc_cali_delete_scheme_curve_fitting`.


    Delete Curve Fitting Scheme
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    .. code:: c

        ESP_LOGI(TAG, ""delete %s calibration scheme"", ""Curve Fitting"");
        ESP_ERROR_CHECK(adc_cali_d"
"elete_scheme_curve_fitting(handle));


.. note::

    If you want to use your custom calibration schemes, you could provide a creation function to create your calibration scheme handle. Check the function table ``adc_cali_scheme_t`` in ``components/esp_adc/interface/adc_cali_interface.h`` to know the ESP ADC calibration interface.


.. _adc-result-conversion:

Result Conversion


After setting up the calibration characteristics, you can call :cpp:func:`adc_cali_raw_to_voltage` to convert the ADC"
" raw result into calibrated result. The calibrated result is in the unit of mV. This function may fail due to an invalid argument. Especially, if this function returns :c:macro:`ESP_ERR_INVALID_STATE`, this means the calibration scheme is not created. You need to create a calibration scheme handle, use :cpp:func:`adc_cali_check_scheme` to know the supported calibration scheme. On the other hand, you could also provide a custom calibration scheme and create the handle.

.. only:: esp32c2

    .. "
"note::

        ADC calibration is only supported under :c:macro:`ADC_ATTEN_DB_0` and :c:macro:`ADC_ATTEN_DB_12`. Under :c:macro:`ADC_ATTEN_DB_0`, the attenuation of ADC is set to 0 dB, and input voltage higher than 950 mV is not supported. Under :c:macro:`ADC_ATTEN_DB_12`, the attenuation of ADC is set to 11 dB, and input voltage higher than 2800 mV is not supported.

Get Voltage
~~~~~~~~~~~

.. code:: c

    ESP_ERROR_CHECK(adc_cali_raw_to_voltage(adc_cali_handle, adc_raw[0][0], &voltage[0][0]"
"));
    ESP_LOGI(TAG, ""ADC%d Channel[%d] Cali Voltage: %d mV"", ADC_UNIT_1 + 1, EXAMPLE_ADC1_CHAN0, voltage[0][0]);


.. _adc-thread-safety:

Thread Safety


The factory function :cpp:func:`esp_adc_cali_new_scheme` is guaranteed to be thread-safe by the driver. Therefore, you can call them from different RTOS tasks without protection by extra locks.

Other functions that take the :cpp:type:`adc_cali_handle_t` as the first positional parameter are not thread-safe, you should avoid calling them fro"
"m multiple tasks.


.. only:: esp32

    .. _adc-kconfig-options:

    Kconfig Options
    

    - :ref:`CONFIG_ADC_CAL_EFUSE_TP_ENABLE` - disable this to decrease the code size, if the calibration eFuse value is not set to :cpp:type:`ADC_CALI_LINE_FITTING_EFUSE_VAL_EFUSE_TP`.
    - :ref:`CONFIG_ADC_CAL_EFUSE_VREF_ENABLE` - disable this to decrease the code size, if the calibration eFuse value is not set to :cpp:type:`ADC_CALI_LINE_FITTING_EFUSE_VAL_EFUSE_VREF`.
    - :ref:`CONFIG_ADC_CAL_LUT_EN"
"ABLE` - disable this to decrease the code size, if you do not calibrate the ADC raw results under :c:macro:`ADC_ATTEN_DB_12`.


.. _adc-minimize-noise:

Minimize Noise


The {IDF_TARGET_NAME} ADC is sensitive to noise, leading to large discrepancies in ADC readings. Depending on the usage scenario, you may need to connect a bypass capacitor (e.g., a 100 nF ceramic capacitor) to the ADC input pad in use, to minimize noise. Besides, multisampling may also be used to further mitigate the effects of"
" noise.

.. only:: esp32

    .. figure:: ../../../_static/diagrams/adc/adc-noise-graph.jpg
        :align: center
        :alt: ADC noise mitigation

        Graph illustrating noise mitigation using capacitor and multisampling of 64 samples.


API Reference



.. include-build-file:: inc/adc_cali.inc
.. include-build-file:: inc/adc_cali_scheme.inc
"
"Digital Signature (DS)




The Digital Signature (DS) module provides hardware acceleration of signing messages based on RSA. It uses pre-encrypted parameters to calculate a signature. The parameters are encrypted using HMAC as a key-derivation function. In turn, the HMAC uses eFuses as the input key. The whole process happens in hardware so that neither the decryption key for the RSA parameters nor the input key for the HMAC key derivation function can be seen by the software while calculating "
"the signature.

For more detailed information on the hardware involved in the signature calculation and the registers used, see **{IDF_TARGET_NAME} Technical Reference Manual** > **Digital Signature (DS)** [`PDF `__].


Private Key Parameters


The private key parameters for the RSA signature are stored in flash. To prevent unauthorized access, they are AES-encrypted. The HMAC module is used as a key-derivation function to calculate the AES encryption key for the private key parameters. In turn,"
" the HMAC module uses a key from the eFuses key block which can be read-protected to prevent unauthorized access as well.

Upon signature calculation invocation, the software only specifies which eFuse key to use, the corresponding eFuse key purpose, the location of the encrypted RSA parameters, and the message.

Key Generation


Both the HMAC key and the RSA private key have to be created and stored before the DS peripheral can be used. This needs to be done in software on the {IDF_TARGET_NAME}"
" or alternatively on a host. For this context, ESP-IDF provides :cpp:func:`esp_efuse_write_block` to set the HMAC key and :cpp:func:`esp_hmac_calculate` to encrypt the private RSA key parameters.

You can find instructions on how to calculate and assemble the private key parameters in **{IDF_TARGET_NAME} Technical Reference Manual** > **Digital Signature (DS)** [`PDF `__].

Signature Calculation with ESP-IDF


For more detailed information on the workflow and the registers used, see **{IDF_TARGE"
"T_NAME} Technical Reference Manual** > **Digital Signature (DS)** [`PDF `__].

Three parameters need to be prepared to calculate the digital signature:

#. The eFuse key block ID which is used as the key for the HMAC
#. The location of the encrypted private key parameters
#. The message to be signed

Since the signature calculation takes some time, there are two possible API versions to use in ESP-IDF. The first one is :cpp:func:`esp_ds_sign` and simply blocks until the calculation is finished. "
"If software needs to do something else during the calculation, :cpp:func:`esp_ds_start_sign` can be called, followed by periodic calls to :cpp:func:`esp_ds_is_busy` to check when the calculation has finished. Once the calculation has finished, :cpp:func:`esp_ds_finish_sign` can be called to get the resulting signature.

The APIs :cpp:func:`esp_ds_sign` and :cpp:func:`esp_ds_start_sign` calculate a plain RSA signature with the help of the DS peripheral. This signature needs to be converted to an "
"appropriate format for further use. For example, the MbedTLS SSL stack supports PKCS#1 format. The API :cpp:func:`esp_ds_rsa_sign` can be used to obtain the signature directly in the PKCS#1 v1.5 format. It internally uses :cpp:func:`esp_ds_start_sign` and converts the signature into PKCS#1 v1.5 format.

.. note::

    This is only the basic DS building block, the message length is fixed. To create signatures of arbitrary messages, the input is normally a hash of the actual message, padded up to "
"the required length. An API to do this is planned in the future.

.. _configure-the-ds-peripheral:

Configure the DS Peripheral for a TLS Connection


The DS peripheral on {IDF_TARGET_NAME} chip must be configured before it can be used for a TLS connection. The configuration involves the following steps:

1) Randomly generate a 256-bit value called the ``Initialization Vector`` (IV).
2) Randomly generate a 256-bit value called the ``HMAC_KEY``.
3) Calculate the encrypted private key parameters f"
"rom the client private key (RSA) and the parameters generated in the above steps.
4) Then burn the 256-bit ``HMAC_KEY`` on the eFuse, which can only be read by the DS peripheral.

For more details, see **{IDF_TARGET_NAME} Technical Reference Manual** > **Digital Signature (DS)** [`PDF `__].

To configure the DS peripheral for development purposes, you can use the `esp-secure-cert-tool `_.

The encrypted private key parameters obtained after the DS peripheral configuration are then to be kept in "
"flash. Furthermore, they are to be passed to the DS peripheral which makes use of those parameters for the Digital Signature operation. The application then needs to read the DS data from the flash, which has been done through the APIs provided by the `esp_secure_cert_mgr `_ component. Please refer to the `component/README `_ for more details.

The process of initializing the DS peripheral and then performing the Digital Signature operation is done internally with the help of `ESP-TLS`. Please r"
"efer to :ref:`digital-signature-with-esp-tls` for more details.

As mentioned in the `ESP-TLS` documentation, the application only needs to provide the encrypted private key parameters to the esp_tls context (as `ds_data`), which internally performs all necessary operations for initializing the DS peripheral and then performing the DS operation.

Example for SSL Mutual Authentication Using DS


The example :example:`protocols/mqtt/ssl_ds` shows how to use the DS peripheral for mutual authenticat"
"ion. The example uses `mqtt_client` (Implemented through `ESP-MQTT`) to connect to broker ``test.mosquitto.org`` using SSL transport with mutual authentication. The SSL part is internally performed with `ESP-TLS`. See :example_file:`protocols/mqtt/ssl_ds/README.md` for more details.

API Reference


.. include-build-file:: inc/esp_ds.inc
"
"GPIO & RTC GPIO




GPIO Summary


.. include:: gpio/{IDF_TARGET_PATH_NAME}.inc
    :start-after: gpio-summary
    :end-before: ---

GPIO driver offers a dump function :cpp:func:`gpio_dump_io_configuration` to show the current configurations of IOs, such as pull-up/pull-down, input/output enable, pin mapping, etc. Below is an example of how to dump the configuration of GPIO4, GPIO18, and GPIO26:

::

    gpio_dump_io_configuration(stdout, (1ULL ` is running
        :SOC_RISCV_COPROC_SUPPORTED: -"
" The :doc:`Ultra Low Power RISC-V co-processor ` is running
        :SOC_LP_CORE_SUPPORTED: - The :doc:`Ultra Low Power LP-Core co-processor ` is running
        - Analog functions such as ADC/DAC/etc are in use
        :SOC_LP_PERIPHERALS_SUPPORTED: - LP peripherals, such as LP_UART, LP_I2C, are in use


.. only:: SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER or SOC_GPIO_FLEX_GLITCH_FILTER_NUM

    GPIO Glitch Filter
    

    The {IDF_TARGET_NAME} chip features hardware filters to remove unwanted glitch "
"pulses from the input GPIO, which can help reduce false triggering of the interrupt and prevent a noise being routed to the peripheral side.

    .. only:: SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER

        Each GPIO can be configured with a glitch filter, which can be used to filter out pulses shorter than **two** sample clock cycles. The duration of the filter is not configurable. The sample clock is the clock source of the IO_MUX. In the driver, we call this kind of filter as ``pin glitch filter``. "
"You can create the filter handle by calling :cpp:func:`gpio_new_pin_glitch_filter`. All the configurations for a pin glitch filter are listed in the :cpp:type:`gpio_pin_glitch_filter_config_t` structure.

        - :cpp:member:`gpio_pin_glitch_filter_config_t::gpio_num` sets the GPIO number to enable the glitch filter.

    .. only:: SOC_GPIO_FLEX_GLITCH_FILTER_NUM

        {IDF_TARGET_FLEX_GLITCH_FILTER_NUM:default=""8""}

        {IDF_TARGET_NAME} provides {IDF_TARGET_FLEX_GLITCH_FILTER_NUM} fle"
"xible glitch filters, whose duration is configurable. We refer to this kind of filter as ``flex flitch filter``. Each of them can be applied to any input GPIO. However, applying multiple filters to the same GPIO does not make difference from one. You can create the filter handle by calling :cpp:func:`gpio_new_flex_glitch_filter`. All the configurations for a flexible glitch filter are listed in the :cpp:type:`gpio_flex_glitch_filter_config_t` structure.

        - :cpp:member:`gpio_flex_glitch_f"
"ilter_config_t::gpio_num` sets the GPIO that will be applied to the flex glitch filter.
        - :cpp:member:`gpio_flex_glitch_filter_config_t::window_width_ns` and :cpp:member:`gpio_flex_glitch_filter_config_t::window_thres_ns` are the key parameters of the glitch filter. During :cpp:member:`gpio_flex_glitch_filter_config_t::window_width_ns`, any pulse whose width is shorter than :cpp:member:`gpio_flex_glitch_filter_config_t::window_thres_ns` will be discarded. Please note that, you can not se"
"t :cpp:member:`gpio_flex_glitch_filter_config_t::window_thres_ns` bigger than :cpp:member:`gpio_flex_glitch_filter_config_t::window_width_ns`.

    .. only:: SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER and SOC_GPIO_FLEX_GLITCH_FILTER_NUM

        Please note, the ``pin glitch filter`` and ``flex glitch filter`` are independent. You can enable both of them for the same GPIO.

    The glitch filter is disabled by default, and can be enabled by calling :cpp:func:`gpio_glitch_filter_enable`. To recycle the f"
"ilter, you can call :cpp:func:`gpio_del_glitch_filter`. Please note, before deleting the filter, you should disable it first by calling :cpp:func:`gpio_glitch_filter_disable`.


.. only:: SOC_GPIO_SUPPORT_PIN_HYS_FILTER

    GPIO Hysteresis Filter
    

    {IDF_TARGET_NAME} support the hardware hysteresis of the input pin, which can reduce the GPIO interrupt shoot by accident due to unstable sampling when the input voltage is near the criteria of logic 0 and 1, especially when the input logic l"
"evel conversion is slow or the voltage setup time is too long.

    .. only:: SOC_GPIO_SUPPORT_PIN_HYS_CTRL_BY_EFUSE

        Each pin can enable hysteresis function independently. By default, it controlled by eFuse and been closed, but it can also be enabled or disabled by software manually. You can select the hysteresis control mode by configuring :cpp:member:`gpio_config_t::hys_ctrl_mode`. Hysteresis control mode is set along with all the other GPIO configurations in :cpp:func:`gpio_config`.
"
"
        .. note::

            When the hysteresis function is controlled by eFuse, this feature can still be controlled independently for each pin, you need to `burn the eFuse `_ to enable the hysteresis function on specific GPIO additionally.

    .. only:: not SOC_GPIO_SUPPORT_PIN_HYS_CTRL_BY_EFUSE

        Each pin can enable hysteresis function independently. By default, the function is not enabled. You can select the hysteresis control mode by configuring :cpp:member:`gpio_config_t::hys_c"
"trl_mode`. Hysteresis control mode is set along with all the other GPIO configurations in :cpp:func:`gpio_config`.


Application Example


API Reference - Normal GPIO


.. include-build-file:: inc/gpio.inc
.. include-build-file:: inc/gpio_types.inc


.. only:: SOC_RTCIO_INPUT_OUTPUT_SUPPORTED

    API Reference - RTC GPIO
    

    .. include-build-file:: inc/rtc_io.inc
    .. include-build-file:: inc/lp_io.inc
    .. include-build-file:: inc/rtc_io_types.inc

.. only:: SOC_GPIO_SUPPORT_PIN_GLIT"
"CH_FILTER or SOC_GPIO_FLEX_GLITCH_FILTER_NUM

      API Reference - GPIO Glitch Filter
      

      .. include-build-file:: inc/gpio_filter.inc
"
"Touch Element




Overview


The Touch Element Library is a highly abstracted element library designed on the basis of the touch sensor driver. The library provides a unified and user-friendly software interface to quickly build capacitive touch sensor applications. For more information about the touch sensor driver API, see :doc:`../peripherals/touch_pad`.

Architecture


The Touch Element library configures touch sensor peripherals via the touch sensor driver. However, some necessary hardware "
"parameters should be passed to :cpp:func:`touch_element_install` and will be configured automatically only after calling :cpp:func:`touch_element_start`. This sequential order is essential because configuring these parameters has a significant impact on the run-time system. Therefore, they must be configured after calling the start function to ensure the system functions properly.

These parameters include touch channel threshold, driver-level of waterproof shield sensor, etc. The Touch Element "
"library sets the touch sensor interrupt and the esp_timer routine up, and the hardware information of the touch sensor (channel state, channel number) will be obtained in the touch sensor interrupt service routine. When the specified channel event occurs, the hardware information is passed to the esp_timer callback routine, which then dispatches the touch sensor channel information to the touch elements (such as button, slider, etc.). The library then runs a specified algorithm to update the tou"
"ch element's state or calculate its position and dispatches the result accordingly.

So when using the Touch Element library, you are relieved from the implementation details of the touch sensor peripheral. The library handles most of the hardware information and passes the more meaningful messages to the event handler routine.

The workflow of the Touch Element library is illustrated in the picture below.

.. figure:: /../_static/touch_element/te_architecture.svg
    :scale: 100 %
    :align: c"
"enter

    Touch Element architecture


The features in relation to the Touch Element library in {IDF_TARGET_NAME} are given in the table below.

.. list-table::
    :header-rows: 1
    :widths: 70 30
    :align: center
      - ESP32S2
      - ✔
      - ✔
      - ✔
      - ✔


Peripheral


{IDF_TARGET_NAME} integrates one touch sensor peripheral with several physical channels.

.. only:: esp32s2 or esp32s3

    - 14 physical capacitive touch channels
    - Timer or software FSM trigger mode
    "
"- Up to 5 kinds of interrupt (Upper threshold and lower threshold interrupt, measure one channel finish and measure all channels finish interrupt, measurement timeout interrupt)
    - Sleep mode wakeup source
    - Hardware internal de-noise
    - Hardware filter
    - Hardware waterproof sensor
    - Hardware proximity sensor

The channels are located as follows:

.. list-table::
    :header-rows: 1
    :widths: 50 50
    :align: center
      - {IDF_TARGET_NAME}
      - **GPIO 0 (reserved)**
  "
"    - **GPIO 1**
      - **GPIO 2**
      - **GPIO 3**
      - **GPIO 4**
      - **GPIO 5**
      - **GPIO 6**
      - **GPIO 7**
      - **GPIO 8**
      - **GPIO 9**
      - **GPIO 10**
      - **GPIO 11**
      - **GPIO 12**
      - **GPIO 13**
      - **GPIO 14**


.. only:: esp32

    - 10 physical capacitive touch channels
    - Timer or software FSM trigger mode
    - 2 kinds of interrupt (Greater than the threshold and less than the threshold)
    - Sleep mode wakeup source

The channel"
"s are located as follows:

.. list-table::
    :header-rows: 1
    :widths: 50 50
    :align: center
      - {IDF_TARGET_NAME}
      - **GPIO 0 (effective)**
      - **GPIO 1**
      - **GPIO 2**
      - **GPIO 3**
      - **GPIO 4**
      - **GPIO 5**
      - **GPIO 6**
      - **GPIO 7**
      - **GPIO 8**
      - **GPIO 9**


Terminology


The terms used in relation to the Touch Element library are given below.

.. list-table::
    :header-rows: 1
    :widths: 50 50
    :align: center
      -"
" Definition
      - Touch sensor peripheral inside the chip
      - Touch sensor channels inside the touch sensor peripheral
      - Off-chip physical solder pad, generally inside the PCB
      - Internal de-noise channel, which is always Channel 0 and is reserved
      - One of the waterproof sensors for detecting droplets in small areas and compensating for the influence of water drops on measurements
      - One of the waterproof sensors for detecting extensive wading and to temporarily disab"
"le the touch sensor
      - The channel that waterproof shield sensor connected to, which is always Channel 14
      - The channel that waterproof guard sensor connected to
      - Off-chip physical solder pad, generally is grids, and is connected to shield the sensor
      - Off-chip physical solder pad, usually a ring, and is connected to the guard sensor

.. figure:: /../_static/touch_element/te_component.svg
    :scale: 100 %
    :align: center

    Touch sensor application system components"
"


Touch Sensor Signal


Each touch sensor is able to provide the following types of signals:

- Raw: The Raw signal is the unfiltered signal from the touch sensor.
- Smooth: The Smooth signal is a filtered version of the Raw signal via an internal hardware filter.
- Benchmark: The Benchmark signal is also a filtered signal that filters out extremely low-frequency noise.

All of these signals can be obtained using touch sensor driver API.

.. figure:: /../_static/touch_element/te_signal.png
    "
":scale: 40 %
    :align: center

    Touch sensor signals


Touch Sensor Signal Threshold


The Touch Sensor Threshold value is a configurable threshold value used to determine when a touch sensor is touched or not. When the difference between the Smooth signal and the Benchmark signal becomes greater than the threshold value (i.e., ``(smooth - benchmark) > threshold``), the touch channel's state will be changed and a touch interrupt will be triggered simultaneously.

.. figure:: /../_static/tou"
"ch_element/te_threshold.svg
    :scale: 40 %
    :align: center

    Touch sensor signal threshold


Sensitivity


Important performance parameter of the touch sensor, the larger it is, the better touch the sensor performs. It could be calculated by the format below:

.. math::

    Sensitivity = \frac{Signal_{press} - Signal_{release}}{Signal_{release}} = \frac{Signal_{delta}}{Signal_{benchmark}}


Waterproof


Waterproof is the hardware feature of a touch sensor which has a guard sensor and sh"
"ield sensor (always connect to Channel 14) that has the ability to resist a degree of influence of water drop and detect the water stream.


Touch Button


The touch button consumes one channel of the touch sensor, and it looks like as the picture below:


.. figure:: /../_static/touch_element/te_button.svg
    :scale: 100 %
    :align: center

    Touch button


Touch Slider


The touch slider consumes several channels (at least three channels) of the touch sensor, the more channels consumed, t"
"he higher resolution and accuracy position it performs. The touch slider looks like as the picture below:

.. figure:: /../_static/touch_element/te_slider.svg
    :scale: 100 %
    :align: center

    Touch slider


Touch Matrix


The touch matrix button consumes several channels (at least 2 + 2 = 4 channels), and it gives a solution to use fewer channels and get more buttons. {IDF_TARGET_NAME} supports up to 49 buttons. The touch matrix button looks like as the picture below:

.. figure:: /../_"
"static/touch_element/te_matrix.svg
    :scale: 100 %
    :align: center

    Touch matrix


Touch Element Library Usage


Using this library should follow the initialization flow below:

In code, the flow above may look like as follows:

.. code-block:: c

    static touch_xxx_handle_t element_handle; //Declare a touch element handle

    //Define the subscribed event handler
    void event_handler(touch_xxx_handle_t out_handle, touch_xxx_message_t out_message, void *arg)
    {
        //Event h"
"andler logic
    }

    void app_main()
    {
        //Using the default initializer to config Touch Element library
        touch_elem_global_config_t global_config = TOUCH_ELEM_GLOBAL_DEFAULT_CONFIG();
        touch_element_install(&global_config);

        //Using the default initializer to config Touch elements
        touch_xxx_global_config_t elem_global_config = TOUCH_XXXX_GLOBAL_DEFAULT_CONFIG();
        touch_xxx_install(&elem_global_config);

        //Create a new instance
        to"
"uch_xxx_config_t element_config = {
            ...
            ...
        };
        touch_xxx_create(&element_config, &element_handle);

        //Subscribe the specified events by using the event mask
        touch_xxx_subscribe_event(element_handle, TOUCH_ELEM_EVENT_ON_PRESS | TOUCH_ELEM_EVENT_ON_RELEASE, NULL);

        //Choose CALLBACK as the dispatch method
        touch_xxx_set_dispatch_method(element_handle, TOUCH_ELEM_DISP_CALLBACK);

        //Register the callback routine
        t"
"ouch_xxx_set_callback(element_handle, event_handler);

        //Start Touch Element library processing
        touch_element_start();
    }


Initialization



Touch Element Instance Startup


Events Processing


If :cpp:enumerator:`TOUCH_ELEM_DISP_EVENT` dispatch method is configured, you need to start up an event handler task to obtain the touch element message, all the elements' raw message could be obtained by calling :cpp:func:`touch_element_message_receive`, then extract the element-class"
"-specific message by calling the corresponding message decoder with :cpp:func:`touch_xxxx_get_message` to get the touch element's extracted message; If :cpp:enumerator:`TOUCH_ELEM_DISP_CALLBACK` dispatch method is configured, you need to pass an event handler by calling :cpp:func:`touch_xxxx_set_callback` before the touch element starts working, all the element's extracted message will be passed to the event handler function.

.. warning::

    Since the event handler function runs on the core o"
"f the element library, i.e., in the esp_timer callback routine, please avoid performing operations that may cause blocking or delays, such as calling :cpp:func:`vTaskDelay`.


In code, the events handle procedure may look like as follows:

.. code-block:: c

    /*  TOUCH_ELEM_DISP_EVENT  */
    void element_handler_task(void *arg)
    {
        touch_elem_message_t element_message;
        while(1) {
            if (touch_element_message_receive(&element_message, Timeout) == ESP_OK) {
         "
"       const touch_xxxx_message_t *extracted_message = touch_xxxx_get_message(&element_message); //Decode message
                ... //Event handler logic
            }
        }
    }
    void app_main()
    {
        ...

        touch_xxxx_set_dispatch_method(element_handle, TOUCH_ELEM_DISP_EVENT);  //Set TOUCH_ELEM_DISP_EVENT as the dispatch method
        xTaskCreate(&element_handler_task, ""element_handler_task"", 2048, NULL, 5, NULL);  //Create a handler task

        ...
    }
    /*  */
"
"
    ...
    /*  TOUCH_ELEM_DISP_CALLBACK  */
    void element_handler(touch_xxxx_handle_t out_handle, touch_xxxx_message_t out_message, void *arg)
    {
        //Event handler logic
    }

    void app_main()
    {
        ...

        touch_xxxx_set_dispatch_method(element_handle, TOUCH_ELEM_DISP_CALLBACK);  //Set TOUCH_ELEM_DISP_CALLBACK as the dispatch method
        touch_xxxx_set_callback(element_handle, element_handler);  //Register an event handler function

        ...
    }
    /*  */"
"


Waterproof Usage


The Touch Element Waterproof example is available in :example:`peripherals/touch_sensor/touch_element/touch_element_waterproof` directory.

In code, the waterproof configuration may look as follows:

.. code-block:: c

    void app_main()
    {
        ...

        touch_xxxx_install();                 //Initialize instance (button, slider, etc)
        touch_xxxx_create(&element_handle);  //Create a new Touch element

        ...

        touch_element_waterproof_install()"
";              //Initialize Touch Element waterproof
        touch_element_waterproof_add(element_handle);   //Let an element associate with the guard sensor

        ...
    }

Wakeup from Light/Deep-sleep Mode


Only Touch Button can be configured as a wake-up source.

Light- or Deep-sleep modes are both supported to be wakened up by a touch sensor. For the Light-sleep mode, any installed touch button can wake it up. But only the sleep button can wake up from Deep-sleep mode, and the touch sen"
"sor will do a calibration immediately, the reference value will be calibrated to a wrong value if our finger does not remove timely. Though the wrong reference value recovers after the finger removes away and has no effect on the driver logic, if you do not want to see a wrong reference value while waking up from Deep-sleep mode, you can call :cpp:func:`touch_element_sleep_enable_wakeup_calibration` to disable the wakeup calibration.

The Touch Element Wakeup example is available in `system/ligh"
"t_sleep` directory.

.. code-block:: c

    void app_main()
    {
        ...
        touch_element_install();
        touch_button_install();                 //Initialize the touch button
        touch_button_create(&element_handle);  //Create a new Touch element

        ...

        // ESP_ERROR_CHECK(touch_element_enable_light_sleep(&sleep_config));
        ESP_ERROR_CHECK(touch_element_enable_deep_sleep(button_handle[0], &sleep_config));
        // ESP_ERROR_CHECK(touch_element_sleep_enable"
"_wakeup_calibration(button_handle[0], false)); // (optional) Disable wakeup calibration to prevent updating the baseline to a wrong value

        touch_element_start();

        ...
    }

Application Example


All the Touch Element library examples could be found in the :example:`peripherals/touch_sensor/touch_element` directory of ESP-IDF examples.


API Reference - Touch Element Core


.. include-build-file:: inc/touch_element.inc


API Reference - Touch Button


.. include-build-file:: inc/"
"touch_button.inc


API Reference - Touch Slider


.. include-build-file:: inc/touch_slider.inc


API Reference - Touch Matrix


.. include-build-file:: inc/touch_matrix.inc
"
"Clock Tree




{IDF_TARGET_RC_FAST_VAGUE_FREQ: default=""17.5"", esp32=""8"", esp32s2=""8"", esp32h2=""8""}

{IDF_TARGET_RC_FAST_ADJUSTED_FREQ: default=""17.5"", esp32=""8.5"", esp32s2=""8.5"", esp32h2=""8.5""}

{IDF_TARGET_XTAL_FREQ: default=""40"", esp32=""2 ~ 40"", esp32c2=""40/26"", esp32h2=""32""}

{IDF_TARGET_RC_SLOW_VAGUE_FREQ: default=""136"", esp32=""150"", esp32s2=""90""}

{IDF_TARGET_OSC_SLOW_PIN: default=""GPIO0"", esp32c2=""pin0 (when its frequency is no more than 136 kHz)"", ""esp32c6=""GPIO0"", esp32h2=""GPIO13""}

The"
" clock subsystem of {IDF_TARGET_NAME} is used to source and distribute system/module clocks from a range of root clocks. The clock tree driver maintains the basic functionality of the system clock and the intricate relationship among module clocks.

This document starts with the introduction to root and module clocks. Then it covers the clock tree APIs that can be called to monitor the status of the module clocks at runtime.

Introduction


This section lists definitions of {IDF_TARGET_NAME}'s s"
"upported root clocks and module clocks. These definitions are commonly used in the driver configuration, to help select a proper source clock for the peripheral.

Root Clocks


Root clocks generate reliable clock signals. These clock signals then pass through various gates, muxes, dividers, or multipliers to become the clock sources for every functional module: the CPU core(s), Wi-Fi, Bluetooth, the RTC, and the peripherals.

{IDF_TARGET_NAME}'s root clocks are listed in :cpp:type:`soc_root_clk_"
"t`:

    .. list::

        - Internal {IDF_TARGET_RC_FAST_VAGUE_FREQ} MHz RC Oscillator (RC_FAST)

            This RC oscillator generates a about {IDF_TARGET_RC_FAST_ADJUSTED_FREQ} MHz clock signal output as the ``RC_FAST_CLK``.

            .. only:: SOC_CLK_RC_FAST_D256_SUPPORTED

                The about {IDF_TARGET_RC_FAST_ADJUSTED_FREQ} MHz signal output is also passed into a configurable divider, which by default divides the input clock frequency by 256, to generate a ``RC_FAST_D256_CL"
"K``.

                The exact frequency of ``RC_FAST_CLK`` can be computed in runtime through calibration on the ``RC_FAST_D256_CLK``.

            .. only:: not SOC_CLK_RC_FAST_D256_SUPPORTED and SOC_CLK_RC_FAST_SUPPORT_CALIBRATION

                The exact frequency of ``RC_FAST_CLK`` can be computed in runtime through calibration.

            .. only:: not SOC_CLK_RC_FAST_SUPPORT_CALIBRATION

                The exact frequency of ``RC_FAST_CLK`` cannot be computed in runtime through cali"
"bration, but it is still possible to get its frequency through an oscilloscope or a logic analyzer by routing the clock signal to a GPIO pin.

        - External {IDF_TARGET_XTAL_FREQ} MHz Crystal (XTAL)

        - Internal {IDF_TARGET_RC_SLOW_VAGUE_FREQ} kHz RC Oscillator (RC_SLOW)

            This RC oscillator generates a about {IDF_TARGET_RC_SLOW_VAGUE_FREQ}kHz clock signal output as the ``RC_SLOW_CLK``. The exact frequency of this clock can be computed in runtime through calibration.

    "
"    .. only:: SOC_CLK_XTAL32K_SUPPORTED

            - External 32 kHz Crystal - optional (XTAL32K)

                .. only:: esp32

                    The clock source for this ``XTAL32K_CLK`` can be either a 32 kHz crystal connecting to the ``32K_XP`` and ``32K_XN`` pins or a 32 kHz clock signal generated by an external circuit. The external signal must be connected to the ``32K_XN`` pin. Additionally, a 1 nF capacitor must be placed between the ``32K_XP`` pin and ground. In this case, the `"
"`32K_XP`` pin cannot be used as a GPIO pin.

                .. only:: esp32p4

                    The clock source for this ``XTAL32K_CLK`` is a 32 kHz crystal connecting to the ``XTAL_32K_P`` and ``XTAL_32K_N`` pins.

                .. only:: not esp32 and not esp32p4

                     The clock source for this ``XTAL32K_CLK`` can be either a 32 kHz crystal connecting to the ``XTAL_32K_P`` and ``XTAL_32K_N`` pins or a 32 kHz clock signal generated by an external circuit. The external sig"
"nal must be connected to the ``XTAL_32K_P`` pin.

                ``XTAL32K_CLK`` can also be calibrated to get its exact frequency.

        .. only:: SOC_CLK_OSC_SLOW_SUPPORTED

            - External Slow Clock - optional (OSC_SLOW)

                A clock signal generated by an external circuit can be connected to {IDF_TARGET_OSC_SLOW_PIN} to be the clock source for the ``RTC_SLOW_CLK``. This clock can also be calibrated to get its exact frequency.

        .. only:: SOC_CLK_RC32K_SUPPORTED"
"

            - Internal 32 kHz RC Oscillator (RC32K)

                The exact frequency of this clock can be computed in runtime through calibration.

Typically, the frequency of the signal generated from an RC oscillator circuit is less accurate and more sensitive to the environment compared to the signal generated from a crystal. {IDF_TARGET_NAME} provides several clock source options for the ``RTC_SLOW_CLK``, and it is possible to make the choice based on the requirements for system time a"
"ccuracy and power consumption. For more details, please refer to :ref:`rtc-clock-source-choice`.

Module Clocks


{IDF_TARGET_NAME}'s available module clocks are listed in :cpp:type:`soc_module_clk_t`. Each module clock has a unique ID. You can get more information on each clock by checking the documented enum value.

API Usage


The clock tree driver provides an all-in-one API to get the frequency of the module clocks, :cpp:func:`esp_clk_tree_src_get_freq_hz`. This function allows you to obtain"
" the clock frequency at any time by providing the clock name :cpp:enum:`soc_module_clk_t` and specifying the desired precision level for the returned frequency value :cpp:enum:`esp_clk_tree_src_freq_precision_t`.

API Reference


.. include-build-file:: inc/clk_tree_defs.inc
.. include-build-file:: inc/esp_clk_tree.inc
"
"Digital To Analog Converter (DAC)




{IDF_TARGET_DAC_CH_1: default = ""Not Updated!"", esp32 = ""GPIO25"", esp32s2 = ""GPIO17""}
{IDF_TARGET_DAC_CH_2: default = ""Not Updated!"", esp32 = ""GPIO26"", esp32s2 = ""GPIO18""}
{IDF_TARGET_DAC_REF_PIN: default = ""Not Updated!"", esp32 = ""VDD3P3_RTC"", esp32s2 = ""VDD3P3_RTC_IO""}

Overview


{IDF_TARGET_NAME} has two 8-bit DAC (digital to analog converter) channels respectively connected to {IDF_TARGET_DAC_CH_1} (Channel 1) and {IDF_TARGET_DAC_CH_2} (Channel 2). Each"
" DAC channel can convert the digital value 0~255 to the analog voltage 0~Vref (The reference voltage 'Vref' here is input from the pin {IDF_TARGET_DAC_REF_PIN}, which ideally equals to the power supply VDD). The output voltage can be calculated as the following::

    out_voltage = Vref * digi_val / 255

The DAC peripheral supports outputting analog signal in the following ways:

For other analog output options, see :doc:`Sigma-Delta Modulation ` and :doc:`LED Control `. Both modules produce hig"
"h-frequency PWM/PDM output, which can be hardware low-pass filtered in order to generate a lower frequency analog output.

DAC File Structure


.. figure:: ../../../_static/diagrams/dac/dac_file_structure.png
    :align: center
    :alt: DAC file structure

    DAC File Structure


**Public headers that need to be included in the DAC application are listed as follows:**

- ``dac.h``: The top header file of the legacy DAC driver, which should be only included in the apps which use the legacy driv"
"er API.
- ``dac_oneshot.h``: The top header file of the new DAC driver, which should be included in the apps which use the new driver API with one-shot mode.
- ``dac_cosine.h``: The top header file of the new DAC driver, which should be included in the apps which use the new driver API with cosine mode.
- ``dac_continuous.h``: The top header file of the new DAC driver, which should be included in the apps which use the new driver API with continuous mode.

.. note::

    The legacy driver cannot"
" coexist with the new driver. Include ``dac.h`` to use the legacy driver or ``dac_oneshot.h``, ``dac_cosine.h``, and ``dac_continuous.h`` to use the new driver. The legacy driver might be removed in the future.

Functional Overview


Resources Management


The DAC on {IDF_TARGET_NAME} has two channels. The channels have separate software resources and can be managed by :cpp:type:`dac_oneshot_handle_t`, :cpp:type:`dac_cosine_handle_t`, or :cpp:type:`dac_continuous_handle_t` according to the usage"
". Registering different modes on a same DAC channel is not allowed.

Direct Voltage Output (One-shot/Direct Mode)


The DAC channels in the group can convert an 8-bit digital value into the analog when :cpp:func:`dac_oneshot_output_voltage` is called (it can be called in ISR). The analog voltage is kept on the DAC channel until the next conversion starts. To start the voltage conversion, the DAC channels need to be enabled first through registering by :cpp:func:`dac_oneshot_new_channel`.

Contin"
"uous Wave Output (Continuous/DMA Mode)


DAC channels can convert digital data continuously via the DMA. There are three ways to write the DAC data:

.. only:: esp32

    On ESP32, the DAC digital controller can be connected internally to the I2S0 and use its DMA for continuous conversion. Although the DAC only needs 8-bit data for conversion, it has to be the left-shifted 8 bits (i.e., the high 8 bits in a 16-bit slot) to satisfy the I2S communication format. By default, the driver helps to exp"
"and the data to 16-bit wide automatically. To expand manually, please disable :ref:`CONFIG_DAC_DMA_AUTO_16BIT_ALIGN` in the menuconfig.

    The clock of the DAC digital controller comes from I2S0 as well, so there are two clock sources for selection:

    - :cpp:enumerator:`dac_continuous_digi_clk_src_t::DAC_DIGI_CLK_SRC_PLL_D2` supports frequency between 19.6 KHz to several MHz. It is the default clock which can also be selected by :cpp:enumerator:`dac_continuous_digi_clk_src_t::DAC_DIGI_CLK_S"
"RC_DEFAULT`.
    - :cpp:enumerator:`dac_continuous_digi_clk_src_t::DAC_DIGI_CLK_SRC_APLL` supports frequency between 648 Hz to several MHz. However, it might be occupied by other peripherals, thus not providing the required frequency. In such case, this clock source is available only if APLL still can be correctly divided into the target DAC DMA frequency.

.. only:: esp32s2

    On ESP32-S2, the DAC digital controller can be connected internally to the SPI3 and use its DMA for continuous conver"
"sion.

    The clock sources of the DAC digital controller include:

    - :cpp:enumerator:`dac_continuous_digi_clk_src_t::DAC_DIGI_CLK_SRC_APB` supports frequency between 77 Hz to several MHz. It is the default clock which can also be selected by :cpp:enumerator:`dac_continuous_digi_clk_src_t::DAC_DIGI_CLK_SRC_DEFAULT`.
    - :cpp:enumerator:`dac_continuous_digi_clk_src_t::DAC_DIGI_CLK_SRC_APLL` supports frequency between 6 Hz to several MHz. However, it might be occupied by other peripherals, "
"thus not providing the required frequency. In such case, this clock source is available only if APLL still can be correctly divided into the target DAC DMA frequency.


Cosine Wave Output (Cosine Mode)


The DAC peripheral has a cosine wave generator, which can generate cosine wave on the channels. Users can specify the frequency, amplitude, and phase of the cosine wave. To output the cosine wave, please acquire the DAC to cosine mode using :cpp:func:`dac_cosine_new_channel`, and then start the "
"cosine wave generator by :cpp:func:`dac_cosine_start`.

Currently, the clock source of the cosine wave generator only comes from ``RTC_FAST`` which can be selected by :cpp:enumerator:`dac_cosine_clk_src_t::DAC_COSINE_CLK_SRC_RTC_FAST`. It is also the default clock source which is the same as :cpp:enumerator:`dac_cosine_clk_src_t::DAC_COSINE_CLK_SRC_RTC_DEFAULT`.

Power Management


When the power management is enabled (i.e., :ref:`CONFIG_PM_ENABLE` is on), the system will adjust or stop the cloc"
"k source of DAC before entering Light-sleep mode, thus potential influence to the DAC signals may lead to false data conversion.

When using DAC driver in continuous mode, it can prevent the system from changing or stopping the clock source in DMA or cosine mode by acquiring a power management lock. When the clock source is generated from APB, the lock type will be set to :cpp:enumerator:`esp_pm_lock_type_t::ESP_PM_APB_FREQ_MAX`. When the clock source is APLL (only in DMA mode), it will be set t"
"o :cpp:enumerator:`esp_pm_lock_type_t::ESP_PM_NO_LIGHT_SLEEP`. Whenever the DAC is converting (i.e., DMA or cosine wave generator is working), the driver guarantees that the power management lock is acquired after calling :cpp:func:`dac_continuous_enable`. Likewise, the driver will release the lock when :cpp:func:`dac_continuous_disable` is called.

IRAM Safe


By default, the DAC DMA interrupt will be deferred when the cache is disabled for reasons like writing/erasing Flash. Thus the DMA EOF i"
"nterrupt will not get executed in time.

To avoid such case in real-time applications, you can enable the Kconfig option :ref:`CONFIG_DAC_ISR_IRAM_SAFE` which:

This allows the interrupt to run while the cache is disabled but comes at the cost of increased IRAM consumption.

Thread Safety


All the public DAC APIs are guaranteed to be thread safe by the driver, which means users can call them from different RTOS tasks without protection by extra locks. Notice that the DAC driver uses mutex lock "
"to ensure the thread safety, thus the APIs except :cpp:func:`dac_oneshot_output_voltage` are not allowed to be used in ISR.

Kconfig Options


- :ref:`CONFIG_DAC_ISR_IRAM_SAFE` controls whether the default ISR handler can work when cache is disabled. See `IRAM Safe `__ for more information.
- :ref:`CONFIG_DAC_SUPPRESS_DEPRECATE_WARN` controls whether to suppress the warning message compilation while using the legacy DAC driver.
- :ref:`CONFIG_DAC_ENABLE_DEBUG_LOG` is used to enable the debug log"
" output. Enable this option increases the firmware binary size.

.. only:: esp32

    - :ref:`CONFIG_DAC_DMA_AUTO_16BIT_ALIGN` auto expands the 8-bit data to 16-bit data in the driver to satisfy the I2S DMA format.

Application Example


The basic examples for the ``One-shot Mode``, ``Continuous Mode``, and ``Cosine Mode`` can be found in:

- :example:`peripherals/dac/dac_oneshot`
- :example:`peripherals/dac/dac_continuous`
- :example:`peripherals/dac/dac_cosine_wave`

API Reference


.. include"
"-build-file:: inc/dac_oneshot.inc
.. include-build-file:: inc/dac_cosine.inc
.. include-build-file:: inc/dac_continuous.inc
.. include-build-file:: inc/components/esp_driver_dac/include/driver/dac_types.inc
.. include-build-file:: inc/components/hal/include/hal/dac_types.inc
"
"SPI Features


.. _spi_master_features:

SPI Master


.. _spi_bus_lock:

SPI Bus Lock


To realize the multiplexing of different devices from different drivers, including SPI Master, SPI Flash, etc., an SPI bus lock is applied on each SPI bus. Drivers can attach their devices to the bus with the arbitration of the lock.

Each bus lock is initialized with a BG (background) service registered. All devices that request transactions on the bus should wait until the BG is successfully disabled.

- Fo"
"r the SPI1 bus, the BG is the cache. The bus lock disables the cache before device operations start, and enables it again after the device releases the lock. No devices on SPI1 are allowed to use ISR, since it is meaningless for the task to yield to other tasks when the cache is disabled.

  .. only:: esp32

      There are quite a few limitations when using the SPI Master driver on the SPI1 bus. See :ref:`spi_master_on_spi1_bus`.

  .. only:: not esp32

      The SPI Master driver has not suppo"
"rted SPI1 bus. Only the SPI Flash driver can attach to the bus.

- For other buses, the driver can register the ISR as a BG. If a device task requests exclusive bus access, the bus lock will block the task, disable the ISR, and then unblock the task. After the task releases the lock, the lock will try to re-enable the ISR if there are still pending transactions in the ISR.
"
"Inter-IC Sound (I2S)




{IDF_TARGET_I2S_NUM:default=""one"", esp32=""two"", esp32s3=""two""}

Introduction


I2S (Inter-IC Sound) is a synchronous serial communication protocol usually used for transmitting audio data between two digital audio devices.

{IDF_TARGET_NAME} contains {IDF_TARGET_I2S_NUM} I2S peripheral(s). These peripherals can be configured to input and output sample data via the I2S driver.

An I2S bus that communicates in standard or TDM mode consists of the following lines:

- **MCLK"
":** Master clock line. It is an optional signal depending on the slave side, mainly used for offering a reference clock to the I2S slave device.
- **BCLK:** Bit clock line. The bit clock for data line.
- **WS:** Word (Slot) select line. It is usually used to identify the vocal tract except PDM mode.
- **DIN/DOUT:** Serial data input/output line. Data will loopback internally if DIN and DOUT are set to a same GPIO.

.. only:: SOC_I2S_SUPPORTS_PDM_TX or SOC_I2S_SUPPORTS_PDM_RX

    An I2S bus that"
" communicates in PDM mode consists of the following lines:

    - **CLK:** PDM clock line.
    - **DIN/DOUT:** Serial data input/output line.

Each I2S controller has the following features that can be configured by the I2S driver:

- Operation as system master or slave
- Capable of acting as transmitter or receiver
- DMA controller that allows stream sampling of data without requiring the CPU to copy each data sample

.. only:: SOC_I2S_HW_VERSION_1

    Each controller supports single RX or TX "
"simplex communication. As RX and TX channels share a clock, they can only be combined with the same configuration to establish a full-duplex communication.

.. only:: SOC_I2S_HW_VERSION_2

    Each controller has separate RX and TX channels. That means they are able to work under different clocks and slot configurations with separate GPIO pins. Note that although the internal MCLKs of TX channel and RX channel are separate on a controller, the output MCLK signal can only be attached to one chann"
"el. If independent MCLK output is required for each channel, they must be allocated on different I2S controllers.

I2S File Structure


.. figure:: ../../../_static/diagrams/i2s/i2s_file_structure.png
    :align: center
    :alt: I2S file structure

    I2S File Structure

**Public headers that need to be included in the I2S application are as follows:**

- ``i2s.h``: The header file that provides legacy I2S APIs (for apps using legacy driver).
- ``i2s_std.h``: The header file that provides stan"
"dard communication mode specific APIs (for apps using new driver with standard mode).
- ``i2s_pdm.h``: The header file that provides PDM communication mode specific APIs (for apps using new driver with PDM mode).
- ``i2s_tdm.h``: The header file that provides TDM communication mode specific APIs (for apps using new driver with TDM mode).

.. note::

    The legacy driver cannot coexist with the new driver. Include ``i2s.h`` to use the legacy driver, or include the other three headers to use the "
"new driver. The legacy driver might be removed in future.

**Public headers that have been included in the headers above are as follows:**

- ``i2s_types_legacy.h``: The header file that provides legacy public types that are only used in the legacy driver.
- ``i2s_types.h``: The header file that provides public types.
- ``i2s_common.h``: The header file that provides common APIs for all communication modes.

I2S Clock


Clock Source


- :cpp:enumerator:`i2s_clock_src_t::I2S_CLK_SRC_DEFAULT`: Def"
"ault PLL clock.

.. only:: not esp32h2

    - :cpp:enumerator:`i2s_clock_src_t::I2S_CLK_SRC_PLL_160M`: 160 MHz PLL clock.

.. only:: esp32h2

    - :cpp:enumerator:`i2s_clock_src_t::I2S_CLK_SRC_PLL_96M`: 96 MHz PLL clock.

.. only:: SOC_I2S_SUPPORTS_APLL

    - :cpp:enumerator:`i2s_clock_src_t::I2S_CLK_SRC_APLL`: Audio PLL clock, which is more precise than ``I2S_CLK_SRC_PLL_160M`` in high sample rate applications. Its frequency is configurable according to the sample rate. However, if APLL has b"
"een occupied by EMAC or other channels, the APLL frequency cannot be changed, and the driver will try to work under this APLL frequency. If this frequency cannot meet the requirements of I2S, the clock configuration will fail.

Clock Terminology


- **Sample rate**: The number of sampled data in one second per slot.
- **SCLK**: Source clock frequency. It is the frequency of the clock source.
- **MCLK**: Master clock frequency. BCLK is generated from this clock. The MCLK signal usually serves as "
"a reference clock and is mostly needed to synchronize BCLK and WS between I2S master and slave roles.
- **BCLK**: Bit clock frequency. Every tick of this clock stands for one data bit on data pin. The slot bit width configured in :cpp:member:`i2s_std_slot_config_t::slot_bit_width` is equal to the number of BCLK ticks, which means there will be 8/16/24/32 BCLK ticks in one slot.
- **LRCK** / **WS**: Left/right clock or word select clock. For non-PDM mode, its frequency is equal to the sample rate"
".

.. note::

    Normally, MCLK should be the multiple of ``sample rate`` and BCLK at the same time. The field :cpp:member:`i2s_std_clk_config_t::mclk_multiple` indicates the multiple of MCLK to the ``sample rate``. In most cases, ``I2S_MCLK_MULTIPLE_256`` should be enough. However, if ``slot_bit_width`` is set to ``I2S_SLOT_BIT_WIDTH_24BIT``, to keep MCLK a multiple to the BCLK, :cpp:member:`i2s_std_clk_config_t::mclk_multiple` should be set to multiples that are divisible by 3 such as ``I2S_M"
"CLK_MULTIPLE_384``. Otherwise, WS will be inaccurate.

.. _i2s-communication-mode:

I2S Communication Mode


Overview of All Modes


            
 Target    Standard   PDM TX    PDM RX     TDM     ADC/DAC   LCD/Camera
            
ESP32      I2S 0/1    I2S 0     I2S 0      none     I2S 0      I2S 0
ESP32-S2    I2S 0     none      none       none     none       I2S 0
ESP32-C3    I2S 0     I2S 0     none      I2S 0     none       none
ESP32-C6    I2S 0     I2S 0     none      I2S 0     none       "
"none
ESP32-S3   I2S 0/1    I2S 0     I2S 0    I2S 0/1    none       none
ESP32-H2    I2S 0     I2S 0     none      I2S 0     none       none
ESP32-P4   I2S 0~2    I2S 0     I2S 0    I2S 0~2    none       none
            

Standard Mode


In standard mode, there are always two sound channels, i.e., the left and right channels, which are called ""slots"". These slots support 8/16/24/32-bit width sample data. The communication format for the slots mainly includes the followings:

- **Philips Format*"
"*: Data signal has one-bit shift comparing to the WS signal, and the duty of WS signal is 50%.

.. wavedrom:: /../_static/diagrams/i2s/std_philips.json

- **MSB Format**: Basically the same as Philips format, but without data shift.

.. wavedrom:: /../_static/diagrams/i2s/std_msb.json

- **PCM Short Format**: Data has one-bit shift and meanwhile the WS signal becomes a pulse lasting for one BCLK cycle.

.. wavedrom:: /../_static/diagrams/i2s/std_pcm.json


.. only:: SOC_I2S_SUPPORTS_PDM_TX

    "
"PDM Mode (TX)
    

    PDM (Pulse-density Modulation) mode for the TX channel can convert PCM data into PDM format which always has left and right slots. PDM TX is only supported on I2S0 and it only supports 16-bit width sample data. It needs at least a CLK pin for clock signal and a DOUT pin for data signal (i.e., the WS and SD signal in the following figure; the BCK signal is an internal bit sampling clock, which is not needed between PDM devices). This mode allows users to configure the up-s"
"ampling parameters :cpp:member:`i2s_pdm_tx_clk_config_t::up_sample_fp` and :cpp:member:`i2s_pdm_tx_clk_config_t::up_sample_fs`. The up-sampling rate can be calculated by ``up_sample_rate = i2s_pdm_tx_clk_config_t::up_sample_fp / i2s_pdm_tx_clk_config_t::up_sample_fs``. There are two up-sampling modes in PDM TX:

    - **Fixed Clock Frequency**: In this mode, the up-sampling rate changes according to the sample rate. Setting ``fp = 960`` and ``fs = sample_rate / 100``, then the clock frequency (F"
"pdm) on CLK pin will be fixed to ``128 * 48 KHz = 6.144 MHz``. Note that this frequency is not equal to the sample rate (Fpcm).
    - **Fixed Up-sampling Rate**: In this mode, the up-sampling rate is fixed to 2. Setting ``fp = 960`` and ``fs = 480``, then the clock frequency (Fpdm) on CLK pin will be ``128 * sample_rate``.

    .. wavedrom:: /../_static/diagrams/i2s/pdm.json


.. only:: SOC_I2S_SUPPORTS_PDM_RX

    PDM Mode (RX)
    

    PDM (Pulse-density Modulation) mode for RX channel can re"
"ceive PDM-format data and convert the data into PCM format. PDM RX is only supported on I2S0, and it only supports 16-bit width sample data. PDM RX needs at least a CLK pin for clock signal and a DIN pin for data signal. This mode allows users to configure the down-sampling parameter :cpp:member:`i2s_pdm_rx_clk_config_t::dn_sample_mode`. There are two down-sampling modes in PDM RX:

    - :cpp:enumerator:`i2s_pdm_dsr_t::I2S_PDM_DSR_8S`: In this mode, the clock frequency (Fpdm) on the WS pin is `"
"`sample_rate (Fpcm) * 64``.
    - :cpp:enumerator:`i2s_pdm_dsr_t::I2S_PDM_DSR_16S`: In this mode, the clock frequency (Fpdm) on the WS pin is ``sample_rate (Fpcm) * 128``.


.. only:: SOC_I2S_SUPPORTS_TDM

    TDM Mode
    

    TDM (Time Division Multiplexing) mode supports up to 16 slots. These slots can be enabled by :cpp:member:`i2s_tdm_slot_config_t::slot_mask`.

    .. only:: SOC_I2S_TDM_FULL_DATA_WIDTH

        Any data bit-width is supported no matter how many slots are enabled, which me"
"ans there can be up to ``32 bit-width * 16 slots = 512 bit`` data in one frame.

    .. only:: not SOC_I2S_TDM_FULL_DATA_WIDTH

        But due to the hardware limitation, only up to 4 slots are supported while the slot is set to 32 bit-width, and 8 slots for 16 bit-width, 16 slots for 8 bit-width. The slot communication format of TDM is almost the same as the standard mode, yet with some small differences.

    - **Philips Format**: Data signal has one-bit shift comparing to the WS signal. And "
"no matter how many slots are contained in one frame, the duty of WS signal always keeps 50%.

    .. wavedrom:: /../_static/diagrams/i2s/tdm_philips.json

    - **MSB Format**: Basically the same as the Philips format, but without data shift.

    .. wavedrom:: /../_static/diagrams/i2s/tdm_msb.json

    - **PCM Short Format**: Data has one-bit shift and the WS signal becomes a pulse lasting one BCLK cycle for every frame.

    .. wavedrom:: /../_static/diagrams/i2s/tdm_pcm_short.json

    - **PC"
"M Long Format**: Data has one-bit shift and the WS signal lasts one-slot bit width for every frame. For example, the duty of WS will be 25% if there are four slots enabled, and 20% if there are five slots.

    .. wavedrom:: /../_static/diagrams/i2s/tdm_pcm_long.json

.. only:: SOC_I2S_SUPPORTS_LCD_CAMERA

    LCD/Camera Mode
    

    LCD/Camera mode is only supported on I2S0 over a parallel bus. For LCD mode, I2S0 should work at master TX mode. For camera mode, I2S0 should work at slave RX mod"
"e. These two modes are not implemented by the I2S driver. Please refer to :doc:`/api-reference/peripherals/lcd` for details about the LCD implementation. For more information, see **{IDF_TARGET_NAME} Technical Reference Manual** > **I2S Controller (I2S)** > LCD Mode [`PDF `__].

.. only:: SOC_I2S_SUPPORTS_ADC_DAC

    ADC/DAC Mode
    

    ADC and DAC modes only exist on ESP32 and are only supported on I2S0. Actually, they are two sub-modes of LCD/Camera mode. I2S0 can be routed directly to the"
" internal analog-to-digital converter (ADC) and digital-to-analog converter (DAC). In other words, ADC and DAC peripherals can read or write continuously via I2S0 DMA. As they are not actual communication modes, the I2S driver does not implement them.

Functional Overview


The I2S driver offers the following services:

Resource Management


There are three levels of resources in the I2S driver:

- ``platform level``: Resources of all I2S controllers in the current target.
- ``controller level``"
": Resources in one I2S controller.
- ``channel level``: Resources of TX or RX channel in one I2S controller.

The public APIs are all channel-level APIs. The channel handle :cpp:type:`i2s_chan_handle_t` can help users to manage the resources under a specific channel without considering the other two levels. The other two upper levels' resources are private and are managed by the driver automatically. Users can call :cpp:func:`i2s_new_channel` to allocate a channel handle and call :cpp:func:`i2s_"
"del_channel` to delete it.

Power Management


When the power management is enabled (i.e., :ref:`CONFIG_PM_ENABLE` is on), the system will adjust or stop the source clock of I2S before entering Light-sleep, thus potentially changing the I2S signals and leading to transmitting or receiving invalid data.

The I2S driver can prevent the system from changing or stopping the source clock by acquiring a power management lock. When the source clock is generated from APB, the lock type will be set to :c"
"pp:enumerator:`esp_pm_lock_type_t::ESP_PM_APB_FREQ_MAX` and when the source clock is APLL (if supported), it will be set to :cpp:enumerator:`esp_pm_lock_type_t::ESP_PM_NO_LIGHT_SLEEP`. Whenever the user is reading or writing via I2S (i.e., calling :cpp:func:`i2s_channel_read` or :cpp:func:`i2s_channel_write`), the driver guarantees that the power management lock is acquired. Likewise, the driver releases the lock after the reading or writing finishes.

Finite State Machine


There are three stat"
"es for an I2S channel, namely, ``registered``, ``ready``, and ``running``. Their relationship is shown in the following diagram:

.. figure:: ../../../_static/diagrams/i2s/i2s_state_machine.png
    :align: center
    :alt: I2S Finite State Machine

    I2S Finite State Machine

The ```` in the diagram can be replaced by corresponding I2S communication modes, e.g., ``std`` for standard two-slot mode. For more information about communication modes, please refer to the :ref:`i2s-communication-mode`"
" section.

Data Transport


The data transport of the I2S peripheral, including sending and receiving, is realized by DMA. Before transporting data, please call :cpp:func:`i2s_channel_enable` to enable the specific channel. When the sent or received data reaches the size of one DMA buffer, the ``I2S_OUT_EOF`` or ``I2S_IN_SUC_EOF`` interrupt will be triggered. Note that the DMA buffer size is not equal to :cpp:member:`i2s_chan_config_t::dma_frame_num`. One frame here refers to all the sampled dat"
"a in one WS circle. Therefore, ``dma_buffer_size = dma_frame_num * slot_num * slot_bit_width / 8``. For the data transmitting, users can input the data by calling :cpp:func:`i2s_channel_write`. This function helps users to copy the data from the source buffer to the DMA TX buffer and wait for the transmission to finish. Then it will repeat until the sent bytes reach the given size. For the data receiving, the function :cpp:func:`i2s_channel_read` waits to receive the message queue which contains"
" the DMA buffer address. It helps users copy the data from the DMA RX buffer to the destination buffer.

Both :cpp:func:`i2s_channel_write` and :cpp:func:`i2s_channel_read` are blocking functions. They keeps waiting until the whole source buffer is sent or the whole destination buffer is loaded, unless they exceed the max blocking time, where the error code ``ESP_ERR_TIMEOUT`` returns. To send or receive data asynchronously, callbacks can be registered by  :cpp:func:`i2s_channel_register_event_c"
"allback`. Users are able to access the DMA buffer directly in the callback function instead of transmitting or receiving by the two blocking functions. However, please be aware that it is an interrupt callback, so do not add complex logic, run floating operation, or call non-reentrant functions in the callback.

Configuration


Users can initialize a channel by calling corresponding functions (i.e., :func:`i2s_channel_init_std_mode`, :func:`i2s_channel_init_pdm_rx_mode`, :func:`i2s_channel_init_"
"pdm_tx_mode`, or :func:`i2s_channel_init_tdm_mode`) to a specific mode. If the configurations need to be updated after initialization, users have to first call :cpp:func:`i2s_channel_disable` to ensure that the channel has stopped, and then call corresponding ``reconfig`` functions, like :cpp:func:`i2s_channel_reconfig_std_slot`, :cpp:func:`i2s_channel_reconfig_std_clock`, and :cpp:func:`i2s_channel_reconfig_std_gpio`.

IRAM Safe


By default, the I2S interrupt will be deferred when the cache is"
" disabled for reasons like writing/erasing flash. Thus the EOF interrupt will not get executed in time.

To avoid such case in real-time applications, you can enable the Kconfig option :ref:`CONFIG_I2S_ISR_IRAM_SAFE` that:

This allows the interrupt to run while the cache is disabled, but comes at the cost of increased IRAM consumption.

Thread Safety


All the public I2S APIs are guaranteed to be thread safe by the driver, which means users can call them from different RTOS tasks without protec"
"tion by extra locks. Notice that the I2S driver uses mutex lock to ensure the thread safety, thus these APIs are not allowed to be used in ISR.

Kconfig Options


- :ref:`CONFIG_I2S_ISR_IRAM_SAFE` controls whether the default ISR handler can work when the cache is disabled. See `IRAM Safe `__ for more information.
- :ref:`CONFIG_I2S_SUPPRESS_DEPRECATE_WARN` controls whether to suppress the compiling warning message while using the legacy I2S driver.
- :ref:`CONFIG_I2S_ENABLE_DEBUG_LOG` is used t"
"o enable the debug log output. Enable this option increases the firmware binary size.

Application Example


The examples of the I2S driver can be found in the directory :example:`peripherals/i2s`. Here are some simple usages of each mode:

Standard TX/RX Usage


Different slot communication formats can be generated by the following helper macros for standard mode. As described above, there are three formats in standard mode, and their helper macros are:

- :c:macro:`I2S_STD_PHILIPS_SLOT_DEFAULT"
"_CONFIG`
- :c:macro:`I2S_STD_PCM_SLOT_DEFAULT_CONFIG`
- :c:macro:`I2S_STD_MSB_SLOT_DEFAULT_CONFIG`

The clock config helper macro is:

- :c:macro:`I2S_STD_CLK_DEFAULT_CONFIG`

Please refer to :ref:`i2s-api-reference-i2s_std` for  information about STD API. And for more details, please refer to :component_file:`esp_driver_i2s/include/driver/i2s_std.h`.

STD TX Mode
~~~~~~~~~~~

Take 16-bit data width for example. When the data in a ``uint16_t`` writing buffer are:

++++++++++
| data 0 | data 1 | "
"data 2 | data 3 | data 4 | data 5 | data 6 | data 7 |  ...   |
++++++++++
| 0x0001 | 0x0002 | 0x0003 | 0x0004 | 0x0005 | 0x0006 | 0x0007 | 0x0008 |  ...   |
++++++++++

Here is the table of the real data on the line with different :cpp:member:`i2s_std_slot_config_t::slot_mode` and :cpp:member:`i2s_std_slot_config_t::slot_mask`.

.. only:: esp32

    ++++++++++++
    | data bit width | slot mode | slot mask | WS low   | WS high  | WS low   | WS high  | WS low   | WS high  | WS low   | WS high  |
"
"    ++++++++++++
    |                |  mono     |   left    | 0x0002   | 0x0000   | 0x0001   | 0x0000   | 0x0004   | 0x0000   | 0x0003   | 0x0000   |
    |     16 bit     |           ++++++++++
    |                |           |   right   | 0x0000   | 0x0002   | 0x0000   | 0x0001   | 0x0000   | 0x0004   | 0x0000   | 0x0003   |
    |                |           ++++++++++
    |                |           |   both    | 0x0002   | 0x0002   | 0x0001   | 0x0001   | 0x0004   | 0x0004   | 0x0003   | 0"
"x0003   |
    |                +++++++++++
    |                |  stereo   |   left    | 0x0001   | 0x0001   | 0x0003   | 0x0003   | 0x0005   | 0x0005   | 0x0007   | 0x0007   |
    |                |           ++++++++++
    |                |           |   right   | 0x0002   | 0x0002   | 0x0004   | 0x0004   | 0x0006   | 0x0006   | 0x0008   | 0x0008   |
    |                |           ++++++++++
    |                |           |   both    | 0x0001   | 0x0002   | 0x0003   | 0x0004   | 0x0005  "
" | 0x0006   | 0x0007   | 0x0008   |
    ++++++++++++

    .. note::

        It is similar when the data is 32-bit width, but take care when using 8-bit and 24-bit data width. For 8-bit width, the written buffer should still use ``uint16_t`` (i.e., align with 2 bytes), and only the high 8 bits are valid while the low 8 bits are dropped. For 24-bit width, the buffer is supposed to use ``uint32_t`` (i.e., align with 4 bytes), and only the high 24 bits are valid while the low 8 bits are dropped.

 "
"       Besides, for 8-bit and 16-bit mono modes, the real data on the line is swapped. To get the correct data sequence, the writing buffer needs to swap the data every two bytes.

.. only:: esp32s2

    ++++++++++++
    | data bit width | slot mode | slot mask | WS low   | WS high  | WS low   | WS high  | WS low   | WS high  | WS low   | WS high  |
    ++++++++++++
    |                |  mono     |   left    | 0x0001   | 0x0000   | 0x0002   | 0x0000   | 0x0003   | 0x0000   | 0x0004   | 0x0000 "
"  |
    |     16 bit     |           ++++++++++
    |                |           |   right   | 0x0000   | 0x0001   | 0x0000   | 0x0002   | 0x0000   | 0x0003   | 0x0000   | 0x0004   |
    |                |           ++++++++++
    |                |           |   both    | 0x0001   | 0x0001   | 0x0002   | 0x0002   | 0x0003   | 0x0003   | 0x0004   | 0x0004   |
    |                +++++++++++
    |                |  stereo   |   left    | 0x0001   | 0x0001   | 0x0003   | 0x0003   | 0x0005   | 0x0"
"005   | 0x0007   | 0x0007   |
    |                |           ++++++++++
    |                |           |   right   | 0x0002   | 0x0002   | 0x0004   | 0x0004   | 0x0006   | 0x0006   | 0x0008   | 0x0008   |
    |                |           ++++++++++
    |                |           |   both    | 0x0001   | 0x0002   | 0x0003   | 0x0004   | 0x0005   | 0x0006   | 0x0007   | 0x0008   |
    ++++++++++++

    .. note::

        Similar for 8-bit and 32-bit data widths, the type of the buffer is bet"
"ter to be ``uint8_t`` and ``uint32_t``. But specially, when the data width is 24-bit, the data buffer should be aligned with 3-byte (i.e., every 3 bytes stands for a 24-bit data in one slot). Additionally, :cpp:member:`i2s_chan_config_t::dma_frame_num`, :cpp:member:`i2s_std_clk_config_t::mclk_multiple`, and the writing buffer size should be the multiple of ``3``, otherwise the data on the line or the sample rate will be incorrect.

.. only:: not (esp32 or esp32s2)

    ++++++++++++
    | data bi"
"t width | slot mode | slot mask | WS low   | WS high  | WS low   | WS high  | WS low   | WS high  | WS low   | WS high  |
    ++++++++++++
    |                |  mono     |   left    | 0x0001   | 0x0000   | 0x0002   | 0x0000   | 0x0003   | 0x0000   | 0x0004   | 0x0000   |
    |     16 bit     |           ++++++++++
    |                |           |   right   | 0x0000   | 0x0001   | 0x0000   | 0x0002   | 0x0000   | 0x0003   | 0x0000   | 0x0004   |
    |                |           ++++++++++
   "
" |                |           |   both    | 0x0001   | 0x0001   | 0x0002   | 0x0002   | 0x0003   | 0x0003   | 0x0004   | 0x0004   |
    |                +++++++++++
    |                |  stereo   |   left    | 0x0001   | 0x0000   | 0x0003   | 0x0000   | 0x0005   | 0x0000   | 0x0007   | 0x0000   |
    |                |           ++++++++++
    |                |           |   right   | 0x0000   | 0x0002   | 0x0000   | 0x0004   | 0x0000   | 0x0006   | 0x0000   | 0x0008   |
    |                "
"|           ++++++++++
    |                |           |   both    | 0x0001   | 0x0002   | 0x0003   | 0x0004   | 0x0005   | 0x0006   | 0x0007   | 0x0008   |
    ++++++++++++

    .. note::

        Similar for 8-bit and 32-bit data widths, the type of the buffer is better to be ``uint8_t`` and ``uint32_t``. But specially, when the data width is 24-bit, the data buffer should be aligned with 3-byte (i.e., every 3 bytes stands for a 24-bit data in one slot). Additionally, :cpp:member:`i2s_chan_co"
"nfig_t::dma_frame_num`, :cpp:member:`i2s_std_clk_config_t::mclk_multiple`, and the writing buffer size should be the multiple of ``3``, otherwise the data on the line or the sample rate will be incorrect.

.. code-block:: c

    #include ""driver/i2s_std.h""
    #include ""driver/gpio.h""

    i2s_chan_handle_t tx_handle;
    /* Get the default channel configuration by the helper macro.
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    /* Allocate a new "
"TX channel and get the handle of this channel */
    i2s_new_channel(&chan_cfg, &tx_handle, NULL);

    /* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
    i2s_std_config_t std_cfg = {
        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(48000),
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = GPIO_NUM_4,
        "
"    .ws = GPIO_NUM_5,
            .dout = GPIO_NUM_18,
            .din = I2S_GPIO_UNUSED,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };
    /* Initialize the channel */
    i2s_channel_init_std_mode(tx_handle, &std_cfg);

    /* Before writing data, start the TX channel first */
    i2s_channel_enable(tx_handle);
    i2s_channel_write(tx_handle, src_buf, bytes_to_write, bytes_"
"written, ticks_to_wait);

    /* If the configurations of slot or clock need to be updated,
    // i2s_channel_disable(tx_handle);
    // std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_MONO; // Default is stereo
    // i2s_channel_reconfig_std_slot(tx_handle, &std_cfg.slot_cfg);
    // std_cfg.clk_cfg.sample_rate_hz = 96000;
    // i2s_channel_reconfig_std_clock(tx_handle, &std_cfg.clk_cfg);

    /* Have to stop the channel before deleting it */
    i2s_channel_disable(tx_handle);
    /* If the hand"
"le is not needed any more, delete it to release the channel resources */
    i2s_del_channel(tx_handle);

STD RX Mode
~~~~~~~~~~~

Taking 16-bit data width for example, when the data on the line are:

++++++++++
| WS low | WS high| WS low | WS high| WS low | WS high| WS low | WS high|  ...   |
++++++++++
| 0x0001 | 0x0002 | 0x0003 | 0x0004 | 0x0005 | 0x0006 | 0x0007 | 0x0008 |  ...   |
++++++++++

Here is the table of the data received in the buffer with different :cpp:member:`i2s_std_slot_confi"
"g_t::slot_mode` and :cpp:member:`i2s_std_slot_config_t::slot_mask`.

.. only:: esp32

    ++++++++++++
    | data bit width | slot mode | slot mask | data 0   | data 1   | data 2   | data 3   | data 4   | data 5   | data 6   | data 7   |
    ++++++++++++
    |                |  mono     |   left    | 0x0001   | 0x0000   | 0x0005   | 0x0003   | 0x0009   | 0x0007   | 0x000d   | 0x000b   |
    |                |           ++++++++++
    |     16 bit     |           |   right   | 0x0002   | 0x0000  "
" | 0x0006   | 0x0004   | 0x000a   | 0x0008   | 0x000e   | 0x000c   |
    |                +++++++++++
    |                |  stereo   |   any     | 0x0001   | 0x0002   | 0x0003   | 0x0004   | 0x0005   | 0x0006   | 0x0007   | 0x0008   |
    ++++++++++++

    .. note::

        The receive case is a little bit complicated on ESP32. Firstly, when the data width is 8-bit or 24-bit, the received data will still align with two bytes or four bytes, which means that the valid data are put in the high 8"
" bits in every two bytes and high 24 bits in every four bytes. For example, the received data will be ``0x5A00`` when the data on the line is ``0x5A`` in 8-bit width, and ``0x0000 5A00`` if the data on the line is ``0x00 005A``. Secondly, for the 8-bit or 16-bit mono case, the data in buffer is swapped every two data, so it may be necessary to manually swap the data back to the correct order.

.. only:: esp32s2

    ++++++++++++
    | data bit width | slot mode | slot mask | data 0   | data 1   "
"| data 2   | data 3   | data 4   | data 5   | data 6   | data 7   |
    ++++++++++++
    |                |  mono     |   left    | 0x0001   | 0x0003   | 0x0005   | 0x0007   | 0x0009   | 0x000b   | 0x000d   | 0x000f   |
    |                |           ++++++++++
    |     16 bit     |           |   right   | 0x0002   | 0x0004   | 0x0006   | 0x0008   | 0x000a   | 0x000c   | 0x000e   | 0x0010   |
    |                +++++++++++
    |                |  stereo   |   any     | 0x0001   | 0x0002   |"
" 0x0003   | 0x0004   | 0x0005   | 0x0006   | 0x0007   | 0x0008   |
    ++++++++++++

    .. note::

        8-bit, 24-bit, and 32-bit are similar as 16-bit, where the data bit-width in the receiving buffer is equal to the data bit-width on the line. Additionally, when using 24-bit data width, :cpp:member:`i2s_chan_config_t::dma_frame_num`, :cpp:member:`i2s_std_clk_config_t::mclk_multiple`, and the receiving buffer size should be the multiple of ``3``, otherwise the data on the line or the sample"
" rate will be incorrect.

.. only:: not (esp32 or esp32s2)

    ++++++++++++
    | data bit width | slot mode | slot mask | data 0   | data 1   | data 2   | data 3   | data 4   | data 5   | data 6   | data 7   |
    ++++++++++++
    |                |  mono     |   left    | 0x0001   | 0x0003   | 0x0005   | 0x0007   | 0x0009   | 0x000b   | 0x000d   | 0x000f   |
    |                |           ++++++++++
    |     16 bit     |           |   right   | 0x0002   | 0x0004   | 0x0006   | 0x0008   | 0"
"x000a   | 0x000c   | 0x000e   | 0x0010   |
    |                +++++++++++
    |                |  stereo   |   any     | 0x0001   | 0x0002   | 0x0003   | 0x0004   | 0x0005   | 0x0006   | 0x0007   | 0x0008   |
    ++++++++++++

    .. note::

        8-bit, 24-bit, and 32-bit are similar as 16-bit, the data bit-width in the receiving buffer is equal to the data bit-width on the line. Additionally, when using 24-bit data width, :cpp:member:`i2s_chan_config_t::dma_frame_num`, :cpp:member:`i2s_std"
"_clk_config_t::mclk_multiple`, and the receiving buffer size should be the multiple of ``3``, otherwise the data on the line or the sample rate will be incorrect.

.. code-block:: c

    #include ""driver/i2s_std.h""
    #include ""driver/gpio.h""

    i2s_chan_handle_t rx_handle;
    /* Get the default channel configuration by helper macro.
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    /* Allocate a new RX channel and get the handle of this channel "
"*/
    i2s_new_channel(&chan_cfg, NULL, &rx_handle);

    /* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
    i2s_std_config_t std_cfg = {
        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(48000),
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = GPIO_NUM_4,
            .ws = GPIO_NUM_5,
            .dout = I2S_"
"GPIO_UNUSED,
            .din = GPIO_NUM_19,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };
    /* Initialize the channel */
    i2s_channel_init_std_mode(rx_handle, &std_cfg);

    /* Before reading data, start the RX channel first */
    i2s_channel_enable(rx_handle);
    i2s_channel_read(rx_handle, desc_buf, bytes_to_read, bytes_read, ticks_to_wait);

    /* Have to stop the "
"channel before deleting it */
    i2s_channel_disable(rx_handle);
    /* If the handle is not needed any more, delete it to release the channel resources */
    i2s_del_channel(rx_handle);


.. only:: SOC_I2S_SUPPORTS_PDM_TX

    PDM TX Usage
    

    For PDM mode in TX channel, the slot configuration helper macro is:

    - :c:macro:`I2S_PDM_TX_SLOT_DEFAULT_CONFIG`

    The clock configuration helper macro is:

    - :c:macro:`I2S_PDM_TX_CLK_DEFAULT_CONFIG`

    Please refer to :ref:`i2s-api-r"
"eference-i2s_pdm` for information about PDM TX API. And for more details, please refer to :component_file:`esp_driver_i2s/include/driver/i2s_pdm.h`.

    The PDM data width is fixed to 16-bit. When the data in an ``int16_t`` writing buffer is:

    ++++++++++
    | data 0 | data 1 | data 2 | data 3 | data 4 | data 5 | data 6 | data 7 |  ...   |
    ++++++++++
    | 0x0001 | 0x0002 | 0x0003 | 0x0004 | 0x0005 | 0x0006 | 0x0007 | 0x0008 |  ...   |
    ++++++++++

    .. only:: esp32

        Here i"
"s the table of the real data on the line with different :cpp:member:`i2s_pdm_tx_slot_config_t::slot_mode` and :cpp:member:`i2s_pdm_tx_slot_config_t::slot_mask` (The PDM format on the line is transferred to PCM format for better comprehension).

        +++++++++++
        | slot mode | slot mask |  left    |  right   |  left    |  right   |  left    |  right   |  left    |  right   |
        +++++++++++
        |  mono     |   left    | 0x0001   | 0x0000   | 0x0002   | 0x0000   | 0x0003   | 0x00"
"00   | 0x0004   | 0x0000   |
        |           ++++++++++
        |           |   right   | 0x0000   | 0x0001   | 0x0000   | 0x0002   | 0x0000   | 0x0003   | 0x0000   | 0x0004   |
        |           ++++++++++
        |           |   both    | 0x0001   | 0x0001   | 0x0002   | 0x0002   | 0x0003   | 0x0003   | 0x0004   | 0x0004   |
        +++++++++++
        |  stereo   |   left    | 0x0001   | 0x0001   | 0x0003   | 0x0003   | 0x0005   | 0x0005   | 0x0007   | 0x0007   |
        |           +++"
"+++++++
        |           |   right   | 0x0002   | 0x0002   | 0x0004   | 0x0004   | 0x0006   | 0x0006   | 0x0008   | 0x0008   |
        |           ++++++++++
        |           |   both    | 0x0001   | 0x0002   | 0x0003   | 0x0004   | 0x0005   | 0x0006   | 0x0007   | 0x0008   |
        +++++++++++

    .. only:: not esp32

        Here is the table of the real data on the line with different :cpp:member:`i2s_pdm_tx_slot_config_t::slot_mode` and :cpp:member:`i2s_pdm_tx_slot_config_t::line_mod"
"e` (The PDM format on the line is transferred to PCM format for easier comprehension).

        ++++++++++++
        |    line mode   | slot mode | line |  left  |  right |  left  |  right |  left  |  right |  left  |  right |
        ++++++++++++
        |                |    mono   | dout | 0x0001 | 0x0000 | 0x0002 | 0x0000 | 0x0003 | 0x0000 | 0x0004 | 0x0000 |
        | one-line Codec +++++++++++
        |                |   stereo  | dout | 0x0001 | 0x0002 | 0x0003 | 0x0004 | 0x0005 | 0x0006"
" | 0x0007 | 0x0008 |
        ++++++++++++
        |  one-line DAC  |    mono   | dout | 0x0001 | 0x0001 | 0x0002 | 0x0002 | 0x0003 | 0x0003 | 0x0004 | 0x0004 |
        ++++++++++++
        |                |    mono   | dout | 0x0002 | 0x0002 | 0x0004 | 0x0004 | 0x0006 | 0x0006 | 0x0008 | 0x0008 |
        |                |           ++++++++++
        |                |           | dout2| 0x0000 | 0x0000 | 0x0000 | 0x0000 | 0x0000 | 0x0000 | 0x0000 | 0x0000 |
        |  two-line DAC  ++++++++++"
"+
        |                |   stereo  | dout | 0x0002 | 0x0002 | 0x0004 | 0x0004 | 0x0006 | 0x0006 | 0x0008 | 0x0008 |
        |                |           ++++++++++
        |                |           | dout2| 0x0001 | 0x0001 | 0x0003 | 0x0003 | 0x0005 | 0x0005 | 0x0007 | 0x0007 |
        ++++++++++++

        .. note::

            There are three line modes for PDM TX mode, i.e., ``I2S_PDM_TX_ONE_LINE_CODEC``, ``I2S_PDM_TX_ONE_LINE_DAC``, and ``I2S_PDM_TX_TWO_LINE_DAC``. One-line codec is "
"for the PDM codecs that require clock signal. The PDM codec can differentiate the left and right slots by the clock level. The other two modes are used to drive power amplifiers directly with a low-pass filter. They do not need the clock signal, so there are two lines to differentiate the left and right slots. Additionally, for the mono mode of one-line codec, users can force change the slot to the right by setting the clock invert flag in GPIO configuration.


    .. code-block:: c

        #in"
"clude ""driver/i2s_pdm.h""
        #include ""driver/gpio.h""

        /* Allocate an I2S TX channel */
        i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
        i2s_new_channel(&chan_cfg, &tx_handle, NULL);

        /* Init the channel into PDM TX mode */
        i2s_pdm_tx_config_t pdm_tx_cfg = {
            .clk_cfg = I2S_PDM_TX_CLK_DEFAULT_CONFIG(36000),
            .slot_cfg = I2S_PDM_TX_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO)"
",
            .gpio_cfg = {
                .clk = GPIO_NUM_5,
                .dout = GPIO_NUM_18,
                .invert_flags = {
                    .clk_inv = false,
                },
            },
        };
        i2s_channel_init_pdm_tx_mode(tx_handle, &pdm_tx_cfg);

        ...


.. only:: SOC_I2S_SUPPORTS_PDM_RX

    PDM RX Usage
    

    For PDM mode in RX channel, the slot configuration helper macro is:

    - :c:macro:`I2S_PDM_RX_SLOT_DEFAULT_CONFIG`

    The clock configuratio"
"n helper macro is:

    - :c:macro:`I2S_PDM_RX_CLK_DEFAULT_CONFIG`

    Please refer to :ref:`i2s-api-reference-i2s_pdm` for information about PDM RX API. And for more details, please refer to :component_file:`esp_driver_i2s/include/driver/i2s_pdm.h`.

    The PDM data width is fixed to 16-bit. When the data on the line (The PDM format on the line is transferred to PCM format for easier comprehension) is:

    ++++++++++
    |  left  |  right |  left  |  right |  left  |  right |  left  |  right"
" |  ...   |
    ++++++++++
    | 0x0001 | 0x0002 | 0x0003 | 0x0004 | 0x0005 | 0x0006 | 0x0007 | 0x0008 |  ...   |
    ++++++++++

    Here is the table of the data received in a ``int16_t`` buffer with different :cpp:member:`i2s_pdm_rx_slot_config_t::slot_mode` and :cpp:member:`i2s_pdm_rx_slot_config_t::slot_mask`.

    .. only:: esp32

        +++++++++++
        | slot mode | slot mask | data 0   | data 1   | data 2   | data 3   | data 4   | data 5   | data 6   | data 7   |
        +++++++++++"
"
        |  mono     |   left    | 0x0001   | 0x0003   | 0x0005   | 0x0007   | 0x0009   | 0x000b   | 0x000d   | 0x000f   |
        |           ++++++++++
        |           |   right   | 0x0002   | 0x0004   | 0x0006   | 0x0008   | 0x000a   | 0x000c   | 0x000e   | 0x0010   |
        +++++++++++
        |  stereo   |   both    | 0x0001   | 0x0002   | 0x0003   | 0x0004   | 0x0005   | 0x0006   | 0x0007   | 0x0008   |
        +++++++++++

    .. only:: esp32s3

        +++++++++++
        | slot mod"
"e | slot mask | data 0   | data 1   | data 2   | data 3   | data 4   | data 5   | data 6   | data 7   |
        +++++++++++
        |  mono     |   left    | 0x0001   | 0x0003   | 0x0005   | 0x0007   | 0x0009   | 0x000b   | 0x000d   | 0x000f   |
        |           ++++++++++
        |           |   right   | 0x0002   | 0x0004   | 0x0006   | 0x0008   | 0x000a   | 0x000c   | 0x000e   | 0x0010   |
        +++++++++++
        |  stereo   |   both    | 0x0002   | 0x0001   | 0x0004   | 0x0003   | 0x0"
"006   | 0x0005   | 0x0008   | 0x0007   |
        +++++++++++

        .. note::

            The right slot is received first in stereo mode. To switch the left and right slots in the buffer, please set the :cpp:member:`i2s_pdm_rx_gpio_config_t::invert_flags::clk_inv` to force invert the clock signal.

            Specially, ESP32-S3 supports up to 4 data lines in PDM RX mode, where each data line can be connected to two PDM MICs (left and right slots). This means that the PDM RX on ESP32-S3 can"
" support up to 8 PDM MICs. To enable multiple data lines, set the bits in :cpp:member:`i2s_pdm_rx_gpio_config_t::slot_mask` to enable corresponding slots first, and then set the data GPIOs in :cpp:type:`i2s_pdm_rx_gpio_config_t`.

    .. code-block:: c

        #include ""driver/i2s_pdm.h""
        #include ""driver/gpio.h""

        i2s_chan_handle_t rx_handle;

        /* Allocate an I2S RX channel */
        i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
    "
"    i2s_new_channel(&chan_cfg, NULL, &rx_handle);

        /* Init the channel into PDM RX mode */
        i2s_pdm_rx_config_t pdm_rx_cfg = {
            .clk_cfg = I2S_PDM_RX_CLK_DEFAULT_CONFIG(36000),
            .slot_cfg = I2S_PDM_RX_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),
            .gpio_cfg = {
                .clk = GPIO_NUM_5,
                .din = GPIO_NUM_19,
                .invert_flags = {
                    .clk_inv = false,
                },
       "
"     },
        };
        i2s_channel_init_pdm_rx_mode(rx_handle, &pdm_rx_cfg);

        ...


.. only:: SOC_I2S_SUPPORTS_TDM

    TDM TX/RX Usage
    

    Different slot communication formats can be generated by the following helper macros for TDM mode. As described above, there are four formats in TDM mode, and their helper macros are:

    - :c:macro:`I2S_TDM_PHILIPS_SLOT_DEFAULT_CONFIG`
    - :c:macro:`I2S_TDM_MSB_SLOT_DEFAULT_CONFIG`
    - :c:macro:`I2S_TDM_PCM_SHORT_SLOT_DEFAULT_CONFIG`
"
"    - :c:macro:`I2S_TDM_PCM_LONG_SLOT_DEFAULT_CONFIG`

    The clock config helper macro is:

    - :c:macro:`I2S_TDM_CLK_DEFAULT_CONFIG`

    Please refer to :ref:`i2s-api-reference-i2s_tdm` for information about TDM API. And for more details, please refer to :component_file:`esp_driver_i2s/include/driver/i2s_tdm.h`.

    .. note::

        Due to hardware limitation, when setting the clock configuration for a slave role, please be aware that :cpp:member:`i2s_tdm_clk_config_t::bclk_div` should "
"not be smaller than 8. Increasing this field can reduce the lagging of the data sent from the slave. In the high sample rate case, the data might lag behind for more than one BCLK which leads to data malposition. Users may gradually increase :cpp:member:`i2s_tdm_clk_config_t::bclk_div` to correct it.

        As :cpp:member:`i2s_tdm_clk_config_t::bclk_div` is the division of MCLK to BCLK, increasing it also increases the MCLK frequency. Therefore, the clock calculation may fail if MCLK is too hi"
"gh to divide from the source clock. This means that a larger value for :cpp:member:`i2s_tdm_clk_config_t::bclk_div` is not necessarily better.

    TDM TX Mode
    ~~~~~~~~~~~

    .. code-block:: c

        #include ""driver/i2s_tdm.h""
        #include ""driver/gpio.h""

        /* Allocate an I2S TX channel */
        i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
        i2s_new_channel(&chan_cfg, &tx_handle, NULL);

        /* Init the channel into TDM m"
"ode */
        i2s_tdm_config_t tdm_cfg = {
            .clk_cfg = I2S_TDM_CLK_DEFAULT_CONFIG(44100),
            .slot_cfg = I2S_TDM_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO,
                        I2S_TDM_SLOT0 | I2S_TDM_SLOT1 | I2S_TDM_SLOT2 | I2S_TDM_SLOT3),
            .gpio_cfg = {
                .mclk = I2S_GPIO_UNUSED,
                .bclk = GPIO_NUM_4,
                .ws = GPIO_NUM_5,
                .dout = GPIO_NUM_18,
                .din = I2S_GPIO_"
"UNUSED,
                .invert_flags = {
                    .mclk_inv = false,
                    .bclk_inv = false,
                    .ws_inv = false,
                },
            },
        };
        i2s_channel_init_tdm_mode(tx_handle, &tdm_cfg);

        ...

    TDM RX Mode
    ~~~~~~~~~~~

    .. code-block:: c

        #include ""driver/i2s_tdm.h""
        #include ""driver/gpio.h""

        /* Set the channel mode to TDM */
        i2s_chan_config_t chan_cfg = I2S_CHANNEL_CONFIG(I2S_"
"ROLE_MASTER, I2S_COMM_MODE_TDM, &i2s_pin);
        i2s_new_channel(&chan_cfg, NULL, &rx_handle);

        /* Init the channel into TDM mode */
        i2s_tdm_config_t tdm_cfg = {
            .clk_cfg = I2S_TDM_CLK_DEFAULT_CONFIG(44100),
            .slot_cfg = I2S_TDM_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO,
                        I2S_TDM_SLOT0 | I2S_TDM_SLOT1 | I2S_TDM_SLOT2 | I2S_TDM_SLOT3),
            .gpio_cfg = {
                .mclk = I2S_GPIO_UNUSED,
   "
"             .bclk = GPIO_NUM_4,
                .ws = GPIO_NUM_5,
                .dout = I2S_GPIO_UNUSED,
                .din = GPIO_NUM_18,
                .invert_flags = {
                    .mclk_inv = false,
                    .bclk_inv = false,
                    .ws_inv = false,
                },
            },
        };
        i2s_channel_init_tdm_mode(rx_handle, &tdm_cfg);
        ...

Full-duplex


Full-duplex mode registers TX and RX channel in an I2S port at the same time, a"
"nd the channels share the BCLK and WS signals. Currently, STD and TDM communication modes supports full-duplex mode in the following way, but PDM full-duplex is not supported because due to different PDM TX and RX clocks.

Note that one handle can only stand for one channel. Therefore, it is still necessary to configure the slot and clock for both TX and RX channels one by one.

Here is an example of how to allocate a pair of full-duplex channels:

.. code-block:: c

    #include ""driver/i2s_std"
".h""
    #include ""driver/gpio.h""

    i2s_chan_handle_t tx_handle;
    i2s_chan_handle_t rx_handle;

    /* Allocate a pair of I2S channel */
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    /* Allocate for TX and RX channel at the same time, then they will work in full-duplex mode */
    i2s_new_channel(&chan_cfg, &tx_handle, &rx_handle);

    /* Set the configurations for BOTH TWO channels, since TX and RX channel have to be same in full-duplex mo"
"de */
    i2s_std_config_t std_cfg = {
        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(32000),
        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = GPIO_NUM_4,
            .ws = GPIO_NUM_5,
            .dout = GPIO_NUM_18,
            .din = GPIO_NUM_19,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                "
".ws_inv = false,
            },
        },
    };
    i2s_channel_init_std_mode(tx_handle, &std_cfg);
    i2s_channel_init_std_mode(rx_handle, &std_cfg);

    i2s_channel_enable(tx_handle);
    i2s_channel_enable(rx_handle);

    ...

.. only:: SOC_I2S_HW_VERSION_1

    Simplex Mode
    

    To allocate a channel handle in simplex mode, :cpp:func:`i2s_new_channel` should be called for each channel. The clock and GPIO pins of TX/RX channel on {IDF_TARGET_NAME} are not independent, so the TX and "
"RX channel cannot coexist on the same I2S port in simplex mode.

    .. code-block:: c

        #include ""driver/i2s_std.h""
        #include ""driver/gpio.h""

        i2s_chan_handle_t tx_handle;
        i2s_chan_handle_t rx_handle;

        i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
        i2s_new_channel(&chan_cfg, &tx_handle, NULL);
        i2s_std_config_t std_tx_cfg = {
            .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(48000),
            .slot_c"
"fg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
            .gpio_cfg = {
                .mclk = GPIO_NUM_0,
                .bclk = GPIO_NUM_4,
                .ws = GPIO_NUM_5,
                .dout = GPIO_NUM_18,
                .din = I2S_GPIO_UNUSED,
                .invert_flags = {
                    .mclk_inv = false,
                    .bclk_inv = false,
                    .ws_inv = false,
                },
            },
        };
       "
" /* Initialize the channel */
        i2s_channel_init_std_mode(tx_handle, &std_tx_cfg);
        i2s_channel_enable(tx_handle);

        /* RX channel will be registered on another I2S, if no other available I2S unit found
        i2s_new_channel(&chan_cfg, NULL, &rx_handle);
        i2s_std_config_t std_rx_cfg = {
            .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(16000),
            .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
            .gpio_cf"
"g = {
                .mclk = I2S_GPIO_UNUSED,
                .bclk = GPIO_NUM_6,
                .ws = GPIO_NUM_7,
                .dout = I2S_GPIO_UNUSED,
                .din = GPIO_NUM_19,
                .invert_flags = {
                    .mclk_inv = false,
                    .bclk_inv = false,
                    .ws_inv = false,
                },
            },
        };
        i2s_channel_init_std_mode(rx_handle, &std_rx_cfg);
        i2s_channel_enable(rx_handle);

.. only:: SOC"
"_I2S_HW_VERSION_2

    Simplex Mode
    

    To allocate a channel in simplex mode, :cpp:func:`i2s_new_channel` should be called for each channel. The clock and GPIO pins of TX/RX channel on {IDF_TARGET_NAME} are independent, so they can be configured with different modes and clocks, and are able to coexist on the same I2S port in simplex mode. PDM duplex can be realized by registering PDM TX simplex and PDM RX simplex on the same I2S port. But in this way, PDM TX/RX might work with different c"
"locks, so take care when configuring the GPIO pins and clocks.

    The following example offers a use case for the simplex mode, but note that although the internal MCLK signals for TX and RX channel are separate, the output MCLK can only be bound to one of them if they are from the same controller. If MCLK has been initialized by both channels, it will be bound to the channel that initializes later.

    .. code-block:: c

        #include ""driver/i2s_std.h""
        #include ""driver/gpio.h""

 "
"       i2s_chan_handle_t tx_handle;
        i2s_chan_handle_t rx_handle;
        i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
        i2s_new_channel(&chan_cfg, &tx_handle, NULL);
        i2s_std_config_t std_tx_cfg = {
            .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(48000),
            .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
            .gpio_cfg = {
                .mclk = GPIO_NUM_0,
           "
"     .bclk = GPIO_NUM_4,
                .ws = GPIO_NUM_5,
                .dout = GPIO_NUM_18,
                .din = I2S_GPIO_UNUSED,
                .invert_flags = {
                    .mclk_inv = false,
                    .bclk_inv = false,
                    .ws_inv = false,
                },
            },
        };
        /* Initialize the channel */
        i2s_channel_init_std_mode(tx_handle, &std_tx_cfg);
        i2s_channel_enable(tx_handle);

        /* RX channel will be regi"
"stered on another I2S, if no other available I2S unit found
        i2s_new_channel(&chan_cfg, NULL, &rx_handle); // Both RX and TX channel will be registered on I2S0, but they can work with different configurations.
        i2s_std_config_t std_rx_cfg = {
            .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(16000),
            .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
            .gpio_cfg = {
                .mclk = I2S_GPIO_UNUSED,
             "
"   .bclk = GPIO_NUM_6,
                .ws = GPIO_NUM_7,
                .dout = I2S_GPIO_UNUSED,
                .din = GPIO_NUM_19,
                .invert_flags = {
                    .mclk_inv = false,
                    .bclk_inv = false,
                    .ws_inv = false,
                },
            },
        };
        i2s_channel_init_std_mode(rx_handle, &std_rx_cfg);
        i2s_channel_enable(rx_handle);


Application Notes


How to Prevent Data Lost


For applications that nee"
"d a high frequency sample rate, the massive data throughput may cause data lost. Users can receive data lost event by registering the ISR callback function to receive the event queue:

    .. code-block:: c

        static IRAM_ATTR bool i2s_rx_queue_overflow_callback(i2s_chan_handle_t handle, i2s_event_data_t *event, void *user_ctx)
        {
            // handle RX queue overflow event ...
            return false;
        }

        i2s_event_callbacks_t cbs = {
            .on_recv = NULL,
"
"            .on_recv_q_ovf = i2s_rx_queue_overflow_callback,
            .on_sent = NULL,
            .on_send_q_ovf = NULL,
        };
        TEST_ESP_OK(i2s_channel_register_event_callback(rx_handle, &cbs, NULL));

Please follow these steps to prevent data lost:

    interrupt_interval(unit: sec) = dma_frame_num / sample_rate
    dma_buffer_size = dma_frame_num * slot_num * data_bit_width / 8  polling_cycle / interrupt_interval

    recv_buffer_size > dma_desc_num * dma_buffer_size

For examp"
"le, if there is an I2S application, and the known values are::

    sample_rate = 144000 Hz
    data_bit_width = 32 bits
    slot_num = 2
    polling_cycle = 10 ms

Then the parameters ``dma_frame_num``, ``dma_desc_num``, and ``recv_buf_size`` can be calculated as follows::

    dma_frame_num * slot_num * data_bit_width / 8 = dma_buffer_size  polling_cycle / interrupt_interval = cell(10 / 3.549) = cell(2.818) = 3
    recv_buffer_size > dma_desc_num * dma_buffer_size = 3 * 4092 = 12276 bytes


AP"
"I Reference


.. _i2s-api-reference-i2s_std:

Standard Mode


.. include-build-file:: inc/i2s_std.inc

.. only:: SOC_I2S_SUPPORTS_PDM

    .. _i2s-api-reference-i2s_pdm:

    PDM Mode
    

    .. include-build-file:: inc/i2s_pdm.inc

.. only:: SOC_I2S_SUPPORTS_TDM

    .. _i2s-api-reference-i2s_tdm:

    TDM Mode
    

    .. include-build-file:: inc/i2s_tdm.inc

.. _i2s-api-reference-i2s_driver:

I2S Driver


.. include-build-file:: inc/i2s_common.inc

.. _i2s-api-reference-i2s_types:

I2S Typ"
"es


.. include-build-file:: inc/components/esp_driver_i2s/include/driver/i2s_types.inc
.. include-build-file:: inc/components/hal/include/hal/i2s_types.inc
"
"Analog to Digital Converter (ADC) Continuous Mode Driver




{IDF_TARGET_ADC_NUM:default=""two"", esp32c2=""one"", esp32c6=""one"", esp32h2=""one""}

Introduction


The Analog to Digital Converter is integrated on the chip and is capable of measuring analog signals from specific analog IO pads. Additionally, the Direct Memory Access (DMA) functionality is utilized to efficiently retrieve ADC conversion results.

{IDF_TARGET_NAME} has {IDF_TARGET_ADC_NUM} ADC unit(s), which can be used in scenarios like:"
"

- Generate one-shot ADC conversion result
- Generate continuous ADC conversion results

This guide introduces ADC continuous mode conversion.

Driver Concepts


ADC continuous mode conversion is made up of multiple conversion frames.

- Conversion Frame: One conversion frame contains multiple conversion results. Conversion frame size is configured in :cpp:func:`adc_continuous_new_handle` in bytes.
- Conversion Result: One conversion result contains multiple bytes, see :c:macro:`SOC_ADC_DIGI_RE"
"SULT_BYTES`. Its structure is :cpp:type:`adc_digi_output_data_t`, including ADC unit, ADC channel, and raw data.

.. image:: /../_static/diagrams/adc/adc_conversion_frame.png
    :scale: 100 %
    :align: center

Functional Overview


The following sections of this document cover the typical steps to install the ADC continuous mode driver, and read ADC conversion results from a group of ADC channels continuously:

- :ref:`adc-continuous-resource-allocation`: covers which parameters should be set"
" up to initialize the ADC continuous mode driver and how to deinitialize it.
- :ref:`adc-continuous-adc-configurations`: describes how to configure the ADC(s) to make it work under continuous mode.
- :ref:`adc-continuous-adc-control`: describes ADC control functions.
- :ref:`adc-continuous-register-event-callbacks`: describes how to hook user-specific code to an ADC continuous mode event callback function.
- :ref:`adc-continuous-read-conversion-result`: covers how to get ADC conversion result.
-"
" :ref:`adc-continuous-hardware-limitations`: describes the ADC-related hardware limitations.
- :ref:`adc-continuous-power-management`: covers power management-related information.
- :ref:`adc-continuous-iram-safe`: covers the IRAM safe functions.
- :ref:`adc-continuous-thread-safety`: lists which APIs are guaranteed to be thread-safe by the driver.


.. _adc-continuous-resource-allocation:

Resource Allocation


The ADC continuous mode driver is implemented based on {IDF_TARGET_NAME} SAR ADC mod"
"ule. Different ESP targets might have different numbers of independent ADCs.

To create an ADC continuous mode driver handle, set up the required configuration structure :cpp:type:`adc_continuous_handle_cfg_t`:

- :cpp:member:`adc_continuous_handle_cfg_t::max_store_buf_size`: set the maximum size of the pool in bytes, and the driver saves ADC conversion result into the pool. If this pool is full, new conversion results will be lost.
- :cpp:member:`adc_continuous_handle_cfg_t::conv_frame_size`: s"
"et the size of the ADC conversion frame, in bytes.
- :cpp:member:`adc_continuous_handle_cfg_t::flags`: set the flags that can change the driver's behavior.

  - ``flush_pool``: auto flush the pool when it's full.


After setting up the above configurations for the ADC, call :cpp:func:`adc_continuous_new_handle` with the prepared :cpp:type:`adc_continuous_handle_cfg_t`. This function may fail due to various errors such as invalid arguments, insufficient memory, etc.

.. only:: esp32

    Especial"
"ly, when this function returns :c:macro:`ESP_ERR_NOT_FOUND`, this means the I2S0 peripheral is in use. See :ref:`adc-continuous-hardware-limitations` for more information.

.. only:: esp32s2

    Especially, when this function returns :c:macro:`ESP_ERR_NOT_FOUND`, this means the SPI3 peripheral is in use. See :ref:`adc-continuous-hardware-limitations` for more information.

.. only:: SOC_GDMA_SUPPORTED

    Especially, when this function returns :c:macro:`ESP_ERR_NOT_FOUND`, this means there is "
"no free GDMA channel.

If the ADC continuous mode driver is no longer used, you should deinitialize the driver by calling :cpp:func:`adc_continuous_deinit`.


.. only:: SOC_ADC_DIG_IIR_FILTER_SUPPORTED

    IIR filter
    ~~~~~~~~~~

    Two IIR filters are available when ADC is working in continuous mode. To create an ADC IIR filter, you should set up :cpp:type:`adc_continuous_iir_filter_config_t` and call :cpp:func:`adc_new_continuous_iir_filter`.

    - :cpp:member:`adc_digi_filter_config_t::"
"unit`: ADC unit.
    - :cpp:member:`adc_digi_filter_config_t::channel`: ADC channel to be filtered.
    - :cpp:member:`adc_digi_filter_config_t::coeff`: Filter coefficient.

    .. only:: SOC_ADC_DIG_IIR_FILTER_UNIT_BINDED

            On {IDF_TARGET_NAME}, the filter is per ADC unit. Once a filter is enabled, all the enabled ADC channels in this ADC unit will be filtered. However, we suggest only enabling one ADC channel per unit, when using the filter feature. Because the filtered results depe"
"nd on the previous filtered result. So you should not enable multiple ADC channels, to avoid mixing the filtered results.

    To recycle a filter, you should call :cpp:func:`adc_del_continuous_iir_filter`.

    .. only:: not SOC_ADC_DIG_IIR_FILTER_UNIT_BINDED

        .. note::

            If you use both filters on the same ADC channel, then only the first one will take effect.

.. only:: SOC_ADC_MONITOR_SUPPORTED

    Monitor
    ~~~~~~~

    {IDF_TARGET_SOC_ADC_DIGI_MONITOR_NUM} monitors ar"
"e available when ADC is working under continuous mode, you can set one or two threshold(s) of a monitor on a working ADC channel, then the monitor will invoke interrupts every sample loop if conversion result outranges of the threshold. To create an ADC monitor, you need to set up the :cpp:type:`adc_monitor_config_t` and call :cpp:func:`adc_new_continuous_monitor`.

    - :cpp:member:`adc_monitor_config_t::adc_unit`: Configures which ADC unit the channel you want to monitor belongs to.
    - :cp"
"p:member:`adc_monitor_config_t::channel`: The channel you want to monitor.
    - :cpp:member:`adc_monitor_config_t::h_threshold`: The high threshold, conversion result larger than this value invokes interrupt, set to -1 if do not use.
    - :cpp:member:`adc_monitor_config_t::l_threshold`: The low threshold, conversion result less than this value invokes interrupt, set to -1 if do not use.

    Once a monitor is created, you can operate it by following APIs to construct your apps.

    - :cpp:fun"
"c:`adc_continuous_monitor_enable`: Enable a monitor.
    - :cpp:func:`adc_continuous_monitor_disable`: Disable a monitor.
    - :cpp:func:`adc_monitor_register_callbacks`: register user callbacks to take action when the ADC value exceeds of the threshold.
    - :cpp:func:`adc_del_continuous_monitor`: Delete a created monitor and free resources.

    .. only:: esp32s2

        .. NOTE::

            There are some hardware limitations on {IDF_TARGET_NAME}:

Initialize the ADC Continuous Mode Driv"
"er
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: c

    adc_continuous_handle_cfg_t adc_config = {
        .max_store_buf_size = 1024,
        .conv_frame_size = 100,
    };
    ESP_ERROR_CHECK(adc_continuous_new_handle(&adc_config));


Recycle the ADC Unit
~~~~~~~~~~~~~~~~~~~~

.. code:: c

    ESP_ERROR_CHECK(adc_continuous_deinit());


.. _adc-continuous-adc-configurations:

ADC Configurations


After the ADC continuous mode driver is initialized, set up the :cpp:type:`adc_continuous_c"
"onfig_t` to configure ADC IOs to measure analog signal:

- :cpp:member:`adc_continuous_config_t::pattern_num`: number of ADC channels that will be used.
- :cpp:member:`adc_continuous_config_t::adc_pattern`: list of configs for each ADC channel that will be used, see the description below.
- :cpp:member:`adc_continuous_config_t::sample_freq_hz`: expected ADC sampling frequency in Hz.
- :cpp:member:`adc_continuous_config_t::conv_mode`: continuous conversion mode.
- :cpp:member:`adc_continuous_conf"
"ig_t::format`: conversion output format.

Set :cpp:type:`adc_digi_pattern_config_t` with the following process:

- :cpp:member:`adc_digi_pattern_config_t::atten`: ADC attenuation. Refer to the On-Chip Sensor and Analog Signal Processing chapter in `TRM `__.
- :cpp:member:`adc_digi_pattern_config_t::channel`: the IO corresponding ADC channel number. See the note below.
- :cpp:member:`adc_digi_pattern_config_t::unit`: the ADC that the IO is subordinate to.
- :cpp:member:`adc_digi_pattern_config_t:"
":bit_width`: the bitwidth of the raw conversion result.

.. note::

    For the IO corresponding ADC channel number, check `TRM `__ to acquire the ADC IOs. Besides, :cpp:func:`adc_continuous_io_to_channel` and :cpp:func:`adc_continuous_channel_to_io` can be used to acquire the ADC channels and ADC IOs.

To make these settings take effect, call :cpp:func:`adc_continuous_config` with the configuration structure above. This API may fail due to reasons like :c:macro:`ESP_ERR_INVALID_ARG`. When it re"
"turns :c:macro:`ESP_ERR_INVALID_STATE`, this means the ADC continuous mode driver is started, you should not call this API at this moment.

See ADC continuous mode example :example:`peripherals/adc/continuous_read` to see configuration codes.


.. only:: SOC_ADC_DIG_IIR_FILTER_SUPPORTED

    To enable/disable the ADC IIR filter, you should call :cpp:func:`adc_continuous_iir_filter_enable` / :cpp:func:`adc_continuous_iir_filter_disable`.

.. only:: SOC_ADC_MONITOR_SUPPORTED

    To enable/disable"
" the ADC monitor, you should call :cpp:func:`adc_continuous_monitor_enable` / :cpp:func:`adc_continuous_monitor_disable`.

.. _adc-continuous-adc-control:

ADC Control


Start and Stop
~~~~~~~~~~~~~~

Calling :cpp:func:`adc_continuous_start` makes the ADC start to measure analog signals from the configured ADC channels, and generate the conversion results.

On the contrary, calling :cpp:func:`adc_continuous_stop` stops the ADC conversion.

.. code::c

    ESP_ERROR_CHECK(adc_continuous_start());"
"

.. code:: c

    ESP_ERROR_CHECK(adc_continuous_stop());


.. _adc-continuous-register-event-callbacks:

Register Event Callbacks


By calling :cpp:func:`adc_continuous_register_event_callbacks`, you can hook your own function to the driver ISR. Supported event callbacks are listed in :cpp:type:`adc_continuous_evt_cbs_t`.

- :cpp:member:`adc_continuous_evt_cbs_t::on_conv_done`: this is invoked when one conversion frame finishes.
- :cpp:member:`adc_continuous_evt_cbs_t::on_pool_ovf`: this is in"
"voked when the internal pool is full. Newer conversion results will be discarded.

As the above callbacks are called in an ISR context, you should always ensure the callback function is suitable for an ISR context. Blocking logic should not appear in these callbacks. The callback function prototype is declared in :cpp:type:`adc_continuous_callback_t`.

You can also register your own context when calling :cpp:func:`adc_continuous_register_event_callbacks` by the parameter ``user_data``. This user"
" data will be passed to the callback functions directly.

This function may fail due to reasons like :c:macro:`ESP_ERR_INVALID_ARG`. Especially, when :ref:`CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE` is enabled, this error may indicate that the callback functions are not in the internal RAM. Check the error log for more details. Besides, when it fails due to :c:macro:`ESP_ERR_INVALID_STATE`, it indicates that the ADC continuous mode driver is started, and you should not add a callback at this moment.

"
"
Conversion Done Event
~~~~~~~~~~~~~~~~~~~~~

When the driver completes a conversion, it triggers the :cpp:member:`adc_continuous_evt_cbs_t::on_conv_done` event and fills the event data. Event data contains a buffer pointer to a conversion frame buffer, together with the size. Refer to :cpp:type:`adc_continuous_evt_data_t` to know the event data structure.

.. note::

    It is worth noting that, the data buffer :cpp:member:`adc_continuous_evt_data_t::conv_frame_buffer` is maintained by the driv"
"er itself. Therefore, never free this piece of memory.

.. note::

    When the Kconfig option :ref:`CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE` is enabled, the registered callbacks and the functions called by the callbacks should be placed in IRAM. The involved variables should be placed in internal RAM as well.

Pool Overflow Event
~~~~~~~~~~~~~~~~~~~

The ADC continuous mode driver has an internal pool to save the conversion results. When the pool is full, a pool overflow event will emerge. Under th"
"is condition, the driver will not fill in the event data. This usually happens because the speed to read data from the pool by calling :cpp:func:`adc_continuous_read` is much slower than the ADC conversion speed.


.. _adc-continuous-read-conversion-result:

Read Conversion Result


After calling :cpp:func:`adc_continuous_start`, the ADC continuous conversion starts. Call :cpp:func:`adc_continuous_read` to get the conversion results of the ADC channels. You need to provide a buffer to get the ra"
"w results.

Function :cpp:func:`adc_continuous_read` tries to read the expected length of conversion results each time.

- When calling :cpp:func:`adc_continuous_read`, you can request to read a conversion result of the specified length. Sometimes, however, the actual available conversion results may be less than the requested length, in which case the function still moves the data from the internal pool into the buffer you provided. Therefore, to learn the number of conversion results actually "
"moved into the buffer, please check the value of ``out_length``.
- If there is no conversion result generated in the internal pool, the function will block for ``timeout_ms`` until the conversion results are generated. If there are still no generated results, the function will return :c:macro:`ESP_ERR_TIMEOUT`.
- If the generated results fill up the internal pool, newly generated results will be lost. Next time when :cpp:func:`adc_continuous_read` is called, this function will return :c:macro:`E"
"SP_ERR_INVALID_STATE` to indicate this situation.

This API aims to give you a chance to read all the ADC continuous conversion results.

The ADC conversion results read from the above function are raw data. To calculate the voltage based on the ADC raw results, this formula can be used:

.. parsed-literal::

    Vout = Dout * Vmax / Dmax       (1)

where:

.. list-table::
    :header-rows: 1
    :widths: 20 80
    :align: center
      - Digital output result, standing for the voltage.
      - A"
"DC raw digital reading result.
      - Maximum measurable input analog voltage, this is related to the ADC attenuation, please refer to the On-Chip Sensor and Analog Signal Processing chapter in `TRM `__.
      - Maximum of the output ADC raw digital reading result, which is 2^bitwidth, where the bitwidth is the :cpp:member:`adc_digi_pattern_config_t::bit_width` configured before.

To do further calibration to convert the ADC raw result to voltage in mV, please refer to :doc:`adc_calibration`.

"
".. _adc-continuous-hardware-limitations:

.. _hardware_limitations_adc_continuous:

Hardware Limitations


- A specific ADC unit can only work under one operating mode at any one time, either continuous mode or one-shot mode. :cpp:func:`adc_continuous_start` has provided the protection.

- Random Number Generator (RNG) uses ADC as an input source. When ADC continuous mode driver works, the random number generated from RNG will be less random.

.. only:: esp32 or esp32s2

    - ADC2 is also used "
"by Wi-Fi. :cpp:func:`adc_continuous_start` has provided the protection between Wi-Fi driver and ADC continuous mode driver.

.. only:: esp32

    - ADC continuous mode driver uses I2S0 peripheral as hardware DMA FIFO. Therefore, if I2S0 is in use already, the :cpp:func:`adc_continuous_new_handle` will return :c:macro:`ESP_ERR_NOT_FOUND`.

    - ESP32 DevKitC: GPIO 0 cannot be used due to external auto program circuits.

    - ESP-WROVER-KIT: GPIO 0, 2, 4, and 15 cannot be used due to external co"
"nnections for different purposes.

.. only:: esp32s2

    - ADC continuous mode driver uses SPI3 peripheral as hardware DMA FIFO. Therefore, if SPI3 is in use already, the :cpp:func:`adc_continuous_new_handle` will return :c:macro:`ESP_ERR_NOT_FOUND`.

.. only:: esp32c3

    - ADC2 DMA functionality is no longer supported to retrieve ADC conversion results due to hardware limitations, as unstable results have been observed. This issue can be found in `ESP32C3 Errata `_. For compatibility, you ca"
"n enable :ref:`CONFIG_ADC_CONTINUOUS_FORCE_USE_ADC2_ON_C3_S3` to force use ADC2.

.. only:: esp32s3

    - ADC2 DMA functionality is no longer supported to retrieve ADC conversion results due to hardware limitations, as unstable results have been observed. This issue can be found in `ESP32S3 Errata `_. For compatibility, you can enable :ref:`CONFIG_ADC_CONTINUOUS_FORCE_USE_ADC2_ON_C3_S3` to force use ADC2.

    .. _adc-continuous-power-management:

.. only:: not esp32s3

    .. _adc-continuous-p"
"ower-management:

Power Management


When power management is enabled, i.e., :ref:`CONFIG_PM_ENABLE` is on, the APB clock frequency may be adjusted when the system is in an idle state, thus potentially changing the behavior of ADC continuous conversion.

However, the continuous mode driver can prevent this change by acquiring a power management lock of type :cpp:enumerator:`ESP_PM_APB_FREQ_MAX`. The lock is acquired after the continuous conversion is started by :cpp:func:`adc_continuous_start`. "
"Similarly, the lock will be released after :cpp:func:`adc_continuous_stop`. Therefore, :cpp:func:`adc_continuous_start` and :cpp:func:`adc_continuous_stop` should appear in pairs, otherwise, the power management will be out of action.


.. _adc-continuous-iram-safe:

IRAM Safe


All the ADC continuous mode driver APIs are not IRAM-safe. They are not supposed to be run when the Cache is disabled. By enabling the Kconfig option :ref:`CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE`, the driver's internal ISR "
"handler is IRAM-safe, which means even when the Cache is disabled, the driver will still save the conversion results into its internal pool.


.. _adc-continuous-thread-safety:

Thread Safety


ADC continuous mode driver APIs are not guaranteed to be thread-safe. However, the share hardware mutual exclusion is provided by the driver. See :ref:`adc-continuous-hardware-limitations` for more details.


Application Examples



API Reference


.. include-build-file:: inc/adc_continuous.inc
"
"USB Host




The document provides information regarding the USB Host Library. This document is split into the following sections:

.. contents:: Sections
  :depth: 2

..  Overview 

Overview


The USB Host Library (hereinafter referred to as the Host Library) is the lowest layer of the USB Host stack that exposes a public facing API. In most cases, applications that require USB Host functionality do not need to interface with the Host Library directly. Instead, most applications use the API pro"
"vided by a host class driver that is implemented on top of the Host Library.

However, you may want to use the Host Library directly for some of (but not limited to) the following reasons:

- Implementation of a custom host class driver
- Usage of lower level USB Host API

Features & Limitations


The Host Library has the following features:

- Supports Full Speed (FS) and Low Speed (LS) Devices.
- Supports all four transfer types, i.e., Control, Bulk, Interrupt, and Isochronous.
- Allows multip"
"le class drivers to run simultaneously, i.e., multiple clients of the Host Library.
- A single device can be used by multiple clients simultaneously, e.g., composite devices.
- The Host Library itself and the underlying Host Stack does not internally instantiate any OS tasks. The number of tasks is entirely controlled by how the Host Library interface is used. However, a general rule of thumb regarding the number of tasks is ``(the number of host class drivers running + 1)``.

Currently, the Hos"
"t Library and the underlying Host Stack has the following limitations:

- Only supports a single device, but the Host Library's API is designed for multiple device support.
- Only supports Asynchronous transfers.
- Only supports using the first configuration found. Changing to other configurations is not supported yet.
- Transfer timeouts are not supported yet.


..  Architecture 

Architecture


.. figure:: ../../../_static/usb_host_lib_entities.png
    :align: center
    :alt: Diagram of the K"
"ey Entities of USB Host Functionality
    :figclass: align-center

    Diagram of the key entities involved in USB Host functionality

The diagram above shows the key entities that are involved when implementing USB Host functionality. These entities are:

- The **Host Library**
- **Clients** of the Host Library
- **Devices**
- Host Library **Daemon Task**

Host Library


The Host Library is the lowest public-facing API layer of the ESP-IDF USB Host Stack. Any other ESP-IDF component (such as a "
"class driver or a user component) that needs to communicate with a connected USB device can only do so using the Host Library API either directly or indirectly.

The Host Library's API is split into two sub-sets, namely the **Library API** and **Client API**.

- The Client API handles the communication between a client of the Host Library and one or more USB devices. The Client API should only be called by registered clients of the Host Library.
- The Library API handles all of the Host Library "
"processing that is not specific to a single client, such as device enumeration. Usually, the library API is called by a Host Library Daemon Task.

Clients


A client of the Host Library is a software component, such as a host class driver or user component, which utilizes the Host Library to establish communication with a USB device. Generally, each client has a one-to-one relation with a task. This implies that all Client API calls pertaining to a specific client must originate from the context"
" of the same task.

By organizing the software components that use the Host Library's into clients, the Host Library can delegate the handling of all events specific to that client to the client's task. In other words, each client task is responsible for all the required processing and event handling associated with the USB communication that the client initiates.

Daemon Task


Although the Host Library delegates the handling of client events to the clients themselves, there are still Library e"
"vents – events that are not specific to any particular client – that need to be handled. Library event handling can include things such as:

- Handling USB device connection, enumeration, and disconnection
- Rerouting control transfers to/from clients
- Forwarding events to clients

Therefore, in addition to the client tasks, the Host Library also requires a task, which is usually the Host Library Daemon Task, to handle all of the library events.

Devices


The Host Library shields clients from "
"the details of device handling, encompassing details such as connection, memory allocation, and enumeration. The clients are provided only with a list of already connected and enumerated devices to choose from. During enumeration, each device is automatically configured to use the first configuration found, namely, the first configuration descriptor returned on a Get Configuration Descriptor request. For most standard devices, the first configuration will have a ``bConfigurationValue`` of ``1``."
"

It is possible for two or more clients to simultaneously communicate with the same device as long as they are not communicating to the same interface. However, multiple clients can simultaneously communicate with the same device's default endpoint (i.e., EP0), which will result in their control transfers being serialized.

For a client to communicate with a device, the client must:

#. Open the device using the device's address. This lets the Host Library know that the client is using that dev"
"ice.
#. Claim the interface(s) that will be used for communication. This prevents other clients from claiming the same interface(s).
#. Send transfers to the endpoints of claimed interfaces. The client's task is responsible for handling its own processing and events related to USB device communication.


..  Usage 

Usage


The Host Library and the underlying Host Stack will not create any tasks. All tasks, namely the client tasks and the Daemon Task, need to be created by the class drivers or t"
"he user. Instead, the Host Library provides two event handler functions that handle all of the required Host Library processing, thus these functions should be called repeatedly from the client tasks and the Daemon Task. Therefore, the implementation of client tasks and the Daemon Task will be largely centered around the invocation of these event handler functions.

Host Library & Daemon Task


Basic Usage
""""""""""""""""""""""

The Host Library API provides :cpp:func:`usb_host_lib_handle_events` to handl"
"e library events. This function should be called repeatedly, typically from the Daemon Task. Some notable features regarding :cpp:func:`usb_host_lib_handle_events` are:

- The function can block until a library event needs handling.
- Event flags are returned on each invocation. These event flags are useful for knowing when the Host Library can be uninstalled.

A bare-bones Daemon Task would resemble something like the following code snippet:

.. code-block:: c

    #include ""usb/usb_host.h""

  "
"  void daemon_task(void *arg)
    {
        ...
        bool exit = false;
        while (!exit) {
            uint32_t event_flags;
            usb_host_lib_handle_events(portMAX_DELAY, &event_flags);
            if (event_flags & USB_HOST_LIB_EVENT_FLAGS_NO_CLIENTS) {
                ...
            }
            if (event_flags & USB_HOST_LIB_EVENT_FLAGS_ALL_FREE) {
                ...
            }
            ...
        }
        ...
    }

.. note::

    See the :example:`peripherals/usb/"
"host/usb_host_lib` example for full implementation of the Daemon Task.

Lifecycle
""""""""""""""""""

.. figure:: ../../../_static/usb_host_lib_lifecycle.png
    :align: center
    :alt: Graph of Typical USB Host Library Lifecycle
    :figclass: align-center

    Graph of Typical USB Host Library Lifecycle

The graph above illustrates the typical lifecycle of the Host Library with multiple clients and devices. Specifically, the example involves:

- two registered clients (Client 1 and Client 2).
- two co"
"nnected devices (Device 1 and Device 2), where Client 1 communicates with Device 1 and Client 2 communicates with Device 2.

With reference to the graph above, the typical lifecycle involves the following key stages.
    - Installation must be done before any other Host Library API is called.
    - Where :cpp:func:`usb_host_install` is called (e.g., from the Daemon Task or another task) depends on the synchronization logic between the Daemon Task, client tasks, and the rest of the system.
    - "
"This is typically called from the client task, where the client task waits for a signal from the Daemon Task.
    - This can be called elsewhere if necessary as long it is called after :cpp:func:`usb_host_install`.
    - Each registered client (in this case Client 1 and Client 2) is notified of the new device by way of the :cpp:enumerator:`USB_HOST_CLIENT_EVENT_NEW_DEV` event.
    - Client 1 opens Device 1 and begins communication with it.
    - Client 1 and 2 are notified of a new device via a "
":cpp:enumerator:`USB_HOST_CLIENT_EVENT_NEW_DEV` event.
    - Client 2 opens Device 2 and begins communication with it.
    - Client 1 is notified by way of :cpp:enumerator:`USB_HOST_CLIENT_EVENT_DEV_GONE` and begins its cleanup.
    - Client 2 is not notified as it has not opened Device 1.
    - This is typically called from the client task before the task exits.
    - This can be called elsewhere if necessary as long as Client 1 has already completed its cleanup.
    - The Daemon Task is notifi"
"ed of the deregistration of all clients by way the :c:macro:`USB_HOST_LIB_EVENT_FLAGS_NO_CLIENTS` event flag as Client 2 is the last client to deregister.
    - Device 2 is still allocated (i.e., not freed), as it is still connected albeit not currently opened by any client.
    - The Daemon Task must free Device 2 first by calling :cpp:func:`usb_host_device_free_all`.
    - If :cpp:func:`usb_host_device_free_all` was able to free all devices, the function will return `ESP_OK` indicating that al"
"l devices have been freed.
    - If :cpp:func:`usb_host_device_free_all` was unable to free all devices for reasons like the device is still opened by a client, the function will return `ESP_ERR_NOT_FINISHED`.
    - The Daemon Task must wait for :cpp:func:`usb_host_lib_handle_events` to return the :c:macro:`USB_HOST_LIB_EVENT_FLAGS_ALL_FREE` event flag in order to know when all devices have been freed.

Clients & Class Driver


Basic Usage
""""""""""""""""""""""

The Host Library API provides :cpp:func:`us"
"b_host_client_handle_events` to handle a particular client's events. This function should be called repeatedly, typically from the client's task. Some notable features regarding :cpp:func:`usb_host_client_handle_events` are:

- The function can block until a client event needs handling.
- The function's primary purpose is to call the various event handling callbacks when a client event occurs.

The following callbacks are called from within :cpp:func:`usb_host_client_handle_events` thus allowing"
" the client task to be notified of events.

- The client event callback of type :cpp:type:`usb_host_client_event_cb_t` delivers client event messages to the client. Client event messages indicate events such as the addition or removal of a device.
- The USB transfer completion callback of type :cpp:type:`usb_transfer_cb_t` indicates that a particular USB transfer previously submitted by the client has been completed.

.. note::

    Given that the callbacks are called from within :cpp:func:`usb_"
"host_client_handle_events`, users should avoid blocking from within the callbacks as this will result in :cpp:func:`usb_host_client_handle_events` being blocked as well, thus preventing other pending client events from being handled.

The following code snippet demonstrates a bare-bones host class driver and its client task. The code snippet contains:

- A simple client task function ``client_task`` that calls :cpp:func:`usb_host_client_handle_events` in a loop.
- Implementations of a client eve"
"nt callback and transfer completion callbacks.
- Implementation of a simple state machine for the class driver. The class driver simply opens a device, sends an OUT transfer to EP1, then closes the device.

.. code-block:: c

    #include 
    #include ""usb/usb_host.h""

    #define CLASS_DRIVER_ACTION_OPEN_DEV    0x01
    #define CLASS_DRIVER_ACTION_TRANSFER    0x02
    #define CLASS_DRIVER_ACTION_CLOSE_DEV   0x03

    struct class_driver_control {
        uint32_t actions;
        uint8_t dev_a"
"ddr;
        usb_host_client_handle_t client_hdl;
        usb_device_handle_t dev_hdl;
    };

    static void client_event_cb(const usb_host_client_event_msg_t *event_msg, void *arg)
    {
        // This function is called from within usb_host_client_handle_events(). Do not block and try to keep it short
        struct class_driver_control *class_driver_obj = (struct class_driver_control *)arg;
        switch (event_msg->event) {
            case USB_HOST_CLIENT_EVENT_NEW_DEV:
                "
"class_driver_obj->actions |= CLASS_DRIVER_ACTION_OPEN_DEV;
                class_driver_obj->dev_addr = event_msg->new_dev.address; //Store the address of the new device
                break;
            case USB_HOST_CLIENT_EVENT_DEV_GONE:
                class_driver_obj->actions |= CLASS_DRIVER_ACTION_CLOSE_DEV;
                break;
            default:
                break;
        }
    }

    static void transfer_cb(usb_transfer_t *transfer)
    {
        // This function is called fro"
"m within usb_host_client_handle_events(). Do not block and try to keep it short
        struct class_driver_control *class_driver_obj = (struct class_driver_control *)transfer->context;
        printf(""Transfer status %d, actual number of bytes transferred %d\n"", transfer->status, transfer->actual_num_bytes);
        class_driver_obj->actions |= CLASS_DRIVER_ACTION_CLOSE_DEV;
    }

    void client_task(void *arg)
    {
        ... // Wait until Host Library is installed
        // Initialize cl"
"ass driver objects
        struct class_driver_control class_driver_obj = {0};
        // Register the client
        usb_host_client_config_t client_config = {
            .is_synchronous = false,
            .max_num_event_msg = 5,
            .async = {
                .client_event_callback = client_event_cb,
                .callback_arg = &class_driver_obj,
            }
        };
        usb_host_client_register(&client_config, &class_driver_obj.client_hdl);
        //Allocate a USB tran"
"sfer
        usb_transfer_t *transfer;
        usb_host_transfer_alloc(1024, 0, &transfer);

        //Event handling loop
        bool exit = false;
        while (!exit) {
            // Call the client event handler function
            usb_host_client_handle_events(class_driver_obj.client_hdl, portMAX_DELAY);
            // Execute pending class driver actions
            if (class_driver_obj.actions & CLASS_DRIVER_ACTION_OPEN_DEV) {
                // Open the device and claim interface 1
 "
"               usb_host_device_open(class_driver_obj.client_hdl, class_driver_obj.dev_addr, &class_driver_obj.dev_hdl);
                usb_host_interface_claim(class_driver_obj.client_hdl, class_driver_obj.dev_hdl, 1, 0);
            }
            if (class_driver_obj.actions & CLASS_DRIVER_ACTION_TRANSFER) {
                // Send an OUT transfer to EP1
                memset(transfer->data_buffer, 0xAA, 1024);
                transfer->num_bytes = 1024;
                transfer->device_handl"
"e = class_driver_obj.dev_hdl;
                transfer->bEndpointAddress = 0x01;
                transfer->callback = transfer_cb;
                transfer->context = (void *)&class_driver_obj;
                usb_host_transfer_submit(transfer);
            }
            if (class_driver_obj.actions & CLASS_DRIVER_ACTION_CLOSE_DEV) {
                // Release the interface and close the device
                usb_host_interface_release(class_driver_obj.client_hdl, class_driver_obj.dev_hdl, 1);
"
"                usb_host_device_close(class_driver_obj.client_hdl, class_driver_obj.dev_hdl);
                exit = true;
            }
            ... // Handle any other actions required by the class driver
        }

        // Cleanup class driver
        usb_host_transfer_free(transfer);
        usb_host_client_deregister(class_driver_obj.client_hdl);
        ... // Delete the client task. Signal the Daemon Task if necessary.
    }

.. note::

    An actual host class driver is likely to s"
"upport many more features, thus will have a much more complex state machine. A host class driver is also likely to need to:

    - Be able to open multiple devices
    - Parse an opened device's descriptors to identify if the device is of the target class
    - Communicate with multiple endpoints of an interface in a particular order
    - Claim multiple interfaces of a device
    - Handle various errors

Lifecycle
""""""""""""""""""

The typical life cycle of a client task and class driver will go throu"
"gh the following stages:

#. Wait for some signal regarding the Host Library being installed.
#. Register the client via :cpp:func:`usb_host_client_register` and allocate any other class driver resources, such as allocating transfers using :cpp:func:`usb_host_transfer_alloc`.
#. For each new device that the class driver needs to communicate with:

    a. Check if the device is already connected via :cpp:func:`usb_host_device_addr_list_fill`.
    b. If the device is not already connected, wait fo"
"r a :cpp:enumerator:`USB_HOST_CLIENT_EVENT_NEW_DEV` event from the client event callback.
    c. Open the device via :cpp:func:`usb_host_device_open`.
    d. Parse the device and configuration descriptors via :cpp:func:`usb_host_get_device_descriptor` and :cpp:func:`usb_host_get_active_config_descriptor` respectively.
    e. Claim the necessary interfaces of the device via :cpp:func:`usb_host_interface_claim`.

#. Submit transfers to the device via :cpp:func:`usb_host_transfer_submit` or :cpp:fu"
"nc:`usb_host_transfer_submit_control`.
#. Once an opened device is no longer needed by the class driver, or has disconnected, as indicated by a :cpp:enumerator:`USB_HOST_CLIENT_EVENT_DEV_GONE` event:

    a. Stop any previously submitted transfers to the device's endpoints by calling :cpp:func:`usb_host_endpoint_halt` and :cpp:func:`usb_host_endpoint_flush` on those endpoints.
    b. Release all previously claimed interfaces via :cpp:func:`usb_host_interface_release`.
    c. Close the device via"
" :cpp:func:`usb_host_device_close`.

#. Deregister the client via :cpp:func:`usb_host_client_deregister` and free any other class driver resources.
#. Delete the client task. Signal the Daemon Task if necessary.


..  Examples 

Examples


Host Library Examples


The :example:`peripherals/usb/host/usb_host_lib` demonstrates basic usage of the USB Host Library's API to implement a pseudo-class driver.

Class Driver Examples


The USB Host Stack provides a number of examples that implement host cl"
"ass drivers using the Host Library's API.

CDC-ACM
""""""""""""""

MSC
""""""

HID
""""""

UVC
""""""

..  USB Host Menuconfig 

Host Stack Configuration


Non-Compliant Device Support


To support USB devices that are non-compliant in various scenarios or exhibit specific behaviors, it is possible to configure the USB Host stack.

As a USB device may be hot-plugged, it is essential to have configurable delays between power switching and device attachment, and when the device's internal power has stabilized.

E"
"numeration Configuration
""""""""""""""""""""""""""""""""""""""""""""""""""

During the process of enumerating connected USB devices, several delay values ensure the proper functioning of the device.

.. figure:: ../../../_static/usb_host/poweron-timings.png
    :align: center
    :alt: USB Root Hub Power-on and Connection Events Timing

    USB Root Hub Power-on and Connection Events Timing

The figure above shows all the delay values associated with both turning on port power with a device connected and hot-plugging a"
" device.

.. note::

    For more details regarding connection event timings, please refer to `USB 2.0 Specification `_ > Chapter 7.1.7.3 *Connect and Disconnect Signaling*.

Configurable parameters of the USB host stack can be configured with multiple options via Menuconfig.

Multiple Configuration Support


To support USB devices that have more than one configuration, it is possible to specify the desired configuration number during a device's enumeration process.

Enumeration Filter
"""""""""""""""""""
"""""""""""""""""""

The enumeration filter is a callback function of type :cpp:type:`usb_host_enum_filter_cb_t` called at the beginning of the enumeration process once a device descriptor is read from a newly attached USB device. Consequently, the user is provided with the obtained device descriptor. Through this callback, the user can:

To use the enumeration filter, users should enable the :ref:`CONFIG_USB_HOST_ENABLE_ENUM_FILTER_CALLBACK` option using menuconfig. Users can specify the callback by sett"
"ing :cpp:member:`usb_host_config_t::enum_filter_cb` which is then passed to the Host Library when calling :cpp:func:`usb_host_install`.

..  API Reference 

API Reference


The API of the USB Host Library is separated into the following header files. However, it is sufficient for applications to only ``#include ""usb/usb_host.h""`` and all USB Host Library headers will also be included.

- :component_file:`usb/include/usb/usb_host.h` contains the functions and types of the USB Host Library.
- :com"
"ponent_file:`usb/include/usb/usb_helpers.h` contains various helper functions that are related to the USB protocol such as descriptor parsing.
- :component_file:`usb/include/usb/usb_types_stack.h` contains types that are used across multiple layers of the USB Host stack.
- :component_file:`usb/include/usb/usb_types_ch9.h` contains types and macros related to Chapter 9 of the USB2.0 specification, i.e., descriptors and standard requests.


.. include-build-file:: inc/usb_host.inc

.. include-buil"
"d-file:: inc/usb_helpers.inc

.. include-build-file:: inc/usb_types_stack.inc

.. include-build-file:: inc/usb_types_ch9.inc

..  Maintainers Notes 

Maintainers Notes


.. note::

    For more details regarding the internal implementation details of the USB Host stack, please refer to :doc:`/api-reference/peripherals/usb_host/usb_host_notes_index`.

.. toctree::
    :hidden:
    :maxdepth: 0

    usb_host/usb_host_notes_index
"
"SDMMC Host Driver




Overview


{IDF_TARGET_NAME}'s SDMMC host peripheral has two slots. Each slot can be used independently to connect to an SD card, SDIO device, or eMMC chip.

.. only:: esp32

    - Slot 0 (:c:macro:`SDMMC_HOST_SLOT_0`) is an 8-bit slot. It uses ``HS1_*`` signals in the PIN MUX.
    - Slot 1 (:c:macro:`SDMMC_HOST_SLOT_1`) is a 4-bit slot. It uses ``HS2_*`` signals in the PIN MUX.

    The slots are connected to {IDF_TARGET_NAME} GPIOs using IO MUX. Pin mappings of these slot"
"s are given in the table below.

    .. list-table::
        :header-rows: 1
        :widths: 20 40 40
        :align: center
          - Slot 0
          - Slot 1
          - GPIO11
          - GPIO15
          - GPIO6
          - GPIO14
          - GPIO7
          - GPIO2
          - GPIO8
          - GPIO4
          - GPIO9
          - GPIO12
          - GPIO10
          - GPIO13
          - GPIO16
          -
          - GPIO17
          -
          - GPIO5
          -
          - GPIO18
   "
"       -
          - any input via GPIO matrix
          - any input via GPIO matrix
          - any input via GPIO matrix
          - any input via GPIO matrix

    The Card Detect (CD) and Write Protect (WP) signals can be routed to arbitrary pins using the GPIO matrix. To reserve the pins, set the ``cd`` and ``wp`` members of the :cpp:class:`sdmmc_slot_config_t` structure before calling :cpp:func:`sdmmc_host_init_slot`. Please note that it is not advised to specify a CD pin when working with "
"SDIO cards, because the CD signal in ESP32 can also trigger SDIO slave interrupt.

    .. warning::

        Pins used by Slot 0 (``HS1_*``) are also used to connect the SPI flash chip in ESP32-WROOM and ESP32-WROVER modules. These pins cannot be concurrently shared between an SD card and an SPI flash. If you need to use Slot 0, establish an alternative connection for the SPI flash using different pins and configure the necessary eFuses accordingly.


.. only:: esp32s3

    Both slots :c:macro:`"
"SDMMC_HOST_SLOT_0` and :c:macro:`SDMMC_HOST_SLOT_1` support 1-, 4- and 8-line SD interfaces. The slots are connected to {IDF_TARGET_NAME} GPIOs using the GPIO matrix. This means that any GPIO may be used for each of the SD card signals.

.. only:: esp32p4

    - :c:macro:`SDMMC_HOST_SLOT_1` is routed via GPIO Matrix. This means that any GPIO may be used for each of the SD card signals. It is for non UHS-I usage.
    - :c:macro:`SDMMC_HOST_SLOT_0` is dedicated to UHS-I mode, which is not yet supp"
"orted in the driver.

    Currently SDMMC host driver is using the on-chip LDO 4 as the default power supply. SDMMC power control driver is not supported yet. If you buy the ESP32P4 chip itself and plan to use SDMMC peripheral, make sure the VDDPST_5 pin is connected to the on-chip LDO 4 or correct external power supply.

Supported Speed Modes


SDMMC Host driver supports the following speed modes:

- Default Speed (20 MHz): 1-line or 4-line with SD cards, and 1-line, 4-line, or 8-line with 3.3 "
"V eMMC
- High Speed (40 MHz): 1-line or 4-line with SD cards, and 1-line, 4-line, or 8-line with 3.3 V eMMC
- High Speed DDR (40 MHz): 4-line with 3.3 V eMMC

Speed modes not supported at present:

- High Speed DDR mode: 8-line eMMC
- UHS-I 1.8 V modes: 4-line SD cards


Using the SDMMC Host Driver


Of all the functions listed below, only the following ones will be used directly by most applications:

- :cpp:func:`sdmmc_host_init`
- :cpp:func:`sdmmc_host_init_slot`
- :cpp:func:`sdmmc_host_deini"
"t`

Other functions, such as the ones given below, will be called by the SD/MMC protocol layer via function pointers in the :cpp:class:`sdmmc_host_t` structure:

- :cpp:func:`sdmmc_host_set_bus_width`
- :cpp:func:`sdmmc_host_set_card_clk`
- :cpp:func:`sdmmc_host_do_transaction`


Configuring Bus Width and Frequency


With the default initializers for :cpp:class:`sdmmc_host_t` and :cpp:class:`sdmmc_slot_config_t`, i.e., :c:macro:`SDMMC_HOST_DEFAULT` and :c:macro:`SDMMC_SLOT_CONFIG_DEFAULT`, SDMMC"
" Host driver will attempt to use the widest bus supported by the card (4 lines for SD, 8 lines for eMMC) and the frequency of 20 MHz.

In the designs where communication at 40 MHz frequency can be achieved, it is possible to increase the bus frequency by changing the ``max_freq_khz`` field of :cpp:class:`sdmmc_host_t`:

.. code-block::

    sdmmc_host_t host = SDMMC_HOST_DEFAULT();
    host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;

If you need a specific frequency other than standard speeds, you are"
" free to use any value from within an appropriate range of the SD interface given (SDMMC or SDSPI). However, the real clock frequency shall be calculated by the underlying driver and the value can be different from the one required.

For the SDMMC, ``max_freq_khz`` works as the upper limit so the final frequency value shall be always lower or equal. For the SDSPI, the nearest fitting frequency is supplied and thus the value can be greater than/equal to/lower than ``max_freq_khz``.

To configure "
"the bus width, set the ``width`` field of :cpp:class:`sdmmc_slot_config_t`. For example, to set 1-line mode:

.. code-block::

    sdmmc_slot_config_t slot = SDMMC_SLOT_CONFIG_DEFAULT();
    slot.width = 1;

.. only:: SOC_SDMMC_USE_GPIO_MATRIX

    Configuring GPIOs
    

    {IDF_TARGET_NAME} SDMMC Host can be configured to use arbitrary GPIOs for each of the signals. Configuration is performed by setting members of :cpp:class:`sdmmc_slot_config_t` structure.

    For example, to use GPIOs 1-6 "
"for CLK, CMD, and D0-D3 signals respectively:

    .. code-block::

        sdmmc_slot_config_t slot = SDMMC_SLOT_CONFIG_DEFAULT();
        slot.clk = GPIO_NUM_1;
        slot.cmd = GPIO_NUM_2;
        slot.d0 = GPIO_NUM_3;
        slot.d1 = GPIO_NUM_4;
        slot.d2 = GPIO_NUM_5;
        slot.d3 = GPIO_NUM_6;

    It is also possible to configure Card Detect and Write Protect pins. Similar to other signals, set ``cd`` and ``wp`` members of the same structure:

    .. code-block::

        slo"
"t.cd = GPIO_NUM_7;
        slot.wp = GPIO_NUM_8;

    ``SDMMC_SLOT_CONFIG_DEFAULT`` sets both to ``GPIO_NUM_NC``, meaning that by default the signals are not used.

    Once :cpp:class:`sdmmc_slot_config_t` structure is initialized this way, you can use it when calling :cpp:func:`sdmmc_host_init_slot` or one of the higher level functions (such as :cpp:func:`esp_vfs_fat_sdmmc_mount`).

DDR Mode for eMMC Chips


By default, DDR mode will be used if:

- SDMMC host frequency is set to :c:macro:`SDMM"
"C_FREQ_HIGHSPEED` in :cpp:class:`sdmmc_host_t` structure, and
- eMMC chip reports DDR mode support in its CSD register

DDR mode places higher requirements for signal integrity. To disable DDR mode while keeping the :c:macro:`SDMMC_FREQ_HIGHSPEED` frequency, clear the :c:macro:`SDMMC_HOST_FLAG_DDR` bit in :cpp:member:`sdmmc_host_t::flags` field of the :cpp:class:`sdmmc_host_t`:

.. code-block::

    sdmmc_host_t host = SDMMC_HOST_DEFAULT();
    host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;
    host."
"flags &= ~SDMMC_HOST_FLAG_DDR;


See also


- :doc:`../storage/sdmmc`: introduces the higher-level driver which implements the protocol layer.
- :doc:`sdspi_host`: introduces a similar driver that uses the SPI controller and is limited to SD protocol's SPI mode.
- :doc:`sd_pullup_requirements`: introduces pull-up support and compatibilities of modules and development kits.


API Reference


.. include-build-file:: inc/sdmmc_host.inc
"
"Sharing the SPI Bus Among SD Cards and Other SPI Devices




The SD card has an SPI mode, enabling it to function as an SPI device, but there are some restrictions that we need to pay attention to.

Pin Loading of Other Devices


When adding more devices onto the same bus, the overall pin loading increases. The loading consists of AC loading (pin capacitor) and DC loading (pull-ups).

AC Loading


SD cards, designed for high-speed communications, have small pin capacitors (AC loading) to work un"
"til 50 MHz. However, the other attached devices will increase the pin's AC loading.

Heavy AC loading of a pin may prevent the pin from being toggled quickly. By using an oscilloscope, you will see the edges of the pin become smoother, i.e., the gradient of the edge is smaller. The setup timing requirements of an SD card may be violated when the card is connected to a bus with a high AC load. Even worse, high AC loads may cause the SD card and other SPI devices to fail to properly resolve clock "
"signals from the host, affecting communication stability.

This issue may be more obvious if other attached devices are not designed to work at the same frequency as the SD card, because they may have larger pin capacitors. The larger the pin capacity, the greater the pin response time, the smaller the max frequency the SD bus can work.

To see if your pin AC loading is too heavy, you can try the following tests:

Terminology:

 - **launch edge**: at which clock edge the data starts to toggle;
 "
"- **latch edge**: at which clock edge the data is supposed to be sampled by the receiver. For SD card, it is the rising edge.

   - If you see the clock is not fast enough, e.g., the rising/falling edge is longer than 1/4 of the clock cycle, it means the clock is skewed too much.
   - If you see the data line unstable before the latch edge of the clock, it means the load of the data line is too large.

   You may also observe the corresponding phenomenon that data delayed largely from the launch"
"ing edge of the clock with logic analyzers. But it is not as obvious as with an oscilloscope.

   If the lower frequency can work while the higher frequency cannot, it is an indication that the AC loading on the pins is too large.

If the AC loading of the pins is too large, you can either use other faster devices with lower pin load or slow down the clock speed.

DC Loading


The pull-ups required by SD cards are usually around 10 kOhm to 50 kOhm, which may be too strong for some other SPI devi"
"ces.

Check the specification of your device about its DC output current, it should be larger than 700 μA, otherwise, the device output may not be read correctly.

Initialization Sequence


.. note::

  If you see any problem in the following steps, please make sure the timing is correct first. You can try to slow down the clock speed, such as setting ``SDMMC_FREQ_PROBING`` to 400 kHz for SD card, to avoid the influence of pin AC loading, as discussed in the previous section.

When using an SD c"
"ard with other SPI devices on the same SPI bus, due to the restrictions of the SD card startup flow, the following initialization sequence should be followed. Refer to :example:`storage/sd_card` for further details.

   You can do this by either:

   This step will put the SD card into the SPI mode, which **should** be done before all other SPI communications on the same bus. Otherwise, the card will stay in the SD mode, in which mode it may randomly respond to any SPI communications on the bus,"
" even when its CS line is not addressed.

   If you want to test this behavior, please also note that, once the card is put into SPI mode, it will not return to SD mode before the next power cycle, i.e., powered down and powered up again.
"
"JPEG Decoder


Introduction


JPEG is a commonly used method of lossy compression for digital images, particularly for those images produced by digital photography. The degree of compression can be adjusted, allowing a selectable tradeoff between storage size and image quality. JPEG typically achieves 10:1 compression with little perceptible loss in image quality.

JPEG codec on {IDF_TARGET_NAME} is an image codec, which is based on the JPEG baseline standard, for compressing and decompressing i"
"mages to reduce the bandwidth required to transmit images or the space required to store images, making it possible to process large-resolution images. But please note, at one time, the codec engine can only work as either encoder or decoder.

Functional Overview


The JPEG driver offers following services:

-  `Resource Allocation `__ - covers how to allocate JPEG resources with properly set of configurations. It also covers how to recycle the resources when they finished working.
-  `JPEG Deco"
"der Engine `__ - covers behavior of JPEG decoder engine. Introduce how to use decoder engine functions to decode an image (from jpg format to raw format).
-  `Thread Safety `__ - lists which APIs are guaranteed to be thread safe by the driver.
-  `Kconfig Options `__ - lists the supported Kconfig options that can bring different effects to the driver.

Resource Allocation


Install JPEG decoder engine
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JPEG decoder engine requires the configuration that specified by :"
"cpp:type:`jpeg_decode_engine_cfg_t`:

- :cpp:member:`jpeg_decode_engine_cfg_t::intr_priority` Set the priority of the interrupt. If set to ``0`` , then the driver will use a interrupt with low or medium priority (priority level may be one of 1,2 or 3), otherwise use the priority indicated by :cpp:member:`jpeg_decode_engine_cfg_t::intr_priority` Please use the number form (1,2,3) , not the bitmask form ((1<<1),(1<<2),(1<<3)).

If the configurations in :cpp:type:`jpeg_decode_engine_cfg_t` is speci"
"fied, users can call :cpp:func:`jpeg_new_decoder_engine` to allocate and initialize a JPEG decoder engine. This function will return an JPEG decoder handle if it runs correctly. You can take following code as reference.

.. code:: c

    jpeg_decoder_handle_t jpgd_handle;

    jpeg_decode_engine_cfg_t decode_eng_cfg = {
        .intr_priority = 0,
        .timeout_ms = 40,
    };

    ESP_ERROR_CHECK(jpeg_new_decoder_engine(&decode_eng_cfg, &jpgd_handle));


Uninstall JPEG decoder engine
~~~~~~~"
"~~~~~~~~~~~~~~~~~~~~~~

If a previously installed JPEG engine is no longer needed, it's recommended to recycle the resource by calling :cpp:func:`jpeg_del_decoder_engine`, so that to release the underlying hardware.

JPEG Decoder Engine


After installing the JPEG decoder driver by :cpp:func:`jpeg_new_decoder_engine`, {IDF_TARGET_NAME} is ready to decode JPEG pictures by :cpp:func:`jpeg_decoder_process`. :cpp:func:`jpeg_decoder_process` is flexible for decoding different types of pictures by a c"
"onfigurable parameter called :cpp:type:`jpeg_decode_cfg_t`:

- :cpp:member:`jpeg_decode_cfg_t::output_format` Set the output raw image format.
- :cpp:member:`jpeg_decode_cfg_t::rgb_order` Set the output pixel order. (RGB or BGR).
- :cpp:member:`jpeg_decode_cfg_t::jpeg_yuv_rgb_conv_std_t` Set the output YUV and RGB conversion standard (BT601 or BT709)

Moreover, our jpeg decoder api provides a helper function which helps you get the basic information of your given image. Calling :cpp:func:`jpeg_d"
"ecoder_get_info` would return the picture information structure called :cpp:func:`jpeg_decoder_get_info`. If you already know the picture basic information, this functions is unnecessary to be called.

Overall, You can take following code as reference, the code is going to decode a 1080*1920 picture.

.. code:: c

    jpeg_decode_cfg_t decode_cfg_rgb = {
        .output_format = JPEG_DECODE_OUT_FORMAT_RGB888,
        .rgb_order = JPEG_DEC_RGB_ELEMENT_ORDER_BGR,
    };

    uint8_t *bit_stream = "
"(uint8_t*)heap_caps_aligned_calloc(JPEG_BUFFER_MALLOC_ALIGN_VALUE, 1, bit_stream_size, MALLOC_CAP_SPIRAM);
    uint8_t *out_buf = (uint8_t*)heap_caps_aligned_calloc(JPEG_BUFFER_MALLOC_ALIGN_VALUE, 1, 1920 * 1080 * 3, MALLOC_CAP_SPIRAM); // Sufficient space for output images.

    jpeg_decode_picture_info_t header_info;
    ESP_ERROR_CHECK(jpeg_decoder_get_info(bit_stream, bit_stream_size, &header_info));
    uint32_t out_size = 0;
    ESP_ERROR_CHECK(jpeg_decoder_process(jpgd_handle, &decode_cfg"
"_rgb, bit_stream, bit_stream_size, out_buf, &out_size));

.. note::

    Firstly, in above code, you should make sure the `bit_stream` and `out_buf` should be :c:macro:`JPEG_BUFFER_MALLOC_ALIGN_VALUE` byte aligned.
    Secondly, the content of `bit_stream` buffer should not be changed until :cpp:func:`jpeg_decoder_process` returns.

Thread Safety


The factory function :cpp:func:`jpeg_new_decoder_engine`, :cpp:func:`jpeg_decoder_get_info`, :cpp:func:`jpeg_decoder_process`, and :cpp:func:`jpeg_de"
"l_decoder_engine` are guaranteed to be thread safe by the driver, which means, user can call them from different RTOS tasks without protection by extra locks.

Kconfig Options


- :ref:`CONFIG_JPEG_ENABLE_DEBUG_LOG` is used to enable the debug log at the cost of increased firmware binary size.

API Reference


.. only:: SOC_JPEG_DECODE_SUPPORTED

    .. include-build-file:: inc/jpeg_decode.inc

.. include-build-file:: inc/components/esp_driver_jpeg/include/driver/jpeg_types.inc
.. include-build-"
"file:: inc/components/hal/include/hal/jpeg_types.inc
"
"Inter-Integrated Circuit (I2C)


Introduction


I2C is a serial, synchronous, multi-device, half-duplex communication protocol that allows co-existence of multiple masters and slaves on the same bus. I2C uses two bidirectional open-drain lines: serial data line (SDA) and serial clock line (SCL), pulled up by resistors.

{IDF_TARGET_NAME} has {IDF_TARGET_SOC_I2C_NUM} I2C controller (also called port), responsible for handling communication on the I2C bus. A single I2C controller can be a master o"
"r a slave.

Typically, an I2C slave device has a 7-bit address or 10-bit address. {IDF_TARGET_NAME} supports both I2C Standard-mode (Sm) and Fast-mode (Fm) which can go up to 100KHz and 400KHz respectively.

.. warning::

    The clock frequency of SCL in master mode should not be larger than 400 KHz

.. note::

    The frequency of SCL is influenced by both the pull-up resistor and the wire capacitance. Therefore, users are strongly recommended to choose appropriate pull-up resistors to make th"
"e frequency accurate. The recommended value for pull-up resistors usually ranges from 1K Ohms to 10K Ohms.

    Keep in mind that the higher the frequency, the smaller the pull-up resistor should be (but not less than 1 KOhms). Indeed, large resistors will decline the current, which will increase the clock switching time and reduce the frequency. We usually recommend a range of 2 KOhms to 5 KOhms, but users may also need to make some adjustments depending on their current draw requirements.


I2"
"C Clock Configuration


.. list::

    - :cpp:enumerator:`i2c_clock_source_t::I2C_CLK_SRC_DEFAULT`: Default I2C source clock.
    :SOC_I2C_SUPPORT_XTAL: - :cpp:enumerator:`i2c_clock_source_t::I2C_CLK_SRC_XTAL`: External crystal for I2C clock source.
    :SOC_I2C_SUPPORT_RTC: - :cpp:enumerator:`i2c_clock_source_t::I2C_CLK_RC_FAST`: Internal 20MHz rc oscillator for I2C clock source.
    :SOC_I2C_SUPPORT_APB: - :cpp:enumerator:`i2c_clock_source_t::I2C_CLK_SRC_APB`: APB clock as I2C clock source.
  "
"  :SOC_I2C_SUPPORT_REF_TICK: - :cpp:enumerator:`i2c_clock_source_t::I2C_CLK_SRC_REF_TICK`: 1MHZ clock.

I2C File Structure


.. figure:: ../../../_static/diagrams/i2c/i2c_code_structure.png
    :align: center
    :alt: I2C file structure

    I2C file structure

**Public headers that need to be included in the I2C application**

- ``i2c.h``: The header file of legacy I2C APIs (for apps using legacy driver).
- ``i2c_master.h``: The header file that provides standard communication mode specific AP"
"Is (for apps using new driver with master mode).
- ``i2c_slave.h``: The header file that provides standard communication mode specific APIs (for apps using new driver with slave mode).

.. note::

    The legacy driver can't coexist with the new driver. Include ``i2c.h`` to use the legacy driver or the other two headers to use the new driver. Please keep in mind that the legacy driver is now deprecated and will be removed in future.

**Public headers that have been included in the headers above*"
"*

- ``i2c_types_legacy.h``: The legacy public types that only used in the legacy driver.
- ``i2c_types.h``: The header file that provides public types.

Functional Overview


The I2C driver offers following services:

-  `Resource Allocation `__ - covers how to allocate I2C bus with properly set of configurations. It also covers how to recycle the resources when they finished working.
-  `I2C Master Controller `__ - covers behavior of I2C master controller. Introduce data transmit, data receive"
", and data transmit and receive.
-  `I2C Slave Controller `__ - covers behavior of I2C slave controller. Involve data transmit and data receive.
-  `Power Management `__ - describes how different source clock will affect power consumption.
-  `IRAM Safe `__ - describes tips on how to make the I2C interrupt work better along with a disabled cache.
-  `Thread Safety `__ - lists which APIs are guaranteed to be thread safe by the driver.
-  `Kconfig Options `__ - lists the supported Kconfig options "
"that can bring different effects to the driver.

Resource Allocation


Both I2C master bus and I2C slave bus, when supported, are represented by :cpp:type:`i2c_bus_handle_t` in the driver. The available ports are managed in a resource pool that allocates a free port on request.

Install I2C master bus and device
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The I2C master is designed based on bus-device model. So :cpp:type:`i2c_master_bus_config_t` and :cpp:type:`i2c_device_config_t` are required separatel"
"y to allocate the I2C master bus instance and I2C device instance.

.. figure:: ../../../_static/diagrams/i2c/i2c_master_module.png
    :align: center
    :alt: I2C master bus-device module

    I2C master bus-device module

I2C master bus requires the configuration that specified by :cpp:type:`i2c_master_bus_config_t`:

- :cpp:member:`i2c_master_bus_config_t::i2c_port` sets the I2C port used by the controller.
- :cpp:member:`i2c_master_bus_config_t::sda_io_num` sets the GPIO number for the seri"
"al data bus (SDA).
- :cpp:member:`i2c_master_bus_config_t::scl_io_num` sets the GPIO number for the serial clock bus (SCL).
- :cpp:member:`i2c_master_bus_config_t::clk_source` selects the source clock for I2C bus. The available clocks are listed in :cpp:type:`i2c_clock_source_t`. For the effect on power consumption of different clock source, please refer to `Power Management `__  section.
- :cpp:member:`i2c_master_bus_config_t::glitch_ignore_cnt` sets the glitch period of master bus, if the glit"
"ch period on the line is less than this value, it can be filtered out, typically value is 7.
- :cpp:member:`i2c_master_bus_config_t::intr_priority` Set the priority of the interrupt. If set to ``0`` , then the driver will use a interrupt with low or medium priority (priority level may be one of 1,2 or 3), otherwise use the priority indicated by :cpp:member:`i2c_master_bus_config_t::intr_priority` Please use the number form (1,2,3) , not the bitmask form ((1`__  section.
    - :cpp:member:`i2c_sl"
"ave_config_t::send_buf_depth` sets the sending buffer length.
    - :cpp:member:`i2c_slave_config_t::slave_addr` sets the slave address
    - :cpp:member:`i2c_master_bus_config_t::intr_priority` Set the priority of the interrupt. If set to ``0`` , then the driver will use a interrupt with low or medium priority (priority level may be one of 1,2 or 3), otherwise use the priority indicated by :cpp:member:`i2c_master_bus_config_t::intr_priority` Please use the number form (1,2,3) , not the bitmask "
"form ((1`__] to learn how I2C stretch works.
    :SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE: - :cpp:member:`i2c_slave_config_t::broadcast_en` Set true to enable the slave broadcase. When the slave receives the general call address 0x00 from the master and the R/W bit followed is 0, it responds to the master regardless of its own address.
    :SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS: - :cpp:member:`i2c_slave_config_t::access_ram_en` Set true to enable the non-fifo mode. Thus the I2C data fifo can be used a"
"s RAM, and double addressing will be synchronised opened.
    :SOC_I2C_SLAVE_SUPPORT_SLAVE_UNMATCH: - :cpp:member:`i2c_slave_config_t::slave_unmatch_en` Set true to enable the slave unmatch interrupt. If master send command address cannot match the slave address, and unmatch interrupt will be triggered.

Once the :cpp:type:`i2c_slave_config_t` structure is populated with mandatory parameters, users can call :cpp:func:`i2c_new_slave_device` to allocate and initialize an I2C master bus. This funct"
"ion will return an I2C bus handle if it runs correctly. Specifically, when there are no more I2C port available, this function will return :c:macro:`ESP_ERR_NOT_FOUND` error.

.. code:: c

    i2c_slave_config_t i2c_slv_config = {
        .addr_bit_len = I2C_ADDR_BIT_LEN_7,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .i2c_port = TEST_I2C_PORT,
        .send_buf_depth = 256,
        .scl_io_num = I2C_SLAVE_SCL_IO,
        .sda_io_num = I2C_SLAVE_SDA_IO,
        .slave_addr = 0x58,
    };

"
"    i2c_slave_dev_handle_t slave_handle;
    ESP_ERROR_CHECK(i2c_new_slave_device(&i2c_slv_config, &slave_handle));

Uninstall I2C slave device
~~~~~~~~~~~~~~~~~~~~~~~~~~

If a previously installed I2C bus is no longer needed, it's recommended to recycle the resource by calling :cpp:func:`i2c_del_slave_device`, so that to release the underlying hardware.


I2C Master Controller


After installing the i2c master driver by :cpp:func:`i2c_new_master_bus`, {IDF_TARGET_NAME} is ready to communicate w"
"ith other I2C devices. I2C APIs allow the standard transactions. Like the wave as follows:

.. wavedrom:: /../_static/diagrams/i2c/i2c_trans_wave.json

I2C Master Write
~~~~~~~~~~~~~~~~

After installing I2C master bus successfully, you can simply call :cpp:func:`i2c_master_transmit` to write data to the slave device. The principle of this function can be explained by following chart.

In order to organize the process, the driver uses a command link, that should be populated with a sequence of c"
"ommands and then passed to I2C controller for execution.

.. figure:: ../../../_static/diagrams/i2c/i2c_master_write_slave.png
    :align: center
    :alt: I2C master write to slave

    I2C master write to slave

Simple example for writing data to slave:

.. code:: c

    #define DATA_LENGTH 100
    i2c_master_bus_config_t i2c_mst_config = {
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .i2c_port = I2C_PORT_NUM_0,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_io_num = I2C_MASTER_SD"
"A_IO,
        .glitch_ignore_cnt = 7,
    };
    i2c_master_bus_handle_t bus_handle;

    ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_mst_config, &bus_handle));

    i2c_device_config_t dev_cfg = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = 0x58,
        .scl_speed_hz = 100000,
    };

    i2c_master_dev_handle_t dev_handle;
    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &dev_cfg, &dev_handle));

    ESP_ERROR_CHECK(i2c_master_transmit(dev_handle, data_wr, DA"
"TA_LENGTH, -1));

I2C Master Read
~~~~~~~~~~~~~~~

After installing I2C master bus successfully, you can simply call :cpp:func:`i2c_master_receive` to read data from the slave device. The principle of this function can be explained by following chart.

.. figure:: ../../../_static/diagrams/i2c/i2c_master_read_slave.png
    :align: center
    :alt: I2C master read from slave

    I2C master read from slave

Simple example for reading data from slave:

.. code:: c

    #define DATA_LENGTH 100
    "
"i2c_master_bus_config_t i2c_mst_config = {
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .i2c_port = I2C_PORT_NUM_0,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .glitch_ignore_cnt = 7,
    };
    i2c_master_bus_handle_t bus_handle;

    ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_mst_config, &bus_handle));

    i2c_device_config_t dev_cfg = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = 0x58,
        .scl_speed_hz = 10000"
"0,
    };

    i2c_master_dev_handle_t dev_handle;
    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &dev_cfg, &dev_handle));

    i2c_master_receive(dev_handle, data_rd, DATA_LENGTH, -1);

I2C Master Write and Read
~~~~~~~~~~~~~~~~~~~~~~~~~

Some I2C device needs write configurations before reading data from it, therefore, an interface called :cpp:func:`i2c_master_transmit_receive` can help. The principle of this function can be explained by following chart.

.. figure:: ../../../_stati"
"c/diagrams/i2c/i2c_master_write_read_slave.png
    :align: center
    :alt: I2C master write to slave and read from slave

    I2C master write to slave and read from slave

Simple example for writing and reading from slave:

.. code:: c

    i2c_device_config_t dev_cfg = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = 0x58,
        .scl_speed_hz = 100000,
    };

    i2c_master_dev_handle_t dev_handle;
    ESP_ERROR_CHECK(i2c_master_bus_add_device(I2C_PORT_NUM_0, &dev"
"_cfg, &dev_handle));
    uint8_t buf[20] = {0x20};
    uint8_t buffer[2];
    ESP_ERROR_CHECK(i2c_master_transmit_receive(i2c_bus_handle, buf, sizeof(buf), buffer, 2, -1));

I2C Master Probe
~~~~~~~~~~~~~~~~

I2C driver can use :cpp:func:`i2c_master_probe` to detect whether the specific device has been connected on I2C bus. If this function return ``ESP_OK``, that means the device has been detected.

.. figure:: ../../../_static/diagrams/i2c/i2c_master_probe.png
    :align: center
    :alt: I2C "
"master probe

    I2C master probe

Simple example for probing an I2C device:

.. code:: c

    i2c_master_bus_config_t i2c_mst_config_1 = {
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .i2c_port = TEST_I2C_PORT,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .glitch_ignore_cnt = 7,
        .flags.enable_internal_pullup = true,
    };
    i2c_master_bus_handle_t bus_handle;

    ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_mst_config_1, &bus_handle));
"
"    ESP_ERROR_CHECK(i2c_master_probe(bus_handle, 0x22, -1));
    ESP_ERROR_CHECK(i2c_del_master_bus(bus_handle));


I2C Slave Controller


After installing the i2c slave driver by :cpp:func:`i2c_new_slave_device`, {IDF_TARGET_NAME} is ready to communicate with other I2C master as a slave.

I2C Slave Write
~~~~~~~~~~~~~~~

The send buffer of the I2C slave is used as a FIFO to store the data to be sent. The data will queue up until the master requests them. You can call :cpp:func:`i2c_slave_transm"
"it` to transfer data.

Simple example for writing data to FIFO:

.. code:: c

    uint8_t *data_wr = (uint8_t *) malloc(DATA_LENGTH);

    i2c_slave_config_t i2c_slv_config = {
        .addr_bit_len = I2C_ADDR_BIT_LEN_7,   // 7-bit address
        .clk_source = I2C_CLK_SRC_DEFAULT,    // set the clock source
        .i2c_port = 0,                        // set I2C port number
        .send_buf_depth = 256,                // set tx buffer length
        .scl_io_num = 2,                      // SC"
"L gpio number
        .sda_io_num = 1,                      // SDA gpio number
        .slave_addr = 0x58,                   // slave address
    };

    i2c_bus_handle_t i2c_bus_handle;
    ESP_ERROR_CHECK(i2c_new_slave_device(&i2c_slv_config, &i2c_bus_handle));
    for (int i = 0; i `__ for more information.
- :ref:`CONFIG_I2C_ENABLE_DEBUG_LOG` is used to enable the debug log at the cost of increased firmware binary size.

API Reference


.. include-build-file:: inc/i2c_master.inc

.. only:: S"
"OC_I2C_SUPPORT_SLAVE

    .. include-build-file:: inc/i2c_slave.inc

.. include-build-file:: inc/components/esp_driver_i2c/include/driver/i2c_types.inc
.. include-build-file:: inc/components/hal/include/hal/i2c_types.inc
"
"LCD
===

Introduction


ESP chips can generate various kinds of timings that needed by common LCDs on the market, like SPI LCD, I80 LCD (a.k.a Intel 8080 parallel LCD), RGB/SRGB LCD, I2C LCD, etc. The ``esp_lcd`` component is officially to support those LCDs with a group of universal APIs across chips.

Functional Overview


In ``esp_lcd``, an LCD panel is represented by :cpp:type:`esp_lcd_panel_handle_t`, which plays the role of an **abstract frame buffer**, regardless of the frame memory is al"
"located inside ESP chip or in external LCD controller. Based on the location of the frame buffer and the hardware connection interface, the LCD panel drivers are mainly grouped into the following categories:

.. list::

    - Controller based LCD driver involves multiple steps to get a panel handle, like bus allocation, IO device registration and controller driver install. The frame buffer is located in the controller's internal GRAM (Graphical RAM). ESP-IDF provides only a limited number of LCD"
" controller drivers out of the box (e.g., ST7789, SSD1306), :ref:`more_controller_based_lcd_drivers` are maintained in the `Espressif Component Registry `__.
    - :ref:`spi_lcd_panel` describes the steps to install the SPI LCD IO driver and then get the panel handle.
    - :ref:`i2c_lcd_panel` describes the steps to install the I2C LCD IO driver and then get the panel handle.
    :SOC_LCD_I80_SUPPORTED: - :ref:`i80_lcd_panel` describes the steps to install the I80 LCD IO driver and then get the"
" panel handle.
    :SOC_LCD_RGB_SUPPORTED: - :ref:`rgb_lcd_panel` - is based on a group of specific synchronous signals indicating where to start and stop a frame. The frame buffer is allocated on the ESP side. The driver install steps are much simplified because we do not need to install any IO interface driver in this case.
    - :ref:`lcd_panel_operations` - provides a set of APIs to operate the LCD panel, like turning on/off the display, setting the orientation, etc. These operations are com"
"mon for either controller-based LCD panel driver or RGB LCD panel driver.

.. _spi_lcd_panel:

SPI Interfaced LCD


#. Create an SPI bus. Please refer to :doc:`SPI Master API doc ` for more details.

    .. code-block:: c

        spi_bus_config_t buscfg = {
            .sclk_io_num = EXAMPLE_PIN_NUM_SCLK,
            .mosi_io_num = EXAMPLE_PIN_NUM_MOSI,
            .miso_io_num = EXAMPLE_PIN_NUM_MISO,
            .quadwp_io_num = -1, // Quad SPI LCD driver is not yet supported
            .quad"
"hd_io_num = -1, // Quad SPI LCD driver is not yet supported
            .max_transfer_sz = EXAMPLE_LCD_H_RES * 80 * sizeof(uint16_t), // transfer 80 lines of pixels (assume pixel is RGB565) at most in one SPI transaction
        };
        ESP_ERROR_CHECK(spi_bus_initialize(LCD_HOST, &buscfg, SPI_DMA_CH_AUTO)); // Enable the DMA feature

#. Allocate an LCD IO device handle from the SPI bus. In this step, you need to provide the following information:

    - :cpp:member:`esp_lcd_panel_io_spi_conf"
"ig_t::dc_gpio_num`: Sets the gpio number for the DC signal line (some LCD calls this ``RS`` line). The LCD driver uses this GPIO to switch between sending command and sending data.
    - :cpp:member:`esp_lcd_panel_io_spi_config_t::cs_gpio_num`: Sets the gpio number for the CS signal line. The LCD driver uses this GPIO to select the LCD chip. If the SPI bus only has one device attached (i.e., this LCD), you can set the gpio number to ``-1`` to occupy the bus exclusively.
    - :cpp:member:`esp_lc"
"d_panel_io_spi_config_t::pclk_hz` sets the frequency of the pixel clock, in Hz. The value should not exceed the range recommended in the LCD spec.
    - :cpp:member:`esp_lcd_panel_io_spi_config_t::spi_mode` sets the SPI mode. The LCD driver uses this mode to communicate with the LCD. For the meaning of the SPI mode, please refer to the :doc:`SPI Master API doc `.
    - :cpp:member:`esp_lcd_panel_io_spi_config_t::lcd_cmd_bits` and :cpp:member:`esp_lcd_panel_io_spi_config_t::lcd_param_bits` set th"
"e bit width of the command and parameter that recognized by the LCD controller chip. This is chip specific, you should refer to your LCD spec in advance.
    - :cpp:member:`esp_lcd_panel_io_spi_config_t::trans_queue_depth` sets the depth of the SPI transaction queue. A bigger value means more transactions can be queued up, but it also consumes more memory.

    .. code-block:: c

        esp_lcd_panel_io_handle_t io_handle = NULL;
        esp_lcd_panel_io_spi_config_t io_config = {
            ."
"dc_gpio_num = EXAMPLE_PIN_NUM_LCD_DC,
            .cs_gpio_num = EXAMPLE_PIN_NUM_LCD_CS,
            .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
            .lcd_cmd_bits = EXAMPLE_LCD_CMD_BITS,
            .lcd_param_bits = EXAMPLE_LCD_PARAM_BITS,
            .spi_mode = 0,
            .trans_queue_depth = 10,
        };
        // Attach the LCD to the SPI bus
        ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)LCD_HOST, &io_config, &io_handle));

#. Install the LCD controlle"
"r driver. The LCD controller driver is responsible for sending the commands and parameters to the LCD controller chip. In this step, you need to specify the SPI IO device handle that allocated in the last step, and some panel specific configurations:

    - :cpp:member:`esp_lcd_panel_dev_config_t::reset_gpio_num` sets the LCD's hardware reset GPIO number. If the LCD does not have a hardware reset pin, set this to ``-1``.
    - :cpp:member:`esp_lcd_panel_dev_config_t::rgb_ele_order` sets the R-G-"
"B element order of each color data.
    - :cpp:member:`esp_lcd_panel_dev_config_t::bits_per_pixel` sets the bit width of the pixel color data. The LCD driver uses this value to calculate the number of bytes to send to the LCD controller chip.
    - :cpp:member:`esp_lcd_panel_dev_config_t::data_endian` specifies the data endian to be transmitted to the screen. No need to specify for color data within 1 byte, like RGB232. For drivers that do not support specifying data endian, this field would be "
"ignored.

    .. code-block:: c

        esp_lcd_panel_handle_t panel_handle = NULL;
        esp_lcd_panel_dev_config_t panel_config = {
            .reset_gpio_num = EXAMPLE_PIN_NUM_RST,
            .rgb_ele_order = LCD_RGB_ELEMENT_ORDER_BGR,
            .bits_per_pixel = 16,
        };
        // Create LCD panel handle for ST7789, with the SPI IO device handle
        ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(io_handle, &panel_config, &panel_handle));

.. _i2c_lcd_panel:

I2C Interfaced LCD


"
"#. Create I2C bus. Please refer to :doc:`I2C API doc ` for more details.

    .. code-block:: c

        i2c_master_bus_handle_t i2c_bus = NULL;
        i2c_master_bus_config_t bus_config = {
            .clk_source = I2C_CLK_SRC_DEFAULT,
            .glitch_ignore_cnt = 7,
            .i2c_port = I2C_BUS_PORT,
            .sda_io_num = EXAMPLE_PIN_NUM_SDA,
            .scl_io_num = EXAMPLE_PIN_NUM_SCL,
            .flags.enable_internal_pullup = true,
        };
        ESP_ERROR_CHECK(i2c_new_"
"master_bus(&bus_config, &i2c_bus));

#. Allocate an LCD IO device handle from the I2C bus. In this step, you need to provide the following information:

    - :cpp:member:`esp_lcd_panel_io_i2c_config_t::dev_addr` sets the I2C device address of the LCD controller chip. The LCD driver uses this address to communicate with the LCD controller chip.
    - :cpp:member:`esp_lcd_panel_io_i2c_config_t::scl_speed_hz` sets the I2C clock frequency in Hz. The value should not exceed the range recommended in "
"the LCD spec.
    - :cpp:member:`esp_lcd_panel_io_i2c_config_t::lcd_cmd_bits` and :cpp:member:`esp_lcd_panel_io_i2c_config_t::lcd_param_bits` set the bit width of the command and parameter that recognized by the LCD controller chip. This is chip specific, you should refer to your LCD spec in advance.

    .. code-block:: c

        esp_lcd_panel_io_handle_t io_handle = NULL;
        esp_lcd_panel_io_i2c_config_t io_config = {
            .dev_addr = EXAMPLE_I2C_HW_ADDR,
            .scl_speed_hz"
" = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
            .control_phase_bytes = 1, // refer to LCD spec
            .dc_bit_offset = 6,       // refer to LCD spec
            .lcd_cmd_bits = EXAMPLE_LCD_CMD_BITS,
            .lcd_param_bits = EXAMPLE_LCD_CMD_BITS,
        };
        ESP_ERROR_CHECK(esp_lcd_new_panel_io_i2c(i2c_bus, &io_config, &io_handle));

#. Install the LCD controller driver. The LCD controller driver is responsible for sending the commands and parameters to the LCD controller chip. In thi"
"s step, you need to specify the I2C IO device handle that allocated in the last step, and some panel specific configurations:

    - :cpp:member:`esp_lcd_panel_dev_config_t::reset_gpio_num` sets the LCD's hardware reset GPIO number. If the LCD does not have a hardware reset pin, set this to ``-1``.
    - :cpp:member:`esp_lcd_panel_dev_config_t::bits_per_pixel` sets the bit width of the pixel color data. The LCD driver uses this value to calculate the number of bytes to send to the LCD controller"
" chip.

    .. code-block:: c

        esp_lcd_panel_handle_t panel_handle = NULL;
        esp_lcd_panel_dev_config_t panel_config = {
            .bits_per_pixel = 1,
            .reset_gpio_num = EXAMPLE_PIN_NUM_RST,
        };
        ESP_ERROR_CHECK(esp_lcd_new_panel_ssd1306(io_handle, &panel_config, &panel_handle));

.. only:: SOC_LCD_I80_SUPPORTED

    .. _i80_lcd_panel:

    I80 Interfaced LCD
    

    #. Create I80 bus by :cpp:func:`esp_lcd_new_i80_bus`. You need to set up the following"
" parameters for an Intel 8080 parallel bus:

        - :cpp:member:`esp_lcd_i80_bus_config_t::clk_src` sets the clock source of the I80 bus. Note, the default clock source may be different between ESP targets.
        - :cpp:member:`esp_lcd_i80_bus_config_t::wr_gpio_num` sets the GPIO number of the pixel clock (also referred as ``WR`` in some LCD spec)
        - :cpp:member:`esp_lcd_i80_bus_config_t::dc_gpio_num` sets the GPIO number of the data/command select pin (also referred as ``RS`` in som"
"e LCD spec)
        - :cpp:member:`esp_lcd_i80_bus_config_t::bus_width` sets the bit width of the data bus (only support ``8`` or ``16``)
        - :cpp:member:`esp_lcd_i80_bus_config_t::data_gpio_nums` is the array of the GPIO number of the data bus. The number of GPIOs should be equal to the :cpp:member:`esp_lcd_i80_bus_config_t::bus_width` value.
        - :cpp:member:`esp_lcd_i80_bus_config_t::max_transfer_bytes` sets the maximum number of bytes that can be transferred in one transaction.

 "
"       .. code-block:: c

            esp_lcd_i80_bus_handle_t i80_bus = NULL;
            esp_lcd_i80_bus_config_t bus_config = {
                .clk_src = LCD_CLK_SRC_DEFAULT,
                .dc_gpio_num = EXAMPLE_PIN_NUM_DC,
                .wr_gpio_num = EXAMPLE_PIN_NUM_PCLK,
                .data_gpio_nums = {
                    EXAMPLE_PIN_NUM_DATA0,
                    EXAMPLE_PIN_NUM_DATA1,
                    EXAMPLE_PIN_NUM_DATA2,
                    EXAMPLE_PIN_NUM_DATA3,
         "
"           EXAMPLE_PIN_NUM_DATA4,
                    EXAMPLE_PIN_NUM_DATA5,
                    EXAMPLE_PIN_NUM_DATA6,
                    EXAMPLE_PIN_NUM_DATA7,
                },
                .bus_width = 8,
                .max_transfer_bytes = EXAMPLE_LCD_H_RES * 100 * sizeof(uint16_t), // transfer 100 lines of pixels (assume pixel is RGB565) at most in one transaction
                .psram_trans_align = EXAMPLE_PSRAM_DATA_ALIGNMENT,
                .sram_trans_align = 4,
            };"
"
            ESP_ERROR_CHECK(esp_lcd_new_i80_bus(&bus_config, &i80_bus));

    #. Allocate an LCD IO device handle from the I80 bus. In this step, you need to provide the following information:

        - :cpp:member:`esp_lcd_panel_io_i80_config_t::cs_gpio_num` sets the GPIO number of the chip select pin.
        - :cpp:member:`esp_lcd_panel_io_i80_config_t::pclk_hz` sets the pixel clock frequency in Hz. Higher pixel clock frequency results in higher refresh rate, but may cause flickering if the"
" DMA bandwidth is not sufficient or the LCD controller chip does not support high pixel clock frequency.
        - :cpp:member:`esp_lcd_panel_io_i80_config_t::lcd_cmd_bits` and :cpp:member:`esp_lcd_panel_io_i80_config_t::lcd_param_bits` set the bit width of the command and parameter that recognized by the LCD controller chip. This is chip specific, you should refer to your LCD spec in advance.
        - :cpp:member:`esp_lcd_panel_io_i80_config_t::trans_queue_depth` sets the maximum number of tra"
"nsactions that can be queued in the LCD IO device. A bigger value means more transactions can be queued up, but it also consumes more memory.

        .. code-block:: c

            esp_lcd_panel_io_handle_t io_handle = NULL;
            esp_lcd_panel_io_i80_config_t io_config = {
                .cs_gpio_num = EXAMPLE_PIN_NUM_CS,
                .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
                .trans_queue_depth = 10,
                .dc_levels = {
                    .dc_idle_level = 0,
"
"                    .dc_cmd_level = 0,
                    .dc_dummy_level = 0,
                    .dc_data_level = 1,
                },
                .lcd_cmd_bits = EXAMPLE_LCD_CMD_BITS,
                .lcd_param_bits = EXAMPLE_LCD_PARAM_BITS,
            };
            ESP_ERROR_CHECK(esp_lcd_new_panel_io_i80(i80_bus, &io_config, &io_handle));

    #. Install the LCD controller driver. The LCD controller driver is responsible for sending the commands and parameters to the LCD controller "
"chip. In this step, you need to specify the I80 IO device handle that allocated in the last step, and some panel specific configurations:

        - :cpp:member:`esp_lcd_panel_dev_config_t::bits_per_pixel` sets the bit width of the pixel color data. The LCD driver uses this value to calculate the number of bytes to send to the LCD controller chip.
        - :cpp:member:`esp_lcd_panel_dev_config_t::reset_gpio_num` sets the GPIO number of the reset pin. If the LCD controller chip does not have a r"
"eset pin, you can set this value to ``-1``.
        - :cpp:member:`esp_lcd_panel_dev_config_t::rgb_ele_order` sets the color order the pixel color data.

        .. code-block:: c

            esp_lcd_panel_dev_config_t panel_config = {
                .reset_gpio_num = EXAMPLE_PIN_NUM_RST,
                .rgb_ele_order = LCD_RGB_ELEMENT_ORDER_RGB,
                .bits_per_pixel = 16,
            };
            ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(io_handle, &panel_config, &panel_handle));"
"

    .. _more_controller_based_lcd_drivers:

.. only:: not SOC_LCD_I80_SUPPORTED

    .. _more_controller_based_lcd_drivers:

More Controller Based LCD Drivers


More LCD panel drivers and touch drivers are available in `ESP-IDF Component Registry `_. The list of available and planned drivers with links is in this `table `_.

.. only:: SOC_LCD_RGB_SUPPORTED

    .. _rgb_lcd_panel:

    RGB Interfaced LCD
    

    RGB LCD panel is allocated in one step: :cpp:func:`esp_lcd_new_rgb_panel`, with v"
"arious configurations specified by :cpp:type:`esp_lcd_rgb_panel_config_t`.

    - :cpp:member:`esp_lcd_rgb_panel_config_t::clk_src` selects the clock source for the RGB LCD controller. The available clock sources are listed in :cpp:type:`lcd_clock_source_t`.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::data_width` set number of data lines used by the RGB interface. Currently, the supported value can be 8 or 16.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::bits_per_pixel` set the number of bi"
"ts per pixel. This is different from :cpp:member:`esp_lcd_rgb_panel_config_t::data_width`. By default, if you set this field to 0, the driver will automatically adjust the bpp to the :cpp:member:`esp_lcd_rgb_panel_config_t::data_width`. But in some cases, these two value must be different. For example, a Serial RGB interface LCD only needs ``8`` data lines, but the color width can reach to ``RGB888``, i.e., the :cpp:member:`esp_lcd_rgb_panel_config_t::bits_per_pixel` should be set to ``24``.
   "
" - :cpp:member:`esp_lcd_rgb_panel_config_t::hsync_gpio_num`, :cpp:member:`esp_lcd_rgb_panel_config_t::vsync_gpio_num`, :cpp:member:`esp_lcd_rgb_panel_config_t::de_gpio_num`, :cpp:member:`esp_lcd_rgb_panel_config_t::pclk_gpio_num`, :cpp:member:`esp_lcd_rgb_panel_config_t::disp_gpio_num` and :cpp:member:`esp_lcd_rgb_panel_config_t::data_gpio_nums` are the GPIO pins used by the RGB LCD controller. If some of them are not used, please set it to `-1`.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::sr"
"am_trans_align` and :cpp:member:`esp_lcd_rgb_panel_config_t::psram_trans_align` set the alignment of the allocated frame buffer. Internally, the DMA transfer ability will adjust against these alignment values. A higher alignment value can lead to a bigger DMA burst size. Please note, the alignment value must be a power of 2.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::bounce_buffer_size_px` set the size of bounce buffer. This is only necessary for a so-called ""bounce buffer"" mode. Please refe"
"r to :ref:`bounce_buffer_with_single_psram_frame_buffer` for more information.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::timings` sets the LCD panel specific timing parameters. All required parameters are listed in the :cpp:type:`esp_lcd_rgb_timing_t`, including the LCD resolution and blanking porches. Please fill them according to the datasheet of your LCD.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::fb_in_psram` sets whether to allocate the frame buffer from PSRAM or not. Please refer "
"to :ref:`single_frame_buffer_in_psram` for more information.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::num_fbs` sets the number of frame buffers allocated by the driver. For backward compatibility, ``0`` means to allocate ``one`` frame buffer. Please use :cpp:member:`esp_lcd_rgb_panel_config_t::no_fb` if you do not want to allocate any frame buffer.
    - :cpp:member:`esp_lcd_rgb_panel_config_t::no_fb` if sets, no frame buffer will be allocated. This is also called the :ref:`bounce_buffer_o"
"nly` mode.

    RGB LCD Frame Buffer Operation Modes
    

    Most of the time, the RGB LCD driver should maintain at least one screen sized frame buffer. According to the number and location of the frame buffer, the driver provides several different buffer modes.

    Single Frame Buffer in Internal Memory
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This is the default and simplest and you do not have to specify flags or bounce buffer options. A frame buffer is allocated from the internal "
"memory. The frame data is read out by DMA to the LCD verbatim. It needs no CPU intervention to function, but it has the downside that it uses up a fair bit of the limited amount of internal memory.

    .. code:: c

        esp_lcd_panel_handle_t panel_handle = NULL;
        esp_lcd_rgb_panel_config_t panel_config = {
            .data_width = 16, // RGB565 in parallel mode, thus 16bit in width
            .clk_src = LCD_CLK_SRC_DEFAULT,
            .disp_gpio_num = EXAMPLE_PIN_NUM_DISP_EN,
    "
"        .pclk_gpio_num = EXAMPLE_PIN_NUM_PCLK,
            .vsync_gpio_num = EXAMPLE_PIN_NUM_VSYNC,
            .hsync_gpio_num = EXAMPLE_PIN_NUM_HSYNC,
            .de_gpio_num = EXAMPLE_PIN_NUM_DE,
            .data_gpio_nums = {
                EXAMPLE_PIN_NUM_DATA0,
                EXAMPLE_PIN_NUM_DATA1,
                EXAMPLE_PIN_NUM_DATA2,
                // other GPIOs
                // The number of GPIOs here should be the same to the value of `data_width` above
                ...
  "
"          },
            // The timing parameters should refer to your LCD spec
            .timings = {
                .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
                .h_res = EXAMPLE_LCD_H_RES,
                .v_res = EXAMPLE_LCD_V_RES,
                .hsync_back_porch = 40,
                .hsync_front_porch = 20,
                .hsync_pulse_width = 1,
                .vsync_back_porch = 8,
                .vsync_front_porch = 4,
                .vsync_pulse_width = 1,
            "
"},
        };
        ESP_ERROR_CHECK(esp_lcd_new_rgb_panel(&panel_config, &panel_handle));

    .. _single_frame_buffer_in_psram:

    Single Frame Buffer in PSRAM
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    If you have PSRAM and want to store the frame buffer there rather than in the limited internal memory, the LCD peripheral will use EDMA to fetch frame data directly from the PSRAM, bypassing the internal cache. You can enable this feature by setting the :cpp:member:`esp_lcd_rgb_panel_config_t::fb"
"_in_psram` to ``true``. The downside of this is that when both the CPU as well as EDMA need access to the PSRAM, the bandwidth will be **shared** between them, that is, EDMA gets half and the CPUs get the other half. If there are other peripherals using EDMA as well, with a high enough pixel clock this can lead to starvation of the LCD peripheral, leading to display corruption. However, if the pixel clock is low enough for this not to be an issue, this is a solution that uses almost no CPU inter"
"vention.

    .. only:: esp32s3

        The PSRAM shares the same SPI bus with the main Flash (the one stores your firmware binary). At one time, there only be one consumer of the SPI bus. When you also use the main flash to serve your file system (e.g., :doc:`SPIFFS `), the bandwidth of the underlying SPI bus will also be shared, leading to display corruption. You can use :cpp:func:`esp_lcd_rgb_panel_set_pclk` to update the pixel clock frequency to a lower value.


    .. code:: c

        esp"
"_lcd_panel_handle_t panel_handle = NULL;
        esp_lcd_rgb_panel_config_t panel_config = {
            .data_width = 16, // RGB565 in parallel mode, thus 16bit in width
            .clk_src = LCD_CLK_SRC_DEFAULT,
            .disp_gpio_num = EXAMPLE_PIN_NUM_DISP_EN,
            .pclk_gpio_num = EXAMPLE_PIN_NUM_PCLK,
            .vsync_gpio_num = EXAMPLE_PIN_NUM_VSYNC,
            .hsync_gpio_num = EXAMPLE_PIN_NUM_HSYNC,
            .de_gpio_num = EXAMPLE_PIN_NUM_DE,
            .data_gpio_nums"
" = {
                EXAMPLE_PIN_NUM_DATA0,
                EXAMPLE_PIN_NUM_DATA1,
                EXAMPLE_PIN_NUM_DATA2,
                // other GPIOs
                // The number of GPIOs here should be the same to the value of `data_width` above
                ...
            },
            // The timing parameters should refer to your LCD spec
            .timings = {
                .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
                .h_res = EXAMPLE_LCD_H_RES,
                .v_res "
"= EXAMPLE_LCD_V_RES,
                .hsync_back_porch = 40,
                .hsync_front_porch = 20,
                .hsync_pulse_width = 1,
                .vsync_back_porch = 8,
                .vsync_front_porch = 4,
                .vsync_pulse_width = 1,
            },
            .flags.fb_in_psram = true, // allocate frame buffer from PSRAM
        };
        ESP_ERROR_CHECK(esp_lcd_new_rgb_panel(&panel_config, &panel_handle));

    .. _double_frame_buffer_in_psram:

    Double Frame Buf"
"fer in PSRAM
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    To avoid tearing effect, using two screen sized frame buffers is the easiest approach. In this mode, the frame buffer can only be allocated from PSRAM, because of the limited internal memory. The frame buffer that the CPU write to and the frame buffer that the EDMA read from are guaranteed to be different and independent. The EDMA will only switch between the two frame buffers when the previous write operation is finished and the current frame h"
"as been sent to the LCD. The downside of this mode is that, you have to maintain the synchronization between the two frame buffers.

    .. code:: c

        esp_lcd_panel_handle_t panel_handle = NULL;
        esp_lcd_rgb_panel_config_t panel_config = {
            .data_width = 16, // RGB565 in parallel mode, thus 16bit in width
            .num_fbs = 2,     // allocate double frame buffer
            .clk_src = LCD_CLK_SRC_DEFAULT,
            .disp_gpio_num = EXAMPLE_PIN_NUM_DISP_EN,
        "
"    .pclk_gpio_num = EXAMPLE_PIN_NUM_PCLK,
            .vsync_gpio_num = EXAMPLE_PIN_NUM_VSYNC,
            .hsync_gpio_num = EXAMPLE_PIN_NUM_HSYNC,
            .de_gpio_num = EXAMPLE_PIN_NUM_DE,
            .data_gpio_nums = {
                EXAMPLE_PIN_NUM_DATA0,
                EXAMPLE_PIN_NUM_DATA1,
                EXAMPLE_PIN_NUM_DATA2,
                // other GPIOs
                // The number of GPIOs here should be the same to the value of `data_width` above
                ...
      "
"      },
            // The timing parameters should refer to your LCD spec
            .timings = {
                .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
                .h_res = EXAMPLE_LCD_H_RES,
                .v_res = EXAMPLE_LCD_V_RES,
                .hsync_back_porch = 40,
                .hsync_front_porch = 20,
                .hsync_pulse_width = 1,
                .vsync_back_porch = 8,
                .vsync_front_porch = 4,
                .vsync_pulse_width = 1,
            },
 "
"           .flags.fb_in_psram = true, // allocate frame buffer from PSRAM
        };
        ESP_ERROR_CHECK(esp_lcd_new_rgb_panel(&panel_config, &panel_handle));

    .. _bounce_buffer_with_single_psram_frame_buffer:

    Bounce Buffer with Single PSRAM Frame Buffer
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This mode allocates two so-called ``bounce buffers`` from the internal memory, and a main frame buffer that is still in PSRAM. This mode is selected by setting the :cpp:member:`e"
"sp_lcd_rgb_panel_config_t::fb_in_psram` flag and additionally specifying a non-zero :cpp:member:`esp_lcd_rgb_panel_config_t::bounce_buffer_size_px` value. The bounce buffers only need to be large enough to hold a few lines of display data, which is significantly less than the main frame buffer. The LCD peripheral uses DMA to read data from one of the bounce buffers, and meanwhile an interrupt routine uses the CPU DCache to copy data from the main PSRAM frame buffer into the other bounce buffer. "
"Once the LCD peripheral has finished reading the bounce buffer, the two buffers change place and the CPU can fill the others. The advantage of this mode is that, you can achieve higher pixel clock frequency. As the bounce buffers are larger than the FIFOs in the EDMA path, this method is also more robust against short bandwidth spikes. The downside is a major increase in CPU use and the LCD **CAN NOT** work if we disable the cache of the external memory, via e.g., OTA or NVS write to the main fl"
"ash.

    .. note::

        It is highly recommended to turn on the ""PSRAM XIP (Execute In Place)"" feature in this mode by enabling the Kconfig options: :ref:`CONFIG_SPIRAM_FETCH_INSTRUCTIONS` and :ref:`CONFIG_SPIRAM_RODATA`, which allows the CPU to fetch instructions and readonly data from the PSRAM instead of the main flash. What is more, the external memory cache will not be disabled even if you attempt to write to the main flash through SPI1. This makes it possible to display an OTA progres"
"s bar for your application.

    .. note::

        This mode still has another problem which is also caused by insufficient PSRAM bandwidth. e.g., when your draw buffers are allocated from PSRAM, and their contents are copied into the internal frame buffer on CPU core 1. On CPU core 0, there is another memory copy happening in the DMA EOF ISR. In this situation, both CPUs are accessing the PSRAM by cache and sharing the bandwidth of the PSRAM. This increases the memory copy time that spent in t"
"he DMA EOF ISR significantly. The driver can not switch the bounce buffer in time, thus leading to a shift on the LCD screen. Although the driver can detect such a condition and perform a restart in the LCD's VSYNC interrupt handler, you still can see a flickering on the screen.

    .. code:: c

        esp_lcd_panel_handle_t panel_handle = NULL;
        esp_lcd_rgb_panel_config_t panel_config = {
            .data_width = 16, // RGB565 in parallel mode, thus 16bit in width
            .clk_src"
" = LCD_CLK_SRC_DEFAULT,
            .bounce_buffer_size_px = 10 * EXAMPLE_LCD_H_RES, // allocate 10 lines data as bounce buffer from internal memory
            .disp_gpio_num = EXAMPLE_PIN_NUM_DISP_EN,
            .pclk_gpio_num = EXAMPLE_PIN_NUM_PCLK,
            .vsync_gpio_num = EXAMPLE_PIN_NUM_VSYNC,
            .hsync_gpio_num = EXAMPLE_PIN_NUM_HSYNC,
            .de_gpio_num = EXAMPLE_PIN_NUM_DE,
            .data_gpio_nums = {
                EXAMPLE_PIN_NUM_DATA0,
                EXAMPL"
"E_PIN_NUM_DATA1,
                EXAMPLE_PIN_NUM_DATA2,
                // other GPIOs
                // The number of GPIOs here should be the same to the value of `data_width` above
                ...
            },
            // The timing parameters should refer to your LCD spec
            .timings = {
                .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
                .h_res = EXAMPLE_LCD_H_RES,
                .v_res = EXAMPLE_LCD_V_RES,
                .hsync_back_porch = 40,
     "
"           .hsync_front_porch = 20,
                .hsync_pulse_width = 1,
                .vsync_back_porch = 8,
                .vsync_front_porch = 4,
                .vsync_pulse_width = 1,
            },
            .flags.fb_in_psram = true, // allocate frame buffer from PSRAM
        };
        ESP_ERROR_CHECK(esp_lcd_new_rgb_panel(&panel_config, &panel_handle));

    Note that this mode also allows for a :cpp:member:`esp_lcd_rgb_panel_config_t::bb_invalidate_cache` flag to be set. Enabl"
"ing this frees up the cache lines after they are used to read out the frame buffer data from PSRAM, but it may lead to slight corruption if the other core writes data to the frame buffer at the exact time the cache lines are freed up. (Technically, a write to the frame buffer can be ignored if it falls between the cache writeback and the cache invalidate calls.)

    .. _bounce_buffer_only:

    Bounce Buffer Only
    ~~~~~~~~~~~~~~~~~~

    This mode is similar to the :ref:`bounce_buffer_with_s"
"ingle_psram_frame_buffer`, but there is no PSRAM frame buffer initialized by the LCD driver. Instead, the user supplies a callback function that is responsible for filling the bounce buffers. As this driver does not care where the written pixels come from, this allows for the callback doing e.g., on-the-fly conversion from a smaller, 8-bit-per-pixel PSRAM frame buffer to an 16-bit LCD, or even procedurally-generated frame-buffer-less graphics. This option is selected by setting the :cpp:member:`"
"esp_lcd_rgb_panel_config_t::no_fb` flag and supplying a :cpp:member:`esp_lcd_rgb_panel_config_t::bounce_buffer_size_px` value. And then register the :cpp:member:`esp_lcd_rgb_panel_event_callbacks_t::on_bounce_empty` callback by calling :cpp:func:`esp_lcd_rgb_panel_register_event_callbacks`.

    .. note::

        It should never happen in a well-designed embedded application, but it can in theory be possible that the DMA cannot deliver data as fast as the LCD consumes it. In the {IDF_TARGET_NAM"
"E} hardware, this leads to the LCD simply outputting dummy bytes while DMA waits for data. If we were to run DMA in a stream fashion, this would mean a de-sync between the LCD address the DMA reads the data for and the LCD address the LCD peripheral thinks it outputs data for, leading to a **permanently** shifted image.
        In order to stop this from happening, you can either enable the :ref:`CONFIG_LCD_RGB_RESTART_IN_VSYNC` option, so the driver can restart the DMA in the VBlank interrupt a"
"utomatically or call :cpp:func:`esp_lcd_rgb_panel_restart` to restart the DMA manually. Note :cpp:func:`esp_lcd_rgb_panel_restart` does not restart the DMA immediately, the DMA is still restarted in the next VSYNC event.

    .. _lcd_panel_operations:

.. only:: not SOC_LCD_RGB_SUPPORTED

    .. _lcd_panel_operations:

LCD Panel Basic Operations


.. _steps_add_manufacture_init:

Steps to Add Manufacture Specific Initialization


The LCD controller drivers (e.g., st7789) in ESP-IDF only provide "
"basic initialization in the :cpp:func:`esp_lcd_panel_init`, leaving the vast majority of settings to the default values. Some LCD modules needs to set a bunch of manufacture specific configurations before it can display normally. These configurations usually include gamma, power voltage and so on. If you want to add manufacture specific initialization, please follow the steps below:

.. code:: c

    esp_lcd_panel_reset(panel_handle);
    esp_lcd_panel_init(panel_handle);
    // set extra config"
"urations e.g., gamma control
    // with the underlying IO handle
    // please consult your manufacture for special commands and corresponding values
    esp_lcd_panel_io_tx_param(io_handle, GAMMA_CMD, (uint8_t[]) {
           GAMMA_ARRAY
        }, N);
    // turn on the display
    esp_lcd_panel_disp_on_off(panel_handle, true);

Application Example


LCD examples are located under: :example:`peripherals/lcd`:

.. list::
    :SOC_LCD_I80_SUPPORTED: * i80 controller based LCD and LVGL animation"
" UI - :example:`peripherals/lcd/i80_controller`
    :SOC_LCD_RGB_SUPPORTED: * RGB panel example with scatter chart UI - :example:`peripherals/lcd/rgb_panel`

API Reference


.. include-build-file:: inc/lcd_types.inc
.. include-build-file:: inc/esp_lcd_types.inc
.. include-build-file:: inc/esp_lcd_panel_io.inc
.. include-build-file:: inc/esp_lcd_panel_ops.inc
.. include-build-file:: inc/esp_lcd_panel_vendor.inc

.. only:: SOC_LCD_RGB_SUPPORTED

    .. include-build-file:: inc/esp_lcd_panel_rgb.in"
"c
"
"Parallel IO


Introduction


The Parallel IO peripheral is a general purpose parallel interface that can be used to connect to external devices such as LED matrix, LCD display, Printer and Camera. The peripheral has independent TX and RX units. Each unit can have up to 8 or 16 data signals plus 1 or 2 clock signals. [1]_

The TX and RX driver of Parallel IO peripheral are designed separately, you can include ``driver/parlio_tx.h`` or ``driver/parlio_rx.h`` to use any of them.

Application Exampl"
"es



API Reference


.. include-build-file:: inc/parlio_tx.inc
.. include-build-file:: inc/parlio_rx.inc
.. include-build-file:: inc/components/esp_driver_parlio/include/driver/parlio_types.inc
.. include-build-file:: inc/components/hal/include/hal/parlio_types.inc

.. [1]
   Different ESP chip series might have different numbers of PARLIO TX/RX instances, and the maximum data bus can also be different. For more details, please refer to **{IDF_TARGET_NAME} Technical Reference Manual** > Chapter"
" **Parallel IO (PARLIO)** [`PDF `__]. The driver does not forbid you from applying for more driver objects, but it returns error when all available hardware resources are used up. Please always check the return value when doing resource allocation (e.g., :cpp:func:`parlio_new_tx_unit`).
"
"Analog Comparator


{IDF_TARGET_ANA_CMPR_SRC_CHAN0: default=""NOT UPDATED"", esp32h2=""GPIO11"", esp32p4=""GPIO52""}
{IDF_TARGET_ANA_CMPR_EXT_REF_CHAN0: default=""NOT UPDATED"", esp32h2=""GPIO10"", esp32p4=""GPIO51""}
{IDF_TARGET_ANA_CMPR_SRC_CHAN1: default=""NOT UPDATED"", esp32p4=""GPIO54""}
{IDF_TARGET_ANA_CMPR_EXT_REF_CHAN1: default=""NOT UPDATED"", esp32p4=""GPIO53""}

Introduction


Analog Comparator is a peripheral that can be used to compare a source signal with the internal reference voltage or an external"
" reference signal.

It is a cost effective way to replace an amplifier comparator in some scenarios. But unlike the continuous comparing of the amplifier comparator, ESP Analog Comparator is driven by a source clock, which decides the sampling frequency.

Analog Comparator on {IDF_TARGET_NAME} has {IDF_TARGET_SOC_ANA_CMPR_NUM} unit(s), the channels in the unit(s) are:

**UNIT0**

- Source Channel: {IDF_TARGET_ANA_CMPR_SRC_CHAN0}
- External Reference Channel: {IDF_TARGET_ANA_CMPR_EXT_REF_CHAN0}
-"
" Internal Reference Channel: Range 0% ~ 70% of the VDD, the step is 10% of the VDD

.. only:: esp32p4

    **UNIT1**

    - Source Channel: {IDF_TARGET_ANA_CMPR_SRC_CHAN1}
    - External Reference Channel: {IDF_TARGET_ANA_CMPR_EXT_REF_CHAN1}
    - Internal Reference Channel: Range 0% ~ 70% of the VDD, the step is 10% of the VDD

Functional Overview


The following sections of this document cover the typical steps to install and operate an Analog Comparator unit:

-  `Resource Allocation `__ - co"
"vers which parameters should be set up to get a unit handle and how to recycle the resources when it finishes working.
-  `Further Configurations `__ - covers the other configurations that might need to specific and what they are used for.
-  `Enable and Disable Unit `__ - covers how to enable and disable the unit.
-  `Power Management `__ - describes how different source clock selections can affect power consumption.
-  `IRAM Safe `__ - lists which functions are supposed to work even when the c"
"ache is disabled.
-  `Thread Safety `__ - lists which APIs are guaranteed to be thread safe by the driver.
-  `Kconfig Options `__ - lists the supported Kconfig options that can be used to make a different effect on driver behavior.

.. only:: SOC_ANA_CMPR_SUPPORT_ETM

    - `ETM Events `__ -

Resource Allocation


An Analog Comparator unit channel is represented by :cpp:type:`ana_cmpr_handle_t`. Each unit can support either an internal or an external reference.

To allocate the resource of the "
"Analog Comparator unit, :cpp:func:`ana_cmpr_new_unit` need to be called to get the handle of the unit. Configurations :cpp:type:`ana_cmpr_config_t` need to be specified while allocating the unit:

- :cpp:member:`ana_cmpr_config_t::unit` selects the Analog Comparator unit.
- :cpp:member:`ana_cmpr_config_t::clk_src` selects the source clock for Analog Comparator, it can affect the sampling frequency. Note that the clock source of the Analog Comparator comes from the io mux, it is shared with GPIO "
"extension peripherals like SDM (Sigma-Delta Modulation) and Glitch Filter. The configuration will fail if you specific different clock sources for multiple GPIO extension peripherals. The default clock sources of these peripherals are same, typically, we select :cpp:enumerator:`soc_periph_ana_cmpr_clk_src_t::ANA_CMPR_CLK_SRC_DEFAULT` as the clock source.
- :cpp:member:`ana_cmpr_config_t::ref_src` selects the reference source from internal voltage or external signal.
- :cpp:member:`ana_cmpr_confi"
"g_t::cross_type` selects which kind of cross type can trigger the interrupt.

The function :cpp:func:`ana_cmpr_new_unit` can fail due to various errors such as insufficient memory, invalid arguments, etc. If a previously created Analog Comparator unit is no longer required, you should recycle it by calling :cpp:func:`ana_cmpr_del_unit`. It allows the underlying HW channel to be used for other purposes. Before deleting an Analog Comparator unit handle, you should disable it by :cpp:func:`ana_cmpr"
"_unit_disable` in advance, or make sure it has not enabled yet by :cpp:func:`ana_cmpr_unit_enable`.

.. code:: c

    #include ""driver/ana_cmpr.h""

    ana_cmpr_handle_t cmpr = NULL;
    ana_cmpr_config_t config = {
        .unit = 0,
        .clk_src = ANA_CMPR_CLK_SRC_DEFAULT,
        .ref_src = ANA_CMPR_REF_SRC_INTERNAL,
        .cross_type = ANA_CMPR_CROSS_ANY,
    };
    ESP_ERROR_CHECK(ana_cmpr_new_unit(&config, &cmpr));
    // ...
    ESP_ERROR_CHECK(ana_cmpr_del_unit(cmpr));

Further Con"
"figurations


- :cpp:func:`ana_cmpr_set_intl_reference` - Specify the internal reference voltage when :cpp:enumerator:`ana_cmpr_ref_source_t::ANA_CMPR_REF_SRC_INTERNAL` is selected as reference source.

It requires :cpp:member:`ana_cmpr_internal_ref_config_t::ref_volt` to specify the voltage. The voltage related to the VDD power supply, which can only support a certain fixed percentage of VDD. Currently on {IDF_TARGET_NAME}, the internal reference voltage can be range to 0 ~ 70% VDD with a step "
"10%.

.. code:: c

    #include ""driver/ana_cmpr.h""

    ana_cmpr_internal_ref_config_t ref_cfg = {
        .ref_volt = ANA_CMPR_REF_VOLT_50_PCT_VDD,
    };
    ESP_ERROR_CHECK(ana_cmpr_set_internal_reference(cmpr, &ref_cfg));

- :cpp:func:`ana_cmpr_set_debounce` - Set the debounce configuration.

It requires :cpp:member:`ana_cmpr_debounce_config_t::wait_us` to set the interrupt waiting time. The interrupt is disabled temporarily for :cpp:member:`ana_cmpr_debounce_config_t::wait_us` micro second"
"s, so that the frequent triggering can be avoid while the source signal crossing the reference signal. That is, the waiting time is supposed to be inverse ratio to the relative frequency between the source and reference. If the waiting time is set too short, it can not bypass the jitter totally, but if too long, the next crossing interrupt might be missed.

.. code:: c

    #include ""driver/ana_cmpr.h""

    ana_cmpr_debounce_config_t dbc_cfg = {
        .wait_us = 1,
    };
    ESP_ERROR_CHECK(a"
"na_cmpr_set_debounce(cmpr, &dbc_cfg));

- :cpp:func:`ana_cmpr_set_cross_type` - Set the source signal cross type.

The initial cross type is set int :cpp:func:`ana_cmpr_new_unit`, this function can update the cross type, even in ISR context.

.. code:: c

    #include ""driver/ana_cmpr.h""

    ESP_ERROR_CHECK(ana_cmpr_set_cross_type(cmpr, ANA_CMPR_CROSS_POS));

- :cpp:func:`ana_cmpr_register_event_callbacks` - Register the callbacks.

Currently it supports :cpp:member:`ana_cmpr_event_callbacks_t:"
":on_cross`, it will be called when the crossing event (specified by :cpp:member:`ana_cmpr_config_t::cross_type`) occurs.

.. code:: c

    #include ""driver/ana_cmpr.h""

    static bool IRAM_ATTR example_ana_cmpr_on_cross_callback(ana_cmpr_handle_t cmpr,
                                                         const ana_cmpr_cross_event_data_t *edata,
                                                         void *user_ctx)
    {
        // ...
        return false;
    }
    ana_cmpr_event_callba"
"cks_t cbs = {
        .on_cross = example_ana_cmpr_on_cross_callback,
    };
    ESP_ERROR_CHECK(ana_cmpr_register_event_callbacks(cmpr, &cbs, NULL));

.. note::

    When :ref:`CONFIG_ANA_CMPR_ISR_IRAM_SAFE` is enabled, you should guarantee the callback context and involved data to be in internal RAM by add the attribute ``IRAM_ATTR``. (See more in `IRAM Safe `__)

Enable and Disable Unit


- :cpp:func:`ana_cmpr_enable` - Enable the Analog Comparator unit.
- :cpp:func:`ana_cmpr_disable` - Disab"
"le the Analog Comparator unit.

After the Analog Comparator unit is enabled and the crossing event interrupt is enabled, a power management lock will be acquired if the power management is enabled (see `Power Management `__). Under the **enable** state, only :cpp:func:`ana_cmpr_set_intl_reference` and :cpp:func:`ana_cmpr_set_debounce` can be called, other functions can only be called after the unit is disabled.

Calling :cpp:func:`ana_cmpr_disable` does the opposite.

Power Management


When pow"
"er management is enabled (i.e., :ref:`CONFIG_PM_ENABLE` is on), the system will adjust the APB frequency before going into light sleep, thus potentially changing the resolution of the Analog Comparator.

However, the driver can prevent the system from changing APB frequency by acquiring a power management lock of type :cpp:enumerator:`ESP_PM_NO_LIGHT_SLEEP`. Whenever the driver creates a Analog Comparator unit instance that has selected the clock source like :cpp:enumerator:`ANA_CMPR_CLK_SRC_DEF"
"AULT` or :cpp:enumerator:`ANA_CMPR_CLK_SRC_XTAL` as its clock source, the driver guarantees that the power management lock is acquired when enable the channel by :cpp:func:`ana_cmpr_enable`. Likewise, the driver releases the lock when :cpp:func:`ana_cmpr_disable` is called for that channel.

IRAM Safe


By default, the Analog Comparator interrupt will be deferred when the Cache is disabled for reasons like programming/erasing Flash. Thus the alarm interrupt will not get executed in time, which i"
"s not expected in a real-time application.

There is a Kconfig option :ref:`CONFIG_ANA_CMPR_ISR_IRAM_SAFE` that:

This allows the interrupt to run while the cache is disabled but comes at the cost of increased IRAM consumption.

There is a Kconfig option :ref:`CONFIG_ANA_CMPR_CTRL_FUNC_IN_IRAM` that can put commonly used IO control functions into IRAM as well. So that these functions can also be executable when the cache is disabled. These IO control functions are listed as follows:

- :cpp:func"
":`ana_cmpr_set_internal_reference`
- :cpp:func:`ana_cmpr_set_debounce`
- :cpp:func:`ana_cmpr_set_cross_type`

Thread Safety


The factory function :cpp:func:`ana_cmpr_new_unit` is guaranteed to be thread safe by the driver, which means, user can call it from different RTOS tasks without protection by extra locks.
The following functions are allowed to run under ISR context, the driver uses a critical section to prevent them being called concurrently in both task and ISR.

- :cpp:func:`ana_cmpr_s"
"et_internal_reference`
- :cpp:func:`ana_cmpr_set_debounce`
- :cpp:func:`ana_cmpr_set_cross_type`

Other functions that take the :cpp:type:`ana_cmpr_handle_t` as the first positional parameter, are not treated as thread safe. Which means the user should avoid calling them from multiple tasks.

Kconfig Options


- :ref:`CONFIG_ANA_CMPR_ISR_IRAM_SAFE` controls whether the default ISR handler can work when cache is disabled, see `IRAM Safe `__ for more information.
- :ref:`CONFIG_ANA_CMPR_CTRL_FUNC_"
"IN_IRAM` controls where to place the Analog Comparator control functions (IRAM or Flash), see `IRAM Safe `__ for more information.
- :ref:`CONFIG_ANA_CMPR_ENABLE_DEBUG_LOG` is used to enabled the debug log output. Enabling this option increases the firmware binary size.

.. only:: SOC_ANA_CMPR_SUPPORT_ETM

    ETM Events
    

    To create an analog comparator cross event, you need to include ``driver/ana_cmpr_etm.h`` additionally, and allocate the event by :cpp:func:`ana_cmpr_new_etm_event`. Y"
"ou can refer to :doc:`ETM ` for how to connect an event to a task.

Application Example


API Reference


.. include-build-file:: inc/ana_cmpr.inc
.. include-build-file:: inc/ana_cmpr_types.inc

.. [1]
   :cpp:member:`ana_cmpr_event_callbacks_t::on_cross` callback and the functions invoked by itself should also be placed in IRAM, you need to take care of them by themselves.
"
"Analog to Digital Converter (ADC) Oneshot Mode Driver




{IDF_TARGET_ADC_NUM:default=""two"", esp32c2=""one"", esp32c6=""one"", esp32h2=""one""}

Introduction


The Analog to Digital Converter is integrated on the chip and is capable of measuring analog signals from specific analog IO pins.

{IDF_TARGET_NAME} has {IDF_TARGET_ADC_NUM} ADC unit(s), which can be used in scenario(s) like:

- Generate one-shot ADC conversion result

.. only:: SOC_ADC_DMA_SUPPORTED

    - Generate continuous ADC conversion r"
"esults

This guide introduces ADC oneshot mode conversion.


Functional Overview


The following sections of this document cover the typical steps to install and operate an ADC:

- :ref:`adc-oneshot-resource-allocation` - covers which parameters should be set up to get an ADC handle and how to recycle the resources when ADC finishes working.
- :ref:`adc-oneshot-unit-configuration` - covers the parameters that should be set up to configure the ADC unit, so as to get ADC conversion raw result.
- :"
"ref:`adc-oneshot-read-conversion-result` - covers how to get ADC conversion raw result.
- :ref:`hardware_limitations_adc_oneshot` - describes the ADC-related hardware limitations.
- :ref:`adc-oneshot-power-management` - covers power management-related information.
- :ref:`adc-oneshot-iram-safe` - describes tips on how to read ADC conversion raw results when the cache is disabled.
- :ref:`adc-oneshot-thread-safety` - lists which APIs are guaranteed to be thread-safe by the driver.
- :ref:`adc-one"
"shot-kconfig-options` - lists the supported Kconfig options that can be used to make a different effect on driver behavior.

.. _adc-oneshot-resource-allocation:

Resource Allocation


The ADC oneshot mode driver is implemented based on {IDF_TARGET_NAME} SAR ADC module. Different ESP chips might have different numbers of independent ADCs. From the oneshot mode driver's point of view, an ADC instance is represented by :cpp:type:`adc_oneshot_unit_handle_t`.

To install an ADC instance, set up the "
"required initial configuration structure :cpp:type:`adc_oneshot_unit_init_cfg_t`:

- :cpp:member:`adc_oneshot_unit_init_cfg_t::unit_id` selects the ADC. Please refer to the `datasheet `__ to know dedicated analog IOs for this ADC.
- :cpp:member:`adc_oneshot_unit_init_cfg_t::clk_src` selects the source clock of the ADC. If set to 0, the driver will fall back to using a default clock source, see :cpp:type:`adc_oneshot_clk_src_t` to know the details.
- :cpp:member:`adc_oneshot_unit_init_cfg_t::ulp_"
"mode` sets if the ADC will be working under ULP mode.

.. todo::

   Add ULP ADC-related docs here.

After setting up the initial configurations for the ADC, call :cpp:func:`adc_oneshot_new_unit` with the prepared :cpp:type:`adc_oneshot_unit_init_cfg_t`. This function will return an ADC unit handle if the allocation is successful.

This function may fail due to various errors such as invalid arguments, insufficient memory, etc. Specifically, when the to-be-allocated ADC instance is registered al"
"ready, this function will return :c:macro:`ESP_ERR_NOT_FOUND` error. Number of available ADC(s) is recorded by :c:macro:`SOC_ADC_PERIPH_NUM`.

If a previously created ADC instance is no longer required, you should recycle the ADC instance by calling :cpp:func:`adc_oneshot_del_unit`, related hardware and software resources will be recycled as well.

Create an ADC Unit Handle Under Normal Oneshot Mode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: c

    adc_oneshot_unit_handle_t a"
"dc1_handle;
    adc_oneshot_unit_init_cfg_t init_config1 = {
        .unit_id = ADC_UNIT_1,
        .ulp_mode = ADC_ULP_MODE_DISABLE,
    };
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&init_config1, &adc1_handle));


Recycle the ADC Unit
~~~~~~~~~~~~~~~~~~~~

.. code:: c

    ESP_ERROR_CHECK(adc_oneshot_del_unit(adc1_handle));


.. _adc-oneshot-unit-configuration:

Unit Configuration


After an ADC instance is created, set up the :cpp:type:`adc_oneshot_chan_cfg_t` to configure ADC IOs to measure a"
"nalog signal:

- :cpp:member:`adc_oneshot_chan_cfg_t::atten`, ADC attenuation. Refer to `TRM `__ > ``On-Chip Sensor and Analog Signal Processing``.
- :cpp:member:`adc_oneshot_chan_cfg_t::bitwidth`, the bitwidth of the raw conversion result.

.. note::

    For the IO corresponding ADC channel number, check `datasheet `__ to know the ADC IOs.

    Additionally, :cpp:func:`adc_continuous_io_to_channel` and :cpp:func:`adc_continuous_channel_to_io` can be used to know the ADC channels and ADC IOs.

"
"To make these settings take effect, call :cpp:func:`adc_oneshot_config_channel` with the above configuration structure. You should specify an ADC channel to be configured as well. Function :cpp:func:`adc_oneshot_config_channel` can be called multiple times to configure different ADC channels. The Driver will save each of these channel configurations internally.


Configure Two ADC Channels
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: c

    adc_oneshot_chan_cfg_t config = {
        .bitwidth = ADC_BITW"
"IDTH_DEFAULT,
        .atten = ADC_ATTEN_DB_12,
    };
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, EXAMPLE_ADC1_CHAN0, &config));
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, EXAMPLE_ADC1_CHAN1, &config));


.. _adc-oneshot-read-conversion-result:

Read Conversion Result


After above configurations, the ADC is ready to measure the analog signal(s) from the configured ADC channel(s). Call :cpp:func:`adc_oneshot_read` to get the conversion raw result of an ADC chann"
"el.

- :cpp:func:`adc_oneshot_read` is safe to use. ADC(s) are shared by some other drivers/peripherals, see :ref:`hardware_limitations_adc_oneshot`. This function uses mutexes to avoid concurrent hardware usage. Therefore, this function should not be used in an ISR context. This function may fail when the ADC is in use by other drivers/peripherals, and return :c:macro:`ESP_ERR_TIMEOUT`. Under this condition, the ADC raw result is invalid.

This function will fail due to invalid arguments.

The "
"ADC conversion results read from this function are raw data. To calculate the voltage based on the ADC raw results, this formula can be used:

.. parsed-literal::

    Vout = Dout * Vmax / Dmax       (1)

where:

.. list-table::
    :header-rows: 1
    :widths: 20 80
    :align: center
      - Digital output result, standing for the voltage.
      - ADC raw digital reading result.
      - Maximum measurable input analog voltage, this is related to the ADC attenuation, please refer to `TRM `__ > "
"``On-Chip Sensor and Analog Signal Processing``.
      -  Maximum of the output ADC raw digital reading result, which is 2^bitwidth, where bitwidth is the :cpp:member::`adc_oneshot_chan_cfg_t:bitwidth` configured before.

To do further calibration to convert the ADC raw result to voltage in mV, please refer to calibration doc :doc:`adc_calibration`.


Read Raw Result
~~~~~~~~~~~~~~~

.. code:: c

    ESP_ERROR_CHECK(adc_oneshot_read(adc1_handle, EXAMPLE_ADC1_CHAN0, &adc_raw[0][0]));
    ESP_LOGI"
"(TAG, ""ADC%d Channel[%d] Raw Data: %d"", ADC_UNIT_1 + 1, EXAMPLE_ADC1_CHAN0, adc_raw[0][0]);

    ESP_ERROR_CHECK(adc_oneshot_read(adc1_handle, EXAMPLE_ADC1_CHAN1, &adc_raw[0][1]));
    ESP_LOGI(TAG, ""ADC%d Channel[%d] Raw Data: %d"", ADC_UNIT_1 + 1, EXAMPLE_ADC1_CHAN1, adc_raw[0][1]);


.. _hardware_limitations_adc_oneshot:

Hardware Limitations


- Random Number Generator (RNG) uses ADC as an input source. When ADC :cpp:func:`adc_oneshot_read` works, the random number generated from RNG will be "
"less random.

.. only:: SOC_ADC_DMA_SUPPORTED

    - A specific ADC unit can only work under one operating mode at any one time, either continuous mode or oneshot mode. :cpp:func:`adc_oneshot_read` has provided the protection.

.. only:: esp32 or esp32s2 or esp32s3

    - ADC2 is also used by Wi-Fi. :cpp:func:`adc_oneshot_read` has provided protection between the Wi-Fi driver and ADC oneshot mode driver.

.. only:: esp32c3

    - ADC2 oneshot mode is no longer supported, due to hardware limitati"
"ons. The results are not stable. This issue can be found in `ESP32-C3 Series SoC Errata `_. For compatibility, you can enable :ref:`CONFIG_ADC_ONESHOT_FORCE_USE_ADC2_ON_C3` to force use ADC2.

.. only:: esp32

    - ESP32-DevKitC: GPIO0 cannot be used in oneshot mode, because the DevKit has used it for auto-flash.

    - ESP-WROVER-KIT: GPIO 0, 2, 4, and 15 cannot be used due to external connections for different purposes.

    .. _adc-oneshot-power-management:

.. only:: not esp32

    .. _adc-"
"oneshot-power-management:

Power Management


When power management is enabled, i.e., :ref:`CONFIG_PM_ENABLE` is on, the system clock frequency may be adjusted when the system is in an idle state. However, the ADC oneshot mode driver works in a polling routine, the :cpp:func:`adc_oneshot_read` will poll the CPU until the function returns. During this period of time, the task in which ADC oneshot mode driver resides will not be blocked. Therefore the clock frequency is stable when reading.


.. _"
"adc-oneshot-iram-safe:

IRAM Safe


By default, all the ADC oneshot mode driver APIs are not supposed to be run when the Cache is disabled. Cache may be disabled due to many reasons, such as Flash writing/erasing, OTA, etc. If these APIs execute when the Cache is disabled, you will probably see errors like ``Illegal Instruction`` or ``Load/Store Prohibited``.


.. _adc-oneshot-thread-safety:

Thread Safety


- :cpp:func:`adc_oneshot_new_unit`
- :cpp:func:`adc_oneshot_config_channel`
- :cpp:func:"
"`adc_oneshot_read`

Above functions are guaranteed to be thread-safe. Therefore, you can call them from different RTOS tasks without protection by extra locks.

- :cpp:func:`adc_oneshot_del_unit` is not thread-safe. Besides, concurrently calling this function may result in failures of the above thread-safe APIs.


.. _adc-oneshot-kconfig-options:

Kconfig Options


- :ref:`CONFIG_ADC_ONESHOT_CTRL_FUNC_IN_IRAM` controls where to place the ADC fast read function (IRAM or Flash), see `IRAM Safe `__"
" for more details.


Application Examples



API Reference


.. include-build-file:: inc/adc_types.inc
.. include-build-file:: inc/adc_oneshot.inc
"
"SD Pull-up Requirements


Espressif hardware products are designed for multiple use cases which may require different pull states on pins. For this reason, the pull state of particular pins on certain products needs to be adjusted to provide the pull-ups required in the SD bus.

SD pull-up requirements apply to cases where {IDF_TARGET_NAME} uses the SPI or SDMMC controller to communicate with SD cards. When an SD card is operating in SPI mode or 1-bit SD mode, the CMD and DATA (DAT0 - DAT3) line"
"s of the SD bus must be pulled up by 10 kOhm resistors. SD cards and SDIO devices should also have pull-ups on all above-mentioned lines (regardless of whether these lines are connected to the host) in order to prevent them from entering a wrong state.

.. only:: esp32

    By default, the MTDI bootstrapping pin is incompatible with the DAT2 line pull-up if the flash voltage is 3.3 V. For more information, see :ref:`mtdi_strapping_pin` below.

.. todo::

   Add a diagram of the Bus lines and pul"
"lups

This document has the following structure:

- `Overview of compatibility`_ between the default pull states on pins of Espressif's products and the states required by the SD bus
- `Solutions`_ - ideas on how to resolve compatibility issues
- `Related information`_ - other relevant information


.. _compatibility_overview_espressif_hw_sdio:

Overview of Compatibility


This section provides an overview of compatibility issues that might occur when using SDIO (secure digital input output). Si"
"nce the SD bus needs to be connected to pull-ups, these issues should be resolved regardless of whether they are related to master (host) or slave (device). Each issue has links to its respective solution. A solution for a host and device may differ.


Systems on a Chip (SoCs)


.. only:: esp32

    - ESP32 (except for D2WD versions, see `ESP32 datasheet `_):

        - :ref:`sd_pull-up_no_pull-ups`
        - :ref:`strapping_conflicts_dat2` for models with 3.3 V flash chip

    - ESP32-D2WD:

  "
"      - :ref:`sd_pull-up_no_pull-ups`
        - :ref:`no_pull-up_on_gpio12`

.. only:: SOC_SDMMC_USE_GPIO_MATRIX

    {IDF_TARGET_NAME} SDMMC host controller allows using any of GPIOs for any of SD interface signals. However, it is recommended to avoid using strapping GPIOs, GPIOs with internal weak pull-downs and GPIOs commonly used for other purposes to prevent conflicts:

.. only:: esp32s3

    - GPIO0 (strapping pin)
    - GPIO45, GPIO46 (strapping pins, internal weak pulldown)
    - GPIO26 "
"- GPIO32 (commonly used for SPI Flash and PSRAM)
    - GPIO33 - GPIO37 (when using chips and modules with Octal SPI Flash or Octal PSRAM)
    - GPIO43, GPIO44 (GPIOs used for UART0 by default)
    - GPIO19, GPIO20 (GPIOs used for USB by default)


Systems in Packages (SIP)


.. only:: esp32

    - ESP32-PICO-D4:

        - :ref:`sd_pull-up_no_pull-ups`
        - :ref:`strapping_conflicts_dat2`


Modules


.. only:: esp32

    - ESP32-WROOM-32 Series, including ESP32-WROOM-32, ESP32-WROOM-32D, ES"
"P32-WROOM-32U, and ESP32-SOLO-1

        - :ref:`sd_pull-up_no_pull-ups`
        - :ref:`strapping_conflicts_dat2`

    - ESP32-WROVER Series, including ESP32-WROVER and ESP32-WROVER-I

        - :ref:`sd_pull-up_no_pull-ups`

    - ESP32-WROVER-B Series, including ESP32-WROVER-B and ESP32-WROVER-IB

        - :ref:`sd_pull-up_no_pull-ups`
        - :ref:`strapping_conflicts_dat2`


.. _sdio_dev_kits:

Development Boards


.. only:: esp32

    - ESP32-PICO-KIT, including PICO-KIT v4.1, v4.0, and"
" v3

        - :ref:`sd_pull-up_no_pull-ups`
        - :ref:`strapping_conflicts_dat2`
        - :ref:`gpio2_strapping_pin`

    - ESP32-DevKitC, including ESP32-DevKitC v4 and v2

        - :ref:`sd_pull-up_no_pull-ups`
        - :ref:`strapping_conflicts_dat2`
        - :ref:`gpio2_strapping_pin`

    - ESP-WROVER-KIT

        - Required pull-ups are provided
        - :ref:`pull-up_conflicts_on_gpio13` (v4.1, v3, v2, and v1)
        - :ref:`strapping_conflicts_dat2` (v4.1, v2, and v1)
       "
" - :ref:`gpio2_strapping_pin` (v2, v1)

        You can determine the version of your ESP23-WROVER-KIT by checking which module is mounted on it:

        - ESP32-WROVER-B on v4.1
        - ESP32-WROVER on v3
        - ESP32-WROOM-32 on v1 and v2

    - ESP32-LyraTD-MSC

        - Required pull-ups are provided
        - :ref:`strapping_conflicts_dat2`

    - ESP32-LyraT

        - Required pull-ups are provided
        - :ref:`pull-up_conflicts_on_gpio13`

.. only:: esp32s3

    - ESP32-S3-DevK"
"itC-1

        - :ref:`sd_pull-up_no_pull-ups`

    - ESP32-S3-USB-OTG

        - The board may be used in 1-line and 4-line SD mode or SPI mode.
        - Required pull-ups are provided on GPIOs 33-38.

    - ESP32-S3-EYE

        - The board is limited to 1-line SD mode.
        - Required pull-ups are provided on GPIOs 38-40.

.. only:: SOC_SDIO_SLAVE_SUPPORTED

    Non-Espressif Hosts
    

    Please make sure that your SDIO host provides necessary pull-ups for all SD bus signals.


Solutio"
"ns


.. _sd_pull-up_no_pull-ups:

No Pull-ups


If you use a development board without pull-ups, you can do the following:

- If your host and slave device are on separate boards, replace one of them with a board that has pull-ups. For the list of Espressif's development boards with pull-ups, go to :ref:`sdio_dev_kits`.
- Attach external pull-ups by connecting each pin which requires a pull-up to VDD via a 10 kOhm resistor.

.. only:: esp32

    .. _pull-up_conflicts_on_gpio13:

    Pull-up Conf"
"licts on GPIO13
    

    If DAT3 of your device is not properly pulled up, you have the following options:

    - Use 1-bit SD mode and tie the device's DAT3 to VDD
    - Use SPI mode
    - Perform one of the following actions on the GPIO13 pin:
        - Remove the pull-down resistors
        - Attach a pull-up resistor of less than 5 kOhm (2 kOhm suggested)
        - Pull it up or drive it high either by using the host or with 3.3 V on VDD in 1-bit SD mode


    .. _strapping_conflicts_dat2:
"
"
    Conflicts Between Bootstrap and SDIO on DAT2
    

    There is a conflict between the boot strapping requirements of the ESP32 and the SDIO protocol. For details, see :ref:`mtdi_strapping_pin`.

    To resolve the conflict, you have the following options:

    .. warning::

        Burning eFuses is irreversible! The issue list above might be out of date, so please make sure that the module you are burning has a 3.3 V flash chip by checking the information on https://www.espressif.com/. If"
" you burn the 3.3 V eFuses on a module with a 1.8 V flash chip, the module will stop functioning.

    If you are sure that you need to irreversibly burn eFuses, go to your ESP-IDF directory and run the following command:

    .. code-block:: bash

        components/esptool_py/esptool/espefuse.py set_flash_voltage 3.3V

    This command burns the ``XPD_SDIO_TIEH``, ``XPD_SDIO_FORCE``, and ``XPD_SDIO_REG`` eFuses. After all the three eFuses are burned to value 1, the internal VDD_SDIO flash volt"
"age regulator is permanently set to 3.3 V. You will see the following log if the burning succeeds:

    .. code-block:: bash

        espefuse.py v2.6
        Connecting....

        Enable internal flash voltage regulator (VDD_SDIO) to 3.3 V.
        The following eFuses are burned: XPD_SDIO_FORCE, XPD_SDIO_REG, XPD_SDIO_TIEH.
        This is an irreversible operation.
        Type 'BURN' (all capitals) to continue.
        BURN
        VDD_SDIO setting complete.

    To check the status of the"
" eFuses, run::

        ``components/esptool_py/esptool/espefuse.py summary``

    If running from an automated flashing script, ``espefuse.py`` has an option ``--do-not-confirm``.

    For more details, see **{IDF_TARGET_NAME} Technical Reference Manual** [`PDF `__].

        - Leave the host's DAT2 floating and directly connect the slave's DAT2 to VDD.
        - For a slave device, build a firmware with the option ``SDIO_SLAVE_FLAG_DAT2_DISABLED`` and re-flash your device. This option helps av"
"oid slave detecting on the DAT2 line. Note that 4-bit SD mode is no longer supported by the standard Card Common Control Register (CCCR); however, the host is not aware of that. The use of 4-bit SD mode has to be disabled on the host's side.


    .. _no_pull-up_on_gpio12:

    No Pull-up on GPIO12
    

    Your module is compatible with the SDIO protocol. Just connect GPIO12 to VDD via a 10 kOhm resistor.


    .. _gpio2_strapping_pin:

    Download Mode Not Working (minor issue)
    

    Whe"
"n the GPIO2 pin is pulled high in accordance with the SD pull-up requirements, you cannot enter Download mode because GPIO2 is a bootstrapping pin which in this case must be pulled low.

    There are the following solutions:

    - For boards that require shorting the GPIO0 and GPIO2 pins with a jumper, put the jumper in place, and the auto-reset circuit pulls GPIO2 low along with GPIO0 before entering Download mode.
    - For boards with components attached to their GPIO2 pin (such as pull-dow"
"n resistors and/or LEDs), check the schematic of your development board for anything connected to GPIO2.

        - **LEDs** would not affect operation in most cases.
        - **Pull-down resistors** can interfere with DAT0 signals and must be removed.

    If the above solutions do not work for you, please determine if it is the host or slave device that has pull-ups affecting their GPIO2, then locate these pull-ups and remove them.


.. _related_info_sdio:

Related Information


.. only:: esp"
"32

    .. _mtdi_strapping_pin:

    MTDI Strapping Pin
    

    MTDI (GPIO12) is used as a bootstrapping pin to select the output voltage of an internal regulator (VDD_SDIO) which powers the flash chip. This pin has an internal pull-down, so, if left unconnected, it will read low level at startup, which leads to selecting the default 3.3 V operation.

    All ESP32-WROVER modules, excluding ESP32-WROVER-B, use 1.8 V flash and have internal pull-ups on GPIO12. Other modules that use 3.3 V flash"
" have no pull-ups on the GPIO12 pin, and this pin is slightly pulled down internally.

    When adding a pull-up to this pin for SD card operation, consider the following:

    - For boards that do not use the internal regulator (VDD_SDIO) to power flash, GPIO12 can be pulled high.
    - For boards using 1.8 V flash chips, GPIO12 needs to be pulled high at reset. This is fully compatible with the SD card operation.
    - On boards using the internal regulator and a 3.3 V flash chip, GPIO12 must "
"be pulled low at reset. This is incompatible with the SD card operation. For reference information on compatibility of Espressif's boards with the SD card operation, see :ref:`compatibility_overview_espressif_hw_sdio`.


    Internal Pull-ups and Strapping Requirements
    

    Using external resistors is always preferable. However, Espressif's products have internal weak pull-up and pull-down resistors which can be enabled and used instead of external ones. Please keep in mind that this soluti"
"on cannot guarantee reliable SDIO communication.

    With that said, the information about these internal pull-ups and strapping requirements can still be useful. Espressif hardware products have different weak internal pull-ups/pull-downs connected to CMD and DATA pins. The table below shows the default pull-up and pull-down states of the CMD and DATA pins.

    The following abbreviations are used in the table:

    - **WPU**: Weak pull-up inside the SoC
    - **WPD**: Weak pull-down inside t"
"he SoC
    - **PU**: Pull-up inside Espressif modules but outside the SoC

    .. list-table:: Default pull-up and pull-down states of the CMD and DATA pins
       :widths: 25 25 25 25
       :header-rows: 1
         - Pin Name
         - Startup State
         - Strapping Requirement
         - CMD
         - WPU
         -
         - DAT0
         - WPD
         - Low for Download mode
         - DAT1
         - WPD
         -
         - DAT2
         - PU for 1.8 V flash; WPD for 3.3 V flash
"
"         - High for 1.8 V flash; Low for 3.3 V flash
         - DAT3
         - WPU
         -
"
"USB Host Maintainers Notes (Architecture)


The Host Stack is roughly split into multiple layers of abstraction, with each layer representing different USB concepts and a different level of USB Host operation. For example, a higher layer may present an abstraction of devices and application data transfers, whereas a lower layer may present an abstraction of endpoints and USB transfers.

Layer Descriptions


The layers of the Host Stack are described in the following table. The layers are ordered"
" from lowest layer (i.e, furthest away from the user) to highest layer (i.e., closest to the user).

.. list-table:: Host Stack Layers
    :widths: 20 10 70
    :header-rows: 1
      - Files
      - Description
      - N/A
      - This layer represents the USB Controller Hardware of the {IDF_TARGET_NAME}. The API presented by this layer is the register interface of the controller.
      - ``usbh_ll.h``
      - The LL (Low Level) layer abstracts the basic register access of the USB controller acc"
"ording to ESP-IDF's :doc:`Hardware Abstraction API Guidelines `. In other words, this layer provides APIs to access the controller's registers and format/parse the controller's DMA descriptors.
      - ``usbh_hal.h``, ``usbh_hal.c``
      - The HAL (Hardware Abstraction Layer) abstracts the operating steps of the USB controller into functions according to ESP-IDF's :doc:`Hardware Abstraction API Guidelines `. This layer also abstracts the controller's host port and host channels, and provides AP"
"Is to operate the them.
      - ``hcd.h``, ``hcd.c``
      - The HCD (Host Controller Driver) acts as hardware agnostic API for all USB controllers (i.e., an API that can theoretically be used with any USB controller implementation). This layer also abstracts the root port (i.e., root hub) and USB pipes.
      - ``usbh.h``, ``usbh.c``
      - The USBH (USB Host Driver) layer is equivalent to the USBD layer described in chapter 10 of the USB2.0 specification. The USBH presents an abstraction of U"
"SB devices, internally manages a list of connected devices (i.e., device pool), and also arbitrates device sharing between clients (i.e., tracks which endpoints are in use and also presents a shared endpoint 0).
      - ``hub.h``, ``hub.c``
      - The Hub Driver layer acts as a special client of the USBH that is responsible for handling device attachment/detachment, and notifying the USBH of such events. For device attachment, the Hub Driver also handles the enumeration process as well.
      -"
" ``usb_host.h``, ``usb_host.c``
      - The USB Host Library layer is the lowest public API layer of the Host Stack and presents the concept of USB Host Clients. The abstraction of clients allows for multiple class drivers to coexist simultaneously (where each class roughly maps to a single client) and also acts as a mechanism for division of labor (where each client is responsible for its own processing and event handling).
      - See the `ESP-IDF Extra Components repository `_ or the USB Host"
" examples in ESP-IDF (via :example:`peripherals/usb/host`).
      - The Host Class Drivers implement the host side of a particular device class (e.g., CDC, MSC, HID). The exposed API is specific to each class driver.

Layer Dependencies


The Host Stack roughly follows a top to bottom hierarchy with inter-layer dependencies. Given layers A (highest), B, and C (lowest), the Host Stack has the following inter-layer dependency rules:

- a particular layer can use the API of any layer directly below"
" (Layer A using layer B is allowed)
- a particular layer can use the API of any layer indirectly below (Layer A using layer C is allowed) i.e., skipping layers.
- a particular layer must not use the API of any layer above (Layer C using layer A/B is forbidden)

.. note::

  Layer skipping is permitted in order to circumvent the need to repeat the same abstraction across multiple layers. For example, the abstraction of pipes are presented at the HCD layer but are used by multiple layers above.

."
". todo::

  Add diagram of API dependencies between layers
"
"USB Host Maintainers Notes (Design Guidelines)


Design Considerations


The design of the Host Stack takes into account the following design considerations:

**Limited Hardware Resources:**

The embedded nature of Host Stack means limited hardware resources (such as memory and processing power) when compared to larger host systems.

**USB2.0 Chapter 10:**

Chapter 10 of the USB 2.0 specification specifies certain requirements of USB Host systems, in particular the required layers of the USB Hos"
"t's system software.

**Diverse Use Case Complexities:**

The embedded nature of the Host Stack also means a wide range of use cases with differing complexities. Some USB Host applications aim to only support a single vendor specific device, whereas other applications require support for a wide range of devices of different classes.

Requirements


Given the design considerations above, the Host Stack was designed with the following set of requirements:

DMA Support


**Requirement: The Host Sta"
"ck must support DMA.**

The Host Stack must support DMA in order to reduce CPU's workload. DMA support allows the automatic copying of USB transfer data to/from the Host Controller without CPU intervention. This is especially critical given the embedded nature of the CPU (i.e., lower CPU frequencies) and large maximum data payloads of USB transfers (e.g., 1023 bytes for isochronous transfers).

Minimize Memory Copies


**Requirement: The Host Stack should minimize the amount of memory copies whe"
"n passing data between layers.**

Various data and objects (e.g., USB transfers) need to be passed between multiple layers of the Host Stack. The Host Stack should minimize the amount of memory copies that occur between layers by allocating the data's/object's memory once, and simply passing a pointer to that data/object between the layers. Therefore, the Host Stack requires some standardized data types shared across multiple layers (see USB2.0 Section 10.3.4).

Event Driven


**Requirement: The"
" Host Stack must allow for event driven operation (i.e., the Host Stack's API must not be polling).**

The Host Stack needs to support some CPU intensive use application scenarios such as video streaming (i.e., UVC class). Therefore, the Host Stack should minimize CPU usage by allowing for completely event driven operation, thus reserving the majority of CPU time for the application itself (i.e., video encoding/decoding in this case).

The Host Stack needs to communicate events across the layers"
" using interrupts, callbacks, and FreeRTOS synchronization primitives (e.g., queues and semaphores).

No Task Creation


**Requirement: All layers of the Host Stack below (and including) the Host Library layer must not create any tasks.**

Task stacks are generally one of the most memory intensive parts of an ESP-IDF applications. Given the wide range of applications scenarios, the number of tasks created (and their stack sizes) can vary greatly. For example...

- applications that require low l"
"atency or high throughput (such as isochronous transfers) may choose to create a dedicated task to handle those transfers in order to minimize latency.
- applications that do not have strict latency requirements (such as bulk transfers) may choose to handle those transfers from a shared task in order to save some memory.

Therefore, all layers of the Host Stack below (and including) the Host Library layer **must not** create any tasks. Instead, these layers should expose handlers functions to be"
" called from tasks created by the upper layers. Task creation will be delegated to the class driver or application layer.

Operable at Different Layers


Given the wide range of use case complexities, the Host Stack must be operable at different layers, allowing users to use the Host Stack at a lower layer (e.g., the HCD or HAL) or at a higher layer (e.g., a class driver).

Being operable at different layers allows the users to decide on the appropriate trade-off between convenience, control, an"
"d optimization for their application when using the Host Stack. For example...

- Host Stack applications that support a dedicated custom device may want to use a lower level of abstraction for better optimization, control, and simpler API.
- Host Stack applications that need to support a wide range of device classes requires the full Host Stack so that device enumeration is automatically handled.

Coding Conventions


The Host Stack follows the following set of coding rules/guidelines for bette"
"r code readability and maintainability:

Symbols Use Layer Name As Prefix


For each layer of the Host Stack, the symbols exposed by that layer (i.e., functions, types, macros) must be prefixed with that layer's name. For example, the symbols exposed by the HCD layer will be prefixed ``hcd_...``/``HCD_...``.

However, internal symbols (e.g., static functions) **should not** be prefixed with their layer's name. This makes it easier to differentiate between internal and external symbols when modif"
"ying that layer's source code.

Critical Section Functions Prefixed With ``_``


In each layer of the Host Stack, there are various static functions that must be called inside a critical section. The names of these functions are prefixed with ``_`` (e.g., ``_func_called_from_crit()``) to make it easier for maintainers to differentiate which functions should be called from critical sections. For example...

.. code-block:: c

  some_func();  // Called outside critical section
  taskENTER_CRITICAL"
"(&some_lock);
  _some_func_crit();  // Called inside critical section. _ prefix makes it easier to differentiate
  taskEXIT_CRITICAL(&some_lock);

Grouping Structure Members by Locking Mechanism


Some layers of the Host Stack utilize multiple locking schemes (e.g., critical sections and task mutexes) to ensure thread safety, where each locking scheme offers a different level of protection. However, member variables of the same object can be protected by different locking scheme. Therefore, to c"
"learly demarcate the different locking schemes and their associated variables, structure members are grouped by locking scheme as nested structures.

.. list-table:: Locking Scheme
    :widths: 10 10 80
    :header-rows: 1
      - Nested Structure
      - Description
      - ``dynamic``
      - Shared data accessed from both a task context and ISR context are protected by a critical section.
      - ``mux_protected``
      - Shared data accessed from only a task context are protected by a FreeRT"
"OS Mutex
      - ``single_thread``
      - Data that is only ever accessed by the same task do not require the use of any locks.
      - ``constant``
      - Constant data is set once during the object's instantiation and never changed again. Thus, any task or ISR can freely the constant data without the use of locks, so long as the variable is never written to.

Grouping structure members by locking scheme makes the code more maintainable as it makes clear which locking scheme is required when "
"accessing a particular member variable, as demonstrated in the code snippet below:

.. code-block:: c

    typedef struct some_obj some_obj_t;

    some_obj_t obj;

    // Accessing dynamic members requires critical section
    taskENTER_CRITICAL(&some_lock);
    obj.dynamic.varA = 1;
    taskEXIT_CRITICAL(&some_lock);

    // Accessing mutex protected members requires taking the mutex
    xSemaphoreTake(&some_mux, portMAX_DELAY);
    obj.mux_protected.varB = 1;
    xSemaphoreGive(&some_mux);

 "
"   // Accessing single thread members does not require locking so long as this is the only task to access it
    obj.single_thread.varC = 1;

    // Accessing constant members requires no locking. But only read access is allowed
    int local_var = obj.constant.varD;
"
"USB Host Maintainers Notes (DWC_OTG Controller)


The {IDF_TARGET_NAME} uses a DesignWare USB 2.0 On-the-Go Controller (henceforth referred to as DWC_OTG in this document) as its underlying hardware controller, where the DWC_OTG operates in Host Mode with Scatter/Gather DMA enabled.

.. note::

    This section only summarizes the operation of the DWC_OTG operation in Host Mode at a high level. For full details of the DWC_OTG, refer to the DWC_OTG Databook and Programming Guide.

Host Mode Opera"
"ting Model


A simplified version of the operating model of the DWC_OTG in Host Mode is illustrated in the diagram below. The diagram contains some of the key concepts and terms regarding DWC_OTG Host Mode.

.. figure:: ../../../../_static/usb_host/dwc-otg-operation.png
    :align: center
    :alt: DWC_OTG Host Mode Operating Model
    :figclass: align-center

.. note::

    Refer to Databook section 2.1.4 (Host Architecture) for more details

Host Port


The Host Port represents the single USB "
"port provided by the DWC_OTG (in USB terms, this can be thought a single USB port of the root hub of the bus). The Host Port can only connect to a single device, though more devices can be connected via hub devices.

The Host Port is responsible for:

- detecting direct device connections/disconnections
- detecting the speed of the directly connected device
- issuing various bus signals (such as suspend, resume, reset)

Host Channels


In Host Mode, the DWC_OTG uses channels to communicate with "
"device endpoints, where one channel maps to a particular endpoint (in USB terms, channels are the hardware representation of pipes). For example, a channel will map to EP 1 OUT. Each channel has its own set of CSRs (Control and Status Registers) so that they can independently configured and controlled independently. A channel's CSRs are used to...

- specify the details of the channel's target endpoint (e.g., device address, EP number, transfer type, direction)
- start a transfer on the channel "
"(e.g., by setting up DMA descriptors)

When using Scatter/Gather DMA, transfers on Host Channels are completely event driven. Users simply fill out the appropriate DMA descriptors, fill in the channel's CSRs, then enable the channel. The channel will then generate an interrupt when the transfer completes.

Data FIFOs


In Host Mode, the DWC_OTG uses multiple FIFOs as a staging area for the data payloads of USB transfers. When using DMA, the DMA engine will copy data between the TX/RX FIFOs and {"
"IDF_TARGET_NAME}'s internal memory:

- For an OUT transfer, the transfer's data payload is copied from main memory to one of the TX FIFOs by DMA. The MAC Layer will then transmit that data payload in accordance to USB packet formatting.
- For an IN transfer, the MAC Layer will parse the received USB packet and store the received data payload in the RX FIFO. The data is then copied to main memory by DMA.

The destination FIFO depends on the direction and transfer type of the channel:

- All IN ch"
"annel data goes to the RX FIFO
- All non-periodic (i.e., Control and Bulk) OUT channel data goes to the Non-periodic TX (NPTX) FIFO
- All periodic (i.e., Interrupt and Isochronous) OUT channel data goes to the Periodic TX (PTX) FIFO

.. note::

    The separation of non-periodic and periodic OUT channels to the NPTX and PTX FIFOs is due to the periodic nature of Interrupt and Isochronous endpoints (specified by the ``bInterval`` value of the endpoint). The DWC_OTG automatically schedules these p"
"eriodic transfers, thus a separate PTX FIFO allows these periodic transfers to be staged separately.

DMA Engine


The DMA engine is responsible for copying data between the FIFOs and main memory. In Host Mode Scatter/Gather DMA, a particular channel can carry out multiple transfers automatically without software intervention. The following diagram illustrates the DWC_OTG Host Mode Scatter/Gather DMA Memory Structures.

.. figure:: ../../../../_static/usb_host/dwc-otg-scatter-gather.png
    :ali"
"gn: center
    :alt: DWC_OTG Host Mode Scatter/Gather DMA Memory Structures
    :figclass: align-center

- Each USB transfer is described by a Queue Transfer Descriptor (QTD). Each QTD consists of:

  - A 32-bit Buffer Status Quadlet specifying details of the transfer, and also reports the status of the transfer on completion. The Buffer Status Quadlet has bits to specify whether the QTD should generate an interrupt and/or halt the channel on completion.
  - A 32-bit pointer to the data buffer c"
"ontaining the data payload for OUT transfers, or an empty buffer used to store the data payload for IN transfers.

- The data payload of each QTD can be larger than the MPS (Maximum Packet Size) of its target endpoint. The DWC_OTG hardware automatically handles splitting of the transfer into multiple transactions.
- Multiple QTDs can be placed into a single QTD List. A channel will then execute each QTD in the list automatically, and optionally loop back around if configured to do so.
- Before a"
" channel starts data transfer, it is configured with a QTD list (and QTD list length). Once the channel is enabled, USB transfers are executed automatically by the hardware.
- A channel can generate interrupts (configurable) on completion of a particular QTD, or an entire QTD list.

.. note::

    Refer to Programming Guide section 6.2.1 (Descriptor Memory Structures) for more details

Hardware Configuration


The DWC_OTG IP is configurable. The notable Host related configurations of the {IDF_TA"
"RGET_NAME}'s DWC_OTG are listed below:

.. list-table:: {IDF_TARGET_NAME}'s DWC_OTG Configuration
    :widths: 70 30
    :header-rows: 1
      - Configuration
      - ``OTG_MODE = 0``
      - ``OTG_FSPHY_INTERFACE = 1``, ``OTG_HSPHY_INTERFACE = 0``
      - ``OTG_ARCHITECTURE = 2``, ``OTG_EN_DESC_DMA = 1``
      - ``OTG_SINGLE_POINT = 0``
      - ``OTG_NUM_HOST_CHAN = 8``
      - ``OTG_EN_PERIO_HOST = 1``
      - ``OTG_DFIFO_DYNAMIC = 1``, ``OTG_DFIFO_DEPTH = 256``

Scatter/Gather DMA Transfer


"
"The basic operating procedure for Host channels transfers consists of the following steps:

#. Prepare data buffers, QTDs, and QTD list. In particular, which QTDs should halt the channel (and generate an interrupt) on completion.
#. Set channel/endpoint characteristics via CSRs (such as EP address, transfer type, EP MPS etc).
#. Set channel's QTD list related CSRs (such as QTD list pointer and QTD list length) and channel interrupt CSRs
#. Enable the channel. Transfers are now handled automatica"
"lly by hardware using DMA.
#. The Channel generates an interrupt on a channel event (e.g., QTD completion or channel error).
#. Parse the channel interrupt to determine what event occurred.
#. Parse the QTDs to determine the result of each individual transfer.

However, there are some minor differences in channel operation and QTD list usage depending on the transfer type.

Bulk


Bulk transfers are a simplest. Each QTD represents a bulk transfer of a particular direction, where the DWC_OTG auto"
"matically splits a particular QTD into multiple MPS sized transactions. Thus it is possible to fill a QTD list with multiple bulk transfers, and have the entire list executed automatically (i.e., only interrupt on completion of the last QTD).

Control


Control transfers are more complicated as they are bi-directional (i.e., each control transfer stage can have a different direction). Thus, a separate QTD is required for each stage, and each QTD must halt the channel on completion. Halting the c"
"hannel after each QTD allows changing the channel's direction to be changed by reconfiguring the channel's CSRs. Thus a typical control transfer consists of 3 QTDs (one for each stage).

Interrupt


In accordance with the USB2.0 specification, interrupt transfers executes transactions at the endpoints specified service period (i.e., ``bInterval``). A particular interrupt endpoint may not execute more than one interrupt transaction within a service period. The service period is specified in numbe"
"r of microframes/frames, thus a particular interrupt endpoint will generally execute one transaction every Nth microframe/frame until the transfer is complete. For interrupt channels, the service period of a particular channel (i.e., ``bInterval``) is specified via the Host Frame List (see section 6.5 of programming guide for more details).

.. note::

  HS USB allows an interrupt endpoint to have 3 interrupt transactions in a single microframe. See USB2.0 specification section 5.7.3 (Interrupt "
"Transfer Packet Size Constraints) for more details.

Thus, interrupt transfers in Host Mode Scatter/Gather DMA have the following peculiarities:

- If a QTD payload is larger than the endpoint's MPS, the channel will automatically split the transfer into multiple MPS sized transactions (similar to bulk transfers). However, each transaction **is executed at endpoint's specified service period** (i.e., one transaction per ``bInterval``) until the transfer completes.
- For Interrupt IN transfers, i"
"f a short packet is received (i.e., transaction's data payload is < MPS), this indicates that the endpoint has no more data to send. In this case:

  - the channel generates an extra channel interrupt even if the transfer's QTD did not set the IOC (interrupt on complete) bit.
  - however, the channel is not halted even if this extra channel interrupt is generated.
  - software must then use this extra interrupt to manually halt the interrupt channel (thus canceling any remaining QTDs in the QTD "
"list).


.. note::

  Due to the interrupt transfer peculiarities, it may be easier for software allocate a QTD for each transaction instead of an entire transfer.

Isochronous


In accordance with the USB2.0 specification, isochronous transfers executes transactions at the endpoints specified service period (i.e., ``bInterval``) in order to achieve a constant rate of data transfer. A particular isochronous endpoint may not execute more than one isochronous transaction within a service period. T"
"he service period is specified in number of microframes/frames, thus a particular isochronous endpoint will generally execute one transaction every Nth microframe/frame until the transfer is complete. For isochronous channels, the service period of a particular channel (i.e., ``bInterval``) is specified via the Host Frame List (see section 6.5 of programming guide for more details).

However, unlike interrupt transactions, isochronous transactions are not retried on failure (or NAK), due to the "
"need to maintain the constant data rate.

.. note::

  HS USB allows an isochronous endpoint to have 3 interrupt transactions in a single microframe. See USB2.0 specification section 5.6.3 (Isochronous Transfer Packet Size Constraints) for more details.

Thus, isochronous transfers in Host Mode Scatter/Gather DMA have the following peculiarities:

- A QTD must be allocated for each microframe/frame. However, non-service service period QTDs should be left blank (i.e., only ever Nth QTD should be "
"filled if the channel's service period is every Nth microframe/frame).
- **Each filled QTD must represent a single transaction instead of a transfer**.
- Because isochronous transactions are not retried on failure, the status each completed QTD must be checked.

Supplemental Notes


Some of the DWC_OTG's behaviors are not mentioned in the Databook or Programming Guide. This section describes some of those behaviors that are relevant to the Host stack's implementation.

Port Errors Do Not Trigger"
" a Channel Interrupt


If a port error occurs (such as a sudden disconnection or port over-current) while there are one or more active channels...

- The active channels remains active (i.e., ``HCCHAR.ChEna`` remains set) and no channel interrupts are generated.
- Channels could in theory be disabled by setting ``HCCHAR.ChDis``, but this does not work for Isochronous channels as the channel disabled interrupt is never generated.

Therefore, on port errors, a controller soft reset should be used "
"to ensure all channels are disabled.

Port Reset Interrupts


- When the DWC_OTG issues a reset signal on its port, and during the reset signal the device disconnects, the disconnection interrupt (i.e., ``HPRT.PrtConnDet``) is not generated until the reset is deasserted.
- When resetting an already enabled port (i.e., ``HPRT.PrtEna``) such as a second reset during enumeration or a run-time reset, a Port Enable/Disable Change interrupt (i.e., ``HPRT.PrtEnChng``) is generated both on the assertion"
" and deassertion of the reset signal.
"
"USB Host Maintainers Notes (Introduction)


This document contains information regarding the implementation details of the USB Host stack. This document is intended for the maintainers and third-party contributors of the USB Host stack. Users of the USB Host stack should refer to :doc:`../usb_host` instead.

.. warning::

    The implementations details of the USB Host stack is categorized as private API. Thus, all layers (other than the USB Host Library) do not adhere to :ref:`ESP-IDF's version"
"ing scheme ` (i.e., breaking changes are permitted).

.. figure:: ../../../../_static/usb_host/stack-overview.png
    :align: center
    :alt: Diagram of Host Stack Layers
    :figclass: align-center

This document is split into the following sections:

.. toctree::
    :maxdepth: 1

    usb_host_notes_design
    usb_host_notes_arch
    usb_host_notes_dwc_otg

Todo:

- USB Host Maintainers Notes (HAL & LL)
- USB Host Maintainers Notes (HCD)
- USB Host Maintainers Notes (USBH)
- USB Host Maintain"
"ers Notes (Hub)
- USB Host Maintainers Notes (USB Host Library)

..  Introduction 

Introduction


The ESP-IDF USB Host Stack allows the {IDF_TARGET_NAME} to operate as a USB Host. Operating as a USB Host allows the {IDF_TARGET_NAME} to communicate with a wide range of USB devices. However, most USB Host Stack implementations do not run on embedded hardware (i.e., runs on PCs and smartphones), thus have comparatively more resources (i.e., memory and CPU speed).

The implementation of the ESP-IDF"
" USB Host Stack (henceforth referred to as the Host Stack) takes into account the embedded nature of the {IDF_TARGET_NAME} which is reflected in various aspects of the Host Stack's design.

Features & Limitations


**The Host Stack currently supports the following notable features:**

- Support FS (Full Speed) and LS (Low Speed) devices
- Support all transfer types (Control, Bulk, Isochronous, and Interrupt)
- Automatically enumerates connected devices
- Allows multiple class drivers (i.e., Clie"
"nts of the USB Host Library) to run simultaneously and share the same device (i.e., composite devices).

**The Host Stack currently has the following notable limitations:**

- No HS (High Speed) support
- No Hub support (currently only supports a single device)

"
"Overriding Default Chip Drivers


.. warning::

   Customizing SPI Flash Chip Drivers is considered an ""expert"" feature. Users should only do so at their own risk. (See the notes below)

During the SPI Flash driver's initialization (i.e., :cpp:func:`esp_flash_init`), there is a chip detection step during which the driver iterates through a Default Chip Driver List and determine which chip driver can properly support the currently connected flash chip. The Default Chip Drivers are provided by the"
" ESP-IDF, thus are updated in together with each ESP-IDF version. However ESP-IDF also allows users to customize their own chip drivers.

Users should note the following when customizing chip drivers:


Steps For Creating Custom Chip Drivers and Overriding the ESP-IDF Default Driver List


.. highlight: cmake

    - ``spi_flash_chip_drivers.c`` (to provide the ``default_registered_chips`` structure)
    - Any of the ``spi_flash_chip_*.c`` files that matches your own flash model best
    - ``CMak"
"eLists.txt`` and ``linker.lf`` files

   Modify the files above properly. Including:

   - Change the ``default_registered_chips`` variable to non-static and remove the #ifdef logic around it.
   - Update ``linker.lf`` file to rename the fragment header and the library name to match the new component.
   - If reusing other drivers, some header names need prefixing with ``spi_flash/`` when included from outside spi_flash component.

.. note::

   - When writing your own flash chip driver, you can"
" set your flash chip capabilities through ``spi_flash_chip_***(vendor)_get_caps`` and points the function pointer ``get_chip_caps`` for protection to the ``spi_flash_chip_***_get_caps`` function. The steps are as follows.

      .. code-block:: c

         spi_flash_caps_t spi_flash_chip_***(vendor)_get_caps(esp_flash_t *chip)
         {
            spi_flash_caps_t caps_flags = 0;
            // 32-bit-address flash is not supported
            flash-suspend is supported
            caps_flags "
"|= SPI_FLAHS_CHIP_CAP_SUSPEND;
            // flash read unique id.
            caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
            return caps_flags;
         }

      .. code-block:: c

         const spi_flash_chip_t esp_flash_chip_eon = {
            // Other function pointers
            .get_chip_caps = spi_flash_chip_eon_get_caps,
         };

   - You also can see how to implement this in the example :example:`storage/custom_flash_driver`.

        idf_component_register(SRCS ""spi_fl"
"ash_chip_drivers.c""
                               ""spi_flash_chip_mychip.c""  # modify as needed
                               REQUIRES hal
                               PRIV_REQUIRES spi_flash
                               LDFRAGMENTS linker.lf)
        idf_component_add_link_dependency(FROM spi_flash)

   - An example of this component CMakeLists.txt can be found in :example_file:`storage/custom_flash_driver/components/custom_chip_driver/CMakeLists.txt`

Example


See also :example:`storage"
"/custom_flash_driver`.
"
"SPI Flash API




Overview


The spi_flash component contains API functions related to reading, writing, erasing, and memory mapping for data in the external flash.

For higher-level API functions which work with partitions defined in the :doc:`partition table `, see :doc:`/api-reference/storage/partition`

.. note::

    ``esp_partition_*`` APIs are recommended to be used instead of the lower level ``esp_flash_*`` API functions when accessing the main SPI flash chip, since they conduct bounds c"
"hecking and are guaranteed to calculate correct offsets in flash based on the information in the partition table. ``esp_flash_*`` functions can still be used directly when accessing an external (secondary) SPI flash chip.

Different from the API before ESP-IDF v4.0, the functionality of ``esp_flash_*`` APIs is not limited to the ""main"" SPI flash chip (the same SPI flash chip from which program runs). With different chip pointers, you can access external flash chips connected to not only SPI0/1 b"
"ut also other SPI buses like SPI2.

.. note::

    Instead of going through the cache connected to the SPI0 peripheral, most ``esp_flash_*`` APIs go through other SPI peripherals like SPI1, SPI2, etc. This makes them able to access not only the main flash, but also external (secondary) flash.

    However, due to the limitations of the cache, operations through the cache are limited to the main flash. The address range limitation for these operations is also on the cache side. The cache is not a"
"ble to access external flash chips or address range above its capabilities. These cache operations include: mmap, encrypted read/write, executing code or access to variables in the flash.

.. note::

    Flash APIs after ESP-IDF v4.0 are no longer **atomic**. If a write operation occurs during another on-going read operation, and the flash addresses of both operations overlap, the data returned from the read operation may contain both old data and new data (that was updated written by the write "
"operation).

.. note::

    Encrypted flash operations are only supported with the main flash chip (and not with other flash chips, that is on SPI1 with different CS, or on other SPI buses). Reading through cache is only supported on the main flash, which is determined by the HW.

Support for Features of Flash Chips


Quad/Dual Mode Chips


Features of different flashes are implemented in different ways and thus need special support. The fast/slow read and Dual mode (DOUT/DIO) of almost all flas"
"hes with 24-bit address are supported, because they do not need any vendor-specific commands.

Quad mode (QIO/QOUT) is supported on the following chip types:

.. note::

    Only when one flash series listed above is supported by {IDF_TARGET_NAME}, this flash series is supported by the chip driver by default. You can use ``Component config`` > ``SPI Flash driver`` > ``Auto-detect flash chips`` in menuconfig to enable/disable a flash series.

Optional Features


.. toctree::
    :hidden:

    spi"
"_flash_optional_feature

There are some features that are not supported by all flash chips, or not supported by all Espressif chips. These features include:

.. only:: esp32s3

    -  OPI flash - means that flash supports octal mode.

-  32-bit address flash - usually means that the flash has higher capacity (equal to or larger than 16 MB) that needs longer addresses.

.. only:: esp32s3

    -  High performance mode (HPM) - means that flash works under high frequency which is higher than 80 MHz."
"

-  Flash unique ID - means that flash supports its unique 64-bit ID.

.. only:: SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

    -  Suspend & Resume - means that flash can accept suspend/resume command during its writing/erasing. The {IDF_TARGET_NAME} may keep the cache on when the flash is being written/erased and suspend it to read its contents randomly.

If you want to use these features, please ensure both {IDF_TARGET_NAME} and ALL flash chips in your product support these features. For more details,"
" refer to :doc:`spi_flash_optional_feature`.

You may also customise your own flash chip driver. See :doc:`spi_flash_override_driver` for more details.

.. toctree::
   :hidden:

   Custom Flash Driver 

Initializing a Flash Device


To use the ``esp_flash_*`` APIs, you need to initialise a flash chip on a certain SPI bus, as shown below:

.. note:: Multiple flash chips can be attached to the same bus now.

SPI Flash Access API


This is the set of API functions for working with data in flash:

"
"- :cpp:func:`esp_flash_read` reads data from flash to RAM
- :cpp:func:`esp_flash_write` writes data from RAM to flash
- :cpp:func:`esp_flash_erase_region` erases specific region of flash
- :cpp:func:`esp_flash_erase_chip` erases the whole flash
- :cpp:func:`esp_flash_get_chip_size` returns flash chip size, in bytes, as configured in menuconfig

Generally, try to avoid using the raw SPI flash functions to the ""main"" SPI flash chip in favour of :ref:`partition-specific functions `.

SPI Flash Size"
"


The SPI flash size is configured by writing a field in the software bootloader image header, flashed at offset 0x1000.

By default, the SPI flash size is detected by ``esptool.py`` when this bootloader is written to flash, and the header is updated with the correct size. Alternatively, it is possible to generate a fixed flash size by setting :ref:`CONFIG_ESPTOOLPY_FLASHSIZE` in the project configuration.

If it is necessary to override the configured flash size at runtime, it is possible to s"
"et the ``chip_size`` member of the ``g_rom_flashchip`` structure. This size is used by ``esp_flash_*`` functions (in both software & ROM) to check the bounds.

Concurrency Constraints for Flash on SPI1


.. toctree::
    :hidden:

    spi_flash_concurrency

.. attention::

   The SPI0/1 bus is shared between the instruction & data cache (for firmware execution) and the SPI1 peripheral (controlled by the drivers including this SPI flash driver). Hence, calling SPI Flash API on SPI1 bus (including"
" the main flash) causes significant influence to the whole system. See :doc:`spi_flash_concurrency` for more details.


SPI Flash Encryption


It is possible to encrypt the contents of SPI flash and have it transparently decrypted by hardware.

Refer to the :doc:`Flash Encryption documentation ` for more details.

Memory Mapping API


{IDF_TARGET_CACHE_SIZE:default=""64 KB"", esp32c2=16 ~ 64 KB}

{IDF_TARGET_NAME} features memory hardware which allows regions of flash memory to be mapped into inst"
"ruction and data address spaces. This mapping works only for read operations. It is not possible to modify contents of flash memory by writing to a mapped memory region.

Mapping happens in {IDF_TARGET_CACHE_SIZE} pages. Memory mapping hardware can map flash into the data address space and the instruction address space. See the technical reference manual for more details and limitations about memory mapping hardware.

Note that some pages are used to map the application itself into memory, so th"
"e actual number of available pages may be less than the capability of the hardware.

Reading data from flash using a memory mapped region is the only way to decrypt contents of flash when :doc:`flash encryption ` is enabled. Decryption is performed at the hardware level.

Memory mapping API are declared in ``spi_flash_mmap.h`` and ``esp_partition.h``:

- :cpp:func:`spi_flash_mmap` maps a region of physical flash addresses into instruction space or data space of the CPU.
- :cpp:func:`spi_flash_mu"
"nmap` unmaps previously mapped region.
- :cpp:func:`esp_partition_mmap` maps part of a partition into the instruction space or data space of the CPU.

Differences between :cpp:func:`spi_flash_mmap` and :cpp:func:`esp_partition_mmap` are as follows:

- :cpp:func:`spi_flash_mmap` must be given a {IDF_TARGET_CACHE_SIZE} aligned physical address.
- :cpp:func:`esp_partition_mmap` may be given any arbitrary offset within the partition. It adjusts the returned pointer to mapped memory as necessary.

No"
"te that since memory mapping happens in pages, it may be possible to read data outside of the partition provided to ``esp_partition_mmap``, regardless of the partition boundary.

.. note::

    mmap is supported by cache, so it can only be used on main flash.

SPI Flash Implementation


The ``esp_flash_t`` structure holds chip data as well as three important parts of this API:

Host Driver


The host driver relies on an interface (``spi_flash_host_driver_t``) defined in the ``spi_flash_types.h``"
" (in the ``hal/include/hal`` folder). This interface provides some common functions to communicate with the chip.

In other files of the SPI HAL, some of these functions are implemented with existing {IDF_TARGET_NAME} memory-spi functionalities. However, due to the speed limitations of {IDF_TARGET_NAME}, the HAL layer cannot provide high-speed implementations to some reading commands (so the support for it was dropped). The files (``memspi_host_driver.h`` and ``.c``) implement the high-speed ver"
"sion of these commands with the ``common_command`` function provided in the HAL, and wrap these functions as ``spi_flash_host_driver_t`` for upper layer to use.

You can also implement your own host driver, even with the GPIO. As long as all the functions in the ``spi_flash_host_driver_t`` are implemented, the esp_flash API can access the flash regardless of the low-level hardware.

Chip Driver


The chip driver, defined in ``spi_flash_chip_driver.h``, wraps basic functions provided by the host "
"driver for the API layer to use.

Some operations need some commands to be sent first, or read some status afterwards. Some chips need different commands or values, or need special communication ways.

There is a type of chip called ``generic chip`` which stands for common chips. Other special chip drivers can be developed on the base of the generic chip.

The chip driver relies on the host driver.

.. _esp_flash_os_func:

OS Functions


Currently the OS function layer provides entries of a lock"
" and delay.

The lock (see :ref:`spi_bus_lock`) is used to resolve the conflicts among the access of devices on the same SPI bus, and the SPI Flash chip access. E.g.

The delay is used by some long operations which requires the master to wait or polling periodically.

The top API wraps these the chip driver and OS functions into an entire component, and also provides some argument checking.

OS functions can also help to avoid a watchdog timeout when erasing large flash areas. During this time, "
"the CPU is occupied with the flash erasing task. This stops other tasks from being executed. Among these tasks is the idle task to feed the watchdog timer (WDT). If the configuration option :ref:`CONFIG_ESP_TASK_WDT_PANIC` is selected and the flash operation time is longer than the watchdog timeout period, the system will reboot.

It is pretty hard to totally eliminate this risk, because the erasing time varies with different flash chips, making it hard to be compatible in flash drivers. Therefo"
"re, users need to pay attention to it. Please use the following guidelines:

- Increase :ref:`CONFIG_SPI_FLASH_ERASE_YIELD_TICKS` or decrease :ref:`CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS` in menuconfig.
- You can also increase :ref:`CONFIG_ESP_TASK_WDT_TIMEOUT_S` in menuconfig for a larger watchdog timeout period. However, with larger watchdog timeout period, previously detected timeouts may no longer be detected.

.. _spi-flash-implementation-details:

Implementation Details


In order to per"
"form some flash operations, it is necessary to make sure that both CPUs are not running any code from flash for the duration of the flash operation:

- In a single-core setup, the SDK needs to disable interrupts or scheduler before performing the flash operation.
- In a dual-core setup, the SDK needs to make sure that both CPUs are not running any code from flash.

When SPI flash API is called on CPU A (can be PRO or APP), start the ``spi_flash_op_block_func`` function on CPU B using the ``esp_i"
"pc_call`` API. This API wakes up a high priority task on CPU B and tells it to execute a given function, in this case, ``spi_flash_op_block_func``. This function disables cache on CPU B and signals that the cache is disabled by setting the ``s_flash_op_can_start`` flag. Then the task on CPU A disables cache as well and proceeds to execute flash operation.

While a flash operation is running, interrupts can still run on CPUs A and B. It is assumed that all interrupt code is placed into RAM. Once "
"the interrupt allocation API is added, a flag should be added to request the interrupt to be disabled for the duration of a flash operations.

Once the flash operation is complete, the function on CPU A sets another flag, ``s_flash_op_complete``, to let the task on CPU B know that it can re-enable cache and release the CPU. Then the function on CPU A re-enables the cache on CPU A as well and returns control to the calling code.

Additionally, all API functions are protected with a mutex (``s_fla"
"sh_op_mutex``).

In a single core environment (:ref:`CONFIG_FREERTOS_UNICORE` enabled), you need to disable both caches, so that no inter-CPU communication can take place.

Related Documents


.. list::

    - :doc:`spi_flash_optional_feature`
    - :doc:`spi_flash_concurrency`
    :CONFIG_ESP_ROM_HAS_SPI_FLASH: - :doc:`spi_flash_idf_vs_rom`

.. toctree::
    :hidden:

    spi_flash_idf_vs_rom


API Reference - SPI Flash


.. include-build-file:: inc/esp_flash_spi_init.inc
.. include-build-file:"
": inc/esp_flash.inc
.. include-build-file:: inc/spi_flash_mmap.inc
.. include-build-file:: inc/spi_flash_types.inc
.. include-build-file:: inc/esp_flash_err.inc
.. include-build-file:: inc/esp_spi_flash_counters.inc

API Reference - Flash Encrypt


.. include-build-file:: inc/esp_flash_encrypt.inc
"
"Optional Features for Flash


Some features are not supported on all ESP chips and Flash chips. You can check the list below for more information.

-  `Auto Suspend & Resume `__

-  `Flash unique ID `__

-  `High Performance Mode of QSPI Flash Chips `__

-  `32-bit Address Support of QSPI Flash Chips `__

-  `OPI Flash Support `__

.. note::

    When Flash optional features listed in this page are used, aside from the capability of ESP chips, and ESP-IDF verison you are using, you will also nee"
"d to make sure these features are supported by flash chips used.

    - If you are using an official Espressif modules/SiP. Some of the modules/SiPs always support the feature, in this case you can see these features listed in the datasheet. Otherwise please contact `Espressif's business team `_ to know if we can supply such products for you.

    - If you are making your own modules with your own bought flash chips, and you need features listed above. Please contact your vendor if they support "
"the those features, and make sure that the chips can be supplied continuously.

.. attention::

    This document only shows that ESP-IDF code has supported the features of those flash chips. It is not a list of stable flash chips certified by Espressif. If you build your own hardware from flash chips with your own brought flash chips (even with flash listed in this page), you need to validate the reliability of flash chips yourself.

.. _auto-suspend-intro:

Auto Suspend & Resume


This feature"
" is only supported on ESP32-S3, ESP32-C2, ESP32-C3, ESP32-C6, ESP32-H2 for now.

The support for ESP32-P4 may be added in the future.

.. only:: SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

    List of Flash chips that support this feature:

    .. attention::

        There are multiple limitations about the auto-suspend feature, please do read :ref:`auto-suspend` for more information before you enable this feature.


Flash Unique ID


This feature is supported on all Espressif chips.

Unique ID is not fl"
"ash id, which means flash has 64-Bit unique ID for each device. The instruction to read the unique ID (4Bh) accesses a factory-set read-only 64-bit number that is unique to each flash device. This ID number helps you to recognize each single device. Not all flash vendors support this feature. If you try to read the unique ID on a chip which does not have this feature, the behavior is not determined. The support list is as follows.


List of Flash chips that support this feature:

.. _hpm-doc:

H"
"igh Performance Mode of QSPI Flash Chips


This featuer is only supported on ESP32-S3 for now.

The support for ESP32-S2, ESP32-C3, ESP32-C6, ESP32-H2, ESP32-P4 may be added in the future.

.. note::

    This section is provided for QSPI flash chips. Octal flash used on ESP-chips support High performance mode by default so far, please refer to the :ref:`oct-flash-doc` for the list of supported octal flash chips.

.. only:: esp32s3

    High performance mode (HPM) means that the SPI1 and flash c"
"hip works under high frequency. Usually, when the operating frequency of the flash is greater than 80 MHz, it is considered that the flash works under HPM.

    As far as we acknowledged, there are more than three strategies for High Performance Mode (HPM) in typical SPI flash parts. For some flash chips, HPM is controlled by dummy cycle bit in the registers, while for other chips, it can be controlled by other bits (like HPM bit) in the register, or some special command. The difference in strat"
"egies requires the driver to explicitly add support for each chip.

    .. attention::

        It is hard to create several strategies to cover all situations, so all flash chips using HPM need to be supported explicitly. Therefore, if you try to use a flash not listed in :ref:`hpm_dc_support_list`, it might cause some error. So, when you try to use the flash chip beyond supported list, please test properly.

    Moreover, when the `Dummy Cycle adjustment` strategy is adopted by the flash chip,"
" the flash remains in a state in which DC is different from the default value after a software reset. The sub mode of HPM that adjusts the dummy cycle to run at higher frequency in the application is called `HPM-DC`. `HPM-DC` feature needs a feature `DC Aware` to be enabled in the bootloader. Otherwise different DC value will forbid the 2nd bootloader from being boot up after reset.

    To enable High Performance Mode:

        - If bootloader supports `DC Aware`, select ``CONFIG_SPI_FLASH_HPM_"
"DC_AUTO``. This allows the usage of flash chips that adopted `Dummy Cycle adjustment` strategy.

        - If bootloader doesn't support `DC Aware`, select ``CONFIG_SPI_FLASH_HPM_DC_DISABLE``. It avoid consequences caused by running HPM-DC with non-DC-aware bootloaders. But please avoid using flash chips that adopts `Dummy Cycle adjustment` strategy if ``CONFIG_SPI_FLASH_HPM_DC_DISABLE`` is selected. See list of flash models that adpot DC strategy below.

    Check whether the bootloader support"
"s `DC Aware` in the following way:

    - If you are starting a new project, it's suggested to enable `DC Aware` by selecting :ref:`CONFIG_BOOTLOADER_FLASH_DC_AWARE` option in the bootloader menu. Please note that, you won't be able to modify this option via OTA, because the support is in the bootloader.

    - If you are working on an existing project and want to update `HPM-DC` config option in the app via OTA, check the sdkconfig file used to build your bootloader: (Upgrading ESP-IDF version "
"may make this file different from the one used by bootloader to build.)

        - For latest version (ESP-IDF v5.2 and above), if :ref:`CONFIG_BOOTLOADER_FLASH_DC_AWARE` is selected, the bootloader supports `DC Aware`.

        - For versions in this range: (v4.4.4+, v5.0+, and v5.1+), if ``CONFIG_ESPTOOLPY_FLASHFREQ_120M`` is selected, the bootloader supports `DC Aware`. In this case, enable :ref:`CONFIG_BOOTLOADER_FLASH_DC_AWARE` to confirm this (though it will not affect bootloader in device"
"s in the field).

        - For versions below v4.4.4, the bootloader doesn't support `DC Aware`.

    .. _hpm_dc_support_list:

    Quad Flash HPM support list
    

    Flash chips that don't need HPM-DC:

    Following flash chips also have HPM feature, but requires the bootloader to support `DC Aware`:


.. _32-bit-flash-doc:

32-bit Address Support of QSPI Flash Chips


This feature is supported on all Espressif chips (see restrictions to application below).

.. note::

    This section is "
"provided for QSPI flash chips. The 32-bit address support of Octal Flash chips are considered as part of the Octal flash support. Please refer to the :ref:`oct-flash-doc` for the list of supported octal flash chips.

Most NOR flash chips used by Espressif chips use 24-bits address, which can cover 16 MBytes memory. However, for larger memory (usually equal to or larger than 32 MBytes), flash uses a 32-bits address to address memory region higher than 16 MBytes. Unfortunately, 32-bits address chi"
"ps have vendor-specific commands, so we need to support the chips one by one.

List of Flash chips that support this feature:

Restrictions


.. only:: not esp32s3

    .. important::

        Over 16 MBytes space on flash mentioned above can be only used for ``data saving``, like file system.

        Mapping data/instructions to 32-bit physical address space (so as to be accessed by the CPU) needs the support of MMU. However {IDF_TARGET_NAME} doesn't support this feature. Only ESP32-S3 support"
"s this up to now.

.. only:: esp32s3

    By default, space over 16 MBytes on flash mentioned above can be used for ``data saving``, like file system.

    Furhtermore, to map data/instructions to 32-bit physical address space (so as to be accessed by the CPU), please enable the config ``IDF_EXPERIMENTAL_FEATURES`` and ``BOOTLOADER_CACHE_32BIT_ADDR_QUAD_FLASH``.

    Please note that, this option is experimental, which means it can not be used on all flash chips stably. For more information, ple"
"ase contact Espressif Business Support.

.. _oct-flash-doc:

OPI Flash Support


This feature is only supporetd on ESP32-S3 for now.

OPI flash means that the flash chip supports octal peripheral interface, which has octal I/O pins. Different octal flash has different configurations and different commands. Hence, it is necessary to carefully check the support list.

.. only:: esp32s3

    .. note::

       To know how to configure menuconfig for a board with different Flash and PSRAM, please ref"
"er to the :ref:`SPI Flash and External SPI RAM Configuration `

    List of Flash chips that support this feature:
"
"SPI Flash API ESP-IDF Version vs Chip-ROM Version


.. toctree::
   :maxdepth: 1

There is a set of SPI Flash drivers in Chip-ROM which you can use by enabling  :ref:`CONFIG_SPI_FLASH_ROM_IMPL`. Most of the ESP-IDF SPI Flash driver code are in internal RAM, therefore enabling this option frees some internal RAM usage. Note if you enable this option, this means some SPI Flash driver features and bugfixes that are done in ESP-IDF might not be included in the Chip-ROM version.


Feature Supported b"
"y ESP-IDF but Not in Chip-ROM


.. list::

    - Octal Flash chip support. See :ref:`oct-flash-doc` for details.
    - 32-bit-address support for GD25Q256. Note this feature is an optional feature, please do read :ref:`32-bit-flash-doc` for details.
    - TH Flash chip support.
    - Kconfig option :ref:`CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED`.
    - :ref:`CONFIG_SPI_FLASH_VERIFY_WRITE`, enabling this option helps you detect bad writing.
    - :ref:`CONFIG_SPI_FLASH_LOG_FAILED_WRITE`, ena"
"bling this option prints the bad writing.
    - :ref:`CONFIG_SPI_FLASH_WARN_SETTING_ZERO_TO_ONE`, enabling this option checks if you are writing zero to one.
    - :ref:`CONFIG_SPI_FLASH_DANGEROUS_WRITE`, enabling this option checks for flash programming to certain protected regions like bootloader, partition table or application itself.
    - :ref:`CONFIG_SPI_FLASH_ENABLE_COUNTERS`, enabling this option to collect performance data for ESP-IDF SPI Flash driver APIs.
    - :ref:`CONFIG_SPI_FLASH_"
"AUTO_SUSPEND`, enabling this option to automatically suspend / resume a long Flash operation when short Flash operation happens. Note this feature is an optional feature, please do read :ref:`auto-suspend-intro` for more limitations.

Bugfixes Introduced in ESP-IDF but Not in Chip-ROM


.. list::

    - Detected Flash physical size correctly, for larger than 256MBit Flash chips. (Commit ID: b4964279d44f73cce7cfd5cf684567fbdfd6fd9e)
    :esp32c3: - Improved SPI1 cs setup timing, otherwise issue m"
"ay happen on ZB32Q128. (Commit ID: 08f1bbe0c75382f1702e40c941e93314285105d4)
    :esp32s3: - Fixed issue that 4-line Flash encryption cannot work normally when 8-line PSRAM enabled. (Commit ID: 683d92bc884e0f2a7eebea40a551cf05f0c28256)
    :esp32s2: - Fixed issue that only 4MB virtual address ranges can be mapped to read-only data on Flash.
    :esp32s3: - Fixed issue that only 128KB virtual address ranges can be mapped to instructions on Flash.
    :esp32s3: - Fixed issue that only 16MB virtual"
" address ranges can be mapped to read-only data on Flash.
    :esp32c3: - Fixed issue that only 128KB virtual address ranges can be mapped to instructions on Flash.
    :esp32c2: - Fixed issue that only at most 128KB virtual address ranges can be mapped to instructions on Flash.
"
".. _concurrency-constraints-flash:

Concurrency Constraints for Flash on SPI1




The SPI0/1 bus is shared between the instruction & data cache (for firmware execution) and the SPI1 peripheral (controlled by the drivers including this SPI Flash driver). Hence, operations to SPI1 will cause significant influence to the whole system. This kind of operations include calling SPI Flash API or other drivers on SPI1 bus, any operations like read/write/erase or other user defined SPI operations, regardl"
"ess to the main flash or other SPI slave devices.

.. only:: not (esp32c3 or SOC_SPIRAM_XIP_SUPPORTED)

    On {IDF_TARGET_NAME}, these caches must be disabled while reading/writing/erasing.

.. only:: SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

    On {IDF_TARGET_NAME}, the config option :ref:`CONFIG_SPI_FLASH_AUTO_SUSPEND` (enabled by default) allows the cache to read flash concurrently with SPI1 operations. See :ref:`auto-suspend` for more details.

    If this option is disabled, the caches must be di"
"sabled while reading/writing/erasing operations. There are some constraints using driver on the SPI1 bus, see :ref:`impact_disabled_cache`. These constraints will cause more IRAM/DRAM usages.

.. only:: SOC_SPIRAM_XIP_SUPPORTED

    On {IDF_TARGET_NAME}, the config options :ref:`CONFIG_SPIRAM_FETCH_INSTRUCTIONS` (disabled by default) and :ref:`CONFIG_SPIRAM_RODATA` (disabled by default) allow the cache to read/write PSRAM concurrently with SPI1 operations. See :ref:`xip_from_psram` for more deta"
"ils.

    If these options are disabled, the caches must be disabled while reading/writing/erasing operations. There are some constraints using driver on the SPI1 bus, see :ref:`impact_disabled_cache`. These constraints will cause more IRAM/DRAM usages.

.. _impact_disabled_cache:

When the Caches Are Disabled


Under this condition, all CPUs should always execute code and access data from internal RAM. The APIs documented in this file will disable the caches automatically and transparently.

.."
" only:: esp32c3

    .. note::

        When :ref:`CONFIG_SPI_FLASH_AUTO_SUSPEND` is enabled, these APIs will not disable the caches. The hardware will handle the arbitration between them.

.. only:: SOC_SPIRAM_XIP_SUPPORTED

    .. note::

        When :ref:`CONFIG_SPIRAM_FETCH_INSTRUCTIONS` and :ref:`CONFIG_SPIRAM_RODATA` are both enabled, these APIs will not disable the caches.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    The way that these APIs disable the caches suspends all the other task"
"s. Besides, all non-IRAM-safe interrupts will be disabled. The other core will be polling in a busy loop. These will be restored until the Flash operation completes.

.. only:: not SOC_HP_CPU_HAS_MULTIPLE_CORES

    The way that these APIs disable the caches also disables non-IRAM-safe interrupts. These will be restored until the Flash operation completes.

See also :ref:`esp_flash_os_func` and :ref:`spi_bus_lock`.

There are no such constraints and impacts for flash chips on other SPI buses tha"
"n SPI0/1.

For differences between internal RAM (e.g., IRAM, DRAM) and flash cache, please refer to the :ref:`application memory layout ` documentation.


.. _iram-safe-interrupt-handlers:

IRAM-Safe Interrupt Handlers


For interrupt handlers which need to execute when the cache is disabled (e.g., for low latency operations), set the ``ESP_INTR_FLAG_IRAM`` flag when the :doc:`interrupt handler is registered `.

You must ensure that all data and functions accessed by these interrupt handlers, in"
"cluding the ones that handlers call, are located in IRAM or DRAM. See :ref:`how-to-place-code-in-iram`.

If a function or symbol is not correctly put into IRAM/DRAM, and the interrupt handler reads from the flash cache during a flash operation, it will cause a crash due to Illegal Instruction exception (for code which should be in IRAM) or garbage data to be read (for constant data which should be in DRAM).

.. note::

    When working with strings in ISRs, it is not advised to use ``printf`` an"
"d other output functions. For debugging purposes, use :cpp:func:`ESP_DRAM_LOGE` and similar macros when logging from ISRs. Make sure that both ``TAG`` and format string are placed into ``DRAM`` in that case.

Non-IRAM-Safe Interrupt Handlers


If the ``ESP_INTR_FLAG_IRAM`` flag is not set when registering, the interrupt handler will not get executed when the caches are disabled. Once the caches are restored, the non-IRAM-safe interrupts will be re-enabled. After this moment, the interrupt handle"
"r will run normally again. This means that as long as caches are disabled, users will not see the corresponding hardware event happening.


.. only:: SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

   .. include:: auto_suspend.inc

.. only:: SOC_SPIRAM_XIP_SUPPORTED

   .. include:: xip_from_psram.inc
"
"HTTPS Server




Overview


This component is built on top of :doc:`esp_http_server`. The HTTPS server takes advantage of hook registration functions in the regular HTTP server to provide callback function for SSL session.

All documentation for :doc:`esp_http_server` applies also to a server you create this way.

Used APIs


The following APIs of :doc:`esp_http_server` should not be used with :doc:`esp_https_server`, as they are used internally to handle secure sessions and to maintain internal"
" state:

Everything else can be used without limitations.

Usage


Please see the example :example:`protocols/https_server` to learn how to set up a secure server.

Basically, all you need is to generate a certificate, embed it into the firmware, and pass the init struct into the start function after the certificate address and lengths are correctly configured in the init struct.

The server can be started with or without SSL by changing a flag in the init struct - :cpp:member:`httpd_ssl_config:"
":transport_mode`. This could be used, e.g., for testing or in trusted environments where you prefer speed over security.

Performance


The initial session setup can take about two seconds, or more with slower clock speed or more verbose logging. Subsequent requests through the open secure socket are much faster (down to under 100 ms).

Event Handling


ESP HTTPS Server has various events for which a handler can be triggered by :doc:`the Event Loop library ` when the particular event occurs. The"
" handler has to be registered using :cpp:func:`esp_event_handler_register`. This helps in event handling for ESP HTTPS Server.

:cpp:enum:`esp_https_server_event_id_t` has all the events which can happen for ESP HTTPS server.

Expected data type for different ESP HTTP server events in event loop:

    - HTTPS_SERVER_EVENT_ERROR          :   ``esp_https_server_last_error_t``
    - HTTPS_SERVER_EVENT_START          :   ``NULL``
    - HTTPS_SERVER_EVENT_ON_CONNECTED   :   ``NULL``
    - HTTPS_SERVE"
"R_EVENT_ON_DATA        :   ``int``
    - HTTPS_SERVER_EVENT_SENT_DATA      :   ``NULL``
    - HTTPS_SERVER_EVENT_DISCONNECTED   :   ``NULL``
    - HTTPS_SERVER_EVENT_STOP           :   ``NULL``

API Reference


.. include-build-file:: inc/esp_https_server.inc
"
"Application Protocols




.. toctree::
    :maxdepth: 1

    asio
    modbus
    mqtt
    esp_tls
    esp_http_client
    esp_local_ctrl
    esp_serial_slave_link
    esp_crt_bundle
    esp_http_server
    esp_https_server
    icmp_echo
    mdns
    mbedtls

Code examples for this API section are provided in the :example:`protocols` directory of ESP-IDF examples.


IP Network Layer


Documentation for IP Network Layer protocols (below the Application Protocol layer) are provided in :doc:`../netw"
"ork/index`.
"
"ESP-TLS




Overview


The ESP-TLS component provides a simplified API interface for accessing the commonly used TLS functions. It supports common scenarios like CA certification validation, SNI, ALPN negotiation, and non-blocking connection among others. All the configurations can be specified in the ``esp_tls_cfg_t`` data structure. Once done, TLS communication can be conducted using the following APIs:

Any application layer protocol like HTTP1, HTTP2, etc can be executed on top of this layer"
".

Application Example


Simple HTTPS example that uses ESP-TLS to establish a secure socket connection: :example:`protocols/https_request`.

Tree Structure for ESP-TLS Component


    .. code-block:: none

        ├── esp_tls.c
        ├── esp_tls.h
        ├── esp_tls_mbedtls.c
        ├── esp_tls_wolfssl.c
        └── private_include
            ├── esp_tls_mbedtls.h
            └── esp_tls_wolfssl.h

The ESP-TLS component has a file :component_file:`esp-tls/esp_tls.h` which contains the publ"
"ic API headers for the component. Internally, the ESP-TLS component operates using either MbedTLS or WolfSSL, which are SSL/TLS libraries. APIs specific to MbedTLS are present in :component_file:`esp-tls/private_include/esp_tls_mbedtls.h` and APIs specific to WolfSSL are present in :component_file:`esp-tls/private_include/esp_tls_wolfssl.h`.

.. _esp_tls_server_verification:

TLS Server Verification


ESP-TLS provides multiple options for TLS server verification on the client side. The ESP-TLS c"
"lient can verify the server by validating the peer's server certificate or with the help of pre-shared keys. The user should select only one of the following options in the :cpp:type:`esp_tls_cfg_t` structure for TLS server verification. If no option is selected, the client will return a fatal error by default during the TLS connection setup.

    .. warning::

        Enabling this option comes with a potential risk of establishing a TLS connection with a server that has a fake identity, provid"
"ed that the server certificate is not provided either through API or other mechanisms like ca_store etc.

ESP-TLS Server Cert Selection Hook


The ESP-TLS component provides an option to set the server certification selection hook when using the MbedTLS stack. This provides an ability to configure and use a certificate selection callback during server handshake. The callback helps to select a certificate to present to the client based on the TLS extensions supplied in the client hello message, s"
"uch as ALPN and SNI. To enable this feature, please enable  :ref:`CONFIG_ESP_TLS_SERVER_CERT_SELECT_HOOK` in the ESP-TLS menuconfig.

The certificate selection callback can be configured in the :cpp:type:`esp_tls_cfg_t` structure as follows:

.. code-block:: c

    int cert_selection_callback(mbedtls_ssl_context *ssl)
    {
        /* Code that the callback should execute */
        return 0;
    }

    esp_tls_cfg_t cfg = {
        cert_select_cb = cert_section_callback,
    };

.. _esp_tls_wol"
"fssl:

Underlying SSL/TLS Library Options


The ESP-TLS component offers the option to use MbedTLS or WolfSSL as its underlying SSL/TLS library. By default, only MbedTLS is available and used, WolfSSL SSL/TLS library is also available publicly at https://github.com/espressif/esp-wolfssl. The repository provides the WolfSSL component in binary format, and it also provides a few examples that are useful for understanding the API. Please refer to the repository ``README.md`` for information on lice"
"nsing and other options. Please see the below section for instructions on how to use WolfSSL in your project.

.. note::

    As the library options are internal to ESP-TLS, switching the libraries will not change ESP-TLS specific code for a project.

How to Use WolfSSL with ESP-IDF


There are two ways to use WolfSSL in your project:

1) Directly add WolfSSL as a component in your project with the following three commands::

    (First, change the directory (cd) to your project directory)
    m"
"kdir components
    cd components
    git clone --recursive https://github.com/espressif/esp-wolfssl.git

2) Add WolfSSL as an extra component in your project.

    git clone --recursive https://github.com/espressif/esp-wolfssl.git

After the above steps, you will have the option to choose WolfSSL as the underlying SSL/TLS library in the configuration menu of your project as follows::

    idf.py menuconfig > ESP-TLS > SSL/TLS Library > Mbedtls/Wolfssl

Comparison Between MbedTLS and WolfSSL


T"
"he following table shows a typical comparison between WolfSSL and MbedTLS when the :example:`protocols/https_request` example (which includes server authentication) is running with both SSL/TLS libraries and with all respective configurations set to default. For MbedTLS, the IN_CONTENT length and OUT_CONTENT length are set to 16384 bytes and 4096 bytes respectively.

.. list-table::
    :header-rows: 1
    :widths: 40 30 30
    :align: center
      - WolfSSL
      - MbedTLS
      - ~ 19 KB
     "
" - ~ 37 KB
      - ~ 2.2 KB
      - ~ 3.6 KB
      - ~ 858 KB
      - ~ 736 KB

.. note::

    These values can vary based on configuration options and version of respective libraries.

.. only:: esp32

    ATECC608A (Secure Element) with ESP-TLS
    

    ESP-TLS provides support for using ATECC608A cryptoauth chip with ESP32 series of SoCs. The use of ATECC608A is supported only when ESP-TLS is used with MbedTLS as its underlying SSL/TLS stack. ESP-TLS uses MbedTLS as its underlying TLS/SSL st"
"ack by default unless changed manually.

    .. note::

        ATECC608A chip interfaced to ESP32 must be already configured. For details, please refer to `esp_cryptoauth_utility `_.

    To enable the secure element support, and use it in your project for TLS connection, you have to follow the below steps:

    1) Add `esp-cryptoauthlib `_ in your project, for details please refer `how to use esp-cryptoauthlib with ESP-IDF `_.

    2) Enable the following menuconfig option::

        menuconfi"
"g > Component config > ESP-TLS > Use Secure Element (ATECC608A) with ESP-TLS

    3) Select type of ATECC608A chip with following option::

        menuconfig > Component config > esp-cryptoauthlib > Choose Type of ATECC608A chip

    To know more about different types of ATECC608A chips and how to obtain the type of ATECC608A connected to your ESP module, please visit `ATECC608A chip type `_.

    4) Enable the use of ATECC608A in ESP-TLS by providing the following config option in :cpp:type:`e"
"sp_tls_cfg_t`.

    .. code-block:: c

            esp_tls_cfg_t cfg = {
                /* other configurations options */
                .use_secure_element = true,
            };

.. only:: SOC_DIG_SIGN_SUPPORTED

    .. _digital-signature-with-esp-tls:

    Digital Signature with ESP-TLS
    

    ESP-TLS provides support for using the Digital Signature (DS) with {IDF_TARGET_NAME}. Use of the DS for TLS is supported only when ESP-TLS is used with MbedTLS (default stack) as its underlying SS"
"L/TLS stack. For more details on Digital Signature, please refer to the :doc:`Digital Signature (DS) `. The technical details of Digital Signature such as how to calculate private key parameters can be found in **{IDF_TARGET_NAME} Technical Reference Manual** > **Digital Signature (DS)** [`PDF `__]. The DS peripheral must be configured before it can be used to perform Digital Signature, see :ref:`configure-the-ds-peripheral`.

    The DS peripheral must be initialized with the required encrypted"
" private key parameters, which are obtained when the DS peripheral is configured. ESP-TLS internally initializes the DS peripheral when provided with the required DS context, i.e., DS parameters. Please see the below code snippet for passing the DS context to the ESP-TLS context. The DS context passed to the ESP-TLS context should not be freed till the TLS connection is deleted.

    .. code-block:: c

            #include ""esp_tls.h""
            esp_ds_data_ctx_t *ds_ctx;
            /* initial"
"ize ds_ctx with encrypted private key parameters, which can be read from the nvs or provided through the application code */
            esp_tls_cfg_t cfg = {
                .clientcert_buf = /* the client certification */,
                .clientcert_bytes = /* length of the client certification */,
                /* other configurations options */
                .ds_data = (void *)ds_ctx,
            };

    .. note::

        When using Digital Signature for the TLS connection, along with "
"the other required params, only the client certification (`clientcert_buf`) and the DS params (`ds_data`) are required and the client key (`clientkey_buf`) can be set to NULL.

.. only:: SOC_ECDSA_SUPPORTED

    .. _ecdsa-peri-with-esp-tls:

    ECDSA Peripheral with ESP-TLS
    

    ESP-TLS provides support for using the ECDSA peripheral with {IDF_TARGET_NAME}. The use of ECDSA peripheral is supported only when ESP-TLS is used with MbedTLS as its underlying SSL/TLS stack. The ECDSA private key"
" should be present in the eFuse for using the ECDSA peripheral. Please refer to `espefuse.py `__ documentation for programming the ECDSA key in the efuse.
    To use ECDSA peripheral with ESP-TLS, set :cpp:member:`esp_tls_cfg_t::use_ecdsa_peripheral` to `true`, and set :cpp:member:`esp_tls_cfg_t::ecdsa_key_efuse_blk` to the eFuse block ID in which ECDSA private key is stored.
    This will enable the use of ECDSA peripheral for private key operations. As the client private key is already present"
" in the eFuse, it needs not be supplied to the :cpp:type:`esp_tls_cfg_t` structure.

    .. code-block:: c

        #include ""esp_tls.h""
        esp_tls_cfg_t cfg = {
            .use_ecdsa_peripheral = true,
            .ecdsa_key_efuse_blk = /* efuse block with ecdsa private key */,
        };

    .. note::

        When using ECDSA peripheral with TLS, only ``MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`` ciphersuite is supported. If using TLS v1.3, ``MBEDTLS_TLS1_3_AES_128_GCM_SHA256`` c"
"iphersuite is supported.


TLS Ciphersuites


ESP-TLS provides the ability to set a ciphersuites list in client mode. The TLS ciphersuites list informs the server about the supported ciphersuites for the specific TLS connection regardless of the TLS stack configuration. If the server supports any ciphersuite from this list, then the TLS connection will succeed; otherwise, it will fail.

You can set ``ciphersuites_list`` in the :cpp:type:`esp_tls_cfg_t` structure during client connection as follo"
"ws:

.. code-block:: c

    /* ciphersuites_list must end with 0 and must be available in the memory scope active during the entire TLS connection */
    static const int ciphersuites_list[] = {MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, 0};
    esp_tls_cfg_t cfg = {
        .ciphersuites_list = ciphersuites_list,
    };

ESP-TLS will not check the validity of ``ciphersuites_list`` that was set, you should call :cpp:func:`esp_tls_get_ciphersuit"
"es_list` to get ciphersuites list supported in the TLS stack and cross-check it against the supplied list.

.. note::

   This feature is supported only in the MbedTLS stack.

TLS Protocol Version


ESP-TLS provides the ability to set the TLS protocol version for the respective TLS connection. Once the version is specified, it should be exclusively used to establish the TLS connection. This provides an ability to route different TLS connections to different protocol versions like TLS 1.2 and TLS"
" 1.3 at runtime.

.. note::

   At the moment, the feature is supported only when ESP-TLS is used with MbedTLS as its underlying SSL/TLS stack.

To set TLS protocol version with ESP-TLS, set :cpp:member:`esp_tls_cfg_t::tls_version` to the required protocol version from :cpp:type:`esp_tls_proto_ver_t`. If the protocol version field is not set, then the default policy is to allow TLS connection based on the server requirement.

The ESP-TLS connection can be configured to use the specified protocol"
" version as follows:

    .. code-block:: c

        #include ""esp_tls.h""
        esp_tls_cfg_t cfg = {
            .tls_version = ESP_TLS_VER_TLS_1_2,
        };

API Reference


.. include-build-file:: inc/esp_tls.inc
.. include-build-file:: inc/esp_tls_errors.inc
"
"ESP Local Control




Overview


ESP Local Control (**esp_local_ctrl**) component in ESP-IDF provides capability to control an ESP device over HTTPS or Bluetooth® Low Energy. It provides access to application defined **properties** that are available for reading/writing via a set of configurable handlers.

.. only:: SOC_BT_SUPPORTED

    Initialization of the **esp_local_ctrl** service over Bluetooth Low Energy transport is performed as follows:

        .. code-block:: c

            esp_local_"
"ctrl_config_t config = {
                .transport = ESP_LOCAL_CTRL_TRANSPORT_BLE,
                .transport_config = {
                    .ble = & (protocomm_ble_config_t) {
                        .device_name  = SERVICE_NAME,
                        .service_uuid = {
                            /* LSB  MSB */
                            0x21, 0xd5, 0x3b, 0x8d, 0xbd, 0x75, 0x68, 0x8a,
                            0xb4, 0x42, 0xeb, 0x31, 0x4a, 0x1e, 0x98, 0x3d
                        }
      "
"              }
                },
                .proto_sec = {
                    .version = PROTOCOM_SEC0,
                    .custom_handle = NULL,
                    .sec_params = NULL,
                },
                .handlers = {
                    /* User defined handler functions */
                    .get_prop_values = get_property_values,
                    .set_prop_values = set_property_values,
                    .usr_ctx         = NULL,
                    .usr_ctx_free_"
"fn = NULL
                },
                /* Maximum number of properties that may be set */
                .max_properties = 10
            };

            /* Start esp_local_ctrl service */
            ESP_ERROR_CHECK(esp_local_ctrl_start(&config));


Initialization of the **esp_local_ctrl** service over HTTPS transport is performed as follows:

    .. code-block:: c

        /* Set the configuration */
        httpd_ssl_config_t https_conf = HTTPD_SSL_CONFIG_DEFAULT();

        /* Load se"
"rver certificate */
        extern const unsigned char servercert_start[] asm(""_binary_servercert_pem_start"");
        extern const unsigned char servercert_end[]   asm(""_binary_servercert_pem_end"");
        https_conf.servercert = servercert_start;
        https_conf.servercert_len = servercert_end - servercert_start;

        /* Load server private key */
        extern const unsigned char prvtkey_pem_start[] asm(""_binary_prvtkey_pem_start"");
        extern const unsigned char prvtkey_pem_end["
"]   asm(""_binary_prvtkey_pem_end"");
        https_conf.prvtkey_pem = prvtkey_pem_start;
        https_conf.prvtkey_len = prvtkey_pem_end - prvtkey_pem_start;

        esp_local_ctrl_config_t config = {
            .transport = ESP_LOCAL_CTRL_TRANSPORT_HTTPD,
            .transport_config = {
                .httpd = &https_conf
            },
            .proto_sec = {
                .version = PROTOCOM_SEC0,
                .custom_handle = NULL,
                .sec_params = NULL,
           "
" },
            .handlers = {
                /* User defined handler functions */
                .get_prop_values = get_property_values,
                .set_prop_values = set_property_values,
                .usr_ctx         = NULL,
                .usr_ctx_free_fn = NULL
            },
            /* Maximum number of properties that may be set */
            .max_properties = 10
        };

        /* Start esp_local_ctrl service */
        ESP_ERROR_CHECK(esp_local_ctrl_start(&config));

Y"
"ou may set security for transport in ESP local control using following options:

.. note::
    The respective security schemes need to be enabled through the project configuration menu. Please refer to the Enabling protocom security version section in :doc:`Protocol Communication ` for more details.

Creating a Property


Now that we know how to start the **esp_local_ctrl** service, let's add a property to it. Each property must have a unique  (string), a ``type`` (e.g., enum), ``flags.

The ``s"
"ize`` is to be kept 0, if we want our property value to be of variable length (e.g., if it is a string or bytestream). For data types with fixed-length property value, like int, float, etc., setting the ``size`` field to the right value helps **esp_local_ctrl** to perform internal checks on arguments received with write requests.

The interpretation of ``type`` and ``flags`` fields is totally upto the application, hence they may be used as enumerations, bitfields, or even simple integers. One wa"
"y is to use ``type`` values to classify properties, while ``flags`` to specify characteristics of a property.

Here is an example property which is to function as a timestamp. It is assumed that the application defines ``TYPE_TIMESTAMP`` and ``READONLY``, which are used for setting the ``type`` and ``flags`` fields here.

    .. code-block:: c

        /* Create a timestamp property */
        esp_local_ctrl_prop_t timestamp = {
            .name        = ""timestamp"",
            .type        = "
"TYPE_TIMESTAMP,
            .size        = sizeof(int32_t),
            .flags       = READONLY,
            .ctx         = func_get_time,
            .ctx_free_fn = NULL
        };

        /* Now register the property */
        esp_local_ctrl_add_property(&timestamp);


Also notice that there is a ctx field, which is set to point to some custom `func_get_time()`. This can be used inside the property get/set handlers to retrieve timestamp.

Here is an example of ``get_prop_values()`` handler, "
"which is used for retrieving the timestamp.

    .. code-block:: c

        static esp_err_t get_property_values(size_t props_count,
                                             const esp_local_ctrl_prop_t *props,
                                             esp_local_ctrl_prop_val_t *prop_values,
                                             void *usr_ctx)
        {
            for (uint32_t i = 0; i .local/esp_local_ctrl/version
     - Endpoint used for retrieving version string
     - https://"
".local/esp_local_ctrl/control
     - Endpoint used for sending or receiving control messages


API Reference


.. include-build-file:: inc/esp_local_ctrl.inc
"
"ICMP Echo




Overview


ICMP (Internet Control Message Protocol) is used for diagnostic or control purposes or generated in response to errors in IP operations. The common network util ``ping`` is implemented based on the ICMP packets with the type field value of 0, also called ``Echo Reply``.

During a ping session, the source host firstly sends out an ICMP echo request packet and wait for an ICMP echo reply with specific times. In this way, it also measures the round-trip time for the message"
"s. After receiving a valid ICMP echo reply, the source host will generate statistics about the IP link layer (e.g., packet loss, elapsed time, etc).

It is common that IoT device needs to check whether a remote server is alive or not. The device should show the warnings to users when it got offline. It can be achieved by creating a ping session and sending or parsing ICMP echo packets periodically.

To make this internal procedure much easier for users, ESP-IDF provides some out-of-box APIs.

Cr"
"eate a New Ping Session


To create a ping session, you need to fill in the ``esp_ping_config_t`` configuration structure firstly, specifying target IP address, interval times, and etc. Optionally, you can also register some callback functions with the ``esp_ping_callbacks_t`` structure.

Example method to create a new ping session and register callbacks:

.. code-block:: c

    static void test_on_ping_success(esp_ping_handle_t hdl, void *args)
    {
        // optionally, get callback argument"
"s
        // const char* str = (const char*) args;
        // printf(""%s\r\n"", str); // ""foo""
        uint8_t ttl;
        uint16_t seqno;
        uint32_t elapsed_time, recv_len;
        ip_addr_t target_addr;
        esp_ping_get_profile(hdl, ESP_PING_PROF_SEQNO, &seqno, sizeof(seqno));
        esp_ping_get_profile(hdl, ESP_PING_PROF_TTL, &ttl, sizeof(ttl));
        esp_ping_get_profile(hdl, ESP_PING_PROF_IPADDR, &target_addr, sizeof(target_addr));
        esp_ping_get_profile(hdl, ESP_PING_PR"
"OF_SIZE, &recv_len, sizeof(recv_len));
        esp_ping_get_profile(hdl, ESP_PING_PROF_TIMEGAP, &elapsed_time, sizeof(elapsed_time));
        printf(""%d bytes from %s icmp_seq=%d ttl=%d time=%d ms\n"",
               recv_len, inet_ntoa(target_addr.u_addr.ip4), seqno, ttl, elapsed_time);
    }

    static void test_on_ping_timeout(esp_ping_handle_t hdl, void *args)
    {
        uint16_t seqno;
        ip_addr_t target_addr;
        esp_ping_get_profile(hdl, ESP_PING_PROF_SEQNO, &seqno, sizeof(se"
"qno));
        esp_ping_get_profile(hdl, ESP_PING_PROF_IPADDR, &target_addr, sizeof(target_addr));
        printf(""From %s icmp_seq=%d timeout\n"", inet_ntoa(target_addr.u_addr.ip4), seqno);
    }

    static void test_on_ping_end(esp_ping_handle_t hdl, void *args)
    {
        uint32_t transmitted;
        uint32_t received;
        uint32_t total_time_ms;

        esp_ping_get_profile(hdl, ESP_PING_PROF_REQUEST, &transmitted, sizeof(transmitted));
        esp_ping_get_profile(hdl, ESP_PING_PRO"
"F_REPLY, &received, sizeof(received));
        esp_ping_get_profile(hdl, ESP_PING_PROF_DURATION, &total_time_ms, sizeof(total_time_ms));
        printf(""%d packets transmitted, %d received, time %dms\n"", transmitted, received, total_time_ms);
    }

    void initialize_ping()
    {
        /* convert URL to IP address */
        ip_addr_t target_addr;
        struct addrinfo hint;
        struct addrinfo *res = NULL;
        memset(&hint, 0, sizeof(hint));
        memset(&target_addr, 0, sizeof("
"target_addr));
        getaddrinfo(""www.espressif.com"", NULL, &hint, &res);
        struct in_addr addr4 = ((struct sockaddr_in *) (res->ai_addr))->sin_addr;
        inet_addr_to_ip4addr(ip_2_ip4(&target_addr), &addr4);
        freeaddrinfo(res);

        esp_ping_config_t ping_config = ESP_PING_DEFAULT_CONFIG();
        ping_config.target_addr = target_addr;          // target IP address
        ping_config.count = ESP_PING_COUNT_INFINITE;    // ping in infinite mode, esp_ping_stop can stop it
"
"
        /* set callback functions */
        esp_ping_callbacks_t cbs;
        cbs.on_ping_success = test_on_ping_success;
        cbs.on_ping_timeout = test_on_ping_timeout;
        cbs.on_ping_end = test_on_ping_end;
        cbs.cb_args = ""foo"";  // arguments that feeds to all callback functions, can be NULL
        cbs.cb_args = eth_event_group;

        esp_ping_handle_t ping;
        esp_ping_new_session(&ping_config, &cbs, &ping);
    }

Start and Stop Ping Session


You can start and sto"
"p ping session with the handle returned by ``esp_ping_new_session``. Note that, the ping session does not start automatically after creation. If the ping session is stopped, and restart again, the sequence number in ICMP packets will recount from zero again.


Delete a Ping Session


If a ping session will not be used any more, you can delete it with ``esp_ping_delete_session``. Please make sure the ping session is in stop state (i.e., you have called ``esp_ping_stop`` before or the ping session"
" has finished all the procedures) when you call this function.


Get Runtime Statistics


As the example code above, you can call ``esp_ping_get_profile`` to get different runtime statistics of ping session in the callback function.


Application Example


ICMP echo example: :example:`protocols/icmp_echo`

API Reference


.. include-build-file:: inc/ping_sock.inc
"
"Communication with ESP SDIO Slave




This document describes the process of initialization of an ESP SDIO Slave device and then provides details on the ESP SDIO Slave protocol - a non-standard protocol that allows an SDIO Host to communicate with an ESP SDIO slave.

The ESP SDIO Slave protocol was created to implement the communication between SDIO host and slave, because the SDIO specification only shows how to access the custom region of a card (by sending CMD52 and CMD53 to functions 1-7) wi"
"thout any details regarding the underlying hardware implementation.

.. _esp_sdio_slave_caps:

SDIO Slave Capabilities of Espressif Chips


The services provided by the SDIO Slave peripheral of the {IDF_TARGET_NAME} chip are listed in the table below:

.. list-table::
   :widths: 70 30
   :header-rows: 1
     - {IDF_TARGET_NAME}
     - Y
     - 8
     - 8
     - Y
     - Y
     - 56\*

\* Not including the interrupt registers


.. _esp_slave_init:

ESP SDIO Slave Initialization


The host should"
" initialize the {IDF_TARGET_NAME} SDIO slave according to the standard SDIO initialization process (Section 3.1.2 of `SDIO Simplified Specification `_). In this specification as well as below, the SDIO slave is called an SDIO/IO card. Here is a brief example of an ESP SDIO Slave initialization process:

    CMD52 (Write 0x6 = 0x8)

    CMD0

    CMD8

    CMD5 arg = 0x00000000

    CMD5 arg = 0x00ff8000 (according to the response above, poll until ready)

    **Example:**

        Arg of R4 afte"
"r first CMD5 (arg = 0x00000000) is 0xXXFFFF00.

        Keep sending CMD5 with arg = 0x00FFFF00 until the R4 shows card ready (arg bit 31 = 1).

    CMD3

    CMD7 (arg address according to CMD3 response)

    **Example:**

        Arg of R6 after CMD3 is 0x0001xxxx.

        Arg of CMD7 should be 0x00010000.

    CMD52 (Write 0x07 = 0x02)

    CMD52 (Write 0x02 = 0x02)

    CMD52 (Write 0x04 = 0x03)

     CMD52/53 (Read 0x10 ~ 0x11)

     CMD52/53 (Write 0x10 = 0x00)

     CMD52/53 (Write 0x11 "
"= 0x02)

     CMD52/53 (Read 0x10 ~ 0x11, read to check the final value)

     CMD52/53 (Read 0x110 ~ 0x111)

     CMD52/53 (Write 0x110 = 0x00)

     CMD52/53 (Write 0x111 = 0x02)

     CMD52/53 (Read 0x110 ~ 0x111, read to check the final value)


.. _esp_slave_protocol_layer:

ESP SDIO Slave Protocol


The ESP SDIO Slave protocol is based on the SDIO Specification's I/O Read/Write commands, i.e., CMD52 and CMD53. The protocol offers the following services:

- Sending FIFO and receiving FIFO
-"
" 52 8-bit R/W registers shared by host and slave (For details, see *{IDF_TARGET_NAME} Technical Reference Manual* > *SDIO Slave Controller* > *Register Summary* > SDIO SLC Host registers [`PDF `__])
- 16 general purpose interrupt sources, 8 from host to slave and 8 from slave to host

To begin communication, the host needs to enable the I/O Function 1 in the slave and access its registers as described below.

Check the code example: :example:`peripherals/sdio`

The :doc:`ESP Serial Slave Link ` "
"component implements the logic of this protocol for ESP32 SDIO Host when communicating with an ESP32 SDIO slave.

.. _esp_sdio_slave_shared_registers:

Slave Register Table


32-bit
""""""""""""

- 0x044 (TOKEN_RDATA): in which bit 27-16 holds the number of the receiving buffer.
- 0x058 (INT_ST): holds the interrupt source bits from slave to host.
- 0x060 (PKT_LEN): holds the accumulated data length (in bytes) already read by host plus the data copied to the buffer but yet to be read.
- 0x0D4 (INT_CLR"
"): write 1 to clear interrupt bits corresponding to INT_ST.
- 0x0DC (INT_ENA): mask bits for interrupts from slave to host.

8-bit
""""""""""

Shared general purpose registers:

- 0x06C-0x077: R/W registers 0-11 shared by slave and host.
- 0x07A-0x07B: R/W registers 14-15 shared by slave and host.
- 0x07E-0x07F: R/W registers 18-19 shared by slave and host.
- 0x088-0x08B: R/W registers 24-27 shared by slave and host.
- 0x09C-0x0BB: R/W registers 32-63 shared by slave and host.

Interrupt Registers:

"
"- 0x08D (SLAVE_INT): bits for host to interrupt slave. auto clear.

FIFO (Sending and Receiving)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

0x090 - 0x1F7FF are reserved for FIFOs.

The address of CMD53 is related to the length requested to read from or write to the slave in a single transfer, as demonstrated by the equation below:

    *requested length = 0x1F800 - address*

The slave responds to data that has a length equal to the length field of CMD53. In cases where the data is longer than the **requested"
" length**, the data will be zero filled (when sending) or discarded (when receiving). This includes both the block and the byte mode of CMD53.

.. note::

    The function number should be set to 1, and OP Code should be set to 1 (for CMD53).

    In order to achieve higher efficiency when accessing the FIFO by an arbitrary length, the block and byte modes of CMD53 can be used in combination. For example, given that the block size is set to 512 by default, you can write or get 1031 bytes of data"
" from the FIFO by doing the following:

.. _esp_sdio_slave_interrupts:

Interrupts


SDIO interrupts are ""level sensitive"". For host interrupts, the slave sends an interrupt by pulling the DAT1 line down at a proper time. The host detects when the interrupt line is pulled down and reads the INT_ST register to determine the source of the interrupt. After that, the host can clear the interrupt bits by writing the ``INT_CLR`` register and process the interrupt. The host can also mask unneeded sourc"
"es by clearing the bits in the INT_ENA register corresponding to the sources. If all the sources are cleared (or masked), the DAT1 line goes inactive.

On {IDF_TARGET_NAME}, the corresponding ``host_int`` bits are: bit 0 to bit 7.

For slave interrupts, the host sends a transfer to write the ``SLAVE_INT`` register. Once a bit is set to 1, the slave hardware and the driver will detect it and inform the application.

.. _esp_sdio_slave_rcv_fifo:

Receiving FIFO


To write to the slave's receiving "
"FIFO, the host should complete the following steps:

.. _esp_sdio_slave_send_fifo:

Sending FIFO


To read the slave's sending FIFO, the host should complete the following steps:
"
"HTTP Server




Overview


The HTTP Server component provides an ability for running a lightweight web server on {IDF_TARGET_NAME}. Following are detailed steps to use the API exposed by HTTP Server:

Application Example


    .. code-block:: c

        /* Our URI handler function to be called during GET /uri request */
        esp_err_t get_handler(httpd_req_t *req)
        {
            /* Send a simple response */
            const char resp[] = ""URI GET Response"";
            httpd_resp_send"
"(req, resp, HTTPD_RESP_USE_STRLEN);
            return ESP_OK;
        }

        /* Our URI handler function to be called during POST /uri request */
        esp_err_t post_handler(httpd_req_t *req)
        {
            /* Destination buffer for content of HTTP POST request.
            char content[100];

            /* Truncate if content length larger than the buffer */
            size_t recv_size = MIN(req->content_len, sizeof(content));

            int ret = httpd_req_recv(req, content,"
" recv_size);
            if (ret sess_ctx) {
            req->sess_ctx = malloc(sizeof(ANY_DATA_TYPE));  /*!free_ctx = free_ctx_func;                  /*!sess_ctx;

        /* Respond */
        ...............
        ...............
        ...............

        return ESP_OK;
    }


Check the example under :example:`protocols/http_server/persistent_sockets`.


Websocket Server


The HTTP server component provides websocket support. The websocket feature can be enabled in menuconfig using "
"the :ref:`CONFIG_HTTPD_WS_SUPPORT` option. Please refer to the :example:`protocols/http_server/ws_echo_server` example which demonstrates usage of the websocket feature.


Event Handling


ESP HTTP server has various events for which a handler can be triggered by :doc:`the Event Loop library ` when the particular event occurs. The handler has to be registered using :cpp:func:`esp_event_handler_register`. This helps in event handling for ESP HTTP server.

:cpp:enum:`esp_http_server_event_id_t` ha"
"s all the events which can happen for ESP HTTP server.

Expected data type for different ESP HTTP server events in event loop:

    - HTTP_SERVER_EVENT_ERROR           :   ``httpd_err_code_t``
    - HTTP_SERVER_EVENT_START           :   ``NULL``
    - HTTP_SERVER_EVENT_ON_CONNECTED    :   ``int``
    - HTTP_SERVER_EVENT_ON_HEADER       :   ``int``
    - HTTP_SERVER_EVENT_HEADERS_SENT    :   ``int``
    - HTTP_SERVER_EVENT_ON_DATA         :   ``esp_http_server_event_data``
    - HTTP_SERVER_EVENT"
"_SENT_DATA       :   ``esp_http_server_event_data``
    - HTTP_SERVER_EVENT_DISCONNECTED    :   ``int``
    - HTTP_SERVER_EVENT_STOP            :   ``NULL``

API Reference


.. include-build-file:: inc/esp_http_server.inc
"
"ESP Serial Slave Link




Overview


Espressif provides several chips that can work as slaves. These slave devices rely on some common buses, and have their own communication protocols over those buses. The ``esp_serial_slave_link`` component is designed for the master to communicate with ESP slave devices through those protocols over the bus drivers.

After an ``esp_serial_slave_link`` device is initialized properly, the application can use it to communicate with the ESP slave devices convenien"
"tly.

.. note::

  The ESP-IDF component ``esp_serial_slave_link`` has been moved from ESP-IDF since version v5.0 to a separate repository:

  To add ESSL component in your project, please run ``idf.py add-dependency espressif/esp_serial_slave_link``.


Espressif Device Protocols


For more details about Espressif device protocols, see the following documents.

.. toctree::
    :maxdepth: 1

    :SOC_SDIO_SLAVE_SUPPORTED: esp_sdio_slave_protocol
    esp_spi_slave_protocol

Terminology


- ESSL: "
"Abbreviation for ESP Serial Slave Link, the component described by this document.

- Master: The device running the ``esp_serial_slave_link`` component.

- ESSL device: a virtual device on the master associated with an ESP slave device. The device context has the knowledge of the slave protocol above the bus, relying on some bus drivers to communicate with the slave.

- ESSL device handle: a handle to ESSL device context containing the configuration, status and data required by the ESSL componen"
"t. The context stores the driver configurations, communication state, data shared by master and slave, etc.

   - The context should be initialized before it is used, and get deinitialized if not used any more. The master application operates on the ESSL device through this handle.

- ESP slave: the slave device connected to the bus, which ESSL component is designed to communicate with.

- Bus: The bus over which the master and the slave communicate with each other.

- Slave protocol: The specia"
"l communication protocol specified by Espressif HW/SW over the bus.

- TX buffer num: a counter, which is on the slave and can be read by the master, indicates the accumulated buffer numbers that the slave has loaded to the hardware to receive data from the master.

- RX data size: a counter, which is on the slave and can be read by the master, indicates the accumulated data size that the slave has loaded to the hardware to send to the master.

Services Provided by ESP Slave


There are some com"
"mon services provided by the Espressif slaves:

   The slave updates the TX buffer num to inform the master how much data it can receive, and the master then read the TX buffer num, and take off the used buffer number to know how many buffers are remaining.

   The slave updates the RX data size to inform the master how much data it has prepared to send, and then the master read the data size, and take off the data length it has already received to know how many data is remaining.

.. only:: SOC"
"_SDIO_SLAVE_SUPPORTED

   The services provided by the slave depends on the slave's model. See :ref:`esp_sdio_slave_caps` and :ref:`esp_spi_slave_caps` for more details.

.. only:: not SOC_SDIO_SLAVE_SUPPORTED

   The services provided by the slave depends on the slave's model. See :ref:`esp_spi_slave_caps` for more details.


Initialization of ESP Serial Slave Link


.. _essl_sdio_slave_init:

ESP SDIO Slave


The ESP SDIO slave link (ESSL SDIO) devices relies on the SDMMC component. It include"
"s the usage of communicating with ESP SDIO Slave device via the SDMMC Host or SDSPI Host feature. The ESSL device should be initialized as below:

ESP SPI Slave


.. note::

    If you are communicating with the ESP SDIO Slave device through SPI interface, you should use the :ref:`SDIO interface ` instead.

Has not been supported yet.

APIs


After the initialization process above is performed, you can call the APIs below to make use of the services provided by the slave:

Tohost Interrupts (Opt"
"ional)


Frhost Interrupts


TX FIFO


RX FIFO


Reset Counters (Optional)


Call :cpp:func:`essl_reset_cnt` to reset the internal counter if you find the slave has reset its counter.


Application Example


The example below shows how {IDF_TARGET_NAME} SDIO host and slave communicate with each other. The host uses the ESSL SDIO:

:example:`peripherals/sdio`

Please refer to the specific example README.md for details.

API Reference


.. include-build-file:: inc/essl.inc
.. include-build-file:: "
"inc/essl_sdio.inc
.. include-build-file:: inc/essl_spi.inc
"
"ESP-Modbus



The Espressif ESP-Modbus Library (esp-modbus) supports Modbus communication in the networks based on RS485, Wi-Fi, and Ethernet interfaces.
Since ESP-IDF version v5.0, the component ``freemodbus`` has been moved from ESP-IDF to a separate repository:

Hosted Documentation


The documentation can be found through the link below:

Application Example


The examples below demonstrate the ESP-Modbus library of serial and TCP ports for both slave and master implementations respectively."
"

- :example:`protocols/modbus/serial/mb_slave`
- :example:`protocols/modbus/serial/mb_master`
- :example:`protocols/modbus/tcp/mb_tcp_slave`
- :example:`protocols/modbus/tcp/mb_tcp_master`

Please refer to the ``README.md`` documents of each specific example for details.

Protocol References


    - For the detailed protocol specifications, see `The Modbus Organization `_.


"
"ASIO Port




ASIO is a cross-platform C++ library, see https://think-async.com/Asio/. It provides a consistent asynchronous model using a modern C++ approach.

The ESP-IDF component ``ASIO`` has been moved from ESP-IDF since version v5.0 to a separate repository:

To add ASIO component in your project, please run ``idf.py add-dependency espressif/asio``.

Hosted Documentation


The documentation can be found on the link below:
"
"ESP HTTP Client




Overview


``esp_http_client`` component provides a set of APIs for making HTTP/S requests from ESP-IDF applications. The steps to use these APIs are as follows:


Application Example


Simple example that uses ESP HTTP Client to make HTTP/S requests can be found at :example:`protocols/esp_http_client`.


Basic HTTP Request


Check out the example functions ``http_rest_with_url`` and ``http_rest_with_hostname_path`` in the application example for implementation details.


Per"
"sistent Connections


Persistent connection means that the HTTP client can re-use the same connection for several exchanges. If the server does not request to close the connection with the ``Connection: close`` header, the connection is not dropped but is instead kept open and used for further requests.

To allow ESP HTTP client to take full advantage of persistent connections, one should make as many requests as possible using the same handle instance. Check out the example functions ``http_res"
"t_with_url`` and ``http_rest_with_hostname_path`` in the application example. Here, once the connection is created, multiple requests (``GET``, ``POST``, ``PUT``, etc.) are made before the connection is closed.

.. only:: esp32

    Use Secure Element (ATECC608) for TLS
    _____________________________________

    A secure element (ATECC608) can be also used for the underlying TLS connection in the HTTP client connection. Please refer to the **ATECC608A (Secure Element) with ESP-TLS** section "
"in the :doc:`ESP-TLS documentation ` for more details. The secure element support has to be first enabled in menuconfig through :ref:`CONFIG_ESP_TLS_USE_SECURE_ELEMENT`. Then the HTTP client can be configured to use secure element as follows:

    .. code-block:: c

        esp_http_client_config_t cfg = {
            /* other configurations options */
            .use_secure_element = true,
        };


HTTPS Request


ESP HTTP client supports SSL connections using **mbedTLS**, with the ``url``"
" configuration starting with ``https`` scheme or ``transport_type`` set to ``HTTP_TRANSPORT_OVER_SSL``. HTTPS support can be configured via :ref:`CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS` (enabled by default).

.. note::

    While making HTTPS requests, if server verification is needed, an additional root certificate (in PEM format) needs to be provided to the ``cert_pem`` member in the ``esp_http_client_config_t`` configuration. Users can also use the ``ESP x509 Certificate Bundle`` for server veri"
"fication using the ``crt_bundle_attach`` member of the ``esp_http_client_config_t`` configuration.

Check out the example functions ``https_with_url`` and ``https_with_hostname_path`` in the application example for implementation details of the above note.


HTTP Stream


Some applications need to open the connection and control the exchange of data actively (data streaming). In such cases, the application flow is different from regular requests. Example flow is given below:

Check out the examp"
"le function ``http_perform_as_stream_reader`` in the application example for implementation details.


HTTP Authentication


ESP HTTP client supports both **Basic** and **Digest** Authentication.


Examples of Authentication Configuration


        .. highlight:: c

        ::

            esp_http_client_config_t config = {
                .url = ""http://user:passwd@httpbin.org/basic-auth/user/passwd"",
                .auth_type = HTTP_AUTH_TYPE_BASIC,
            };

        .. highlight:: c

"
"        ::

            esp_http_client_config_t config = {
                .url = ""http://httpbin.org/basic-auth/user/passwd"",
                .username = ""user"",
                .password = ""passwd"",
                .auth_type = HTTP_AUTH_TYPE_BASIC,
            };

Event Handling


ESP HTTP Client supports event handling by triggering an event handler corresponding to the event which takes place. :cpp:enum:`esp_http_client_event_id_t` contains all the events which could occur while performing"
" an HTTP request using the ESP HTTP Client.

To enable event handling, you just need to set a callback function using the :cpp:member:`esp_http_client_config_t::event_handler` member.

ESP HTTP Client Diagnostic Information


Diagnostic information could be helpful to gain insights into a problem. In the case of ESP HTTP Client, the diagnostic information can be collected by registering an event handler with :doc:`the Event Loop library `. This feature has been added by keeping in mind the `ESP "
"Insights `_ framework which collects the diagnostic information. However, this feature can also be used without any dependency on the ESP Insights framework for the diagnostic purpose. Event handler can be registered to the event loop using the :cpp:func:`esp_event_handler_register` function.

Expected data types for different HTTP Client events in the event loop are as follows:

    - HTTP_EVENT_ERROR            :   ``esp_http_client_handle_t``
    - HTTP_EVENT_ON_CONNECTED     :   ``esp_http_c"
"lient_handle_t``
    - HTTP_EVENT_HEADERS_SENT     :   ``esp_http_client_handle_t``
    - HTTP_EVENT_ON_HEADER        :   ``esp_http_client_handle_t``
    - HTTP_EVENT_ON_DATA          :   ``esp_http_client_on_data_t``
    - HTTP_EVENT_ON_FINISH        :   ``esp_http_client_handle_t``
    - HTTP_EVENT_DISCONNECTED     :   ``esp_http_client_handle_t``
    - HTTP_EVENT_REDIRECT         :   ``esp_http_client_redirect_event_data_t``

The :cpp:type:`esp_http_client_handle_t` received along with the e"
"vent data will be valid until :cpp:enumerator:`HTTP_EVENT_DISCONNECTED ` is not received. This handle has been sent primarily to differentiate between different client connections and must not be used for any other purpose, as it may change based on client connection state.

TLS Protocol Version


TLS protocol version to be used for the underlying TLS connection can be set in :cpp:type:`esp_http_client_config_t`. Please refer to the **TLS Protocol Version** section in the :doc:`/api-reference/pr"
"otocols/esp_tls` for more details.

The TLS protocol version for the HTTP client can be configured as follows:

    .. code-block:: c

        #include ""esp_http_client.h""
        esp_http_client_config_t config = {
            .tls_version = ESP_HTTP_CLIENT_TLS_VER_TLS_1_2,
        };

API Reference


.. include-build-file:: inc/esp_http_client.inc
"
"mDNS Service




mDNS is a multicast UDP service that is used to provide local network service and host discovery.

The ESP-IDF component ``mDNS`` has been moved from ESP-IDF since version v5.0 to a separate repository:

To add mDNS component in your project, please run ``idf.py add-dependency espressif/mdns``.

Hosted Documentation


The documentation can be found on the link below:
"
"ESP x509 Certificate Bundle




Overview


The ESP x509 Certificate Bundle API provides an easy way to include a bundle of custom x509 root certificates for TLS server verification.

.. note::

    The bundle is currently not available when using WolfSSL.

The bundle comes with the complete list of root certificates from Mozilla's NSS root certificate store. Using the gen_crt_bundle.py python utility, the certificates' subject name and public key are stored in a file and embedded in the {IDF_TAR"
"GET_NAME} binary.

When generating the bundle you may choose between:

In addition, it is possible to specify a path to a certificate file or a directory containing certificates which then will be added to the generated bundle.

.. note::

    Trusting all root certificates means the list will have to be updated if any of the certificates are retracted. This includes removing them from ``cacrt_all.pem``.

Configuration


Most configuration is done through menuconfig. CMake generates the bundle a"
"ccording to the configuration and embed it.

To enable the bundle when using ESP-TLS simply pass the function pointer to the bundle attach function:

.. code-block:: c

    esp_tls_cfg_t cfg = {
         .crt_bundle_attach = esp_crt_bundle_attach,
    };

This is done to avoid embedding the certificate bundle unless activated by the user.

If using mbedTLS directly then the bundle may be activated by directly calling the attach function during the setup process:

.. code-block:: c

    mbedtls_s"
"sl_config conf;
    mbedtls_ssl_config_init(&conf);

    esp_crt_bundle_attach(&conf);


.. _updating_bundle:

Generating the List of Root Certificates


The list of root certificates comes from Mozilla's NSS root certificate store, which can be found `here `_

The list can be downloaded and created by running the script ``mk-ca-bundle.pl`` that is distributed as a part of `curl `_.

Another alternative would be to download the finished list directly from the curl website: `CA certificates extra"
"cted from Mozilla `_

The common certificates bundle were made by selecting the authorities with a market share of more than 1% from w3tech's `SSL Survey `_.

These authorities were then used to pick the names of the certificates for the filter list, ``cmn_crt_authorities.csv``, from `this list `_ provided by Mozilla.


Updating the Certificate Bundle


The bundle is embedded into the app and can be updated along with the app by an OTA update. If you want to include a more up-to-date bundle than"
" the bundle currently included in ESP-IDF, then the certificate list can be downloaded from Mozilla as described in :ref:`updating_bundle`.


Periodic Sync


The bundle is kept updated by periodic sync with the Mozilla's NSS root certificate store. The deprecated certs from the upstream bundle are added to deprecated list (for compatibility reasons) in ESP-IDF minor or patch release. If required, the deprecated certs can be added to the default bundle by enabling :ref:`CONFIG_MBEDTLS_CERTIFICATE"
"_BUNDLE_DEPRECATED_LIST`. The deprecated certs shall be removed (reset) on the next major ESP-IDF release.

Application Examples


Simple HTTPS example that uses ESP-TLS to establish a secure socket connection using the certificate bundle with two custom certificates added for verification: :example:`protocols/https_x509_bundle`.

HTTPS example that uses ESP-TLS and the default bundle: :example:`protocols/https_request`.

HTTPS example that uses mbedTLS and the default bundle: :example:`protocol"
"s/https_mbedtls`.

API Reference


.. include-build-file:: inc/esp_crt_bundle.inc
"
"Mbed TLS




`Mbed TLS `_ is a C library that implements cryptographic primitives, X.509 certificate manipulation and the SSL/TLS and DTLS protocols. Its small code footprint makes it suitable for embedded systems.

.. note::

    ESP-IDF uses a `fork `_ of Mbed TLS which includes a few patches (related to hardware routines of certain modules like ``bignum (MPI)`` and ``ECC``) over vanilla Mbed TLS.

Mbed TLS supports SSL 3.0 up to TLS 1.3 and DTLS 1.0 to 1.2 communication by providing the follo"
"wing:

- TCP/IP communication functions: listen, connect, accept, read/write.
- SSL/TLS communication functions: init, handshake, read/write.
- X.509 functions: CRT, CRL and key handling
- Random number generation
- Hashing
- Encryption/decryption

Supported TLS versions include SSL 3.0, TLS 1.0, TLS 1.1, TLS 1.2, and TLS 1.3, but on the latest ESP-IDF, SSL 3.0, TLS 1.0, and TLS 1.1 have been removed from Mbed TLS. Supported DTLS versions include DTLS 1.0, DTLS 1.1, and DTLS 1.2, but on the late"
"st ESP-IDF, DTLS 1.0 has been removed from Mbed TLS.


Mbed TLS Documentation


For Mbed TLS documentation please refer to the following (upstream) pointers:

- `API Reference`_
- `Knowledge Base`_

Mbed TLS Support in ESP-IDF


Please find the information about the Mbed TLS versions presented in different branches of ESP-IDF `here `__.

.. note::

    Please refer the :ref:`migration_guide_mbedtls` to migrate from Mbed TLS version 2.x to version 3.0 or greater.

Application Examples


Examples "
"in ESP-IDF use :doc:`/api-reference/protocols/esp_tls` which provides a simplified API interface for accessing the commonly used TLS functionality.

Refer to the examples :example:`protocols/https_server/simple` (Simple HTTPS server) and :example:`protocols/https_request` (Make HTTPS requests) for more information.

If the Mbed TLS API is to be used directly, refer to the example :example:`protocols/https_mbedtls`.


Alternatives


:doc:`/api-reference/protocols/esp_tls` acts as an abstraction l"
"ayer over the underlying SSL/TLS library and thus has an option to use Mbed TLS or wolfSSL as the underlying library. By default, only Mbed TLS is available and used in ESP-IDF whereas wolfSSL is available publicly at `` with the upstream submodule pointer.

Please refer to :ref:`ESP-TLS: Underlying SSL/TLS Library Options ` docs for more information on this and comparison of Mbed TLS and wolfSSL.


Important Config Options


Following is a brief list of important config options accessible at ``"
"Component Config -> mbedTLS``. The full list of config options can be found :ref:`here `.

.. list::

    - :ref:`CONFIG_MBEDTLS_SSL_PROTO_TLS1_2`: Support for TLS 1.2
    - :ref:`CONFIG_MBEDTLS_SSL_PROTO_TLS1_3`: Support for TLS 1.3
    - :ref:`CONFIG_MBEDTLS_CERTIFICATE_BUNDLE`: Support for trusted root certificate bundle (more about this: :doc:`/api-reference/protocols/esp_crt_bundle`)
    - :ref:`CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS`: Support for TLS Session Resumption: Client session t"
"ickets
    - :ref:`CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS`: Support for TLS Session Resumption: Server session tickets
    - :ref:`CONFIG_MBEDTLS_HARDWARE_SHA`: Support for hardware SHA acceleration
    :SOC_AES_SUPPORTED: - :ref:`CONFIG_MBEDTLS_HARDWARE_AES`: Support for hardware AES acceleration
    :SOC_MPI_SUPPORTED: - :ref:`CONFIG_MBEDTLS_HARDWARE_MPI`: Support for hardware MPI (bignum) acceleration
    :SOC_ECC_SUPPORTED: - :ref:`CONFIG_MBEDTLS_HARDWARE_ECC`: Support for hardware ECC ac"
"celeration

.. note::

    Mbed TLS v3.0.0 and later support only TLS 1.2 and TLS 1.3 (SSL 3.0, TLS 1.0, TLS 1.1, and DTLS 1.0 are not supported). The support for TLS 1.3 is experimental and only supports the client-side. More information about this can be found out `here `__.


Performance and Memory Tweaks


.. _reducing_ram_usage_mbedtls:

Reducing Heap Usage


The following table shows typical memory usage with different configs when the :example:`protocols/https_request` example (with Serve"
"r Validation enabled) was run with Mbed TLS as the SSL/TLS library.

.. list-table::
    :header-rows: 1
    :widths: 25 60 30
    :align: center
      - Related Configs
      - Heap Usage (approx.)
      - NA
      - 42196 B
      - :ref:`CONFIG_MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH`
      -  42120 B
      - :ref:`CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE`
      - 38533 B
      - :ref:`CONFIG_MBEDTLS_DYNAMIC_BUFFER`
        :ref:`CONFIG_MBEDTLS_DYNAMIC_FREE_CONFIG_DATA`
        :ref:`CONFIG_MBEDTLS"
"_DYNAMIC_FREE_CA_CERT`
      - 22013 B

.. note::

    These values are subject to change with change in configuration options and versions of Mbed TLS.


Reducing Binary Size


Under ``Component Config -> mbedTLS``, there are multiple Mbed TLS features which are enabled by default but can be disabled if not needed to save code size. More information can be about this can be found in :ref:`Minimizing Binary Size ` docs.


.. _`API Reference`: https://mbed-tls.readthedocs.io/projects/api/en/v3.4."
"1/
.. _`Knowledge Base`: https://mbed-tls.readthedocs.io/en/latest/kb/
"
"ESP-MQTT




Overview


ESP-MQTT is an implementation of `MQTT `__ protocol client, which is a lightweight publish/subscribe messaging protocol. Now ESP-MQTT supports `MQTT v5.0 `__.


Features



Application Examples


MQTT Message Retransmission


A new MQTT message is created by calling :cpp:func:`esp_mqtt_client_publish ` or its non blocking counterpart :cpp:func:`esp_mqtt_client_enqueue `.

Messages with QoS 0 is sent only once. QoS 1 and 2 have different behaviors since the protocol requir"
"es extra steps to complete the process.

The ESP-MQTT library opts to always retransmit unacknowledged QoS 1 and 2 publish messages to avoid losses in faulty connections, even though the MQTT specification requires the re-transmission only on reconnect with Clean Session flag been set to 0 (set :cpp:member:`disable_clean_session ` to true for this behavior).

QoS 1 and 2 messages that may need retransmission are always enqueued, but first transmission try occurs immediately if :cpp:func:`esp_mqt"
"t_client_publish ` is used. A transmission retry for unacknowledged messages will occur after :cpp:member:`message_retransmit_timeout `. After :ref:`CONFIG_MQTT_OUTBOX_EXPIRED_TIMEOUT_MS` messages will expire and be deleted. If :ref:`CONFIG_MQTT_REPORT_DELETED_MESSAGES` is set, an event will be sent to notify the user.

Configuration


The configuration is made by setting fields in :cpp:class:`esp_mqtt_client_config_t` struct. The configuration struct has the following sub structs to configure d"
"ifferent aspects of the client operation.

In the following sections, the most common aspects are detailed.

Broker



Broker address can be set by usage of :cpp:class:`address ` struct. The configuration can be made by usage of :cpp:member:`uri ` field or the combination of :cpp:member:`hostname `, :cpp:member:`transport ` and :cpp:member:`port `. Optionally, :cpp:member:`path ` could be set, this field is useful in WebSocket connections.

The :cpp:member:`uri ` field is used in the format ``sc"
"heme://hostname:port/path``.

-  Curently support ``mqtt``, ``mqtts``, ``ws``, ``wss`` schemes
-  MQTT over TCP samples:

   -  ``mqtt://mqtt.eclipseprojects.io``: MQTT over TCP, default port 1883
   -  ``mqtt://mqtt.eclipseprojects.io:1884``: MQTT over TCP, port 1884
   -  ``mqtt://username:password@mqtt.eclipseprojects.io:1884``: MQTT over TCP,
      port 1884, with username and password

-  MQTT over SSL samples:

   -  ``mqtts://mqtt.eclipseprojects.io``: MQTT over SSL, port 8883
   -  ``mqt"
"ts://mqtt.eclipseprojects.io:8884``: MQTT over SSL, port 8884

-  MQTT over WebSocket samples:

   -  ``ws://mqtt.eclipseprojects.io:80/mqtt``

-  MQTT over WebSocket Secure samples:

   -  ``wss://mqtt.eclipseprojects.io:443/mqtt``

-  Minimal configurations:

.. code-block:: c

    const esp_mqtt_client_config_t mqtt_cfg = {
        .broker.address.uri = ""mqtt://mqtt.eclipseprojects.io"",
    };
    esp_mqtt_client_handle_t client = esp_mqtt_client_init(&mqtt_cfg);
    esp_mqtt_client_register_"
"event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, client);
    esp_mqtt_client_start(client);

.. note::

   By default MQTT client uses event loop library to post related MQTT events (connected, subscribed, published, etc.).


For secure connections with TLS used, and to guarantee Broker's identity, the :cpp:class:`verification ` struct must be set.
The broker certificate may be set in PEM or DER format. To select DER, the equivalent :cpp:member:`certificate_len ` field must be set. Otherwise"
", a null-terminated string in PEM format should be provided to :cpp:member:`certificate ` field.

-  Get certificate from server, example: ``mqtt.eclipseprojects.io``
    .. code::

       openssl s_client -showcerts -connect mqtt.eclipseprojects.io:8883  /dev/null | openssl x509 -outform PEM > mqtt_eclipse_org.pem

-  Check the sample application: :example:`protocols/mqtt/ssl`
-  Configuration:

.. code:: c

    const esp_mqtt_client_config_t mqtt_cfg = {
        .broker = {
          .address."
"uri = ""mqtts://mqtt.eclipseprojects.io:8883"",
          .verification.certificate = (const char *)mqtt_eclipse_org_pem_start,
        },
    };

For details about other fields, please check the `API Reference`_ and :ref:`esp_tls_server_verification`.

Client Credentials


All client related credentials are under the :cpp:class:`credentials ` field.


It is possible to set authentication parameters through the :cpp:class:`authentication ` field. The client supports the following authentication me"
"thods:

Session


For MQTT session-related configurations, :cpp:class:`session ` fields should be used.


MQTT allows for a last will and testament (LWT) message to notify other clients when a client ungracefully disconnects. This is configured by the following fields in the :cpp:class:`last_will ` struct.

Change Settings in Project Configuration Menu


The settings for MQTT can be found using :code:`idf.py menuconfig`, under ``Component config`` > ``ESP-MQTT Configuration``.

The following set"
"tings are available:

- :ref:`CONFIG_MQTT_PROTOCOL_311`: enable 3.1.1 version of MQTT protocol

- :ref:`CONFIG_MQTT_TRANSPORT_SSL` and :ref:`CONFIG_MQTT_TRANSPORT_WEBSOCKET`: enable specific MQTT transport layer, such as SSL, WEBSOCKET, and WEBSOCKET_SECURE

- :ref:`CONFIG_MQTT_CUSTOM_OUTBOX`: disable default implementation of mqtt_outbox, so a specific implementation can be supplied


Events

The following events may be posted by the MQTT client:

API Reference


.. include-build-file:: inc/mqt"
"t_client.inc
"
"ESP SPI Slave HD (Half Duplex) Mode Protocol




.. only:: esp32

    .. warning::

        ESP32 does not support this feature.

.. _esp_spi_slave_caps:

SPI Slave Capabilities of Espressif Chips


++++++++++
|                  | ESP32 | ESP32-S2 | ESP32-C3 | ESP32-S3 | ESP32-C2 | ESP32-C6 | ESP32-H2 | ESP32-P4 |
++++++++++
| SPI Slave HD     | N     | Y (v2)   | Y (v2)   | Y (v2)   | Y (v2)   | Y (v2)   | Y (v2)   | Y (v2)   |
++++++++++
| Tohost intr      |       | N        | N        | N    "
"    | N        | N        | N        | N        |
++++++++++
| Frhost intr      |       | 2 \*     | 2 \*     | 2 \*     | 2 \*     | 2 \*     | 2 \*     | 2 \*     |
++++++++++
| TX DMA           |       | Y        | Y        | Y        | Y        | Y        | Y        | Y        |
++++++++++
| RX DMA           |       | Y        | Y        | Y        | Y        | Y        | Y        | Y        |
++++++++++
| Shared registers |       | 72       | 64       | 64       | 64       | 64       | 64  "
"     | 64       |
++++++++++

Introduction


In the half duplex mode, the master has to use the protocol defined by the slave to communicate with the slave. Each transaction may consist of the following phases (listed by the order they should exist):

- Command: 8-bit, master to slave

    This phase determines the rest phases of the transactions. See :ref:`spi_slave_hd_supported_cmds`.

- Address: 8-bit, master to slave, optional

    For some commands (WRBUF, RDBUF), this phase specifies the a"
"ddress of the shared register to write to/read from. For other commands with this phase, they are meaningless but still have to exist in the transaction.

.. only:: esp32s2

    - Dummy: 8-bit (for 1-bit mode) or 4-bit (for 2/4-bit mode), floating, optional

        This phase is the turnaround time between the master and the slave on the bus, and also provides enough time for the slave to prepare the data to send to the master.

.. only:: not esp32s2

    - Dummy: 8-bit, floating, optional

   "
"     This phase is the turnaround time between the master and the slave on the bus, and also provides enough time for the slave to prepare the data to send to the master.

- Data: variable length, the direction is also determined by the command.

    This may be a data OUT phase, in which the direction is slave to master, or a data IN phase, in which the direction is master to slave.

The **direction** means which side (master or slave) controls the MOSI, MISO, WP, and HD pins.

Data IO Modes


"
"In some IO modes, more data wires can be used to send the data. As a result, the SPI clock cycles required for the same amount of data will be less than in the 1-bit mode. For example, in QIO mode, address and data (IN and OUT) should be sent on all 4 data wires (MOSI, MISO, WP, and HD). Here are the modes supported by the ESP32-S2 SPI slave and the wire number (WN) used in corresponding modes.

++++++
| Mode  | Command WN | Address WN | Dummy cycles | Data WN |
++++++
| 1-bit | 1          | 1  "
"        | 1            | 1       |
++++++
| DOUT  | 1          | 1          | 4            | 2       |
++++++
| DIO   | 1          | 2          | 4            | 2       |
++++++
| QOUT  | 1          | 1          | 4            | 4       |
++++++
| QIO   | 1          | 4          | 4            | 4       |
++++++
| QPI   | 4          | 4          | 4            | 4       |
++++++

Normally, which mode is used is determined by the command sent by the master (See :ref:`spi_slave_hd_supported_cmds`)"
", except the QPI mode.

QPI Mode


The QPI mode is a special state of the SPI Slave. The master can send the ENQPI command to put the slave into the QPI mode state. In the QPI mode, the command is also sent in 4-bit, thus it is not compatible with the normal modes. The master should only send QPI commands when the slave is in QPI mode. To exit from the QPI mode, master can send the EXQPI command.

.. _spi_slave_hd_supported_cmds:

Supported Commands


.. note::
    The command name is in a maste"
"r-oriented direction. For example, WRBUF means master writes the buffer of slave.

++++++
| Name     | Description         | Command | Address  | Data                                                     |
++++++
| WRBUF    | Write buffer        | 0x01    | Buf addr | master to slave, no longer than buffer size              |
++++++
| RDBUF    | Read buffer         | 0x02    | Buf addr | slave to master, no longer than buffer size              |
++++++
| WRDMA    | Write DMA           | 0x03    |"
" 8 bits   | master to slave, no longer than length provided by slave |
++++++
| RDDMA    | Read DMA            | 0x04    | 8 bits   | slave to master, no longer than length provided by slave |
++++++
| SEG_DONE | Segments done       | 0x05    | -        | -                                                        |
++++++
| ENQPI    | Enter QPI mode      | 0x06    | -        | -                                                        |
++++++
| WR_DONE  | Write segments done | 0x07    | -        | "
"-                                                        |
++++++
| CMD8     | Interrupt           | 0x08    | -        | -                                                        |
++++++
| CMD9     | Interrupt           | 0x09    | -        | -                                                        |
++++++
| CMDA     | Interrupt           | 0x0A    | -        | -                                                        |
++++++
| EXQPI    | Exit QPI mode       | 0xDD    | -        | -           "
"                                             |
++++++

Moreover, WRBUF, RDBUF, WRDMA, and RDDMA commands have their 2-bit and 4-bit version. To do transactions in 2-bit or 4-bit mode, send the original command ORed by the corresponding command mask below. For example, command 0xA1 means WRBUF in QIO mode.

+++
| Mode  | Mask |
+++
| 1-bit | 0x00 |
+++
| DOUT  | 0x10 |
+++
| DIO   | 0x50 |
+++
| QOUT  | 0x20 |
+++
| QIO   | 0xA0 |
+++
| QPI   | 0xA0 |
+++

Segment Transaction Mode


Segment trans"
"action mode is the only mode supported by the SPI Slave HD driver for now. In this mode, for a transaction the slave loads onto the DMA, the master is allowed to read or write in segments. In this way, the master does not have to prepare a large buffer as the size of data provided by the slave. After the master finishes reading/writing a buffer, it has to send the corresponding termination command to the slave as a synchronization signal. The slave driver will update new data (if exist) onto the"
" DMA upon seeing the termination command.

The termination command is WR_DONE (0x07) for WRDMA and CMD8 (0x08) for RDDMA.

Here is an example for the flow the master read data from the slave DMA:
"
".. _visualgdb:

VisualGDB
#########

What Is VisualGDB?
~~~~~~~~~~~~~~~~~~

`VisualGDB `__ is a powerful extension for Microsoft Visual Studio that provides advanced development tools and features for embedded systems, including support for the ESP-IDF framework. VisualGDB allows you to leverage the familiar and feature-rich Visual Studio environment for your ESP-IDF projects, enabling efficient coding, debugging, and deployment.

Installation
~~~~~~~~~~~~

Please download and install VisualGDB "
"by following the steps stated in `VisualGDB download and installation `__.


Configuration
~~~~~~~~~~~~~

`Creating Advanced ESP32 Projects with ESP-IDF `__ provide basic steps about how to configure an ESP-IDF project in VisualGDB.

You can also refer to `Advanced ESP-IDF Project Structure `__ to get a more comprehensive impression for developing ESP-IDF projects using VisualGDB.

Resources
~~~~~~~~~

For more information about VisualGDB and ESP-IDF integration, refer to the following resources"
":

- `VisualGDB Documentation `__: The official documentation for VisualGDB provides comprehensive guides and tutorials on using VisualGDB with ESP-IDF.
"
".. _clion:

CLion
#####

What Is CLion?
~~~~~~~~~~~~~~

`CLion `__ is a cross-platform integrated Development Environment (IDE) for C and C++ programming. CLion also provides dedicated support for ESP-IDF, allowing developers to seamlessly work with the ESP-IDF framework.

Installation
~~~~~~~~~~~~

To install CLion, please follow the instructions provided in `Install CLion `__ for your operating system (Windows, macOS, or Linux).

Configuration
~~~~~~~~~~~~~

To configure an ESP-IDF project in "
"CLion, please refer to the guide on `Configure an ESP CMake project in CLion `__. This guide will walk you through the necessary steps to set up your project properly.

Resources
~~~~~~~~~

For more information about CLion and ESP-IDF integration, please refer to the following resource:

- `CLion Documentation `__: The official documentation for CLion provides detailed information on various aspects of the IDE, including ESP-IDF integration.
"
".. _platformio:

PlatformIO
##########



.. image:: ../../_static/platformio-logo.png
  :target: https://platformio.org/?utm_source=docs.espressif.com

.. contents::
    :local:

What Is PlatformIO?
~~~~~~~~~~~~~~~~~~~

`PlatformIO `__
is a cross-platform embedded development environment with out-of-the-box support
for ESP-IDF.

Since ESP-IDF support within PlatformIO is not maintained by the Espressif team, please report any issues with PlatformIO directly to its developers in `the official Pl"
"atformIO repositories `_.

A detailed overview of the PlatformIO ecosystem and its philosophy can be found in `the official PlatformIO documentation `_.

Installation
~~~~~~~~~~~~
  services

Configuration
~~~~~~~~~~~~~

Please go through `the official PlatformIO configuration guide for ESP-IDF `_.

Tutorials
~~~~~~~~~

- `ESP-IDF and ESP32-DevKitC: debugging, unit testing, project analysis `__

Project Examples
~~~~~~~~~~~~~~~~

Please check ESP-IDF page in `the official PlatformIO documentatio"
"n `__

Next Steps
~~~~~~~~~~

Here are some useful links for exploring the PlatformIO ecosystem:

- Learn more about `integrations with other IDEs or Text Editors `_
- Get help from `PlatformIO community `_
"
"Contributions Guide




We welcome contributions to the ESP-IDF project!

How to Contribute


Contributions to ESP-IDF - fixing bugs, adding features, adding documentation - are welcome. We accept contributions via `Github Pull Requests `_.

Before Contributing


Before sending us a Pull Request, please consider this list of points:

Pull Request Process


After you open the Pull Request, there will probably be some discussion in the comments field of the request itself.

Once the Pull Request i"
"s ready to merge, it will first be merged into our internal git system for in-house automated testing.

If this process passes, it will be merged into the public GitHub repository.

Legal Part


Before a contribution can be accepted, you will need to sign our :doc:`contributor-agreement`. You will be prompted for this automatically as part of the Pull Request process.

Related Documents


.. toctree::
    :maxdepth: 1

    style-guide
    install-pre-commit-hook
    documenting-code
    creating"
"-examples
    ../api-reference/template
    contributor-agreement
    copyright-guide
    esp-idf-tests-with-pytest
"
"Documenting Code




The purpose of this description is to provide a quick summary of the documentation style used in `espressif/esp-idf`_ repository and how to add new documentation.

Introduction


When documenting code for this repository, please follow `Doxygen style `_. You are doing it by inserting special commands, for instance ``@param``, into standard comments blocks, for example: ::

    /**
     */

Doxygen can phrase the code, extract the commands together with subsequent text, and b"
"uild documentation out of it.

Typical comment block, that contains documentation of a function, looks like below:

.. image:: ../../_static/doc-code-documentation-inline.png
    :align: center
    :alt: Sample inline code documentation

Doxygen supports a couple of formatting styles. It also gives you great flexibility on the level of details to include in documentation. To get familiar with available features, please check data-rich and very well-organized `Doxygen Manual `_.


Why We Need Dox"
"ygen?


The ultimate goal is to ensure that all the code is consistently documented, so we can use tools like `Sphinx`_ and `Breathe`_ to aid preparation and automatic updates of API documentation when the code changes.

With these tools, the above piece of code renders like below:

.. image:: ../../_static/doc-code-documentation-rendered.png
    :align: center
    :alt: Sample inline code after rendering


Go for It!


When writing code for this repository, please follow guidelines below:

    "
".. image:: ../../_static/doc-code-function.png
        :align: center
        :alt: Sample function documented inline and after rendering

    .. image:: ../../_static/doc-code-void-function.png
        :align: center
        :alt: Sample void function documented inline and after rendering

    .. image:: ../../_static/doc-code-member.png
        :align: center
        :alt: Sample of member documentation inline and after rendering


Go One Extra Mile


Here are a couple of tips on how you can m"
"ake your documentation even better and more useful to the reader and writer.

When writing code, please follow the guidelines below:

    /**@{*/
    /**
    void  first_similar_function (void);
    void second_similar_function (void);
    /**@}*/

   For practical example see :component_file:`nvs_flash/include/nvs.h`.

    Code snippets, notes, links, etc., will not make it to the documentation, if not enclosed in a comment block associated with one of the documented objects.

Standardize Docum"
"ent Format


When it comes to text, please follow guidelines below to provide well-formatted Markdown (.md) or reST (.rst) documents.

    .. figure:: ../../_static/doc-format1-recommend.png
        :align: center
        :scale: 20%
        :alt: One line for one paragraph - recommend (click to enlarge)

        One line for one paragraph (click to enlarge)

    .. figure:: ../../_static/doc-format2-notrecommend.png
        :align: center
        :scale: 20%
        :alt: One line for one parag"
"raph - not recommend (click to enlarge)

        No line breaks within the same paragraph (click to enlarge)

    .. figure:: ../../_static/doc-format3-recommend.png
        :align: center
        :scale: 40%
        :alt: Keep the line number for EN and CN files consistent (click to enlarge)

        Keep the line number for EN and CN documents consistent (click to enlarge)

Building Documentation


The documentation is built with the `esp-docs` Python package, which is a wrapper around `Sphinx"
" `_.

To install it simply do::

    pip install esp-docs

After a successful install then the documentation can be built from the docs folder with::

    build-docs build

or for specific target and language with::

    build-docs -t esp32 -l en build

For more in-depth documentation about `esp-docs` features please see the documentation at `esp-docs `_.

Wrap Up


We love good code that is doing cool things. We love it even better, if it is well-documented, so we can quickly make it run and al"
"so do the cool things.

Go ahead, contribute your code and documentation!

Related Documents



.. _espressif/esp-idf: https://github.com/espressif/esp-idf/

.. _interactive shell: http://interactive.blockdiag.com/?compression=deflate&src=eJxlUMFOwzAMvecrrO3aITYQQirlAIIzEseJQ5q4TUSIq8TVGIh_J2m7jbKc7Ge_5_dSO1Lv2soWvoVYgieNoMh7VGzJR9FJtugZ7lYQ0UcKEbYNOY36rRQHZHUPT68vV5tceGLbWCUzPfeaFFMoBZzecVc56vWwJFnWMmJ59CCZg617xpOFbTSyw0pmvT_HJ7hxtFNGBr6wvuu5SCkchcrZ1vAeXZomznh5YgTqfcpR02cBO6vZVDeXBRjMjKEcFRbLh"
"8f18-Z2UUBDnqP9wmp9ncRmSSfND2ldGo2h_zse407g0Mxc1q7HzJ3-4jzYYTJjtQH3iSV-fgFzx50J

.. _Breathe: https://breathe.readthedocs.io/en/latest/
"
"Copyright Header Guide




ESP-IDF is released under :project_file:`the Apache License 2.0 ` with some additional third-party copyrighted code released under various licenses. For further information please refer to :doc:`the list of copyrights and licenses `.

This page explains how the source code should be properly marked with a copyright header. ESP-IDF uses the `Software Package Data Exchange (SPDX) `_ format which is short and can be easily read by humans or processed by automated tools fo"
"r copyright checks.

How to Check the Copyright Headers


Please make sure you have installed the :doc:`pre-commit hooks ` which contain a copyright header checker as well. The checker can suggest a header if it is not able to detect a properly formatted SPDX header.

What If the Checker's Suggestion Is Incorrect?


No automated checker (no matter how good is) can replace humans. So the developer's responsibility is to modify the offered header to be in line with the law and the license restrict"
"ions of the original code on which the work is based on. Certain licenses are not compatible between each other. Such corner cases will be covered by the following examples.

The checker can be configured with the ``tools/ci/check_copyright_config.yaml`` configuration file. Please check the options it offers and consider updating it in order to match the headers correctly.

Common Examples of Copyright Headers


The simplest case is when the code is not based on any licensed previous work, e.g.,"
" it was written completely from scratch. Such code can be decorated with the following copyright header and put under the license of ESP-IDF::

    /*
     */

Less Restrictive Parts of ESP-IDF
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some parts of ESP-IDF are deliberately under less restrictive licenses in order to ease their re-use in commercial closed source projects. This is the case for :project:`ESP-IDF examples ` which are in Public domain or under the Creative Commons Zero Universal (CC0) lice"
"nse. The following header can be used in such source files::

    /*
     */

The option allowing multiple licenses joined with the ``OR`` keyword from the above example can be achieved with the definition of multiple allowed licenses in the ``tools/ci/check_copyright_config.yaml`` configuration file. Please use this option with care and only selectively for a limited part of ESP-IDF.

Third Party Licenses
~~~~~~~~~~~~~~~~~~~~

Code licensed under different licenses, modified by Espressif System"
"s and included in ESP-IDF cannot be licensed under Apache License 2.0 not even if the checker suggests it. It is advised to keep the original copyright header and add an SPDX before it.

The following example is a suitable header for a code licensed under the ""GNU General Public License v2.0 or later"" held by John Doe with some additional modifications done by Espressif Systems::

    /*
     */

The licenses can be identified and the short SPDX identifiers can be found in the official `SPDX lic"
"ense list`_. Other very common licenses are the GPL-2.0-only, the BSD-3-Clause, and the BSD-2-Clause.

In exceptional case, when a license is not present on the `SPDX license list`_, it can be expressed by using the `LicenseRef-[idString]`_ custom license identifier, for example ``LicenseRef-Special-License``. The full license text must be added into the ``LICENSES`` directory under ``Special-License`` filename. ::

    /*
     */

Dedicated ``LicenseRef-Included`` custom license identifier can "
"be used to express a situation when the custom license is included directly in the source file. ::

    /*
     */

The configuration stored in ``tools/ci/check_copyright_config.yaml`` offers features useful for third party licenses:

.. _SPDX license list: https://spdx.org/licenses
.. _LicenseRef-[idString]: https://spdx.github.io/spdx-spec/v2.3/other-licensing-information-detected/#101-license-identifier-field
"
"Install Pre-commit Hook for ESP-IDF Project




Required Dependency


Python 3.8.* or above. This is our recommended Python version for ESP-IDF developers.

If you still have Python versions not compatible, update your Python versions before installing the pre-commit hook.

Install ``pre-commit``


Run ``pip install pre-commit``

Install ``pre-commit`` Hook


Uninstall ``pre-commit`` Hook


Run ``pre-commit uninstall``

What Is More?


For detailed usage, please refer to the documentation of pre"
"-commit_.

.. _pre-commit: https://pre-commit.com/

Common Problems For Windows Users


``/usr/bin/env: python: Permission denied.``

   If you are in Git Bash, please check the python executable location by run ``which python``.

   If the executable is under ``~/AppData/Local/Microsoft/WindowsApps/``, then it is a link to Windows AppStore, not a real one.

   Please install Python manually and update this in your ``PATH`` environment variable.


Your ``USERPROFILE`` contains non-ASCII characte"
"rs

   ``pre-commit`` may fail when initializing an environment for a particular hook when the path of ``pre-commit``'s cache contains non-ASCII characters. The solution is to set ``PRE_COMMIT_HOME`` to a path containing only standard characters before running pre-commit.

   - CMD: ``set PRE_COMMIT_HOME=C:\somepath\pre-commit``
   - PowerShell: ``$Env:PRE_COMMIT_HOME = ""C:\somepath\pre-commit""``
   - git bash: ``export PRE_COMMIT_HOME=""/c/somepath/pre-commit""``
"
"Contributor Agreement




Individual Contributor Non-Exclusive License Agreement Including the Traditional Patent License OPTION


Thank you for your interest in contributing to this Espressif project hosted on GitHub (""We"" or ""Us"").

The purpose of this contributor agreement (""Agreement"") is to clarify and document the rights granted by contributors to Us. To make this document effective, please follow the instructions in the :doc:`index`.
~~~~~~~~~~~~~~

**You** means the Individual Copyright "
"owner who submits a Contribution to Us. If You are an employee and submit the Contribution as part of your employment, You must have had Your employer approve this Agreement or sign the Entity version of this Agreement.

**Contribution** means any original work of authorship (software and/or documentation) including any modifications or additions to an existing work, Submitted by You to Us, in which You own the Copyright. If You do not own the Copyright in the entire work of authorship, please c"
"ontact Us by submitting a comment on GitHub.

**Copyright** means all rights protecting works of authorship owned or controlled by You, including copyright, moral and neighboring rights, as appropriate, for the full term of their existence including any extensions by You.

**Material** means the software or documentation made available by Us to third parties. When this Agreement covers more than one software project, the Material means the software or documentation to which the Contribution was "
"Submitted. After You Submit the Contribution, it may be included in the Material.

**Submit** means any form of physical, electronic, or written communication sent to Us, including but not limited to electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Us, but excluding communication that is conspicuously marked or otherwise designated in writing by You as ""Not a Contribution.""

**Submission Date** means the date You Submit a Con"
"tribution to Us.

**Documentation** means any non-software portion of a Contribution.
~~~~~~~~~~~~~~~~~~~~

2.1 Grant of Copyright License to Us

Subject to the terms and conditions of this Agreement, You hereby grant to Us a worldwide, royalty-free, NON-exclusive, perpetual and irrevocable license, with the right to transfer an unlimited number of non-exclusive licenses or to grant sublicenses to third parties, under the Copyright covering the Contribution to use the Contribution by all means, "
"including, but not limited to:

-  to publish the Contribution
-  to modify the Contribution, to prepare derivative works based upon or containing the Contribution and to combine the Contribution with other software code
-  to reproduce the Contribution in original or modified form
-  to distribute, to make the Contribution available to the public, display and publicly perform the Contribution in original or modified form

2.2 Moral Rights remain unaffected to the extent they are recognized and "
"not waivable by applicable law. Notwithstanding, You may add your name in the header of the source code files of Your Contribution and We will respect this attribution when using Your Contribution.
~~~~~~~~~~~~~~~~~

3.1 Grant of Patent License to US

Subject to the terms and conditions of this Agreement, You hereby grant to Us a worldwide, royalty-free, non-exclusive, perpetual and irrevocable (except as stated in Section 3.2) patent license, with the right to transfer an unlimited number of no"
"n-exclusive licenses or to grant sublicenses to third parties, to make, have made, use, sell, offer for sale, import and otherwise transfer the Contribution and the Contribution in combination with the Material (and portions of such combination). This license applies to all patents owned or controlled by You, whether already acquired or hereafter acquired, that would be infringed by making, having made, using, selling, offering for sale, importing or otherwise transferring of Your Contribution(s"
") alone or by combination of Your Contribution(s) with the Material.

3.2 Revocation of Patent License

You reserve the right to revoke the patent license stated in section 3.1 if We make any infringement claim that is targeted at your Contribution and not asserted for a Defensive Purpose. An assertion of claims of the Patents shall be considered for a ""Defensive Purpose"" if the claims are asserted against an entity that has filed, maintained, threatened, or voluntarily participated in a patent "
"infringement lawsuit against Us or any of Our licensees.
~~~~~~~~~~~~~

THE CONTRIBUTION IS PROVIDED ""AS IS"". MORE PARTICULARLY, ALL EXPRESSED OR IMPLIED WARRANTIES INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE EXPRESSLY DISCLAIMED BY YOU TO US AND BY US TO YOU. TO THE EXTENT THAT ANY SUCH WARRANTIES CANNOT BE DISCLAIMED, SUCH WARRANTY IS LIMITED IN DURATION TO THE MINIMUM PERIOD PERMITTED BY LAW.
~~~~~~~~~~~~~~~"
"~~~~~~~~~~~~~~~

TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT WILL YOU OR US BE LIABLE FOR ANY LOSS OF PROFITS, LOSS OF ANTICIPATED SAVINGS, LOSS OF DATA, INDIRECT, SPECIAL, INCIDENTAL, CONSEQUENTIAL AND EXEMPLARY DAMAGES ARISING OUT OF THIS AGREEMENT REGARDLESS OF THE LEGAL OR EQUITABLE THEORY (CONTRACT, TORT OR OTHERWISE) UPON WHICH THE CLAIM IS BASED.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IF THE DISCLAIMER AND DAMAGE WAIVER MENTIONED IN SECTION 4 AND SECTION 5 CA"
"NNOT BE GIVEN LEGAL EFFECT UNDER APPLICABLE LOCAL LAW, REVIEWING COURTS SHALL APPLY LOCAL LAW THAT MOST CLOSELY APPROXIMATES AN ABSOLUTE WAIVER OF ALL CIVIL LIABILITY IN CONNECTION WITH THE CONTRIBUTION.
~~~~~~~

7.1 This Agreement shall come into effect upon Your acceptance of the terms and conditions.

7.2 In the event of a termination of this Agreement, sections 4, 5, 6, 7 and 8 shall survive such termination and shall remain in full force thereafter. For the avoidance of doubt, Contributions"
" that are already licensed under a free and open source license at the date of the termination shall remain in full force after the termination of this Agreement.
~~~~~~~~~~~~~~~~

8.1 This Agreement and all disputes, claims, actions, suits or other proceedings arising out of this agreement or relating in any way to it shall be governed by the laws of People's Republic of China excluding its private international law provisions.

8.2 This Agreement sets out the entire agreement between You and U"
"s for Your Contributions to Us and overrides all other agreements or understandings.

8.3 If any provision of this Agreement is found void and unenforceable, such provision will be replaced to the extent possible with a provision that comes closest to the meaning of the original provision and that is enforceable. The terms and conditions set forth in this Agreement shall apply notwithstanding any failure of essential purpose of this Agreement or any limited remedy to the maximum extent possible "
"under law.

8.4 You agree to notify Us of any facts or circumstances of which you become aware that would make this Agreement inaccurate in any respect.

.. rubric:: You
   :name: you

+++
| Date       |    |
+++
| Name       |    |
+++
| Title      |    |
+++
| Address    |    |
+++

.. rubric:: Us
   :name: us

+++
| Date       |    |
+++
| Name       |    |
+++
| Title      |    |
+++
| Address    |    |
+++

"
"Creating Examples




Each ESP-IDF example is a complete project that someone else can copy and adapt the code to solve their own problem. Examples should demonstrate ESP-IDF functionality, while keeping this purpose in mind.

Structure


- The ``main`` directory should contain a source file named ``(something)_example_main.c`` with the main functionality.
- If the example has additional functionality, split it logically into separate C or C++ source files under ``main`` and place a correspondin"
"g header file in the same directory.
- If the example has a lot of additional functionality, consider adding a ``components`` directory to the example project and make some example-specific components with library functionality. Only do this if the components are specific to the example, if they are generic or common functionality then they should be added to ESP-IDF itself.
- The example should have a ``README.md`` file. Use the :idf_file:`template example README ` and adapt it for your particu"
"lar example.
- Examples should have a ``pytest_.py`` file for running an automated example test. If submitting a GitHub Pull Request which includes an example, it is OK not to include this file initially. The details can be discussed as part of the `Pull Request `_. Please refer to :doc:`IDF Tests with Pytest Guide ` for details.

General Guidelines


Example code should follow the :doc:`style-guide`.

Checklist


Checklist before submitting a new example:
"
"


ESP-IDF provides a variety of testing mechanisms that runs directly on target ESP chips (referred to as **target test**). These target tests are typically integrated into an ESP-IDF project specifically designed for testing purposes (known as a **test app**). Similar to standard ESP-IDF projects, test apps follow the same build, flash, and monitoring procedures.

In target testing, a connected host (for instance, a PC) is typically required to trigger specific test cases, provide test data, a"
"nd evaluate test results.

On the host side, ESP-IDF employs the pytest framework (alongside certain pytest plugins) to automate target testing. This guide delves into pytest in ESP-IDF, covering the following aspects:

.. note::

  In ESP-IDF, we use the following pytest plugins by default:

  - `pytest-embedded `__ with default services ``esp,idf``
  - `pytest-rerunfailures `__
  - `pytest-ignore-test-results `__

  All the concepts and usages introduced in this guide are based on the default "
"behavior of these plugins, thus may not be available in vanilla pytest.

.. important::

  This guide specifically targets ESP-IDF contributors. Some of the concepts, like the custom markers, may not be directly applicable to personal projects using the ESP-IDF SDK. For running pytest-embedded in personal projects, please refer to `pytest-embedded documentation `__, and explore the `provided examples `__.

Installation


All dependencies could be installed by running the install script with the "
"``--enable-pytest`` argument:

.. code-block:: bash

  $ install.sh --enable-pytest

We have implemented several mechanisms to ensure the successful execution of all installation processes. If you encounter any issues during the installation, please submit an issue report to our `GitHub issue tracker `__.

Common Concepts


A **test app** is a set of binaries which is being built from an IDF project that is used to test a particular feature of your project. Test apps are usually located under ``"
"${IDF_PATH}/examples``, ``${IDF_PATH}/tools/test_apps``, and ``${IDF_PATH}/components//test_apps``.

A **Device under test (DUT)** is a set of ESP chip(s) which connect to a host (e.g., a PC). The host is responsible for flashing the apps to the DUT, triggering the test cases, and inspecting the test results.

A typical ESP-IDF project that contains a pytest script will have the following structure:

.. code-block:: text

  .
  └── my_app/
      ├── main/
      │   └── ...
      ├── CMakeLists.t"
"xt
      └── pytest_foo.py

Sometimes, for some multi-dut tests, one test case requires multiple test apps. In this case, the test app folder structure would be like this:

.. code-block:: text

  .
  ├── my_app_foo/
  │   ├── main/
  │   │   └── ...
  │   └── CMakeLists.txt
  ├── my_app_bar/
  │   ├── main/
  │   │   └── ...
  │   └── CMakeLists.txt
  └── pytest_foo_bar.py

pytest in ESP-IDF


Single DUT Test Cases


Getting Started


.. code-block:: python

  @pytest.mark.esp32
  @pytest.mark."
"esp32s2
  @pytest.mark.generic
  def test_hello_world(dut) -> None:
      dut.expect('Hello world!')

This is a simple test script that could run with our getting-started example :example:`get-started/hello_world`.

First two lines are the target markers:

.. note::

  If the test case can be run on all targets officially supported by ESP-IDF (call ``idf.py --list-targets`` for more details), you can use a special marker ``supported_targets`` to apply all of them in one line.

  We also supports"
" ``preview_targets`` and ``all_targets`` as special target markers (call ``idf.py --list-targets --preview`` for a full targets list including preview targets).

Next, we have the environment marker:

.. note::

  For the detailed explanation of the environment markers, please refer to :idf_file:`ENV_MARKERS definition `

Finally, we have the test function. With a ``dut`` fixture. In single-dut test cases, the ``dut`` fixture is an instance of ``IdfDut`` class, for multi-dut test cases, it is a "
"tuple of ``IdfDut`` instances. For more details regarding the ``IdfDut`` class, please refer to `pytest-embedded IdfDut API reference `__.

Same App with Different sdkconfig Files


For some test cases, you may need to run the same app with different sdkconfig files. For detailed documentation regarding sdkconfig related concepts, please refer to `idf-build-apps Documentation `__.

Here's a simple example that demonstrates how to run the same app with different sdkconfig files. Assume we have th"
"e following folder structure:

.. code-block:: text

  .
  └── my_app/
      ├── main/
      │   └── ...
      ├── CMakeLists.txt
      ├── sdkconfig.ci.foo
      ├── sdkconfig.ci.bar
      └── pytest_foo.py

If the test case needs to run all supported targets with these two sdkconfig files, you can use the following code:

.. code-block:: python

  @pytest.mark.esp32
  @pytest.mark.esp32s2
  @pytest.mark.parametrize('config', [    #  None:
      if config == 'foo':
        dut.expect('This is f"
"rom sdkconfig.ci.foo')
      elif config == 'bar':
        dut.expect('This is from sdkconfig.ci.bar')

All markers will impact the test case simultaneously. Overall, this test function would be replicated to 4 test cases:

- ``test_foo_bar``, with esp32 target, and sdkconfig.ci.foo as the sdkconfig file
- ``test_foo_bar``, with esp32 target, and sdkconfig.ci.bar as the sdkconfig file
- ``test_foo_bar``, with esp32s2 target, and sdkconfig.ci.foo as the sdkconfig file
- ``test_foo_bar``, with esp"
"32s2 target, and sdkconfig.ci.bar as the sdkconfig file

Sometimes in the test script or the log file, you may see the following format:

- ``esp32.foo.test_foo_bar``
- ``esp32.bar.test_foo_bar``
- ``esp32s2.foo.test_foo_bar``
- ``esp32s2.bar.test_foo_bar``

We call this format the **test case ID**. The test case ID should be considered as the unique identifier of a test case. It is composed of the following parts:

- ``esp32``: the target name
- ``foo``: the config name
- ``test_foo_bar``: the "
"test function name

The test case ID is used to identify the test case in the JUnit report.

.. note::

  Nearly all the CLI options of pytest-embedded supports parameterization. To see all supported CLI options, you may run ``pytest --help`` and check the ``embedded-...`` sections for vanilla pytest-embedded ones, and the ``idf`` sections for ESP-IDF specific ones.

.. note::

  The target markers, like ``@pytest.mark.esp32`` and ``@pytest.mark.esp32s2``, are actually syntactic sugar for parame"
"terization. In fact they are defined as:

  .. code-block:: python

    @pytest.mark.parametrize('target', [
        'esp32',
        'esp32s2',
    ], indirect=True)

Same App with Different sdkconfig Files, Different Targets


For some test cases, you may need to run the same app with different sdkconfig files. These sdkconfig files supports different targets. We may use ``pytest.param`` to achieve this. Let's use the same folder structure as above.

.. code-block:: python

  @pytest.mark.para"
"metrize('config', [
      pytest.param('foo', marks=[pytest.mark.esp32]),
      pytest.param('bar', marks=[pytest.mark.esp32s2]),
  ], indirect=True)

Now this test function would be replicated to 2 test cases (represented as test case IDs):

Testing Serial Output (Expecting)


To ensure that test has executed successfully on target, the test script can test that serial output of the target using the ``dut.expect()`` function, for example:

.. code-block:: python

  def test_hello_world(dut) -> "
"None:
      dut.expect('\d+')  # `__.

Multi-DUT Test Cases


Multi-Target Tests with the Same App


In some cases a test may involve multiple targets running the same test app. Parametrize ``count`` to the number of DUTs you want to test with.

.. code-block:: python

  @pytest.mark.parametrize('count', [
      2,
  ], indirect=True)
  @pytest.mark.parametrize('target', [
    'esp32|esp32s2',
    'esp32s3',
  ], indirect=True)
  def test_hello_world(dut) -> None:
      dut[0].expect('Hello worl"
"d!')
      dut[1].expect('Hello world!')

The ``|`` symbol in all parametrized items is used for separating the settings for each DUT. In this example, the test case would be tested with:

After setting the param ``count`` to 2, all the fixtures are changed into tuples.

.. important::

  ``count`` is mandatory for multi-DUT tests.

.. note::

  For detailed multi-dut parametrization documentation, please refer to `pytest-embedded Multi-DUT documentation `__.

.. warning::

  In some test script"
"s, you may see target markers like ``@pytest.mark.esp32`` and ``@pytest.mark.esp32s2`` used together with multi-DUT test cases. This is deprecated and should be replaced with the ``target`` parametrization.

  For example,

  .. code-block:: python

    @pytest.mark.esp32
    @pytest.mark.esp32s2
    @pytest.mark.parametrize('count', [
        2,
    ], indirect=True)
    def test_hello_world(dut) -> None:
        dut[0].expect('Hello world!')
        dut[1].expect('Hello world!')

  should be r"
"eplaced with:

  .. code-block:: python

    @pytest.mark.parametrize('count', [
        2,
    ], indirect=True)
    @pytest.mark.parametrize('target', [
        'esp32',
        'esp32s2',
    ], indirect=True)
    def test_hello_world(dut) -> None:
        dut[0].expect('Hello world!')
        dut[1].expect('Hello world!')

  This could help avoid the ambiguity of the target markers when multi-DUT test cases are using different type of targets.

Multi-Target Tests with Different Apps


In som"
"e cases, a test may involve multiple targets running different test apps (e.g., separate targets to act as master and slave). Usually in ESP-IDF, the folder structure would be like this:

.. code-block:: text

  .
  ├── master/
  │   ├── main/
  │   │   └── ...
  │   └── CMakeLists.txt
  ├── slave/
  │   ├── main/
  │   │   └── ...
  │   └── CMakeLists.txt
  └── pytest_master_slave.py

In this case, we can parametrize the ``app_path`` to the path of the test apps you want to test with.

.. code-"
"block:: python

    @pytest.mark.multi_dut_generic
    @pytest.mark.parametrize('count', [
        2,
    ], indirect=True)
    @pytest.mark.parametrize('app_path, target', [
        (f'{os.path.join(os.path.dirname(__file__), ""master"")}|{os.path.join(os.path.dirname(__file__), ""slave"")}', 'esp32|esp32s2'),
        (f'{os.path.join(os.path.dirname(__file__), ""master"")}|{os.path.join(os.path.dirname(__file__), ""slave"")}', 'esp32s2|esp32'),
    ], indirect=True)
    def test_master_slave(dut) -> N"
"one:
        master = dut[0]
        slave = dut[1]

        master.write('Hello world!')
        slave.expect_exact('Hello world!')

.. note::

  When parametrizing two items, like ``app_path, target`` here, make sure you're passing a list of tuples to the ``parametrize`` decorator. Each tuple should contain the values for each item.

The test case here will be replicated to 2 test cases:

Test Cases with Unity Test Framework


We use `Unity test framework `__ in our unit tests. Overall, we hav"
"e three types of test cases (`Unity test framework `__):

All single-DUT test cases (including normal test cases and multi-stage test cases) can be run using the following command:

.. code-block:: python

  def test_unity_single_dut(dut: IdfDut):
      dut.run_all_single_board_cases()

Using this command will skip all the test cases containing the ``[ignore]`` tag.

If you need to run a group of test cases, you may run:

.. code-block:: python

  def test_unity_single_dut(dut: IdfDut):
      du"
"t.run_all_single_board_cases(group='psram')

It would trigger all test cases with the ``[psram]`` tag.

.. warning::

  You may also see that there are some test scripts with the following statements, which are deprecated. Please use the suggested one as above.

  .. code-block:: python

    def test_unity_single_dut(dut: IdfDut):
        dut.expect_exact('Press ENTER to see the list of tests')
        dut.write('*')
        dut.expect_unity_test_output()

We also provide a fixture ``case_tester"
"`` to trigger all kinds of test cases easier. For example:

.. code-block:: python

  def test_unity_single_dut(case_tester):
      case_tester.run_all_normal_cases()       # to run all normal test cases
      case_tester.run_all_multi_dev_cases()    # to run all multi-device test cases
      case_tester.run_all_multi_stage_cases()  # to run all multi-stage test cases

For a full list of the available functions, please refer to `pytest-embedded case_tester API reference `__.

Running Target Test"
"s in CI


The workflow in CI is as follows:

.. blockdiag::
    :caption: Target Test Child Pipeline Workflow
    :align: center

    blockdiag child-pipeline-workflow {
        default_group_color = lightgray;

        group {
            label = ""build""

            build_test_related_apps; build_non_test_related_apps;
        }

        group {
            label = ""assign_test""

            build_job_report; generate_pytest_child_pipeline;
        }

        group {
            label = ""targe"
"t_test""

            ""Specific Target Test Jobs"";
        }

        group {
            label = "".post""

            target_test_report;
        }

        build_test_related_apps, build_non_test_related_apps -> generate_pytest_child_pipeline, build_job_report -> ""Specific Target Test Jobs"" -> target_test_report;
    }

All build jobs and target test jobs are generated automatically by our CI script :project:`tools/ci/dynamic_pipelines`.

Build Jobs


In CI, all ESP-IDF projects under ``compone"
"nts``, ``examples``, and ``tools/test_apps``, are built with all supported targets and sdkconfig files. The binaries are built under ``build__``. For example

.. code-block:: text

  .
  ├── build_esp32_history/
  │   └── ...
  ├── build_esp32_nohistory/
  │   └── ...
  ├── build_esp32s2_history/
  │   └── ...
  ├── ...
  ├── main/
  ├── CMakeLists.txt
  ├── sdkconfig.ci.history
  ├── sdkconfig.ci.nohistory
  └── ...

There are two types of build jobs, ``build_test_related_apps`` and ``build_non"
"_test_related_apps``.

For ``build_test_related_apps``, all the built binaries will be uploaded to our internal MinIO server. You may find the download link in the build report posted in the internal MR.

For ``build_non_test_related_apps``, all the built binaries will be removed after the build job is finished. Only the build log files will be uploaded to our internal MinIO server. You may also find the download link in the build report posted in the internal MR.

Target Test Jobs


In CI, all "
"generated target test jobs are named according to the pattern "" - "". For example, single-dut test job ``esp32 - generic``, or multi-dut test job ``esp32,esp32 - multi_dut_generic``.

The binaries in the target test jobs are downloaded from our internal MinIO servers. For most of the test cases, only the files that are required by flash (like .bin files, flash_args files, etc) would be downloaded. For some test cases, like jtag test cases, .elf files are also downloaded.

Running Tests Locally


"
"Installation


First you need to install ESP-IDF with additional Python requirements:

.. code-block:: shell

  $ cd $IDF_PATH
  $ bash install.sh --enable-ci --enable-pytest
  $ . ./export.sh

Build Directories


By default, each test case looks for the required binary files in the following directories (in order):

- ``build__``
- ``build_``
- ``build_``
- ``build``

As long as one of the above directories exists, the test case uses that directory to flash the binaries. If non of the above dir"
"ectories exists, the test case fails with an error.

Test Your Test Script


Single-DUT Test Cases with ``sdkconfig.defaults``


This is the simplest use case. Let's take :project:`examples/get-started/hello_world` as an example. Assume we're testing with a ESP32 board.

.. code-block:: shell

  $ cd $IDF_PATH/examples/get-started/hello_world
  $ idf.py set-target esp32 build
  $ pytest --target esp32

Single-DUT Test Cases with ``sdkconfig.ci.xxx``


Some test cases may need to run with differe"
"nt sdkconfig files. Let's take :project:`examples/system/console/basic` as an example. Assume we're testing with a ESP32 board, and test with ``sdkconfig.ci.history``.

.. code-block:: shell

  $ cd $IDF_PATH/examples/system/console/basic
  $ idf.py -DSDKCONFIG_DEFAULTS='sdkconfig.defaults;sdkconfig.ci.history' -B build_esp32_history set-target esp32 build
  $ pytest --target esp32 -k ""not nohistory""

.. note::

    Here if we use ``pytest --target esp32 -k history``, both test cases will be sel"
"ected, since ``pytest -k`` will use string matching to filter the test cases.

If you want to build and test with all sdkconfig files at the same time, you should use our CI script as an helper script:

.. code-block:: shell

  $ cd $IDF_PATH/examples/system/console/basic
  $ python $IDF_PATH/tools/ci/ci_build_apps.py . --target esp32 -v --pytest-apps
  $ pytest --target esp32

The app with ``sdkconfig.ci.history`` will be built in ``build_esp32_history``, and the app with ``sdkconfig.ci.nohisto"
"ry`` will be built in ``build_esp32_nohistory``. ``pytest --target esp32`` will run tests on both apps.

Multi-DUT Test Cases


Some test cases may need to run with multiple DUTs. Let's take :project:`examples/openthread` as an example. The test case function looks like this:

.. code-block:: python

    @pytest.mark.parametrize(
        'config, count, app_path, target', [
            ('rcp|cli_h2|br', 3,
             f'{os.path.join(os.path.dirname(__file__), ""ot_rcp"")}'
             f'|{os.pa"
"th.join(os.path.dirname(__file__), ""ot_cli"")}'
             f'|{os.path.join(os.path.dirname(__file__), ""ot_br"")}',
             'esp32c6|esp32h2|esp32s3'),
        ],
        indirect=True,
    )
    def test_thread_connect(dut:Tuple[IdfDut, IdfDut, IdfDut]) -> None:
        ...

The test cases will run with

- ESP32-C6, flashed with ``ot_rcp``
- ESP32-H2, flashed with ``ot_cli``
- ESP32-S3, flashed with ``ot_br``

Of course we can build the required binaries manually, but we can also use our C"
"I script as an helper script:

.. code-block:: shell

  $ cd $IDF_PATH/examples/openthread
  $ python $IDF_PATH/tools/ci/ci_build_apps.py . --target all -v --pytest-apps -k test_thread_connect
  $ pytest --target esp32c6,esp32h2,esp32s3 -k test_thread_connect

.. important::

    It is mandatory to list all the targets for multi-DUT test cases. Otherwise, the test case would fail with an error.

Debug CI Test Cases


Sometimes you can't reprocude the CI test case failure locally. In this case, y"
"ou may need to debug the test case with the binaries built in CI.

Run pytest with ``--pipeline-id `` to force pytest to download the binaries from CI. For example:

.. code-block:: shell

  $ cd $IDF_PATH/examples/get-started/hello_world
  $ pytest --target esp32 --pipeline-id 123456

Even if you have ``build_esp32_default``, or ``build`` directory locally, pytest would still download the binaries from pipeline 123456 and place the binaries in ``build_esp32_default``. Then run the test case wit"
"h this binary.

.. note::

     should be the parent pipeline id. You can copy it in your MR page.

Pytest Tips and Tricks


Custom Classes


Usually, you may want to write a custom class under these conditions:

This code example is taken from :idf_file:`panic/conftest.py `.

.. code-block:: python

  class PanicTestDut(IdfDut):
      ...

  @pytest.fixture(scope='module')
  def monkeypatch_module(request: FixtureRequest) -> MonkeyPatch:
      mp = MonkeyPatch()
      request.addfinalizer(mp.un"
"do)
      return mp


  @pytest.fixture(scope='module', autouse=True)
  def replace_dut_class(monkeypatch_module: MonkeyPatch) -> None:
      monkeypatch_module.setattr('pytest_embedded_idf.dut.IdfDut', PanicTestDut)

``monkeypatch_module`` provides a `module-scoped `__ `monkeypatch `__ fixture.

``replace_dut_class`` is a `module-scoped `__ `autouse `__ fixture. This function replaces the ``IdfDut`` class with your custom class.

Mark Flaky Tests


Certain test cases are based on Ethernet or Wi"
"-Fi. However, the test may be flaky due to networking issues. Thus, it is possible to mark a particular test case as flaky.

This code example is taken from :idf_file:`pytest_esp_eth.py `.

.. code-block:: python

  @pytest.mark.flaky(reruns=3, reruns_delay=5)
  def test_esp_eth_ip101(dut: IdfDut) -> None:
      ...

This flaky marker means that if the test function failed, the test case would rerun for a maximum of 3 times with 5 seconds delay.

Mark Known Failures


Sometimes, a test can consi"
"stently fail for the following reasons:

- The feature under test (or the test itself) has a bug.
- The test environment is unstable (e.g., due to network issues) leading to a high failure ratio.

Now you may mark this test case with marker `xfail `__ with a user-friendly readable reason.

This code example is taken from :idf_file:`pytest_panic.py `

.. code-block:: python

  @pytest.mark.xfail('config.getvalue(""target"") == ""esp32s2""', reason='raised IllegalInstruction instead')
  def test_cache"
"_error(dut: PanicTestDut, config: str, test_func_name: str) -> None:

This marker means that test is a known failure on the ESP32-S2.

Mark Nightly Run Test Cases


Some test cases are only triggered in nightly run pipelines due to a lack of runners.

.. code-block:: python

  @pytest.mark.nightly_run

This marker means that the test case would only be run with env var ``NIGHTLY_RUN`` or ``INCLUDE_NIGHTLY_RUN``.

Mark Temporarily Disabled in CI


Some test cases which can pass locally may need t"
"o be temporarily disabled in CI due to a lack of runners.

.. code-block:: python

  @pytest.mark.temp_skip_ci(targets=['esp32', 'esp32s2'], reason='lack of runners')

This marker means that the test case could still be run locally with ``pytest --target esp32``, but will not run in CI.

Add New Markers


We are using two types of custom markers, target markers which indicate that the test cases should support this target, and env markers which indicate that the test cases should be assigned to "
"runners with these tags in CI.

You can add new markers by adding one line under the :idf_file:`conftest.py`. If it is a target marker, it should be added into ``TARGET_MARKERS``. If it is a marker that specifies a type of test environment, it should be added into ``ENV_MARKERS``. The syntax should be: ``: ``.

Skip Auto Flash Binary


Skipping auto-flash binary every time would be useful when you are debugging your test script.

You can call pytest with ``--skip-autoflash y`` to achieve it.

Re"
"cord Statistics


Sometimes you may need to record some statistics while running the tests, like the performance test statistics.

You can use `record_xml_attribute `__ fixture in your test script, and the statistics would be recorded as attributes in the JUnit report.

Logging System


Sometimes you may need to add some extra logging lines while running the test cases.

You can use `Python logging module `__ to achieve this.

Here are some logging functions provided as fixtures,

``log_performa"
"nce``


.. code-block:: python

    def test_hello_world(
        dut: IdfDut,
        log_performance: Callable[[str, object], None],
    ) -> None:
        log_performance('test', 1)


The above example would log the performance item with pre-defined format: ``[performance][test]: 1`` and record it under the ``properties`` tag in the JUnit report if ``--junitxml `` is specified. The JUnit test case node would look like:

.. code-block:: html

    
        
            
        
    

``check_p"
"erformance``


We provide C macros ``TEST_PERFORMANCE_LESS_THAN`` and ``TEST_PERFORMANCE_GREATER_THAN`` to log the performance item and check if the value is in the valid range. Sometimes the performance item value could not be measured in C code, so we also provide a Python function for the same purpose. Please note that using C macros is the preferred approach, since the Python function could not recognize the threshold values of the same performance item under different ifdef blocks well.

.."
" code-block:: python

    def test_hello_world(
        dut: IdfDut,
        check_performance: Callable[[str, float, str], None],
    ) -> None:
        check_performance('RSA_2048KEY_PUBLIC_OP', 123, 'esp32')
        check_performance('RSA_2048KEY_PUBLIC_OP', 19001, 'esp32')

The above example would first get the threshold values of the performance item ``RSA_2048KEY_PUBLIC_OP`` from :idf_file:`components/idf_test/include/idf_performance.h` and the target-specific one :idf_file:`components/idf"
"_test/include/esp32/idf_performance_target.h`, then check if the value reached the minimum limit or exceeded the maximum limit.

Let us assume the value of ``IDF_PERFORMANCE_MAX_RSA_2048KEY_PUBLIC_OP`` is 19000. so the first ``check_performance`` line would pass and the second one would fail with warning: ``[Performance] RSA_2048KEY_PUBLIC_OP value is 19001, doesn\'t meet pass standard 19000.0``.

Further Readings


-  pytest documentation: https://docs.pytest.org/en/latest/contents.html
-  pyte"
"st-embedded documentation: https://docs.espressif.com/projects/pytest-embedded/en/latest/
"
"Espressif IoT Development Framework Style Guide



About This Guide


Purpose of this style guide is to encourage use of common coding practices within the ESP-IDF.

Style guide is a set of rules which are aimed to help create readable, maintainable, and robust code. By writing code which looks the same way across the code base we help others read and comprehend the code. By using same conventions for spaces and newlines we reduce chances that future changes will produce huge unreadable diffs. B"
"y following common patterns for module structure and by using language features consistently we help others understand code behavior.

We try to keep rules simple enough, which means that they can not cover all potential cases. In some cases one has to bend these simple rules to achieve readability, maintainability, or robustness.

When doing modifications to third-party code used in ESP-IDF, follow the way that particular project is written. That will help propose useful changes for merging int"
"o upstream project.

C Code Formatting


.. highlight:: c

.. _style-guide-naming:

Naming



Indentation


Use 4 spaces for each indentation level. Do not use tabs for indentation. Configure the editor to emit 4 spaces each time you press tab key.

Vertical Space


Place one empty line between functions. Do not begin or end a function with an empty line.
::

    void function1()
    {
        do_one_thing();
        do_another_thing();
                                    // INCORRECT, do not pl"
"ace empty line here
    }
                                    // place empty line here
    void function2()
    {
                                    // INCORRECT, do not use an empty line here
        int var = 0;
        while (var `` operators.


Sometimes adding horizontal space within a line can help make code more readable. For example, you can add space to align function arguments::

    esp_rom_gpio_connect_in_signal(PIN_CAM_D6,   I2S0I_DATA_IN14_IDX, false);
    esp_rom_gpio_connect_in_"
"signal(PIN_CAM_D7,   I2S0I_DATA_IN15_IDX, false);
    esp_rom_gpio_connect_in_signal(PIN_CAM_HREF, I2S0I_H_ENABLE_IDX,  false);
    esp_rom_gpio_connect_in_signal(PIN_CAM_PCLK, I2S0I_DATA_IN15_IDX, false);

Note however that if someone goes to add new line with a longer identifier as first argument (e.g.,  ``PIN_CAM_VSYNC``), it will not fit. So other lines would have to be realigned, adding meaningless changes to the commit.

Therefore, use horizontal alignment sparingly, especially if you expe"
"ct new lines to be added to the list later.

Never use TAB characters for horizontal alignment.

Never add trailing whitespace at the end of the line.


Braces


- Function definition should have a brace on a separate line::

    // This is correct:
    void function(int arg)
    {

    }

    // NOT like this:
    void function(int arg) {

    }

- Within a function, place opening brace on the same line with conditional and loop statements::

    if (condition) {
        do_one();
    } else if"
" (other_condition) {
        do_two();
    }


Comments


Use ``//`` for single line comments. For multi-line comments it is okay to use either ``//`` on each line or a ``/* */`` block.

Although not directly related to formatting, here are a few notes about using comments effectively.

- Do not use single comments to disable some functionality::

    void init_something()
    {
        setup_dma();
        // load_resources();                // WHY is this thing commented, asks the reader?
    "
"    start_timer();
    }

- If some code is no longer required, remove it completely. If you need it you can always look it up in git history of this file. If you disable some call because of temporary reasons, with an intention to restore it in the future, add explanation on the adjacent line::

    void init_something()
    {
        setup_dma();
        // TODO: we should load resources here, but loader is not fully integrated yet.
        // load_resources();
        start_timer();
    }

- "
"Same goes for ``#if 0 ... #endif`` blocks. Remove code block completely if it is not used. Otherwise, add comment explaining why the block is disabled. Do not use ``#if 0 ... #endif`` or comments to store code snippets which you may need in the future.

- Do not add trivial comments about authorship and change date. You can always look up who modified any given line using git. E.g., this comment adds clutter to the code without adding any useful information::

    void init_something()
    {
   "
"     setup_dma();
        // XXX add 2016-09-01
        init_dma_list();
        fill_dma_item(0);
        // end XXX add
        start_timer();
    }


Line Endings


Commits should only contain files with LF (Unix style) endings.

Windows users can configure git to check out CRLF (Windows style) endings locally and commit LF endings by setting the ``core.autocrlf`` setting. `Github has a document about setting this option `.

If you accidentally have some commits in your branch that add LF end"
"ings, you can convert them to Unix by running this command in an MSYS2 or Unix terminal (change directory to the IDF working directory and check the correct branch is currently checked out, beforehand):

.. code-block:: bash

  git rebase --exec 'git diff-tree --no-commit-id --name-only -r HEAD | xargs dos2unix && git commit -a --amend --no-edit --allow-empty' master

(Note that this line rebases on master, change the branch name at the end to rebase on another branch.)

For updating a single co"
"mmit, it is possible to run ``dos2unix FILENAME`` and then run ``git commit --amend``

Formatting Your Code


ESP-IDF uses Astyle to format source code. The configuration is stored in :project_file:`tools/ci/astyle-rules.yml` file.

Initially, all components are excluded from formatting checks. You can enable formatting checks for the component by removing it from ``components_not_formatted_temporary`` list. Then run:

.. code-block:: bash

    pre-commit run --files  astyle_py

Alternatively, y"
"ou can run ``astyle_py`` manually. You can install it with ``pip install astyle_py==VERSION``. Make sure you have the same version installed as the one specified in :project_file:`.pre-commit-config.yaml` file. With ``astyle_py`` installed, run:

.. code-block:: bash

    astyle_py --rules=$IDF_PATH/tools/ci/astyle-rules.yml 


Type Definitions


Should be snake_case, ending with _t suffix::

    typedef int signed_32_bit_t;

Enum


Enums should be defined through the `typedef` and be namespaced"
"::

    typedef enum
    {
        MODULE_FOO_ONE,
        MODULE_FOO_TWO,
        MODULE_FOO_THREE
    } module_foo_t;


.. _assertions:

Assertions


The standard C ``assert()`` function, defined in ``assert.h`` should be used to check conditions that should be true in source code. In the default configuration, an assert condition that returns ``false`` or 0 will call ``abort()`` and trigger a :doc:`Fatal Error `.

``assert()`` should only be used to detect unrecoverable errors due to a seriou"
"s internal logic bug or corruption, where it is not possible for the program to continue. For recoverable errors, including errors that are possible due to invalid external input, an :doc:`error value should be returned `.

.. note::

   When asserting a value of type ``esp_err_t`` is equal to ``ESP_OK``, use the :ref:`esp-error-check-macro` instead of an ``assert()``.

It is possible to configure ESP-IDF projects with assertions disabled (see :ref:`CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL`)"
". Therefore, functions called in an ``assert()`` statement should not have side-effects.

It is also necessary to use particular techniques to avoid ""variable set but not used"" warnings when assertions are disabled, due to code patterns such as::

  int res = do_something();
  assert(res == 0);

Once the ``assert`` is optimized out, the ``res`` value is unused and the compiler will warn about this. However the function ``do_something()`` must still be called, even if assertions are disabled.

Wh"
"en the variable is declared and initialized in a single statement, a good strategy is to cast it to ``void`` on a new line. The compiler will not produce a warning, and the variable can still be optimized out of the final binary::

  int res = do_something();
  assert(res == 0);
  (void)res;

If the variable is declared separately, for example if it is used for multiple assertions, then it can be declared with the GCC attribute ``__attribute__((unused))``. The compiler will not produce any unuse"
"d variable warnings, but the variable can still be optimized out::

  int res __attribute__((unused));

  res = do_something();
  assert(res == 0);

  res = do_something_else();
  assert(res != 0);


Header File Guards


All public facing header files should have preprocessor guards. A pragma is preferred::

    #pragma once

over the following pattern::

    #ifndef FILE_NAME_H
    #define FILE_NAME_H
    ...
    #endif // FILE_NAME_H

In addition to guard macros, all C header files should have"
" ``extern ""C""`` guards to allow the header to be used from C++ code. Note that the following order should be used: ``pragma once``, then any ``#include`` statements, then ``extern ""C""`` guards::

    #pragma once

    #include 

    #ifdef __cplusplus
    extern ""C"" {
    #endif

    /* declarations go here */

    #ifdef __cplusplus
    }
    #endif


Include Statements


When writing ``#include`` statements, try to maintain the following order:

Use angle brackets for C standard library header"
"s and other POSIX headers (``#include ``).

Use double quotes for all other headers (``#include ""esp_log.h""``).


C++ Code Formatting


The same rules as for C apply. Where they are not enough, apply the following rules.

File Naming

C++ Header files have the extension ``.hpp``. C++ source files have the extension ``.cpp``. The latter is important for the compiler to distinguish them from normal C source files.

Naming


Member Order in Classes

In order of precedence:

For example:

::

    cl"
"ass ForExample {
    public:
        // first constructors, then default constructor, then destructor
        ForExample(double example_factor_arg);
        ForExample();
        ~ForExample();

        // then remaining pubic methods
        set_example_factor(double example_factor_arg);

        // then public member variables
        uint32_t public_data_member;

    private:
        // first private methods
        void internal_method();

        // then private member variables
        dou"
"ble example_factor;
    };

Spacing


Simple Example

::

    // file spaceship.h
    #ifndef SPACESHIP_H_
    #define SPACESHIP_H_
    #include 

    namespace spaceships {

    class SpaceShip {
    public:
        SpaceShip(size_t crew);
        size_t get_crew_size() const;

    private:
        const size_t crew;
    };

    class SpaceShuttle : public SpaceShip {
    public:
        SpaceShuttle();
    };

    class Sojuz : public SpaceShip {
    public:
        Sojuz();
    };

    templa"
"te 
    class CargoShip {
    public:
        CargoShip(const T &cargo);

    private:
        T cargo;
    };

    } // namespace spaceships

    #endif // SPACESHIP_H_

    // file spaceship.cpp
    #include ""spaceship.h""

    namespace spaceships {

    // Putting the curly braces in the same line for constructors is OK if it only initializes
    // values in the initializer list
    SpaceShip::SpaceShip(size_t crew) : crew(crew) { }

    size_t SpaceShip::get_crew_size() const
    {
        "
"return crew;
    }

    SpaceShuttle::SpaceShuttle() : SpaceShip(7)
    {
        // doing further initialization
    }

    Sojuz::Sojuz() : SpaceShip(3)
    {
        // doing further initialization
    }

    template 
    CargoShip::CargoShip(const T &cargo) : cargo(cargo) { }

    } // namespace spaceships


CMake Code Style


- Indent with four spaces.
- Maximum line length 120 characters. When splitting lines, try to
  focus on readability where possible (for example, by pairing up
  keyw"
"ord/argument pairs on individual lines).
- Do not put anything in the optional parentheses after ``endforeach()``, ``endif()``, etc.
- Use lowercase (``with_underscores``) for command, function, and macro names.
- For locally scoped variables, use lowercase (``with_underscores``).
- For globally scoped variables, use uppercase (``WITH_UNDERSCORES``).
- Otherwise follow the defaults of the cmake-lint_ project.

Configuring the Code Style for a Project Using EditorConfig


EditorConfig helps devel"
"opers define and maintain consistent coding styles between different editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.

For more information, see `EditorConfig `_ Website.

Third Party Component Code Styles


ESP-IDF integrates a number of third part"
"y components where these components may have differing code styles.

FreeRTOS


The code style adopted by FreeRTOS is described in the `FreeRTOS style guide `_. Formatting of FreeRTOS source code is automated using `Uncrustify `_, thus a copy of the FreeRTOS code style's Uncrustify configuration (``uncrustify.cfg``) is stored within ESP-IDF FreeRTOS component.

If a FreeRTOS source file is modified, the updated file can be formatted again by following the steps below:

.. code-block:: bash

    "
"uncrustify -c $IDF_PATH/components/freertos/FreeRTOS-Kernel/uncrustify.cfg --replace source.c --no-backup

Documenting Code


Please see the guide here: :doc:`documenting-code`.

Structure


To be written.


Language Features


To be written.

.. _cmake-lint: https://github.com/richq/cmake-lint
"
"
Espressif Wireshark User Guide





1.1 What Is Wireshark?


`Wireshark `_ (originally named ""Ethereal"") is a network packet analyzer that captures network packets and displays the packet data as detailed as possible. It uses WinPcap as its interface to directly capture network traffic going through a network interface controller (NIC).

You could think of a network packet analyzer as a measuring device used to examine what is going on inside a network cable, just like a voltmeter is used by an"
" electrician to examine what is going on inside an electric cable.

In the past, such tools were either very expensive, proprietary, or both. However, with the advent of Wireshark, all that has changed.

Wireshark is released under the terms of the GNU General Public License, which means you can use the software and the source code free of charge. It also allows you to modify and customize the source code.

Wireshark is, perhaps, one of the best open source packet analyzers available today.


1."
"2 Some Intended Purposes


Here are some examples of how Wireshark is typically used:

Beside these examples, Wireshark can be used for many other purposes.


1.3 Features


The main features of Wireshark are as follows:


1.4 Wireshark Can or Cannot Do


  Wireshark can capture traffic from different network media, including wireless LAN.

  Wireshark can import data from a large number of file formats, supported by other capture programs.

  Wireshark can export data into a large number of fil"
"e formats, supported by other capture programs.

  Wireshark can dissect, or decode, a large number of protocols.

  It will not warn you if there are any suspicious activities on your network. However, if strange things happen, Wireshark might help you figure out what is really going on.

  Wireshark does not send packets on the network or influence it in any other way, except for resolving names (converting numerical address values into a human readable format), but even that can be disabled.
"
"


You can get Wireshark from the official website: https://www.wireshark.org/download.html

Wireshark can run on various operating systems. Please download the correct version according to the operating system you are using.



**This demonstration uses Wireshark 2.2.6 on Linux.**


**a) Start Wireshark**

On Linux, you can run the shell script provided below. It starts Wireshark, then configures NIC and the channel for packet capture.

::

  ifconfig $1 down
  iwconfig $1 mode monitor
  iwconf"
"ig $1 channel $2
  ifconfig $1 up
  Wireshark&

In the above script, the parameter ``$1`` represents NIC and ``$2`` represents channel. For example, ``wlan0`` in ``./xxx.sh wlan0 6``, specifies the NIC for packet capture, and ``6`` identifies the channel of an AP or Soft-AP.


**b) Run the Shell Script to Open Wireshark and Display Capture Interface**

.. figure:: ../../_static/ws-capture-interface.jpeg
    :align: center
    :alt: Wireshark Capture Interface
    :figclass: align-center
    :wid"
"th: 60%

    Wireshark Capture Interface

**c) Select the Interface to Start Packet Capture**

As the red markup shows in the picture above, many interfaces are available. The first one is a local NIC and the second one is a wireless NIC.

Please select the NIC according to your requirements. This document will use the wireless NIC to demonstrate packet capture.

Double click *wlan0* to start packet capture.


**d) Set up Filters**

Since all packets in the channel will be captured, and many of "
"them are not needed, you have to set up filters to get the packets that you need.

Please find the picture below with the red markup, indicating where the filters should be set up.

.. figure:: ../../_static/ws-setup-filters.png
    :align: center
    :alt: Setting up Filters in Wireshark
    :figclass: align-center

    Setting up Filters in Wireshark

Click *Filter*, the top left blue button in the picture below. The *display filter* dialogue box will appear.

.. figure:: ../../_static/ws-disp"
"lay-filter-dialogue-box.png
    :align: center
    :alt: *Display Filter* Dialogue Box
    :figclass: align-center
    :width: 60%

    *Display Filter* Dialogue Box

Click the *Expression* button to bring up the *Filter Expression* dialogue box and set the filter according to your requirements.

.. figure:: ../../_static/ws-filter-expression.png
    :align: center
    :alt: *Filter Expression* Dialogue Box
    :figclass: align-center
    :width: 80%

    *Filter Expression* Dialogue Box

**The "
"quickest way**: enter the filters directly in the toolbar.

.. figure:: ../../_static/ws-filter-toolbar.png
    :align: center
    :alt: Filter Toolbar
    :figclass: align-center

    Filter Toolbar

Click on this area to enter or modify the filters. If you enter a wrong or unfinished filter, the built-in syntax check turns the background red. As soon as the correct expression is entered, the background becomes green.

The previously entered filters are automatically saved. You can access them "
"anytime by opening the drop down list.

For example, as shown in the picture below, enter two MAC addresses as the filters and click *Apply* (the blue arrow). In this case, only the packet data transmitted between these two MAC addresses will be captured.

.. figure:: ../../_static/ws-filter-toolbar_green.png
    :align: center
    :alt: Example of MAC Addresses applied in the Filter Toolbar
    :figclass: align-center

    Example of MAC Addresses applied in the Filter Toolbar

**e) Packet List"
"**

You can click any packet in the packet list and check the detailed information about it in the box below the list. For example, if you click the first packet, its details will appear in that box.

.. figure:: ../../_static/ws-packet-list.png
    :align: center
    :alt: Example of Packet List Details
    :figclass: align-center

    Example of Packet List Details

**f) Stop/Start Packet Capture**

As shown in the picture below, click the red button to stop capturing the current packet.

.. f"
"igure:: ../../_static/ws-stop-packet-capture.png
    :align: center
    :alt: Stopping Packets Capture
    :figclass: align-center

    Stopping Packet Capture

Click the top left blue button to start or resume packet capture.

.. figure:: ../../_static/ws-start-resume-packet-capture.png
    :align: center
    :alt: Starting or Resuming Packets Capture
    :figclass: align-center
    :width: 60%

    Starting or Resuming the Packets Capture

**g) Save the Current Packet**

On Linux, go to *File*"
" -> *Export Packet Dissections* -> *As Plain Text File* to save the packet.

.. figure:: ../../_static/ws-save-packets.png
    :align: center
    :alt: Saving Captured Packets
    :figclass: align-center
    :width: 60%

    Saving Captured Packets

Please note that *All packets*, *Displayed* and *All expanded* must be selected.

By default, Wireshark saves the captured packet in a libpcap file. You can also save the file in other formats, e.g., txt, to analyze it in other tools.

"
"
USB OTG Console


On chips with an integrated USB peripheral, it is possible to use USB Communication Device Class (CDC) to implement the serial console, instead of using UART with an external USB-UART bridge chip. {IDF_TARGET_NAME} ROM code contains a USB CDC implementation, which supports for some basic functionality without requiring the application to include the USB stack:

.. note::

    At the moment, this ""USB Console"" feature is incompatible with TinyUSB stack. However, if TinyUSB is u"
"sed, it can provide its own CDC implementation.

Hardware Requirements


Connect {IDF_TARGET_NAME} to the USB port as follows

+++
| GPIO | USB         |
+++
| 20   | D+ (green)  |
+++
| 19   | D- (white)  |
+++
| GND  | GND (black) |
+++
|      | +5V (red)   |
+++

Some development boards may offer a USB connector for the internal USB peripheral — in that case, no extra connections are required.

.. only:: esp32s3

    By default, :doc:`USB_SERIAL_JTAG ` module is connected to the internal PHY "
"of the ESP32-S3, while USB_OTG peripheral can be used only if the external USB PHY is connected. Since CDC console is provided via USB_OTG peripheral, it cannot be used through the internal PHY in this configuration.

    You can permanently switch the internal USB PHY to work with USB_OTG peripheral instead of USB_SERIAL_JTAG by burning ``USB_PHY_SEL`` eFuse. See ESP32-S3 Technical Reference Manual for more details about USB_SERIAL_JTAG and USB_OTG.

    Note however that USB_SERIAL_JTAG also p"
"rovides a CDC console, so enabling the CDC console should not be the primary reason for switching from USB_SERIAL_JTAG to USB_CDC.


Software Configuration


USB console feature can be enabled using ``CONFIG_ESP_CONSOLE_USB_CDC`` option in menuconfig tool (see :ref:`CONFIG_ESP_CONSOLE_UART`).

Once the option is enabled, build the project as usual.

Uploading the Application


.. _usb_console_initial_upload:

Initial Upload


If the {IDF_TARGET_NAME} is not yet flashed with a program that enable"
"s a USB console, an initial upload of the program is required. There are 3 alternative options to perform the initial upload.

Once the initial upload is done, the application will start up and a USB CDC port will appear in the system.

.. note::

    The port name may change after the initial upload, so check the port list again before running ``idf.py monitor``.


Initial Upload Using the ROM Download Mode, over USB CDC


Initial Upload Using the ROM Download Mode, over USB DFU


See :ref:`api"
"_guide_dfu_flash` for details about DFU flashing.

Initial Upload Using UART


On development boards with a USB-UART bridge, upload the application over UART: ``idf.py flash -p PORT`` where ``PORT`` is the name of the serial port provided by the USB-UART bridge.

Subsequent Usage


Once the application is uploaded for the first time, you can run ``idf.py flash`` and ``idf.py monitor`` as usual.

Limitations


There are several limitations to the USB console feature. These may or may not be signi"
"ficant, depending on the type of application being developed, and the development workflow. Most of these limitations stem from the fact that USB CDC is implemented in software, so the console working over USB CDC is more fragile and complex than a console working over UART.

"
"Running ESP-IDF Applications on Host




.. note::

    Running ESP-IDF applications on host is currently still an experimental feature, thus there is no guarantee for API stability. However, user feedback via the `ESP-IDF GitHub repository `_ or the `ESP32 forum `_ is highly welcome, and may help influence the future of design of the ESP-IDF host-based applications.

This document provides an overview of the methods to run ESP-IDF applications on Linux, and what type of ESP-IDF applications can"
" typically be run on Linux.

Introduction


Typically, an ESP-IDF application is built (cross-compiled) on a host machine, uploaded (i.e., flashed) to an ESP chip for execution, and monitored by the host machine via a UART/USB port. However, execution of an ESP-IDF application on an ESP chip can be limiting in various development/usage/testing scenarios.

Therefore, it is possible for an ESP-IDF application to be built and executed entirely within the same Linux host machine (henceforth referred"
" to as ""running on host""). Running ESP-IDF applications on host has several advantages:

- No need to upload to a target.
- Faster execution on a host machine, compared to running on an ESP chip.
- No requirements for any specific hardware, except the host machine itself.
- Easier automation and setup for software testing.
- Large number of tools for code and runtime analysis, e.g., Valgrind.

A large number of ESP-IDF components depend on chip-specific hardware. These hardware dependencies must"
" be mocked or simulated when running on host. ESP-IDF currently supports the following mocking and simulation approaches:

In principle, it is possible to mix both approaches (POSIX/Linux simulator and mocking using CMock), but this has not been done yet in ESP-IDF. Note that despite the name, the FreeRTOS POSIX/Linux simulator currently also works on macOS. Running ESP-IDF applications on host machines is often used for testing. However, simulating the environment and mocking dependencies does "
"not fully represent the target device. Thus, testing on the target device is still necessary, though with a different focus that usually puts more weight on integration and system testing.

.. note::

    Another possibility to run applications on the host is to use the QEMU simulator. However, QEMU development for ESP-IDF applications is still a work in progress and has not been documented yet.

CMock-Based Approach


This approach uses the `CMock `_ framework to solve the problem of missing ha"
"rdware and software dependencies. CMock-based applications running on the host machine have the added advantage that they usually only compile the necessary code, i.e., the (mostly mocked) dependencies instead of the entire system. For a general introduction to Mocks and how to configure and use them in ESP-IDF, please refer to :ref:`mocks`.


POSIX/Linux Simulator Approach


The `FreeRTOS POSIX/Linux simulator `_ is available on ESP-IDF as a preview target already. This simulator allows ESP-IDF"
" components to be implemented on the host, making them accessible to ESP-IDF applications when running on host. Currently, only a limited number of components are ready to be built on Linux. Furthermore, the functionality of each component ported to Linux may also be limited or different compared to the functionality when building that component for a chip target. For more information about whether the desired components are supported on Linux, please refer to :ref:`component-linux-mock-support`"
".

.. only:: not esp32p4

    .. note::

        The FreeRTOS POSIX/Linux simulator allows configuring the :ref:`amazon_smp_freertos` version. However, the simulation still runs in single-core mode. The main reason allowing Amazon SMP FreeRTOS is to provide API compatibility with ESP-IDF applications written for Amazon SMP FreeRTOS.

Requirements for Using Mocks


.. include:: inc/linux-host-requirements.rst

If any mocks are used, then ``Ruby`` is required, too.

Build and Run


To build the ap"
"plication on Linux, the target has to be set to ``linux`` and then it can be built and run:

.. code-block:: bash

  idf.py --preview set-target linux
  idf.py build
  idf.py monitor

.. _component-linux-mock-support:

Component Linux/Mock Support Overview


Note that any ""Yes"" here does not necessarily mean a full implementation or mocking. It can also mean a partial implementation or mocking of functionality. Usually, the implementation or mocking is done to a point where enough functionality "
"is provided to build and run a test application.

.. list-table::
   :header-rows: 1
   :widths: 20 10 10
     - Mock
     - Simulation
     - No
     - Yes
     - Yes
     - No
     - No
     - Yes
     - Yes
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - Yes
     - Yes
     - Yes
     - Yes
     - No
     - Yes
     - Yes
     - Yes
     - No
     - Yes
     - No
     - Yes
     - Yes
     - No
     - Yes
     - Yes
     - No
     - Yes
     - Yes
     - Yes
 "
"    - No
     - Yes
     - No
     - Yes
     - Yes
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - Yes
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - No
     - Yes
     - Yes
     - No
     - Yes
     - No
     - No
     - Yes
"
"Deep Sleep Wake Stubs


{IDF_TARGET_NAME} supports running a ""deep sleep wake stub"" when coming out of deep sleep. This function runs immediately as soon as the chip wakes up - before any normal initialisation, bootloader, or ESP-IDF code has run. After the wake stub runs, the SoC can go back to sleep or continue to start ESP-IDF normally.

Deep sleep wake stub code is loaded into ""RTC Fast Memory"" and any data which it uses must also be loaded into RTC memory. RTC memory regions hold their cont"
"ents during deep sleep.


Rules for Wake Stubs


Wake stub code must be carefully written:


Implementing A Stub


The wake stub in esp-idf is called ``esp_wake_deep_sleep()``. This function runs whenever the SoC wakes from deep sleep. There is a default version of this function provided in esp-idf, but the default function is weak-linked so if your app contains a function named ``esp_wake_deep_sleep()`` then this will override the default.

If supplying a custom wake stub, the first thing it do"
"es should be to call ``esp_default_wake_deep_sleep()``.

It is not necessary to implement ``esp_wake_deep_sleep()`` in your app in order to use deep sleep. It is only necessary if you want to have special behaviour immediately on wake.

If you want to swap between different deep sleep stubs at runtime, it is also possible to do this by calling the ``esp_set_deep_sleep_wake_stub()`` function. This is not necessary if you only use the default ``esp_wake_deep_sleep()`` function.

All of these funct"
"ions are declared in the ``esp_sleep.h`` header under components/{IDF_TARGET_PATH_NAME}.


Loading Code Into RTC Memory


Wake stub code must be resident in RTC Fast Memory. This can be done in one of two ways.

The first way is to use the ``RTC_IRAM_ATTR`` attribute to place a function into RTC memory::

    void RTC_IRAM_ATTR esp_wake_deep_sleep(void) {
        esp_default_wake_deep_sleep();
        // Add additional functionality here
    }

The second way is to place the function into any so"
"urce file whose name starts with ``rtc_wake_stub``. Files names ``rtc_wake_stub*`` have their contents automatically put into RTC memory by the linker.

The first way is simpler for very short and simple code, or for source files where you want to mix ""normal"" and ""RTC"" code. The second way is simpler when you want to write longer pieces of code for RTC memory.


Loading Data Into RTC Memory


Data used by stub code must be resident in RTC memory.

.. only:: SOC_RTC_SLOW_MEM_SUPPORTED

    The d"
"ata can be placed in RTC Fast memory or in RTC Slow memory which is also used by the ULP.

Specifying this data can be done in one of two ways:

The first way is to use the ``RTC_DATA_ATTR`` and ``RTC_RODATA_ATTR`` to specify any data (writeable or read-only, respectively) which should be loaded into RTC memory::

    RTC_DATA_ATTR int wake_count;

    void RTC_IRAM_ATTR esp_wake_deep_sleep(void) {
        esp_default_wake_deep_sleep();
        static RTC_RODATA_ATTR const char fmt_str[] = ""Wake"
" count %d\n"";
        esp_rom_printf(fmt_str, wake_count++);
    }

.. only:: SOC_RTC_SLOW_MEM_SUPPORTED

    The RTC memory area where this data will be placed can be configured via menuconfig option named ``CONFIG_{IDF_TARGET_CFG_PREFIX}_RTCDATA_IN_FAST_MEM``. This option allows to keep slow memory area for ULP programs and once it is enabled the data marked with ``RTC_DATA_ATTR`` and ``RTC_RODATA_ATTR`` are placed in the RTC fast memory segment otherwise it goes to RTC slow memory (default op"
"tion). This option depends on the :ref:`CONFIG_FREERTOS_UNICORE` option because RTC fast memory can be accessed only by PRO_CPU.

    The attributes ``RTC_FAST_ATTR`` and ``RTC_SLOW_ATTR`` can be used to specify data that will be force placed into RTC_FAST and RTC_SLOW memory respectively. Any access to data marked with ``RTC_FAST_ATTR`` is allowed by PRO_CPU only and it is responsibility of user to make sure about it.

.. only:: not SOC_RTC_SLOW_MEM_SUPPORTED

    The attributes ``RTC_FAST_ATTR"
"`` and ``RTC_SLOW_ATTR`` can be used to specify data that will be force placed into RTC_FAST and RTC_SLOW memory respectively, but for {IDF_TARGET_NAME} there is only RTC fast memory, so both attributes will map to this region.


Unfortunately, any string constants used in this way must be declared as arrays and marked with RTC_RODATA_ATTR, as shown in the example above.

The second way is to place the data into any source file whose name starts with ``rtc_wake_stub``.

For example, the equivale"
"nt example in ``rtc_wake_stub_counter.c``::

    int wake_count;

    void RTC_IRAM_ATTR esp_wake_deep_sleep(void) {
        esp_default_wake_deep_sleep();
        esp_rom_printf(""Wake count %d\n"", wake_count++);
    }

The second way is a better option if you need to use strings, or write other more complex code.

To reduce wake-up time use the `CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP` Kconfig option, see more information in :doc:`Fast boot from Deep Sleep `.


CRC Check For Wake Stubs


"
".. only:: SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY

    During deep sleep, only the wake stubs area of RTC Fast memory is validated with CRC. When {IDF_TARGET_NAME} wakes up from deep sleep, the wake stubs area is validated again. If the validation passes, the wake stubs code will be executed. Otherwise, the normal initialization, bootloader, and esp-idf codes will be executed.

.. only:: not SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY

    During deep sleep, all RTC Fast memory areas will be valid"
"ated with CRC. When {IDF_TARGET_NAME} wakes up from deep sleep, the RTC fast memory will be validated with CRC again. If the validation passes, the wake stubs code will be executed. Otherwise, the normal initialization, bootloader and esp-idf codes will be executed.

.. note::

    When the `CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP` option is enabled, all the RTC fast memory except the wake stubs area is added to the heap.


Example


.. only:: SOC_RTC_FAST_MEM_SUPPORTED

ESP-IDF provides an"
" example to show how to implement the Deep-sleep wake stub.

- :example:`system/deep_sleep_wake_stub`
"
"API Guides



.. toctree::
   :maxdepth: 1

   app_trace
   startup
   :SOC_BLUFI_SUPPORTED: blufi
   :SOC_BT_SUPPORTED: bluetooth
   bootloader
   build-system
   :SOC_SUPPORT_COEXISTENCE: coexist
   c
   cplusplus
   core_dump
   current-consumption-measurement-modules
   :SOC_RTC_MEM_SUPPORTED: deep-sleep-stub
   :SOC_USB_OTG_SUPPORTED and not esp32p4: dfu
   error-handling
   :SOC_BLE_MESH_SUPPORTED: esp-ble-mesh/ble-mesh-index
   :SOC_WIFI_MESH_SUPPORT: esp-wifi-mesh
   :SOC_SPIRAM_SUPPORTE"
"D: external-ram
   fatal-errors
   :esp32s3: flash_psram_config
   hardware-abstraction
   :CONFIG_IDF_TARGET_ARCH_XTENSA: hlinterrupts
   jtag-debugging/index
   linker-script-generation
   lwip
   memory-types
   openthread
   partition-tables
   performance/index
   reproducible-builds
   :SOC_WIFI_SUPPORTED or SOC_BT_SUPPORTED or SOC_IEEE802154_SUPPORTED: RF_calibration
   thread-local-storage
   tools/index
   unit-tests
   host-apps
   :SOC_USB_OTG_SUPPORTED and not esp32p4: usb-otg-consol"
"e
   :SOC_USB_SERIAL_JTAG_SUPPORTED: usb-serial-jtag-console
   :SOC_WIFI_SUPPORTED: wifi
   :SOC_WIFI_SUPPORTED: wifi-security
   low-power-mode
"
"Thread Local Storage




Overview


Thread-local storage (TLS) is a mechanism by which variables are allocated such that there is one instance of the variable per extant thread. ESP-IDF provides three ways to make use of such variables:

- :ref:`freertos-native`: ESP-IDF FreeRTOS native APIs.
- :ref:`pthread-api`: ESP-IDF pthread APIs.
- :ref:`c11-std`: C11 standard introduces special keywords to declare variables as thread local.

.. _freertos-native:

FreeRTOS Native APIs


The ESP-IDF FreeRTO"
"S provides the following APIs to manage thread local variables:

- :cpp:func:`vTaskSetThreadLocalStoragePointer`
- :cpp:func:`pvTaskGetThreadLocalStoragePointer`
- :cpp:func:`vTaskSetThreadLocalStoragePointerAndDelCallback`

In this case, the maximum number of variables that can be allocated is limited by :ref:`CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS`. Variables are kept in the task control block (TCB) and accessed by their index. Note that index 0 is reserved for ESP-IDF internal uses.

U"
"sing the APIs above, you can allocate thread local variables of an arbitrary size, and assign them to any number of tasks. Different tasks can have different sets of TLS variables.

If size of the variable is more than 4 bytes, then you need to allocate/deallocate memory for it. Variable's deallocation is initiated by FreeRTOS when task is deleted, but user must provide callback function to do proper cleanup.

.. _pthread-api:

Pthread APIs


The ESP-IDF provides the following :doc:`/api-referen"
"ce/system/pthread` to manage thread local variables:

- :cpp:func:`pthread_key_create`
- :cpp:func:`pthread_key_delete`
- :cpp:func:`pthread_getspecific`
- :cpp:func:`pthread_setspecific`

These APIs have all benefits of the ones above, but eliminates some their limits. The number of variables is limited only by size of available memory on the heap. Due to the dynamic nature, this API introduces additional performance overhead compared to the native one.

.. _c11-std:

C11 Standard


The ESP-IDF"
" FreeRTOS supports thread local variables according to C11 standard, ones specified with ``__thread`` keyword. For details on this feature, please refer to the `GCC documentation `_.

Storage for that kind of variables is allocated on the task stack. Note that area for all such variables in the program is allocated on the stack of every task in the system even if that task does not use such variables at all. For example, ESP-IDF system tasks (e.g., ``ipc``, ``timer`` tasks etc.) will also have t"
"hat extra stack space allocated. Thus feature should be used with care.

Using C11 thread local variables comes at a trade-off. On one hand, they are quite handy to use in programming and can be accessed using minimal CPU instructions. However, this benefit comes at the cost of additional stack usage for all tasks in the system. Due to static nature of variables allocation, all tasks in the system have the same sets of C11 thread local variables.
"
"RF Calibration




{IDF_TARGET_NAME} supports three RF calibration methods during RF initialization:

Partial Calibration


During RF initialization, the partial calibration method is used by default for RF calibration. It is done based on the full calibration data which is stored in the NVS. To use this method, please go to ``menuconfig`` and enable :ref:`CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE`.

Full Calibration


Full calibration is triggered in the following conditions:

Full calibratio"
"n takes 100 ms longer than the partial calibration method. If boot duration is not of critical importance to the application, the full calibration method is recommended. To switch to the full calibration method, go to ``menuconfig`` and disable :ref:`CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE`. If you use the default method of RF calibration, there are two ways to add the function of triggering full calibration as a last-resort remedy.

No Calibration


The no calibration method is only used wh"
"en the device wakes up from Deep-sleep mode.

PHY Initialization Data


The PHY initialization data is used for RF calibration. There are two ways to get the PHY initialization data.

One is to use the default initialization data which is located in the header file :idf_file:`components/esp_phy/{IDF_TARGET_PATH_NAME}/include/phy_init_data.h`. It is embedded into the application binary after compiling and then stored into read-only memory (DROM). To use the default initialization data, please go "
"to ``menuconfig`` and disable :ref:`CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION`.

An alternative is to store the initialization data in a PHY data partition. A PHY data partition is included in the default partition table. However, when using a custom partition table, please ensure that a PHY data partition (type: ``data``, subtype: ``phy``) is included in the custom partition table. Whether you are using a custom partition table or the default partition table, if initialization data is stored in a p"
"artition, it has to be flashed there, otherwise a runtime error occurs. If you want to use initialization data stored in a partition, go to ``menuconfig`` and enable the option :ref:`CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION`.

API Reference


.. include-build-file:: inc/esp_phy_init.inc
.. include-build-file:: inc/esp_phy_cert_test.inc
"
"128        vTaskAllocateMPURegions             xTask=%t pxRegions=%u
33        vTaskDelete                         xTaskToDelete=%t
34        vTaskDelay                          xTicksToDelay=%u
35        vTaskDelayUntil
129        uxTaskPriorityGet                   xTask=%t
56        uxTaskPriorityGetFromISR            xTask=%t
130        eTaskGetState                       xTask=%t
55        vTaskPrioritySet                    xTask=%t uxNewPriority=%u
36        vTaskSuspend                  "
"      xTaskToSuspend=%t
40        vTaskResume                         xTaskToResume=%t
43        xTaskResumeFromISR                  xTaskToResume=%t
131        vTaskStartScheduler
132        vTaskEndScheduler
133        vTaskSuspendAll
134        xTaskResumeAll
135        xTaskGetTickCount
57        xTaskGetTickCountFromISR
136        uxTaskGetNumberOfTasks
137        pcTaskGetName                       xTaskToQuery=%t
138        uxTaskGetStackHighWaterMark         xTask=%t
139        vTaskSetA"
"pplicationTaskTag          xTask=%t pxHookFunction=%u
140        xTaskGetApplicationTaskTag          xTask=%t
141        vTaskSetThreadLocalStoragePointer   xTaskToSet=%T xIndex=%u pvValue=%u
142        pvTaskGetThreadLocalStoragePointer  xTaskToQuery=%T xIndex=%u
143        xTaskCallApplicationTaskHook        xTask=%T pvParameter=%u
144        xTaskGetIdleTaskHandle
145        uxTaskGetSystemState                pxTaskStatusArray=%u uxArraySize=%u pulTotalRunTime=%u
146        vTaskList        "
"                   pcWriteBuffer=%u
147        vTaskGetRunTimeStats                pcWriteBuffer=%u
44        xTaskGenericNotify                  xTaskToNotify=%t ulValue=%u eAction=%u pulPreviousNotificationValue=%u
45        xTaskGenericNotifyFromISR           xTaskToNotify=%t ulValue=%u eAction=%u pulPreviousNotificationValue=%u pxHigherPriorityTaskWoken=%u
46        xTaskNotifyWait                     ulBitsToClearOnEntry=%u ulBitsToClearOnExit=%u pulNotificationValue=%u xTicksToWait=%u
38  "
"      vTaskNotifyGiveFromISR              xTaskToNotify=%t pxHigherPriorityTaskWoken=%u
37        ulTaskNotifyTake                    xClearCountOnExit=%u xTicksToWait=%u
148        xTaskNotifyStateClear               xTask=%t
149        xTaskGetCurrentTaskHandle
150        vTaskSetTimeOutState                pxTimeOut=%u
151        xTaskCheckForTimeOut                pxTimeOut=%u pxTicksToWait=%u
152        vTaskMissedYield
153        xTaskGetSchedulerState
39        vTaskPriorityInherit       "
"         pxMutexHolder=%p
42        xTaskPriorityDisinherit             pxMutexHolder=%p
154        xTaskGenericCreate                  pxTaskCode=%u pcName=%u usStackDepth=%u pvParameters=%u uxPriority=%u pxCreatedTask=%u puxStackBuffer=%u xRegions=%u
155        uxTaskGetTaskNumber                 xTask=%u
156        vTaskSetTaskNumber                  xTask=%u uxHandle=%u
41        vTaskStepTick                       xTicksToJump=%u
157        eTaskConfirmSleepModeStatus
158        xTimerCreat"
"e                        pcTimerName=%u xTimerPeriodInTicks=%u uxAutoReload=%u pvTimerID=%u pxCallbackFunction=%u
159        pvTimerGetTimerID                   xTimer=%u
160        vTimerSetTimerID                    xTimer=%u pvNewID=%u
161        xTimerIsTimerActive                 xTimer=%u
162        xTimerGetTimerDaemonTaskHandle
163        xTimerPendFunctionCallFromISR       xFunctionToPend=%u pvParameter1=%u ulParameter2=%u pxHigherPriorityTaskWoken=%u
164        xTimerPendFunctionCall  "
"            xFunctionToPend=%u pvParameter1=%u ulParameter2=%u xTicksToWait=%u
165        pcTimerGetName                      xTimer=%u
166        xTimerCreateTimerTask
167        xTimerGenericCommand                xTimer=%u xCommandID=%u xOptionalValue=%u pxHigherPriorityTaskWoken=%u xTicksToWait=%u
53        xQueueGenericSend                   xQueue=%I pvItemToQueue=%p xTicksToWait=%u xCopyPosition=%u
50        xQueuePeekFromISR                   xQueue=%I pvBuffer=%p
49        xQueueGeneric"
"Receive                xQueue=%I pvBuffer=%p xTicksToWait=%u xJustPeek=%u
168        uxQueueMessagesWaiting              xQueue=%I
169        uxQueueSpacesAvailable              xQueue=%I
48        vQueueDelete                        xQueue=%I
54        xQueueGenericSendFromISR            xQueue=%I pvItemToQueue=%p pxHigherPriorityTaskWoken=%u xCopyPosition=%u
61        xQueueGiveFromISR                   xQueue=%I pxHigherPriorityTaskWoken=%u
51        xQueueReceiveFromISR                xQueue"
"=%I pvBuffer=%p pxHigherPriorityTaskWoken=%u
62        xQueueIsQueueEmptyFromISR           xQueue=%I
63       xQueueIsQueueFullFromISR            xQueue=%I
170       uxQueueMessagesWaitingFromISR       xQueue=%I
171       xQueueAltGenericSend                xQueue=%I pvItemToQueue=%p xTicksToWait=%u xCopyPosition=%u
172       xQueueAltGenericReceive             xQueue=%I pvBuffer=%p xTicksToWait=%u xJustPeeking=%u
173       xQueueCRSendFromISR                 xQueue=%I pvItemToQueue=%p xCoRoutin"
"ePreviouslyWoken=%u
174       xQueueCRReceiveFromISR              xQueue=%I pvBuffer=%p pxTaskWoken=%u
175       xQueueCRSend                        xQueue=%I pvItemToQueue=%p xTicksToWait=%u
176       xQueueCRReceive                     xQueue=%I pvBuffer=%p xTicksToWait=%u
177       xQueueCreateMutex                   ucQueueType=%u
178       xQueueCreateCountingSemaphore       uxMaxCount=%u uxInitialCount=%u
179       xQueueGetMutexHolder                xSemaphore=%u
180       xQueueTakeMutex"
"Recursive            xMutex=%u xTicksToWait=%u
181       xQueueGiveMutexRecursive            pxMutex=%u
52       vQueueAddToRegistry                 xQueue=%I pcName=%u
182       vQueueUnregisterQueue               xQueue=%I
47       xQueueGenericCreate                 uxQueueLength=%u uxItemSize=%u ucQueueType=%u
183       xQueueCreateSet                     uxEventQueueLength=%u
184       xQueueAddToSet                      xQueueOrSemaphore=%u xQueueSet=%u
185       xQueueRemoveFromSet       "
"          xQueueOrSemaphore=%u xQueueSet=%u
186       xQueueSelectFromSet                 xQueueSet=%u xTicksToWait=%u
187       xQueueSelectFromSetFromISR          xQueueSet=%u
188       xQueueGenericReset                  xQueue=%I xNewQueue=%u
189       vListInitialise                     pxList=%u
190       vListInitialiseItem                 pxItem=%u
191       vListInsert                         pxList=%u pxNewListItem=%u
192       vListInsertEnd                      pxList=%u pxNewListIte"
"m=%u
193       uxListRemove                        pxItemToRemove=%u
194       xEventGroupCreate
195       xEventGroupWaitBits                 xEventGroup=%u uxBitsToWaitFor=%u xClearOnExit=%u xWaitForAllBits=%u xTicksToWait=%u
196       xEventGroupClearBits                xEventGroup=%u uxBitsToClear=%u
58       xEventGroupClearBitsFromISR         xEventGroup=%u uxBitsToSet=%u
197       xEventGroupSetBits                  xEventGroup=%u uxBitsToSet=%u
59       xEventGroupSetBitsFromISR         "
"  xEventGroup=%u uxBitsToSet=%u pxHigherPriorityTaskWoken=%u
198       xEventGroupSync                     xEventGroup=%u uxBitsToSet=%u uxBitsToWaitFor=%u xTicksToWait=%u
60       xEventGroupGetBitsFromISR           xEventGroup=%u
199       vEventGroupDelete                   xEventGroup=%u
200       uxEventGroupGetNumber               xEventGroup=%u
"
"Support for External RAM




.. toctree::
    :maxdepth: 1

Introduction


{IDF_TARGET_PSRAM_VADDR_SIZE:default=""Value not updated"", esp32=""4 MB"", esp32s2=""10.5 MB"", esp32s3=""32 MB"", esp32p4=""64 MB""}

{IDF_TARGET_NAME} has a few hundred kilobytes of internal RAM, residing on the same die as the rest of the chip components. It can be insufficient for some purposes, so {IDF_TARGET_NAME} has the ability to use up to {IDF_TARGET_PSRAM_VADDR_SIZE} of virtual addresses for external PSRAM (Psuedostatic"
" RAM) memory. The external memory is incorporated in the memory map and, with certain restrictions, is usable in the same way as internal data RAM.

.. only:: esp32s3

    The {IDF_TARGET_PSRAM_VADDR_SIZE} virtual addresses are shared with flash instructions and rodata.

Hardware


{IDF_TARGET_NAME} supports PSRAM connected in parallel with the SPI flash chip. While {IDF_TARGET_NAME} is capable of supporting several types of RAM chips, ESP-IDF currently only supports Espressif branded PSRAM chip"
"s (e.g., ESP-PSRAM32, ESP-PSRAM64, etc).

.. note::

    .. only:: esp32 or esp32s2 or esp32s3

        Some PSRAM chips are 1.8 V devices and some are 3.3 V. The working voltage of the PSRAM chip must match the working voltage of the flash component. Consult the datasheet for your PSRAM chip and {IDF_TARGET_NAME} device to find out the working voltages. For a 1.8 V PSRAM chip, make sure to either set the MTDI pin to a high signal level on bootup, or program {IDF_TARGET_NAME} eFuses to always us"
"e the VDD_SIO level of 1.8 V. Not doing this can damage the PSRAM and/or flash chip.

    .. only:: esp32p4

        Some PSRAM chips are 1.8 V devices and some are 3.3 V. Consult the datasheet for your PSRAM chip and {IDF_TARGET_NAME} device to find out the working voltages.

        By default, the PSRAM is powered up by the on-chip LDO2. You can use :ref:`CONFIG_ESP_VDD_PSRAM_LDO_ID` to switch the LDO ID accordingly. Set this value to -1 to use an external power supply, which means the on-chi"
"p LDO will not be used. By default, the PSRAM connected to LDO is set to the correct voltage based on the Espressif module used. You can still use :ref:`CONFIG_ESP_VDD_PSRAM_LDO_VOLTAGE_MV` to select the LDO output voltage if you are not using an Espressif module. When using an external power supply, this option does not exist.

.. note::

    Espressif produces both modules and system-in-package chips that integrate compatible PSRAM and flash and are ready to mount on a product PCB. Consult the"
" Espressif website for more information. If you are using a custom PSRAM chip, ESP-IDF SDK might not be compatible with it.

For specific details about connecting the SoC or module pins to an external PSRAM chip, consult the SoC or module datasheet.

.. _external_ram_config:


Configuring External RAM


ESP-IDF fully supports the use of external RAM in applications. Once the external RAM is initialized at startup, ESP-IDF can be configured to integrate the external RAM in several ways:

.. list:"
":
    :esp32: * :ref:`external_ram_config_noinit`
    :SOC_SPIRAM_XIP_SUPPORTED: * :ref:`external_ram_config_instructions`
    :SOC_SPIRAM_XIP_SUPPORTED: * :ref:`external_ram_config_rodata`

.. _external_ram_config_memory_map:


Integrate RAM into the {IDF_TARGET_NAME} Memory Map


Select this option by choosing ``Integrate RAM into memory map`` from :ref:`CONFIG_SPIRAM_USE`.

This is the most basic option for external RAM integration. Most likely, you will need another, more advanced option.

D"
"uring the ESP-IDF startup, external RAM is mapped into the data virtual address space. The address space is dynamically allocated. The length will be the mininum length between the PSRAM size and the available data virtual address space size.

Applications can manually place data in external memory by creating pointers to this region. So if an application uses external memory, it is responsible for all management of the external RAM: coordinating buffer usage, preventing corruption, etc.

It is "
"recommended to access the PSRAM by ESP-IDF heap memory allocator (see next chapter).

.. _external_ram_config_capability_allocator:


Add External RAM to the Capability Allocator


Select this option by choosing ``Make RAM allocatable using heap_caps_malloc(..., MALLOC_CAP_SPIRAM)`` from :ref:`CONFIG_SPIRAM_USE`.

When enabled, memory is mapped to data virtual address space and also added to the :doc:`capabilities-based heap memory allocator ` using ``MALLOC_CAP_SPIRAM``.

To allocate memory fro"
"m external RAM, a program should call ``heap_caps_malloc(size, MALLOC_CAP_SPIRAM)``. After use, this memory can be freed by calling the normal ``free()`` function.

.. _external_ram_config_malloc:


Provide External RAM via malloc()


Select this option by choosing ``Make RAM allocatable using malloc() as well`` from :ref:`CONFIG_SPIRAM_USE`. This is the default option.

In this case, memory is added to the capability allocator as described for the previous option. However, it is also added to t"
"he pool of RAM that can be returned by the standard ``malloc()`` function.

This allows any application to use the external RAM without having to rewrite the code to use ``heap_caps_malloc(..., MALLOC_CAP_SPIRAM)``.

An additional configuration item, :ref:`CONFIG_SPIRAM_MALLOC_ALWAYSINTERNAL`, can be used to set the size threshold when a single allocation should prefer external memory:

- When allocating a size less than the threshold, the allocator will try internal memory first.
- When allocat"
"ing a size equal to or larger than the threshold, the allocator will try external memory first.

If a suitable block of preferred internal/external memory is not available, the allocator will try the other type of memory.

Because some buffers can only be allocated in internal memory, a second configuration item :ref:`CONFIG_SPIRAM_MALLOC_RESERVE_INTERNAL` defines a pool of internal memory which is reserved for *only* explicitly internal allocations (such as memory for DMA use). Regular ``malloc"
"()`` will not allocate from this pool. The :ref:`MALLOC_CAP_DMA ` and ``MALLOC_CAP_INTERNAL`` flags can be used to allocate memory from this pool.

.. _external_ram_config_bss:

Allow .bss Segment to Be Placed in External Memory


Enable this option by checking :ref:`CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY`.

If enabled, the region of the data virtual address space where the PSRAM is mapped to will be used to store zero-initialized data (BSS segment) from the lwIP, net80211, libpp, wpa_suppl"
"icant and bluedroid ESP-IDF libraries.

Additional data can be moved from the internal BSS segment to external RAM by applying the macro ``EXT_RAM_BSS_ATTR`` to any static declaration (which is not initialized to a non-zero value).

It is also possible to place the BSS section of a component or a library to external RAM using linker fragment scheme ``extram_bss``.

This option reduces the internal static memory used by the BSS segment.

Remaining external RAM can also be added to the capability "
"heap allocator using the method shown above.

.. only:: esp32

    .. _external_ram_config_noinit:

    Allow .noinit Segment to Be Placed in External Memory
    

    Enable this option by checking :ref:`CONFIG_SPIRAM_ALLOW_NOINIT_SEG_EXTERNAL_MEMORY`. If enabled, the region of the data virtual address space where the PSRAM is mapped to will be used to store non-initialized data. The values placed in this segment will not be initialized or modified even during startup or restart.

    By applyi"
"ng the macro ``EXT_RAM_NOINIT_ATTR``, data could be moved from the internal NOINIT segment to external RAM. Remaining external RAM can still be added to the capability heap allocator using the method shown above, :ref:`external_ram_config_capability_allocator`.

.. only:: SOC_SPIRAM_XIP_SUPPORTED

    .. _external_ram_config_instructions:

    Move Instructions in Flash to PSRAM
    

    The :ref:`CONFIG_SPIRAM_FETCH_INSTRUCTIONS` option allows the flash ``.text`` sections (use for instructions"
") to be placed in PSRAM.

    By enabling the :ref:`CONFIG_SPIRAM_FETCH_INSTRUCTIONS` option

    - Instructions from the ``.text`` sections of flash are moved into PSRAM on system startup.

    - The corresponding virtual memory range of those instructions will also be re-mapped to PSRAM.

    If :ref:`CONFIG_SPIRAM_RODATA` is also enabled, the cache will not be disabled during an SPI1 flash operation. You do not need to make sure ISRs, ISR callbacks and involved data are placed in internal RAM"
", thus internal RAM usage can be optimized.

    .. _external_ram_config_rodata:

    Move Read-Only Data in Flash to PSRAM
    

    The :ref:`CONFIG_SPIRAM_RODATA` option allows the flash ``.rodata`` sections (use for read only data) to be placed in PSRAM.

    By enabling the :ref:`CONFIG_SPIRAM_RODATA` option

    - Instructions from the ``.rodata`` sections of flash are moved into PSRAM on system startup.

    - The corresponding virtual memory range of those rodata will also be re-mapped t"
"o PSRAM.

    If :ref:`CONFIG_SPIRAM_FETCH_INSTRUCTIONS` is also enabled, the cache will not be disabled during an SPI1 flash operation. You do not need to make sure ISRs, ISR callbacks and involved data are placed in internal RAM, thus internal RAM usage can be optimized.

Restrictions


External RAM use has the following restrictions:

.. list::

    - When flash cache is disabled (for example, if the flash is being written to), the external RAM also becomes inaccessible. Any read operations f"
"rom or write operations to it will lead to an illegal cache access exception. This is also the reason why ESP-IDF does not by default allocate any task stacks in external RAM (see below).

    :esp32s2: - External RAM cannot be used as a place to store DMA transaction descriptors or as a buffer for a DMA transfer to read from or write into. Therefore when External RAM is enabled, any buffer that will be used in combination with DMA must be allocated using ``heap_caps_malloc(size, MALLOC_CAP_DMA "
"| MALLOC_CAP_INTERNAL)`` and can be freed using a standard ``free()`` call. Note that although {IDF_TARGET_NAME} has hardware support for DMA to or from external RAM, this is not yet supported in ESP-IDF.

    :esp32s3: - Although {IDF_TARGET_NAME} has hardware support for DMA to or from external RAM, there are still limitations:

        :esp32s3: - DMA transaction descriptors cannot be placed in PSRAM.
        :esp32s3: - The bandwidth that DMA accesses external RAM is very limited, especially"
" when the core is trying to access the external RAM at the same time.
        :esp32s3: - You can configure :ref:`CONFIG_SPIRAM_SPEED` as 120 MHz for an octal PSRAM. The bandwidth will be improved. However there are still restrictions for this option. See :ref:`All Supported PSRAM Modes and Speeds ` for more details.

    - External RAM uses the same cache region as the external flash. This means that frequently accessed variables in external RAM can be read and modified almost as quickly as in "
"internal RAM. However, when accessing large chunks of data (> 32 KB), the cache can be insufficient, and speeds will fall back to the access speed of the external RAM. Moreover, accessing large chunks of data can ""push out"" cached flash, possibly making the execution of code slower afterwards.

    - In general, external RAM will not be used as task stack memory. :cpp:func:`xTaskCreate` and similar functions will always allocate internal memory for stack and task TCBs.

The option :ref:`CONFIG_S"
"PIRAM_ALLOW_STACK_EXTERNAL_MEMORY` can be used to allow placing task stacks into external memory. In these cases :cpp:func:`xTaskCreateStatic` must be used to specify a task stack buffer allocated from external memory, otherwise task stacks will still be allocated from internal memory.


Failure to Initialize


By default, failure to initialize external RAM will cause the ESP-IDF startup to abort. This can be disabled by enabling the config item :ref:`CONFIG_SPIRAM_IGNORE_NOTFOUND`.

.. only:: e"
"sp32 or esp32s2

    If :ref:`CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY` is enabled, the option to ignore failure is not available as the linker will have assigned symbols to external memory addresses at link time.


.. only:: not esp32

    Encryption
    

    It is possible to enable automatic encryption for data stored in external RAM. When this is enabled any data read and written through the cache will automatically be encrypted or decrypted by the external memory encryption hardware.

 "
"   This feature is enabled whenever flash encryption is enabled. For more information on how to enable and how it works see :doc:`Flash Encryption `.


.. only:: esp32

    .. include:: inc/external-ram-esp32-notes.rst

.. _ESP32 Series SoC Errata: https://www.espressif.com/sites/default/files/documentation/eco_and_workarounds_for_bugs_in_esp32_en.pdf
.. _ESP32 Chip Revision v3.0 User Guide: https://www.espressif.com/sites/default/files/documentation/ESP32_ECO_V3_User_Guide__EN.pdf
"
"Hardware Abstraction




ESP-IDF provides a group of APIs for hardware abstraction. These APIs allow you to control peripherals at different levels of abstraction, giving you more flexibility compared to using only the ESP-IDF drivers to interact with hardware. ESP-IDF Hardware abstraction is likely to be useful for writing high-performance bare-metal drivers, or for attempting to port an ESP chip to another platform.

This guide is split into the following sections:

.. warning::

    Hardware "
"abstraction API (excluding the driver and ``xxx_types.h``) should be considered an experimental feature, thus cannot be considered public API. The hardware abstraction API does not adhere to the API name changing restrictions of ESP-IDF's versioning scheme. In other words, it is possible that Hardware Abstraction API may change in between non-major release versions.

.. note::

    Although this document mainly focuses on hardware abstraction of peripherals, e.g., UART, SPI, I2C, certain layers "
"of hardware abstraction extend to other aspects of hardware as well, e.g., some of the CPU's features are partially abstracted.

.. _hw-abstraction-architecture:

Architecture


Hardware abstraction in ESP-IDF is comprised of the following layers, ordered from low level of abstraction that is closer to hardware, to high level of abstraction that is further away from hardware.

- Low Level (LL) Layer
- Hardware Abstraction Layer (HAL)
- Driver Layers

The LL Layer, and HAL are entirely contained "
"within the ``hal`` component. Each layer is dependent on the layer below it, i.e, driver depends on HAL, HAL depends on LL, LL depends on the register header files.

For a particular peripheral ``xxx``, its hardware abstraction generally consists of the header files described in the table below. Files that are **Target Specific** have a separate implementation for each target, i.e., a separate copy for each chip. However, the ``#include`` directive is still target-independent, i.e., is the same "
"for different targets, as the build system automatically includes the correct version of the header and source files.

.. |br| raw:: html

    

.. list-table:: Hardware Abstraction Header Files
    :widths: 25 5 70
    :header-rows: 1
      - Target |br| Specific
      - Description
      - Y
      - This header contains a list of C macros specifying the various capabilities of the {IDF_TARGET_NAME}'s peripheral ``xxx``. Hardware capabilities of a peripheral include things such as the number of"
" channels, DMA support, hardware FIFO/buffer lengths, etc.
      - Y
      - The two headers contain a representation of a peripheral's registers in C structure and C macro format respectively, allowing you to operate a peripheral at the register level via either of these two header files.
      - Y
      - If certain signals of a peripheral are mapped to a particular pin of the {IDF_TARGET_NAME}, their mappings are defined in this header as C macros.
      - N
      - This header is mainly used"
" as a convenience header file to automatically include ``xxx_caps.h``, ``xxx_struct.h``, and ``xxx_reg.h``.
      - N
      - This header contains type definitions and macros that are shared among the LL, HAL, and driver layers. Moreover, it is considered public API thus can be included by the application level. The shared types and definitions usually related to non-implementation specific concepts such as the following:

          - Protocol-related types/macros such a frames, modes, common bu"
"s speeds, etc.
          - Features/characteristics of an ``xxx`` peripheral that are likely to be present on any implementation (implementation-independent) such as channels, operating modes, signal amplification or attenuation intensities, etc.
      - Y
      - This header contains the Low Level (LL) Layer of hardware abstraction. LL Layer API are primarily used to abstract away register operations into readable functions.
      - Y
      - The Hardware Abstraction Layer (HAL) is used to abst"
"ract away peripheral operation steps into functions (e.g., reading a buffer, starting a transmission, handling an event, etc). The HAL is built on top of the LL Layer.
      - N
      - The driver layer is the highest level of ESP-IDF's hardware abstraction. Driver layer API are meant to be called from ESP-IDF applications, and internally utilize OS primitives. Thus, driver layer API are event-driven, and can used in a multi-threaded environment.


.. _hw-abstraction-ll-layer:

LL (Low Level) La"
"yer


The primary purpose of the LL Layer is to abstract away register field access into more easily understandable functions. LL functions essentially translate various in/out arguments into the register fields of a peripheral in the form of get/set functions. All the necessary bit shifting, masking, offsetting, and endianness of the register fields should be handled by the LL functions.

.. code-block:: c

    //Inside xxx_ll.h

    static inline void xxx_ll_set_baud_rate(xxx_dev_t *hw,
      "
"                                      xxx_ll_clk_src_t clock_source,
                                            uint32_t baud_rate) {
        uint32_t src_clk_freq = (source_clk == XXX_SCLK_APB) ? APB_CLK_FREQ : REF_CLK_FREQ;
        uint32_t clock_divider = src_clk_freq / baud;
        // Set clock select field
        hw->clk_div_reg.divider = clock_divider >> 4;
        // Set clock divider field
        hw->config.clk_sel = (source_clk == XXX_SCLK_APB) ? 0 : 1;
    }

    static inline uint"
"32_t xxx_ll_get_rx_byte_count(xxx_dev_t *hw) {
        return hw->status_reg.rx_cnt;
    }

The code snippet above illustrates typical LL functions for a peripheral ``xxx``. LL functions typically have the following characteristics:

- All LL functions are defined as ``static inline`` so that there is minimal overhead when calling these functions due to compiler optimization. These functions are not guaranteed to be inlined by the compiler, so any LL function that is called when the cache is dis"
"abled (e.g., from an IRAM ISR context) should be marked with ``__attribute__((always_inline))``.
- The first argument should be a pointer to a ``xxx_dev_t`` type. The ``xxx_dev_t`` type is a structure representing the peripheral's registers, thus the first argument is always a pointer to the starting address of the peripheral's registers. Note that in some cases where the peripheral has multiple channels with identical register layouts, ``xxx_dev_t *hw`` may point to the registers of a particula"
"r channel instead.
- LL functions should be short, and in most cases are deterministic. In other words, in the worst case, runtime of the LL function can be determined at compile time. Thus, any loops in LL functions should be finite bounded; however, there are currently a few exceptions to this rule.
- LL functions are not thread-safe, it is the responsibility of the upper layers (driver layer) to ensure that registers or register fields are not accessed concurrently.


.. _hw-abstraction-hal-l"
"ayer:

HAL (Hardware Abstraction Layer)


The HAL layer models the operational process of a peripheral as a set of general steps, where each step has an associated function. For each step, the details of a peripheral's register implementation (i.e., which registers need to be set/read) are hidden (abstracted away) by the HAL. By modeling peripheral operation as a set of functional steps, any minor hardware implementation differences of the peripheral between different targets or chip versions ca"
"n be abstracted away by the HAL (i.e., handled transparently). In other words, the HAL API for a particular peripheral remains mostly the same across multiple targets/chip versions.

The following HAL function examples are selected from the Watchdog Timer HAL as each function maps to one of the steps in a WDT's operation life cycle, thus illustrating how a HAL abstracts a peripheral's operation into functional steps.

.. code-block:: c

    // Initialize one of the WDTs
    void wdt_hal_init(wdt"
"_hal_context_t *hal, wdt_inst_t wdt_inst, uint32_t prescaler, bool enable_intr);

    // Configure a particular timeout stage of the WDT
    void wdt_hal_config_stage(wdt_hal_context_t *hal, wdt_stage_t stage, uint32_t timeout, wdt_stage_action_t behavior);

    // Start the WDT
    void wdt_hal_enable(wdt_hal_context_t *hal);

    // Feed (i.e., reset) the WDT
    void wdt_hal_feed(wdt_hal_context_t *hal);

    // Handle a WDT timeout
    void wdt_hal_handle_intr(wdt_hal_context_t *hal);

    /"
"/ Stop the WDT
    void wdt_hal_disable(wdt_hal_context_t *hal);

    // De-initialize the WDT
    void wdt_hal_deinit(wdt_hal_context_t *hal);

.. _hw-abstraction-hal-layer-disable-rtc-wdt:

To Disable RTC_WDT


.. code-block:: c

    wdt_hal_context_t rtc_wdt_ctx = RWDT_HAL_CONTEXT_DEFAULT();
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
    wdt_hal_disable(&rtc_wdt_ctx);
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);

.. _hw-abstraction-hal-layer-feed-rtc-wdt:

To Reset the RTC_WDT Counte"
"r


.. code-block:: c

    wdt_hal_context_t rtc_wdt_ctx = RWDT_HAL_CONTEXT_DEFAULT();
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
    wdt_hal_feed(&rtc_wdt_ctx);
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);

HAL functions generally have the following characteristics:

- The first argument to a HAL function has the ``xxx_hal_context_t *`` type. The HAL context type is used to store information about a particular instance of the peripheral (i.e., the context instance). A HAL context is in"
"itialized by the ``xxx_hal_init()`` function and can store information such as the following:

    - The channel number of this instance
    - Pointer to the peripheral's (or channel's) registers  (i.e., a ``xxx_dev_t *`` type)
    - Information about an ongoing transaction (e.g., pointer to DMA descriptor list in use)
    - Some configuration values for the instance (e.g., channel configurations)
    - Variables to maintain state information regarding the instance (e.g., a flag to indicate if t"
"he instance is waiting for transaction to complete)

- HAL functions should not contain any OS primitives such as queues, semaphores, mutexes, etc. All synchronization/concurrency should be handled at higher layers (e.g., the driver).
- Some peripherals may have steps that cannot be further abstracted by the HAL, thus end up being a direct wrapper (or macro) for an LL function.
- Some HAL functions may be placed in IRAM thus may carry an ``IRAM_ATTR`` or be placed in a separate ``xxx_hal_iram.c`"
"` source file.
"
"Build System




This document explains the implementation of the ESP-IDF build system and the concept of ""components"". Read this document if you want to know how to organize and build a new ESP-IDF project or component.


Overview


An ESP-IDF project can be seen as an amalgamation of a number of components. For example, for a web server that shows the current humidity, there could be:

- The ESP-IDF base libraries (libc, ROM bindings, etc)
- The Wi-Fi drivers
- A TCP/IP stack
- The FreeRTOS op"
"erating system
- A web server
- A driver for the humidity sensor
- Main code tying it all together

ESP-IDF makes these components explicit and configurable. To do that, when a project is compiled, the build system will look up all the components in the ESP-IDF directories, the project directories and (optionally) in additional custom component directories. It then allows the user to configure the ESP-IDF project using a text-based menu system to customize each component. After the components in"
" the project are configured, the build system will compile the project.


Concepts


- A ""project"" is a directory that contains all the files and configuration to build a single ""app"" (executable), as well as additional supporting elements such as a partition table, data/filesystem partitions, and a bootloader.

- ""Project configuration"" is held in a single file called ``sdkconfig`` in the root directory of the project. This configuration file is modified via ``idf.py menuconfig`` to customize t"
"he configuration of the project. A single project contains exactly one project configuration.

- An ""app"" is an executable that is built by ESP-IDF. A single project will usually build two apps - a ""project app"" (the main executable, ie your custom firmware) and a ""bootloader app"" (the initial bootloader program which launches the project app).

- ""components"" are modular pieces of standalone code that are compiled into static libraries (.a files) and linked to an app. Some are provided by ESP-I"
"DF itself, others may be sourced from other places.

- ""Target"" is the hardware for which an application is built. A full list of supported targets in your version of ESP-IDF can be seen by running `idf.py --list-targets`.

Some things are not part of the project:

- ""ESP-IDF"" is not part of the project. Instead, it is standalone, and linked to the project via the ``IDF_PATH`` environment variable which holds the path of the ``esp-idf`` directory. This allows the ESP-IDF framework to be decouple"
"d from your project.

- The toolchain for compilation is not part of the project. The toolchain should be installed in the system command line PATH.


Using the Build System


.. _idf.py:

``idf.py``


The ``idf.py`` command-line tool provides a front-end for easily managing your project builds. It manages the following tools:

- CMake_, which configures the project to be built
- Ninja_ which builds the project
- `esptool.py`_ for flashing the target.

You can read more about configuring the bui"
"ld system using ``idf.py`` :doc:`here `.


Using CMake Directly


:ref:`idf.py` is a wrapper around CMake_ for convenience. However, you can also invoke CMake directly if you prefer.

.. highlight:: bash

When ``idf.py`` does something, it prints each command that it runs for easy reference. For example, the ``idf.py build`` command is the same as running these commands in a bash shell (or similar commands for Windows Command Prompt)::

  mkdir -p build
  cd build
  cmake .. -G Ninja   # or 'Uni"
"x Makefiles'
  ninja

In the above list, the ``cmake`` command configures the project and generates build files for use with the final build tool. In this case, the final build tool is Ninja_: running ``ninja`` actually builds the project.

It's not necessary to run ``cmake`` more than once. After the first build, you only need to run ``ninja`` each time. ``ninja`` will automatically re-invoke ``cmake`` if the project needs reconfiguration.

If using CMake with ``ninja`` or ``make``, there are a"
"lso targets for more of the ``idf.py`` sub-commands. For example, running ``make menuconfig`` or ``ninja menuconfig`` in the build directory will work the same as ``idf.py menuconfig``.

.. note::

   If you're already familiar with CMake_, you may find the ESP-IDF CMake-based build system unusual because it wraps a lot of CMake's functionality to reduce boilerplate. See `writing pure CMake components`_ for some information about writing more ""CMake style"" components.


.. _flash-with-ninja-or-m"
"ake:

Flashing with Ninja or Make


It's possible to build and flash directly from ninja or make by running a target like::

  ninja flash

Or::

  make app-flash

Available targets are: ``flash``, ``app-flash`` (app only), ``bootloader-flash`` (bootloader only).

When flashing this way, optionally set the ``ESPPORT`` and ``ESPBAUD`` environment variables to specify the serial port and baud rate. You can set environment variables in your operating system or IDE project. Alternatively, set them d"
"irectly on the command line::

  ESPPORT=/dev/ttyUSB0 ninja flash

.. note::

  Providing environment variables at the start of the command like this is Bash shell Syntax. It will work on Linux and macOS. It won't work when using Windows Command Prompt, but it will work when using Bash-like shells on Windows.

Or::

  make -j3 app-flash ESPPORT=COM4 ESPBAUD=2000000

.. note::

  Providing variables at the end of the command line is ``make`` syntax, and works for ``make`` on all platforms.


Usin"
"g CMake in an IDE


You can also use an IDE with CMake integration. The IDE will want to know the path to the project's ``CMakeLists.txt`` file. IDEs with CMake integration often provide their own build tools (CMake calls these ""generators"") to build the source files as part of the IDE.

When adding custom non-build steps like ""flash"" to the IDE, it is recommended to execute ``idf.py`` for these ""special"" commands.

For more detailed information about integrating ESP-IDF with CMake into an IDE, "
"see `Build System Metadata`_.


.. _setting-python-interpreter:

Setting up the Python Interpreter


ESP-IDF works well with Python version 3.8+.

``idf.py`` and other Python scripts will run with the default Python interpreter, i.e., ``python``. You can switch to a different one like ``python3 $IDF_PATH/tools/idf.py ...``, or you can set up a shell alias or another script to simplify the command.

If using CMake directly, running ``cmake -D PYTHON=python3 ...`` will cause CMake to override the "
"default Python interpreter.

If using an IDE with CMake, setting the ``PYTHON`` value as a CMake cache override in the IDE UI will override the default Python interpreter.

To manage the Python version more generally via the command line, check out the tools pyenv_ or virtualenv_. These let you change the default Python version.


.. _example-project-structure:

Example Project


.. highlight:: none

An example project directory tree might look like this::

    - myProject/
                 - CM"
"akeLists.txt
                 - sdkconfig
                 - bootloader_components/ - boot_component/ - CMakeLists.txt
                                                            - Kconfig
                                                            - src1.c
                 - components/ - component1/ - CMakeLists.txt
                                             - Kconfig
                                             - src1.c
                               - component2/ - CMakeLists.txt
         "
"                                    - Kconfig
                                             - src1.c
                                             - include/ - component2.h
                 - main/       - CMakeLists.txt
                               - src1.c
                               - src2.c

                 - build/

This example ""myProject"" contains the following elements:

- A top-level project CMakeLists.txt file. This is the primary file which CMake uses to learn how to build the pro"
"ject; and may set project-wide CMake variables. It includes the file :idf_file:`/tools/cmake/project.cmake` which implements the rest of the build system. Finally, it sets the project name and defines the project.

- ""sdkconfig"" project configuration file. This file is created/updated when ``idf.py menuconfig`` runs, and holds the configuration for all of the components in the project (including ESP-IDF itself). The ``sdkconfig`` file may or may not be added to the source control system of the p"
"roject.

- Optional ""bootloader_components"" directory contains components that need to be compiled and linked inside the bootloader project. A project does not have to contain custom bootloader components of this kind, but it can be useful in case the bootloader needs to be modified to embed new features.

- Optional ""components"" directory contains components that are part of the project. A project does not have to contain custom components of this kind, but it can be useful for structuring reus"
"able code or including third-party components that aren't part of ESP-IDF. Alternatively, ``EXTRA_COMPONENT_DIRS`` can be set in the top-level CMakeLists.txt to look for components in other places.

- ""main"" directory is a special component that contains source code for the project itself. ""main"" is a default name, the CMake variable ``COMPONENT_DIRS`` includes this component but you can modify this variable. See the :ref:`renaming main ` section for more info. If you have a lot of source files "
"in your project, we recommend grouping most into components instead of putting them all in ""main"".

- ""build"" directory is where the build output is created. This directory is created by ``idf.py`` if it doesn't already exist. CMake configures the project and generates interim build files in this directory. Then, after the main build process is run, this directory will also contain interim object files and libraries as well as final binary output files. This directory is usually not added to sou"
"rce control or distributed with the project source code.

Component directories each contain a component ``CMakeLists.txt`` file. This file contains variable definitions to control the build process of the component, and its integration into the overall project. See `Component CMakeLists Files`_ for more details.

Each component may also include a ``Kconfig`` file defining the `component configuration`_ options that can be set via ``menuconfig``. Some components may also include ``Kconfig.projbu"
"ild`` and ``project_include.cmake`` files, which are special files for `overriding parts of the project`_.


Project CMakeLists File


Each project has a single top-level ``CMakeLists.txt`` file that contains build settings for the entire project. By default, the project CMakeLists can be quite minimal.


Minimal Example CMakeLists


.. highlight:: cmake

Minimal project::

      cmake_minimum_required(VERSION 3.16)
      include($ENV{IDF_PATH}/tools/cmake/project.cmake)
      project(myProject)"
"


.. _project-mandatory-parts:

Mandatory Parts


The inclusion of these three lines, in the order shown above, is necessary for every project:

- ``cmake_minimum_required(VERSION 3.16)`` tells CMake the minimum version that is required to build the project. ESP-IDF is designed to work with CMake 3.16 or newer. This line must be the first line in the CMakeLists.txt file.
- ``include($ENV{IDF_PATH}/tools/cmake/project.cmake)`` pulls in the rest of the CMake functionality to configure the project"
", discover all the components, etc.
- ``project(myProject)`` creates the project itself, and specifies the project name. The project name is used for the final binary output files of the app - ie ``myProject.elf``, ``myProject.bin``. Only one project can be defined per CMakeLists file.


.. _optional_project_variable:

Optional Project Variables


These variables all have default values that can be overridden for custom behavior. Look in :idf_file:`/tools/cmake/project.cmake` for all of the impl"
"ementation details.

- ``COMPONENT_DIRS``: Directories to search for components. Defaults to ``IDF_PATH/components``, ``PROJECT_DIR/components``, and ``EXTRA_COMPONENT_DIRS``. Override this variable if you don't want to search for components in these places.

- ``EXTRA_COMPONENT_DIRS``: Optional list of additional directories to search for components. Paths can be relative to the project directory, or absolute.

- ``COMPONENTS``: A list of component names to build into the project. Defaults to a"
"ll components found in the ``COMPONENT_DIRS`` directories. Use this variable to ""trim down"" the project for faster build times. Note that any component which ""requires"" another component via the REQUIRES or PRIV_REQUIRES arguments on component registration will automatically have it added to this list, so the ``COMPONENTS`` list can be very short.

- ``BOOTLOADER_IGNORE_EXTRA_COMPONENT``: A list of components, placed in ``bootloader_components/``, that should be ignored by the bootloader compila"
"tion. Use this variable if a bootloader component needs to be included conditionally inside the project.

Any paths in these variables can be absolute paths, or set relative to the project directory.

To set these variables, use the `cmake set command `_ ie ``set(VARIABLE ""VALUE"")``. The ``set()`` commands should be placed after the ``cmake_minimum(...)`` line but before the ``include(...)`` line.


.. _rename-main:

Renaming ``main`` Component


The build system provides special treatment to th"
"e ``main`` component. It is a component that gets automatically added to the build provided that it is in the expected location, PROJECT_DIR/main. All other components in the build are also added as its dependencies, saving the user from hunting down dependencies and providing a build that works right out of the box. Renaming the ``main`` component causes the loss of these behind-the-scenes heavy lifting, requiring the user to specify the location of the newly renamed component and manually spec"
"ify its dependencies. Specifically, the steps to renaming ``main`` are as follows:


Overriding Default Build Specifications


The build sets some global build specifications (compile flags, definitions, etc.) that gets used in compiling all sources from all components.

.. highlight:: cmake

For example, one of the default build specifications set is the compile option ``-Wextra``. Suppose a user wants to use override this with ``-Wno-extra``,
it should be done after ``project()``::


    cmake"
"_minimum_required(VERSION 3.16)
    include($ENV{IDF_PATH}/tools/cmake/project.cmake)
    project(myProject)

    idf_build_set_property(COMPILE_OPTIONS ""-Wno-error"" APPEND)

This ensures that the compile options set by the user won't be overridden by the default build specifications, since the latter are set inside ``project()``.


.. _component-directories:

Component CMakeLists Files


Each project contains one or more components. Components can be part of ESP-IDF, part of the project's own c"
"omponents directory, or added from custom component directories (:ref:`see above `).

A component is any directory in the ``COMPONENT_DIRS`` list which contains a ``CMakeLists.txt`` file.


Searching for Components


The list of directories in ``COMPONENT_DIRS`` is searched for the project's components. Directories in this list can either be components themselves (ie they contain a `CMakeLists.txt` file), or they can be top-level directories whose sub-directories are components.

When CMake runs"
" to configure the project, it logs the components included in the build. This list can be useful for debugging the inclusion/exclusion of certain components.


.. _cmake-components-same-name:

Multiple Components with the Same Name


When ESP-IDF is collecting all the components to compile, it will do this in the order specified by ``COMPONENT_DIRS``; by default, this means ESP-IDF's internal components first (``IDF_PATH/components``), then any components in directories specified in ``EXTRA_COMP"
"ONENT_DIRS``, and finally the project's components (``PROJECT_DIR/components``). If two or more of these directories contain component sub-directories with the same name, the component in the last place searched is used. This allows, for example, overriding ESP-IDF components with a modified version by copying that component from the ESP-IDF components directory to the project components directory and then modifying it there. If used in this way, the ESP-IDF directory itself can remain untouched"
".

.. note::

  If a component is overridden in an existing project by moving it to a new location, the project will not automatically see the new component path. Run ``idf.py reconfigure`` (or delete the project build folder) and then build again.


.. _cmake_minimal_component_cmakelists:

Minimal Component CMakeLists


.. highlight:: cmake

The minimal component ``CMakeLists.txt`` file simply registers the component to the build system using ``idf_component_register``::

  idf_component_regist"
"er(SRCS ""foo.c"" ""bar.c""
                         INCLUDE_DIRS ""include""
                         REQUIRES mbedtls)

- ``SRCS`` is a list of source files (``*.c``, ``*.cpp``, ``*.cc``, ``*.S``). These source files will be compiled into the component library.
- ``INCLUDE_DIRS`` is a list of directories to add to the global include search path for any component which requires this component, and also the main source files.
- ``REQUIRES`` is not actually required, but it is very often required to de"
"clare what other components this component will use. See :ref:`component requirements `.

A library with the name of the component will be built and linked to the final app.

Directories are usually specified relative to the ``CMakeLists.txt`` file itself, although they can be absolute.

There are other arguments that can be passed to ``idf_component_register``. These arguments are discussed :ref:`here `.

See `example component requirements`_ and  `example component CMakeLists`_ for more comple"
"te component ``CMakeLists.txt`` examples.


.. _preset_component_variables:

Preset Component Variables


The following component-specific variables are available for use inside component CMakeLists, but should not be modified:

- ``COMPONENT_DIR``: The component directory. Evaluates to the absolute path of the directory containing ``CMakeLists.txt``. The component path cannot contain spaces. This is the same as the ``CMAKE_CURRENT_SOURCE_DIR`` variable.
- ``COMPONENT_NAME``: Name of the compone"
"nt. Same as the name of the component directory.
- ``COMPONENT_ALIAS``: Alias of the library created internally by the build system for the component.
- ``COMPONENT_LIB``: Name of the library created internally by the build system for the component.

The following variables are set at the project level, but available for use in component CMakeLists:

- ``CONFIG_*``: Each value in the project configuration has a corresponding variable available in cmake. All names begin with ``CONFIG_``. :doc:`Mo"
"re information here `.
- ``ESP_PLATFORM``: Set to 1 when the CMake file is processed within the ESP-IDF build system.


Build/Project Variables


The following are some project/build variables that are available as build properties and whose values can be queried using ``idf_build_get_property`` from the component CMakeLists.txt:

- ``PROJECT_NAME``: Name of the project, as set in project CMakeLists.txt file.
- ``PROJECT_DIR``: Absolute path of the project directory containing the project CMakeL"
"ists. Same as the ``CMAKE_SOURCE_DIR`` variable.
- ``COMPONENTS``: Names of all components that are included in this build, formatted as a semicolon-delimited CMake list.
- ``IDF_VER``: Git version of ESP-IDF (produced by ``git describe``)
- ``IDF_VERSION_MAJOR``, ``IDF_VERSION_MINOR``, ``IDF_VERSION_PATCH``: Components of ESP-IDF version, to be used in conditional expressions. Note that this information is less precise than that provided by ``IDF_VER`` variable. ``v4.0-dev-*``, ``v4.0-beta1``, "
"``v4.0-rc1`` and ``v4.0`` will all have the same values of ``IDF_VERSION_*`` variables, but different ``IDF_VER`` values.
- ``IDF_TARGET``: Name of the target for which the project is being built.
- ``PROJECT_VER``: Project version.
- ``EXTRA_PARTITION_SUBTYPES``: CMake list of extra partition subtypes. Each subtype description is a comma-separated string with ``type_name, subtype_name, numeric_value`` format. Components may add new subtypes by appending them to this list.

Other build propertie"
"s are listed :ref:`here `.


.. _component_build_control:

Controlling Component Compilation


.. highlight:: cmake

To pass compiler options when compiling source files belonging to a particular component, use the `target_compile_options`_ function::

  target_compile_options(${COMPONENT_LIB} PRIVATE -Wno-unused-variable)

To apply the compilation flags to a single source file, use the CMake `set_source_files_properties`_ command::

    set_source_files_properties(mysrc.c
        PROPERTIES COM"
"PILE_FLAGS
        -Wno-unused-variable
    )

This can be useful if there is upstream code that emits warnings.

.. note::

    CMake `set_source_files_properties`_ command is not applicable when the source files have been populated with help of the ``SRC_DIRS`` variable in ``idf_component_register``. See :ref:`cmake-file-globbing` for more details.

When using these commands, place them after the call to ``idf_component_register`` in the component CMakeLists file.


.. _component-configuration"
":

Component Configuration


Each component can also have a ``Kconfig`` file, alongside ``CMakeLists.txt``. This contains configuration settings to add to the configuration menu for this component.

These settings are found under the ""Component Settings"" menu when menuconfig is run.

To create a component Kconfig file, it is easiest to start with one of the Kconfig files distributed with ESP-IDF.

For an example, see `Adding conditional configuration`_.


Preprocessor Definitions


The ESP-IDF b"
"uild system adds the following C preprocessor definitions on the command line:

- ``ESP_PLATFORM`` : Can be used to detect that build happens within ESP-IDF.
- ``IDF_VER`` : Defined to a git version string.  E.g. ``v2.0`` for a tagged release or ``v1.0-275-g0efaa4f`` for an arbitrary commit.


.. _component-requirements:

Component Requirements


When compiling each component, the ESP-IDF build system recursively evaluates its dependencies. This means each component needs to declare the componen"
"ts that it depends on (""requires"").


When Writing a Component


.. code-block:: cmake

   idf_component_register(...
                          REQUIRES mbedtls
                          PRIV_REQUIRES console spiffs)

- ``REQUIRES`` should be set to all components whose header files are #included from the *public* header files of this component.

- ``PRIV_REQUIRES`` should be set to all components whose header files are #included from *any source files* in this component, unless already listed i"
"n ``REQUIRES``. Also, any component which is required to be linked in order for this component to function correctly.

- The values of ``REQUIRES`` and ``PRIV_REQUIRES`` should not depend on any configuration choices (``CONFIG_xxx`` macros). This is because requirements are expanded before the configuration is loaded. Other component variables (like include paths or source files) can depend on configuration choices.

- Not setting either or both ``REQUIRES`` variables is fine. If the component h"
"as no requirements except for the `Common component requirements`_ needed for RTOS, libc, etc.

If a component only supports some target chips (values of ``IDF_TARGET``) then it can specify ``REQUIRED_IDF_TARGETS`` in the ``idf_component_register`` call to express these requirements. In this case, the build system will generate an error if the component is included in the build, but does not support the selected target.

.. note::

  In CMake terms, ``REQUIRES`` & ``PRIV_REQUIRES`` are approxima"
"te wrappers around the CMake functions ``target_link_libraries(... PUBLIC ...)`` and ``target_link_libraries(... PRIVATE ...)``.


.. _example component requirements:

Example of Component Requirements


Imagine there is a ``car`` component, which uses the ``engine`` component, which uses the ``spark_plug`` component:

.. code-block:: none

    - autoProject/
                 - CMakeLists.txt
                 - components/ - car/ - CMakeLists.txt
                                         - car.c
"
"                                         - car.h
                               - engine/ - CMakeLists.txt
                                         - engine.c
                                         - include/ - engine.h
                               - spark_plug/  - CMakeLists.txt
                                              - spark_plug.c
                                              - spark_plug.h


Car Component


.. highlight:: c

The ``car.h`` header file is the public interface for the"
" ``car`` component. This header includes ``engine.h`` directly because it uses some declarations from this header::

  /* car.h */
  #include ""engine.h""

  #ifdef ENGINE_IS_HYBRID
  #define CAR_MODEL ""Hybrid""
  #endif

And car.c includes ``car.h`` as well::

  /* car.c */
  #include ""car.h""

This means the ``car/CMakeLists.txt`` file needs to declare that ``car`` requires ``engine``:

.. code-block:: cmake

  idf_component_register(SRCS ""car.c""
                    INCLUDE_DIRS "".""
              "
"      REQUIRES engine)

- ``SRCS`` gives the list of source files in the ``car`` component.
- ``INCLUDE_DIRS`` gives the list of public include directories for this component. Because the public interface is ``car.h``, the directory containing ``car.h`` is listed here.
- ``REQUIRES`` gives the list of components required by the public interface of this component. Because ``car.h`` is a public header and includes a header from ``engine``, we include ``engine`` here. This makes sure that any other"
" component which includes ``car.h`` will be able to recursively include the required ``engine.h`` also.


Engine Component


.. highlight:: c

The ``engine`` component also has a public header file ``include/engine.h``, but this header is simpler::

  /* engine.h */
  #define ENGINE_IS_HYBRID

  void engine_start(void);

The implementation is in ``engine.c``::

  /* engine.c */
  #include ""engine.h""
  #include ""spark_plug.h""

  ...

In this component, ``engine`` depends on ``spark_plug`` but thi"
"s is a private dependency. ``spark_plug.h`` is needed to compile ``engine.c``, but not needed to include ``engine.h``.

This means that the ``engine/CMakeLists.txt`` file can use ``PRIV_REQUIRES``:

.. code-block:: cmake

  idf_component_register(SRCS ""engine.c""
                    INCLUDE_DIRS ""include""
                    PRIV_REQUIRES spark_plug)

As a result, source files in the ``car`` component don't need the ``spark_plug`` include directories added to their compiler search path. This can "
"speed up compilation, and stops compiler command lines from becoming longer than necessary.


Spark Plug Component


The ``spark_plug`` component doesn't depend on anything else. It has a public header file ``spark_plug.h``, but this doesn't include headers from any other components.

This means that the ``spark_plug/CMakeLists.txt`` file doesn't need any ``REQUIRES`` or ``PRIV_REQUIRES`` clauses:

.. code-block:: cmake

  idf_component_register(SRCS ""spark_plug.c""
                    INCLUDE_DI"
"RS ""."")


Source File Include Directories


Each component's source file is compiled with these include path directories, as specified in the passed arguments to ``idf_component_register``:

.. code-block:: cmake

  idf_component_register(..
                         INCLUDE_DIRS ""include""
                         PRIV_INCLUDE_DIRS ""other"")


- The current component's ``INCLUDE_DIRS`` and ``PRIV_INCLUDE_DIRS``.
- The ``INCLUDE_DIRS`` belonging to all other components listed in the ``REQUIRES`` an"
"d ``PRIV_REQUIRES`` parameters (ie all the current component's public and private dependencies).
- Recursively, all of the ``INCLUDE_DIRS`` of those components ``REQUIRES`` lists (ie all public dependencies of this component's dependencies, recursively expanded).


Main Component Requirements


The component named ``main`` is special because it automatically requires all other components in the build. So it's not necessary to pass ``REQUIRES`` or ``PRIV_REQUIRES`` to this component. See :ref:`re"
"naming main ` for a description of what needs to be changed if no longer using the ``main`` component.


.. _component-common-requirements:

Common Component Requirements


To avoid duplication, every component automatically requires some ""common"" IDF components even if they are not mentioned explicitly. Headers from these components can always be included.

The list of common components is: cxx, newlib, freertos, esp_hw_support, heap, log, soc, hal, esp_rom, esp_common, esp_system, xtensa/riscv"
".


Including Components in the Build


- By default, every component is included in the build.
- If you set the ``COMPONENTS`` variable to a minimal list of components used directly by your project, then the build will expand to also include required components. The full list of components will be:

  - Components mentioned explicitly in ``COMPONENTS``.
  - Those components' requirements (evaluated recursively).
  - The ""common"" components that every component depends on.

- Setting ``COMPONENT"
"S`` to the minimal list of required components can significantly reduce compile times.


.. _component-circular-dependencies:

Circular Dependencies


It's possible for a project to contain Component A that requires (``REQUIRES`` or ``PRIV_REQUIRES``) Component B, and Component B that requires Component A. This is known as a dependency cycle or a circular dependency.

CMake will usually handle circular dependencies automatically by repeating the component library names twice on the linker comman"
"d line. However this strategy doesn't always work, and the build may fail with a linker error about ""Undefined reference to ..."", referencing a symbol defined by one of the components inside the circular dependency. This is particularly likely if there is a large circular dependency, i.e., A > B > C > D > A.

The best solution is to restructure the components to remove the circular dependency. In most cases, a software architecture without circular dependencies has desirable properties of modula"
"rity and clean layering and will be more maintainable in the long term. However, removing circular dependencies is not always possible.

To bypass a linker error caused by a circular dependency, the simplest workaround is to increase the CMake `LINK_INTERFACE_MULTIPLICITY`_ property of one of the component libraries. This causes CMake to repeat this library and its dependencies more than two times on the linker command line.

For example:

.. code-block:: cmake

    set_property(TARGET ${COMPONE"
"NT_LIB} APPEND PROPERTY LINK_INTERFACE_MULTIPLICITY 3)

- This line should be placed after ``idf_component_register`` in the component CMakeLists.txt file.
- If possible, place this line in the component that creates the circular dependency by depending on a lot of other components. However, the line can be placed inside any component that is part of the cycle. Choosing the component that owns the source file shown in the linker error message, or the component that defines the symbol(s) mentione"
"d in the linker error message, is a good place to start.
- Usually increasing the value to 3 (default is 2) is enough, but if this doesn't work then try increasing the number further.
- Adding this option will make the linker command line longer, and the linking stage slower.


Advanced Workaround: Undefined Symbols


If only one or two symbols are causing a circular dependency, and all other dependencies are linear, then there is an alternative method to avoid linker errors: Specify the specifi"
"c symbols required for the ""reverse"" dependency as undefined symbols at link time.

For example, if component A depends on component B but component B also needs to reference ``reverse_ops`` from component A (but nothing else), then you can add a line like the following to the component B CMakeLists.txt to resolve the cycle at link time:

.. code-block:: cmake

    # This symbol is provided by 'Component A' at link time
    target_link_libraries(${COMPONENT_LIB} INTERFACE ""-u reverse_ops"")

- Th"
"e ``-u`` argument means that the linker will always include this symbol in the link, regardless of dependency ordering.
- This line should be placed after ``idf_component_register`` in the component CMakeLists.txt file.
- If 'Component B' doesn't need to access any headers of 'Component A', only link to a few symbol(s), then this line can be used instead of any ``REQUIRES`` from B to A. This further simplifies the component structure in the build system.

See the `target_link_libraries`_ documen"
"tation for more information about this CMake function.


.. _component-requirements-implementation:

Requirements in the Build System Implementation


- Very early in the CMake configuration process, the script ``expand_requirements.cmake`` is run. This script does a partial evaluation of all component CMakeLists.txt files and builds a graph of component requirements (this :ref:`graph may have cycles `). The graph is used to generate a file ``component_depends.cmake`` in the build directory.
- T"
"he main CMake process then includes this file and uses it to determine the list of components to include in the build (internal ``BUILD_COMPONENTS`` variable). The ``BUILD_COMPONENTS`` variable is sorted so dependencies are listed first, however, as the component dependency graph has cycles this cannot be guaranteed for all components. The order should be deterministic given the same set of components and component dependencies.
- The value of ``BUILD_COMPONENTS`` is logged by CMake as ""Componen"
"t names: ""
- Configuration is then evaluated for the components included in the build.
- Each component is included in the build normally and the CMakeLists.txt file is evaluated again to add the component libraries to the build.


Component Dependency Order


The order of components in the ``BUILD_COMPONENTS`` variable determines other orderings during the build:

- Order that :ref:`project_include.cmake` files are included in the project.
- Order that the list of header paths is generated for "
"compilation (via ``-I`` argument). (Note that for a given component's source files, only that component's dependency's header paths are passed to the compiler.)


Adding Link-Time Dependencies


.. highlight:: cmake

The ESP-IDF CMake helper function ``idf_component_add_link_dependency`` adds a link-only dependency between one component and another. In almost all cases, it is better to use the ``PRIV_REQUIRES`` feature in ``idf_component_register`` to create a dependency. However, in some cases,"
" it's necessary to add the link-time dependency of another component to this component, i.e., the reverse order to ``PRIV_REQUIRES`` (for example: :doc:`/api-reference/peripherals/spi_flash/spi_flash_override_driver`).

To make another component depend on this component at link time::

  idf_component_add_link_dependency(FROM other_component)

Place this line after the line with ``idf_component_register``.

It's also possible to specify both components by name::

  idf_component_add_link_depende"
"ncy(FROM other_component TO that_component)


.. _override_project_config:

Overriding Parts of the Project


.. _project_include.cmake:

Project_include.cmake


For components that have build requirements that must be evaluated before any component CMakeLists files are evaluated, you can create a file called ``project_include.cmake`` in the component directory. This CMake file is included when ``project.cmake`` is evaluating the entire project.

``project_include.cmake`` files are used inside E"
"SP-IDF, for defining project-wide build features such as ``esptool.py`` command line arguments and the ``bootloader`` ""special app"".

Unlike component ``CMakeLists.txt`` files, when including a ``project_include.cmake`` file the current source directory (``CMAKE_CURRENT_SOURCE_DIR`` and working directory) is the project directory. Use the variable ``COMPONENT_DIR`` for the absolute directory of the component.

Note that ``project_include.cmake`` isn't necessary for the most common component uses"
", such as adding include directories to the project, or ``LDFLAGS`` to the final linking step. These values can be customized via the ``CMakeLists.txt`` file itself. See `Optional Project Variables`_ for details.

``project_include.cmake`` files are included in the order given in ``BUILD_COMPONENTS`` variable (as logged by CMake). This means that a component's ``project_include.cmake`` file will be included after it's all dependencies' ``project_include.cmake`` files, unless both components are "
"part of a dependency cycle. This is important if a ``project_include.cmake`` file relies on variables set by another component. See also :ref:`above `.

Take great care when setting variables or targets in a ``project_include.cmake`` file. As the values are included in the top-level project CMake pass, they can influence or break functionality across all components!


KConfig.projbuild


This is an equivalent to ``project_include.cmake`` for :ref:`component-configuration` KConfig files. If you w"
"ant to include configuration options at the top level of menuconfig, rather than inside the ""Component Configuration"" sub-menu, then these can be defined in the KConfig.projbuild file alongside the ``CMakeLists.txt`` file.

Take care when adding configuration values in this file, as they will be included across the entire project configuration. Where possible, it's generally better to create a KConfig file for :ref:`component-configuration`.


Wrappers to Redefine or Extend Existing Functions


"
"Thanks to the linker's wrap feature, it is possible to redefine or extend the behavior of an existing ESP-IDF function. To do so, you will need to provide the following CMake declaration in your project's ``CMakeLists.txt`` file:

.. code-block:: cmake

    target_link_libraries(${COMPONENT_LIB} INTERFACE ""-Wl,--wrap=function_to_redefine"")

Where ``function_to_redefine`` is the name of the function to redefine or extend. This option will let the linker replace all the calls to ``function_to_rede"
"fine`` functions in the binary libraries with calls to ``__wrap_function_to_redefine`` function. Thus, you must define this new symbol in your application.

The linker will provide a new symbol named ``__real_function_to_redefine`` which points to the former implementation of the function to redefine. It can be called from the new implementation, making it an extension of the former one.

This mechanism is shown in the example :example:`build_system/wrappers`. Check :idf_file:`examples/build_sys"
"tem/wrappers/README.md` for more details.


Override the Default Bootloader


Thanks to the optional ``bootloader_components`` directory present in your ESP-IDf project, it is possible to override the default ESP-IDF bootloader. To do so, a new ``bootloader_components/main`` component should be defined, which will make the project directory tree look like the following:

    - myProject/
                 - CMakeLists.txt
                 - sdkconfig
                 - bootloader_components/ - ma"
"in/ - CMakeLists.txt
                                                  - Kconfig
                                                  - my_bootloader.c
                 - main/       - CMakeLists.txt
                               - app_main.c

                 - build/


Here the ``my_bootloader.c`` file becomes source code for the new bootloader, which means that it will need to perform all the required operations to set up and load the ``main`` application from flash.

It is also possible to con"
"ditionally replace the bootloader depending on a certain condition, such as the target for example. This can be achieved thanks to the ``BOOTLOADER_IGNORE_EXTRA_COMPONENT`` CMake variable. This list can be used to tell the ESP-IDF bootloader project to ignore and not compile the given components present in ``bootloader_components``. For example, if one wants to use the default bootloader for ESP32 target, then ``myProject/CMakeLists.txt`` should look like the following::

    include($ENV{IDF_PA"
"TH}/tools/cmake/project.cmake)

    if(${IDF_TARGET} STREQUAL ""esp32"")
        set(BOOTLOADER_IGNORE_EXTRA_COMPONENT ""main"")
    endif()

    project(main)

It is important to note that this can also be used for any other bootloader components than ``main``. In all cases, the prefix ``bootloader_component`` must not be specified.

See :example:`custom_bootloader/bootloader_override` for an example of overriding the default bootloader.


.. _config_only_component:

Configuration-Only Components

"
"
Special components which contain no source files, only ``Kconfig.projbuild`` and ``KConfig``, can have a one-line ``CMakeLists.txt`` file which calls the function ``idf_component_register()`` with no arguments specified. This function will include the component in the project build, but no library will be built *and* no header files will be added to any included paths.


Debugging CMake


For full details about CMake_ and CMake commands, see the `CMake v3.16 documentation`_.

Some tips for debu"
"gging the ESP-IDF CMake-based build system:

- When CMake runs, it prints quite a lot of diagnostic information including lists of components and component paths.
- Running ``cmake -DDEBUG=1`` will produce more verbose diagnostic output from the IDF build system.
- Running ``cmake`` with the ``--trace`` or ``--trace-expand`` options will give a lot of information about control flow. See the `cmake command line documentation`_.

When included from a project CMakeLists file, the ``project.cmake`` "
"file defines some utility modules and global variables and then sets ``IDF_PATH`` if it was not set in the system environment.

It also defines an overridden custom version of the built-in CMake_ ``project`` function. This function is overridden to add all of the ESP-IDF specific project functionality.


.. _warn-undefined-variables:

Warning On Undefined Variables


By default, the function of warnings on undefined variables is disabled.

To enable this function, we can pass the ``--warn-uninit"
"ialized`` flag to CMake_ or pass the ``--cmake-warn-uninitialized`` flag to ``idf.py`` so it will print a warning if an undefined variable is referenced in the build. This can be very useful to find buggy CMake files.

Browse the :idf_file:`/tools/cmake/project.cmake` file and supporting functions in :idf:`/tools/cmake/` for more details.


.. _component_cmakelists_example:


Example Component CMakeLists


Because the build environment tries to set reasonable defaults that will work most of the "
"time, component ``CMakeLists.txt`` can be very small or even empty (see `Minimal Component CMakeLists`_). However, overriding `preset_component_variables`_ is usually required for some functionality.

Here are some more advanced examples of component CMakeLists files.


.. _add_conditional_config:

Adding Conditional Configuration


The configuration system can be used to conditionally compile some files depending on the options selected in the project configuration.

.. highlight:: none

``Kcon"
"fig``::

    config FOO_ENABLE_BAR
        bool ""Enable the BAR feature.""
        help
            This enables the BAR feature of the FOO component.

``CMakeLists.txt``::

    set(srcs ""foo.c"" ""more_foo.c"")

    if(CONFIG_FOO_ENABLE_BAR)
        list(APPEND srcs ""bar.c"")
    endif()

   idf_component_register(SRCS ""${srcs}""
                        ...)

This example makes use of the CMake `if `_ function and `list APPEND `_ function.

This can also be used to select or stub out an implementatio"
"n, as such:

``Kconfig``::

    config ENABLE_LCD_OUTPUT
        bool ""Enable LCD output.""
        help
            Select this if your board has an LCD.

    config ENABLE_LCD_CONSOLE
        bool ""Output console text to LCD""
        depends on ENABLE_LCD_OUTPUT
        help
            Select this to output debugging output to the LCD

    config ENABLE_LCD_PLOT
        bool ""Output temperature plots to LCD""
        depends on ENABLE_LCD_OUTPUT
        help
            Select this to output te"
"mperature plots

.. highlight:: cmake

``CMakeLists.txt``::

    if(CONFIG_ENABLE_LCD_OUTPUT)
       set(srcs lcd-real.c lcd-spi.c)
    else()
       set(srcs lcd-dummy.c)
    endif()

    # We need font if either console or plot is enabled
    if(CONFIG_ENABLE_LCD_CONSOLE OR CONFIG_ENABLE_LCD_PLOT)
       list(APPEND srcs ""font.c"")
    endif()

    idf_component_register(SRCS ""${srcs}""
                        ...)


Conditions Which Depend on the Target


The current target is available to CMak"
"e files via ``IDF_TARGET`` variable.

In addition to that, if target ``xyz`` is used (``IDF_TARGET=xyz``), then Kconfig variable ``CONFIG_IDF_TARGET_XYZ`` will be set.

Note that component dependencies may depend on ``IDF_TARGET`` variable, but not on Kconfig variables. Also one can not use Kconfig variables in ``include`` statements in CMake files, but ``IDF_TARGET`` can be used in such context.


Source Code Generation


Some components will have a situation where a source file isn't supplied "
"with the component itself but has to be generated from another file. Say our component has a header file that consists of the converted binary data of a BMP file, converted using a hypothetical tool called bmp2h. The header file is then included in as C source file called graphics_lib.c::

    add_custom_command(OUTPUT logo.h
         COMMAND bmp2h -i ${COMPONENT_DIR}/logo.bmp -o log.h
         DEPENDS ${COMPONENT_DIR}/logo.bmp
         VERBATIM)

    add_custom_target(logo DEPENDS logo.h)
    a"
"dd_dependencies(${COMPONENT_LIB} logo)

    set_property(DIRECTORY ""${COMPONENT_DIR}"" APPEND PROPERTY
         ADDITIONAL_CLEAN_FILES logo.h)

This answer is adapted from the `CMake FAQ entry `_, which contains some other examples that will also work with ESP-IDF builds.

In this example, logo.h will be generated in the current directory (the build directory) while logo.bmp comes with the component and resides under the component path. Because logo.h is a generated file, it should be cleaned whe"
"n the project is cleaned. For this reason, it is added to the `ADDITIONAL_CLEAN_FILES`_ property.

.. note::

   If generating files as part of the project CMakeLists.txt file, not a component CMakeLists.txt, then use build property ``PROJECT_DIR`` instead of ``${COMPONENT_DIR}`` and ``${PROJECT_NAME}.elf`` instead of ``${COMPONENT_LIB}``.)

If a a source file from another component included ``logo.h``, then ``add_dependencies`` would need to be called to add a dependency between the two compone"
"nts, to ensure that the component source files were always compiled in the correct order.


.. _cmake_embed_data:

Embedding Binary Data


Sometimes you have a file with some binary or text data that you'd like to make available to your component, but you don't want to reformat the file as a C source.

You can specify argument ``EMBED_FILES`` in the component registration, giving space-delimited names of the files to embed::

  idf_component_register(...
                         EMBED_FILES serv"
"er_root_cert.der)

Or if the file is a string, you can use the variable ``EMBED_TXTFILES``. This will embed the contents of the text file as a null-terminated string::

  idf_component_register(...
                         EMBED_TXTFILES server_root_cert.pem)

.. highlight:: c

The file's contents will be added to the .rodata section in flash, and are available via symbol names as follows::

  extern const uint8_t server_root_cert_pem_start[] asm(""_binary_server_root_cert_pem_start"");
  extern c"
"onst uint8_t server_root_cert_pem_end[]   asm(""_binary_server_root_cert_pem_end"");

The names are generated from the full name of the file, as given in ``EMBED_FILES``. Characters /, ., etc. are replaced with underscores. The _binary prefix in the symbol name is added by objcopy and is the same for both text and binary files.

.. highlight:: cmake

To embed a file into a project, rather than a component, you can call the function ``target_add_binary_data`` like this::

  target_add_binary_data(m"
"yproject.elf ""main/data.bin"" TEXT)

Place this line after the ``project()`` line in your project CMakeLists.txt file. Replace ``myproject.elf`` with your project name. The final argument can be ``TEXT`` to embed a null-terminated string, or ``BINARY`` to embed the content as-is.

For an example of using this technique, see the ""main"" component of the file_serving example :example_file:`protocols/http_server/file_serving/main/CMakeLists.txt` - two files are loaded at build time and linked into th"
"e firmware.

.. highlight:: cmake

It is also possible to embed a generated file::

  add_custom_command(OUTPUT my_processed_file.bin
                    COMMAND my_process_file_cmd my_unprocessed_file.bin)
  target_add_binary_data(my_target ""my_processed_file.bin"" BINARY)

In the example above, ``my_processed_file.bin`` is generated from ``my_unprocessed_file.bin`` through some command ``my_process_file_cmd``, then embedded into the target.

To specify a dependence on a target, use the ``DEPEND"
"S`` argument::

  add_custom_target(my_process COMMAND ...)
  target_add_binary_data(my_target ""my_embed_file.bin"" BINARY DEPENDS my_process)

The ``DEPENDS`` argument to ``target_add_binary_data`` ensures that the target executes first.


Code and Data Placements


ESP-IDF has a feature called linker script generation that enables components to define where its code and data will be placed in memory through linker fragment files. These files are processed by the build system, and is used to aug"
"ment the linker script used for linking app binary. See :doc:`Linker Script Generation ` for a quick start guide as well as a detailed discussion of the mechanism.


.. _component-build-full-override:

Fully Overriding the Component Build Process


.. highlight:: cmake

Obviously, there are cases where all these recipes are insufficient for a certain component, for example when the component is basically a wrapper around another third-party component not originally intended to be compiled under "
"this build system. In that case, it's possible to forego the ESP-IDF build system entirely by using a CMake feature called ExternalProject_. Example component CMakeLists::

  # External build process for quirc, runs in source dir and
  # produces libquirc.a
  externalproject_add(quirc_build
      PREFIX ${COMPONENT_DIR}
      SOURCE_DIR ${COMPONENT_DIR}/quirc
      CONFIGURE_COMMAND """"
      BUILD_IN_SOURCE 1
      BUILD_COMMAND make CC=${CMAKE_C_COMPILER} libquirc.a
      INSTALL_COMMAND """"
   "
"   )

   # Add libquirc.a to the build process
   add_library(quirc STATIC IMPORTED GLOBAL)
   add_dependencies(quirc quirc_build)

   set_target_properties(quirc PROPERTIES IMPORTED_LOCATION
        ${COMPONENT_DIR}/quirc/libquirc.a)
   set_target_properties(quirc PROPERTIES INTERFACE_INCLUDE_DIRECTORIES
        ${COMPONENT_DIR}/quirc/lib)

   set_directory_properties( PROPERTIES ADDITIONAL_CLEAN_FILES
        ""${COMPONENT_DIR}/quirc/libquirc.a"")

(The above CMakeLists.txt can be used to create"
" a component named ``quirc`` that builds the quirc_ project using its own Makefile.)

- ``externalproject_add`` defines an external build system.

  - ``SOURCE_DIR``, ``CONFIGURE_COMMAND``, ``BUILD_COMMAND`` and ``INSTALL_COMMAND`` should always be set. ``CONFIGURE_COMMAND`` can be set to an empty string if the build system has no ""configure"" step. ``INSTALL_COMMAND`` will generally be empty for ESP-IDF builds.
  - Setting ``BUILD_IN_SOURCE`` means the build directory is the same as the source d"
"irectory. Otherwise, you can set ``BUILD_DIR``.
  - Consult the ExternalProject_ documentation for more details about ``externalproject_add()``

- The second set of commands adds a library target, which points to the ""imported"" library file built by the external system. Some properties need to be set in order to add include directories and tell CMake where this file is.
- Finally, the generated library is added to `ADDITIONAL_CLEAN_FILES`_. This means ``make clean`` will delete this library. (No"
"te that the other object files from the build won't be deleted.)

.. only:: esp32

   .. note:: When using an external build process with PSRAM, remember to add ``-mfix-esp32-psram-cache-issue`` to the C compiler arguments. See :ref:`CONFIG_SPIRAM_CACHE_WORKAROUND` for details of this flag.


.. _ADDITIONAL_CLEAN_FILES_note:

ExternalProject Dependencies and Clean Builds


CMake has some unusual behavior around external project builds:

- `ADDITIONAL_CLEAN_FILES`_ only works when ""make"" or ""ninj"
"a"" is used as the build system. If an IDE build system is used, it won't delete these files when cleaning.
- However, the ExternalProject_ configure & build commands will *always* be re-run after a clean is run.
- Therefore, there are two alternative recommended ways to configure the external build command:

The best of these approaches for building an external project will depend on the project itself, its build system, and whether you anticipate needing to frequently recompile the project.


."
". _custom-sdkconfig-defaults:

Custom Sdkconfig Defaults


For example projects or other projects where you don't want to specify a full sdkconfig configuration, but you do want to override some key values from the ESP-IDF defaults, it is possible to create a file ``sdkconfig.defaults`` in the project directory. This file will be used when creating a new config from scratch, or when any new config value hasn't yet been set in the ``sdkconfig`` file.

To override the name of this file or to speci"
"fy multiple files, set the ``SDKCONFIG_DEFAULTS`` environment variable or set ``SDKCONFIG_DEFAULTS`` in top-level ``CMakeLists.txt``. File names that are not specified as full paths are resolved relative to current project's directory.

When specifying multiple files, use a semicolon as the list separator. Files listed first will be applied first. If a particular key is defined in multiple files, the definition in the latter file will override definitions from former files.

Some of the IDF exam"
"ples include a ``sdkconfig.ci`` file. This is part of the continuous integration (CI) test framework and is ignored by the normal build process.


Target-dependent Sdkconfig Defaults


If and only if an ``sdkconfig.defaults`` file exists, the build system will also attempt to load defaults from an ``sdkconfig.defaults.TARGET_NAME`` file, where ``TARGET_NAME`` is the value of ``IDF_TARGET``. For example, for ``esp32`` target, default settings will be taken from ``sdkconfig.defaults`` first, and t"
"hen from ``sdkconfig.defaults.esp32``. If there are no generic default settings, an empty ``sdkconfig.defaults`` still needs to be created if the build system should recognize any additional target-dependent ``sdkconfig.defaults.TARGET_NAME`` files.

If ``SDKCONFIG_DEFAULTS`` is used to override the name of defaults file/files, the name of target-specific defaults file will be derived from ``SDKCONFIG_DEFAULTS`` value/values using the rule above. When there are multiple files in ``SDKCONFIG_DEFA"
"ULTS``, target-specific file will be applied right after the file bringing it in, before all latter files in ``SDKCONFIG_DEFAULTS``

For example, if ``SDKCONFIG_DEFAULTS=""sdkconfig.defaults;sdkconfig_devkit1""``, and there is a file ``sdkconfig.defaults.esp32`` in the same folder, then the files will be applied in the following order: (1) sdkconfig.defaults (2) sdkconfig.defaults.esp32 (3) sdkconfig_devkit1.


.. _flash_parameters:

Flash Arguments


There are some scenarios that we want to flash"
" the target board without IDF. For this case we want to save the built binaries, esptool.py and esptool write_flash arguments. It's simple to write a script to save binaries and esptool.py.

After running a project build, the build directory contains binary output files (``.bin`` files) for the project and also the following flashing data files:

- ``flash_project_args`` contains arguments to flash the entire project (app, bootloader, partition table, PHY data if this is configured).
- ``flash_a"
"pp_args`` contains arguments to flash only the app.
- ``flash_bootloader_args`` contains arguments to flash only the bootloader.

.. highlight:: bash

You can pass any of these flasher argument files to ``esptool.py`` as follows::

  python esptool.py --chip esp32 write_flash @build/flash_project_args

Alternatively, it is possible to manually copy the parameters from the argument file and pass them on the command line.

The build directory also contains a generated file ``flasher_args.json`` wh"
"ich contains project flash information, in JSON format. This file is used by ``idf.py`` and can also be used by other tools which need information about the project build.


Building the Bootloader


The bootloader is a special ""subproject"" inside :idf:`/components/bootloader/subproject`. It has its own project CMakeLists.txt file and builds separate .ELF and .BIN files to the main project. However, it shares its configuration and build directory with the main project.

The subproject is inserte"
"d as an external project from the top-level project, by the file :idf_file:`/components/bootloader/project_include.cmake`. The main build process runs CMake for the subproject, which includes discovering components (a subset of the main components) and generating a bootloader-specific config (derived from the main ``sdkconfig``).


.. _write-pure-component:

Writing Pure CMake Components


The ESP-IDF build system ""wraps"" CMake with the concept of ""components"", and helper functions to automatica"
"lly integrate these components into a project build.

However, underneath the concept of ""components"" is a full CMake build system. It is also possible to make a component which is pure CMake.

.. highlight:: cmake

Here is an example minimal ""pure CMake"" component CMakeLists file for a component named ``json``::

  add_library(json STATIC
  cJSON/cJSON.c
  cJSON/cJSON_Utils.c)

  target_include_directories(json PUBLIC cJSON)

- This is actually an equivalent declaration to the IDF ``json`` comp"
"onent :idf_file:`/components/json/CMakeLists.txt`.
- This file is quite simple as there are not a lot of source files. For components with a large number of files, the globbing behavior of ESP-IDF's component logic can make the component CMakeLists style simpler.)
- Any time a component adds a library target with the component name, the ESP-IDF build system will automatically add this to the build, expose public include directories, etc. If a component wants to add a library target with a differ"
"ent name, dependencies will need to be added manually via CMake commands.


Using Third-Party CMake Projects with Components


CMake is used for a lot of open-source C and C++ projects — code that users can tap into for their applications. One of the benefits of having a CMake build system is the ability to import these third-party projects, sometimes even without modification! This allows for users to be able to get functionality that may not yet be provided by a component, or use another libra"
"ry for the same functionality.

.. highlight:: cmake

Importing a library might look like this for a hypothetical library ``foo`` to be used in the ``main`` component::

  # Register the component
  idf_component_register(...)

  # Set values of hypothetical variables that control the build of `foo`
  set(FOO_BUILD_STATIC OFF)
  set(FOO_BUILD_TESTS OFF)

  # Create and import the library targets
  add_subdirectory(foo)

  # Publicly link `foo` to `main` component
  target_link_libraries(main PUB"
"LIC foo)

For an actual example, take a look at :example:`build_system/cmake/import_lib`. Take note that what needs to be done in order to import the library may vary. It is recommended to read up on the library's documentation for instructions on how to import it from other projects. Studying the library's CMakeLists.txt and build structure can also be helpful.

It is also possible to wrap a third-party library to be used as a component in this manner. For example, the :component:`mbedtls` comp"
"onent is a wrapper for Espressif's fork of `mbedtls `_. See its :component_file:`component CMakeLists.txt `.

The CMake variable ``ESP_PLATFORM`` is set to 1 whenever the ESP-IDF build system is being used. Tests such as ``if (ESP_PLATFORM)`` can be used in generic CMake code if special IDF-specific logic is required.


Using ESP-IDF Components from External Libraries


The above example assumes that the external library ``foo`` (or ``tinyxml`` in the case of the ``import_lib`` example) doesn't "
"need to use any ESP-IDF APIs apart from common APIs such as libc, libstdc++, etc. If the external library needs to use APIs provided by other ESP-IDF components, this needs to be specified in the external CMakeLists.txt file by adding a dependency on the library target ``idf::``.

For example, in the ``foo/CMakeLists.txt`` file::

  add_library(foo bar.c fizz.cpp buzz.cpp)

  if(ESP_PLATFORM)
    # On ESP-IDF, bar.c needs to include esp_flash.h from the spi_flash component
    target_link_librar"
"ies(foo PRIVATE idf::spi_flash)
  endif()


Using Prebuilt Libraries with Components


.. highlight:: cmake

Another possibility is that you have a prebuilt static library (``.a`` file), built by some other build process.

The ESP-IDF build system provides a utility function ``add_prebuilt_library`` for users to be able to easily import and use prebuilt libraries::

  add_prebuilt_library(target_name lib_path [REQUIRES req1 req2 ...] [PRIV_REQUIRES req1 req2 ...])

where:

- ``target_name``- nam"
"e that can be used to reference the imported library, such as when linking to other targets
- ``lib_path``- path to prebuilt library; may be an absolute or relative path to the component directory

Optional arguments ``REQUIRES`` and ``PRIV_REQUIRES`` specify dependency on other components. These have the same meaning as the arguments for ``idf_component_register``.

Take note that the prebuilt library must have been compiled for the same target as the consuming project. Configuration relevant t"
"o the prebuilt library must also match. If not paid attention to, these two factors may contribute to subtle bugs in the app.

For an example, take a look at :example:`build_system/cmake/import_prebuilt`.


Using ESP-IDF in Custom CMake Projects


ESP-IDF provides a template CMake project for easily creating an application. However, in some instances the user might already have an existing CMake project or may want to create a custom one. In these cases it is desirable to be able to consume IDF "
"components as libraries to be linked to the user's targets (libraries/executables).

It is possible to do so by using the :ref:`build system APIs provided ` by :idf_file:`tools/cmake/idf.cmake`. For example:

.. code-block:: cmake

  cmake_minimum_required(VERSION 3.16)
  project(my_custom_app C)

  # Include CMake file that provides ESP-IDF CMake build system APIs.
  include($ENV{IDF_PATH}/tools/cmake/idf.cmake)

  # Include ESP-IDF components in the build, may be thought as an equivalent of
  "
"# add_subdirectory() but with some additional processing and magic for ESP-IDF build
  # specific build processes.
  idf_build_process(esp32)

  # Create the project executable and plainly link the newlib component to it using
  # its alias, idf::newlib.
  add_executable(${CMAKE_PROJECT_NAME}.elf main.c)
  target_link_libraries(${CMAKE_PROJECT_NAME}.elf idf::newlib)

  # Let the build system know what the project executable is to attach more targets, dependencies, etc.
  idf_build_executable(${C"
"MAKE_PROJECT_NAME}.elf)

The example in :example:`build_system/cmake/idf_as_lib` demonstrates the creation of an application equivalent to :example:`hello world application ` using a custom CMake project.

.. only:: esp32

   .. note:: The IDF build system can only set compiler flags for source files that it builds. When an external CMakeLists.txt file is used and PSRAM is enabled, remember to add ``-mfix-esp32-psram-cache-issue`` to the C compiler arguments. See :ref:`CONFIG_SPIRAM_CACHE_WORKAR"
"OUND` for details of this flag.


.. _cmake_buildsystem_api:

ESP-IDF CMake Build System API


Idf-build-commands


.. code-block:: none

  idf_build_get_property(var property [GENERATOR_EXPRESSION])

Retrieve a :ref:`build property ` *property* and store it in *var* accessible from the current scope. Specifying *GENERATOR_EXPRESSION* will retrieve the generator expression string for that property, instead of the actual value, which can be used with CMake commands that support generator expressi"
"ons.

.. code-block:: none

  idf_build_set_property(property val [APPEND])

Set a :ref:`build property ` *property* with value *val*. Specifying *APPEND* will append the specified value to the current value of the property. If the property does not previously exist or it is currently empty, the specified value becomes the first element/member instead.

.. code-block:: none

  idf_build_component(component_dir)

Present a directory *component_dir* that contains a component to the build system. R"
"elative paths are converted to absolute paths with respect to current directory.
All calls to this command must be performed before `idf_build_process`.

This command does not guarantee that the component will be processed during build (see the `COMPONENTS` argument description for `idf_build_process`)

.. code-block:: none

  idf_build_process(target
                    [PROJECT_DIR project_dir]
                    [PROJECT_VER project_ver]
                    [PROJECT_NAME project_name]
      "
"              [SDKCONFIG sdkconfig]
                    [SDKCONFIG_DEFAULTS sdkconfig_defaults]
                    [BUILD_DIR build_dir]
                    [COMPONENTS component1 component2 ...])

Performs the bulk of the behind-the-scenes magic for including ESP-IDF components such as component configuration, libraries creation, dependency expansion and resolution. Among these functions, perhaps the most important from a user's perspective is the libraries creation by calling each component's"
" ``idf_component_register``. This command creates the libraries for each component, which are accessible using aliases in the form idf::*component_name*.
These aliases can be used to link the components to the user's own targets, either libraries or executables.

The call requires the target chip to be specified with *target* argument. Optional arguments for the call include:

- PROJECT_DIR - directory of the project; defaults to CMAKE_SOURCE_DIR
- PROJECT_NAME - name of the project; defaults to"
" CMAKE_PROJECT_NAME
- PROJECT_VER - version/revision of the project; defaults to ""1""
- SDKCONFIG - output path of generated sdkconfig file; defaults to PROJECT_DIR/sdkconfig or CMAKE_SOURCE_DIR/sdkconfig depending if PROJECT_DIR is set
- SDKCONFIG_DEFAULTS - list of files containing default config to use in the build (list must contain full paths); defaults to empty. For each value *filename* in the list, the config from file *filename.target*, if it exists, is also loaded.
- BUILD_DIR - directo"
"ry to place ESP-IDF build-related artifacts, such as generated binaries, text files, components; defaults to CMAKE_BINARY_DIR
- COMPONENTS - select components to process among the components known by the build system (added via `idf_build_component`). This argument is used to trim the build.
  Other components are automatically added if they are required in the dependency chain, i.e., the public and private requirements of the components in this list are automatically added, and in turn the publ"
"ic and private requirements of those requirements, so on and so forth. If not specified, all components known to the build system are processed.

.. code-block:: none

  idf_build_executable(executable)

Specify the executable *executable* for ESP-IDF build. This attaches additional targets such as dependencies related to flashing, generating additional binary files, etc. Should be called after ``idf_build_process``.

.. code-block:: none

  idf_build_get_config(var config [GENERATOR_EXPRESSION]"
")

Get the value of the specified config. Much like build properties, specifying *GENERATOR_EXPRESSION* will retrieve the generator expression string for that config, instead of the actual value, which can be used with CMake commands that support generator expressions. Actual config values are only known after call to ``idf_build_process``, however.


.. _cmake-build-properties:

Idf-build-properties


These are properties that describe the build. Values of build properties can be retrieved by u"
"sing the build command ``idf_build_get_property``. For example, to get the Python interpreter used for the build:

.. code-block:: cmake

  idf_build_get_property(python PYTHON)
  message(STATUS ""The Python intepreter is: ${python}"")

- BUILD_DIR - build directory; set from ``idf_build_process`` BUILD_DIR argument
- BUILD_COMPONENTS - list of components included in the build; set by ``idf_build_process``
- BUILD_COMPONENT_ALIASES - list of library alias of components included in the build; set b"
"y ``idf_build_process``
- C_COMPILE_OPTIONS - compile options applied to all components' C source files
- COMPILE_OPTIONS - compile options applied to all components' source files, regardless of it being C or C++
- COMPILE_DEFINITIONS - compile definitions applied to all component source files
- CXX_COMPILE_OPTIONS - compile options applied to all components' C++ source files
- DEPENDENCIES_LOCK - lock file path used in component manager. The default value is `dependencies.lock` under the projec"
"t path.
- EXECUTABLE - project executable; set by call to ``idf_build_executable``
- EXECUTABLE_NAME - name of project executable without extension; set by call to ``idf_build_executable``
- EXECUTABLE_DIR - path containing the output executable
- IDF_COMPONENT_MANAGER - the component manager is enabled by default, but if this property is set to ``0`` it was disabled by the IDF_COMPONENT_MANAGER environment variable
- IDF_PATH - ESP-IDF path; set from IDF_PATH environment variable, if not, infer"
"red from the location of ``idf.cmake``
- IDF_TARGET - target chip for the build; set from the required target argument for ``idf_build_process``
- IDF_VER - ESP-IDF version; set from either a version file or the Git revision of the IDF_PATH repository
- INCLUDE_DIRECTORIES - include directories for all component source files
- KCONFIGS - list of Kconfig files found in components in build; set by ``idf_build_process``
- KCONFIG_PROJBUILDS - list of Kconfig.projbuild files found in components in b"
"uild; set by ``idf_build_process``
- PROJECT_NAME - name of the project; set from ``idf_build_process`` PROJECT_NAME argument
- PROJECT_DIR - directory of the project; set from ``idf_build_process`` PROJECT_DIR argument
- PROJECT_VER - version of the project; set from ``idf_build_process`` PROJECT_VER argument
- PYTHON - Python interpreter used for the build; set from PYTHON environment variable if available, if not ""python"" is used
- SDKCONFIG - full path to output config file; set from ``idf_b"
"uild_process`` SDKCONFIG argument
- SDKCONFIG_DEFAULTS - list of files containing default config to use in the build; set from ``idf_build_process`` SDKCONFIG_DEFAULTS argument
- SDKCONFIG_HEADER - full path to C/C++ header file containing component configuration; set by ``idf_build_process``
- SDKCONFIG_CMAKE - full path to CMake file containing component configuration; set by ``idf_build_process``
- SDKCONFIG_JSON - full path to JSON file containing component configuration; set by ``idf_build_"
"process``
- SDKCONFIG_JSON_MENUS - full path to JSON file containing config menus; set by ``idf_build_process``


Idf-component-commands


.. code-block:: none

  idf_component_get_property(var component property [GENERATOR_EXPRESSION])

Retrieve a specified *component*'s :ref:`component property `, *property* and store it in *var* accessible from the current scope. Specifying *GENERATOR_EXPRESSION* will retrieve the generator expression string for that property, instead of the actual value, whi"
"ch can be used with CMake commands that support generator expressions.

.. code-block:: none

  idf_component_set_property(component property val [APPEND])

Set a specified *component*'s :ref:`component property `, *property* with value *val*. Specifying *APPEND* will append the specified value to the current value of the property. If the property does not previously exist or it is currently empty, the specified value becomes the first element/member instead.

.. _cmake-component-register:

.. c"
"ode-block:: none

  idf_component_register([[SRCS src1 src2 ...] | [[SRC_DIRS dir1 dir2 ...] [EXCLUDE_SRCS src1 src2 ...]]
                         [INCLUDE_DIRS dir1 dir2 ...]
                         [PRIV_INCLUDE_DIRS dir1 dir2 ...]
                         [REQUIRES component1 component2 ...]
                         [PRIV_REQUIRES component1 component2 ...]
                         [LDFRAGMENTS ldfragment1 ldfragment2 ...]
                         [REQUIRED_IDF_TARGETS target1 target2 ...]
"
"                         [EMBED_FILES file1 file2 ...]
                         [EMBED_TXTFILES file1 file2 ...]
                         [KCONFIG kconfig]
                         [KCONFIG_PROJBUILD kconfig_projbuild]
                         [WHOLE_ARCHIVE])

Register a component to the build system. Much like the ``project()`` CMake command, this should be called from the component's CMakeLists.txt directly (not through a function or macro) and is recommended to be called before any other com"
"mand. Here are some guidelines on what commands can **not** be called before ``idf_component_register``:

  - commands that are not valid in CMake script mode
  - custom commands defined in project_include.cmake
  - build system API commands except ``idf_build_get_property``; although consider whether the property may not have been set yet

Commands that set and operate on variables are generally okay to call before ``idf_component_register``.

The arguments for ``idf_component_register`` includ"
"e:

  - SRCS - component source files used for creating a static library for the component; if not specified, component is a treated as a config-only component and an interface library is created instead.
  - SRC_DIRS, EXCLUDE_SRCS - used to glob source files (.c, .cpp, .S) by specifying directories, instead of specifying source files manually via SRCS. Note that this is subject to the :ref:`limitations of globbing in CMake `. Source files specified in EXCLUDE_SRCS are removed from the globbed f"
"iles.
  - INCLUDE_DIRS - paths, relative to the component directory, which will be added to the include search path for all other components which require the current component
  - PRIV_INCLUDE_DIRS - directory paths, must be relative to the component directory, which will be added to the include search path for this component's source files only
  - REQUIRES - public component requirements for the component
  - PRIV_REQUIRES - private component requirements for the component; ignored on config-"
"only components
  - LDFRAGMENTS - component linker fragment files
  - REQUIRED_IDF_TARGETS - specify the only target the component supports
  - KCONFIG - override the default Kconfig file
  - KCONFIG_PROJBUILD - override the default Kconfig.projbuild file
  - WHOLE_ARCHIVE - if specified, the component library is surrounded by ``-Wl,--whole-archive``, ``-Wl,--no-whole-archive`` when linked. This has the same effect as setting ``WHOLE_ARCHIVE`` component property.

The following are used for :ref"
":`embedding data into the component `, and is considered as source files when determining if a component is config-only. This means that even if the component does not specify source files, a static library is still created internally for the component if it specifies either:

  - EMBED_FILES - binary files to be embedded in the component
  - EMBED_TXTFILES - text files to be embedded in the component


.. _cmake-component-properties:

Idf-component-properties


These are properties that describ"
"e a component. Values of component properties can be retrieved by using the build command ``idf_component_get_property``. For example, to get the directory of the ``freertos`` component:

.. code-block:: cmake

  idf_component_get_property(dir freertos COMPONENT_DIR)
  message(STATUS ""The 'freertos' component directory is: ${dir}"")

- COMPONENT_ALIAS - alias for COMPONENT_LIB used for linking the component to external targets; set by ``idf_build_component`` and alias library itself is created by"
" ``idf_component_register``
- COMPONENT_DIR - component directory; set by ``idf_build_component``
- COMPONENT_OVERRIDEN_DIR - contains the directory of the original component if :ref:`this component overrides another component `
- COMPONENT_LIB - name for created component static/interface library; set by ``idf_build_component`` and library itself is created by ``idf_component_register``
- COMPONENT_NAME - name of the component; set by ``idf_build_component`` based on the component directory nam"
"e
- COMPONENT_TYPE - type of the component, whether LIBRARY or CONFIG_ONLY. A component is of type LIBRARY if it specifies source files or embeds a file
- EMBED_FILES - list of files to embed in component; set from ``idf_component_register`` EMBED_FILES argument
- EMBED_TXTFILES - list of text files to embed in component; set from ``idf_component_register`` EMBED_TXTFILES argument
- INCLUDE_DIRS - list of component include directories; set from ``idf_component_register`` INCLUDE_DIRS argument
- "
"KCONFIG - component Kconfig file; set by ``idf_build_component``
- KCONFIG_PROJBUILD - component Kconfig.projbuild; set by ``idf_build_component``
- LDFRAGMENTS - list of component linker fragment files; set from ``idf_component_register`` LDFRAGMENTS argument
- MANAGED_PRIV_REQUIRES - list of private component dependencies added by the IDF component manager from dependencies in ``idf_component.yml`` manifest file
- MANAGED_REQUIRES - list of public component dependencies added by the IDF compon"
"ent manager from dependencies in ``idf_component.yml`` manifest file
- PRIV_INCLUDE_DIRS - list of component private include directories; set from ``idf_component_register`` PRIV_INCLUDE_DIRS on components of type LIBRARY
- PRIV_REQUIRES - list of private component dependencies; set from value of ``idf_component_register`` PRIV_REQUIRES argument and dependencies in ``idf_component.yml`` manifest file
- REQUIRED_IDF_TARGETS - list of targets the component supports; set from ``idf_component_regist"
"er`` EMBED_TXTFILES argument
- REQUIRES - list of public component dependencies; set from value of ``idf_component_register`` REQUIRES argument and dependencies in ``idf_component.yml`` manifest file
- SRCS - list of component source files; set from SRCS or SRC_DIRS/EXCLUDE_SRCS argument of ``idf_component_register``
- WHOLE_ARCHIVE - if this property is set to ``TRUE`` (or any boolean ""true"" CMake value: 1, ``ON``, ``YES``, ``Y``), the component library is surrounded by ``-Wl,--whole-archive``,"
" ``-Wl,--no-whole-archive`` when linked. This can be used to force the linker to include every object file into the executable, even if the object file doesn't resolve any references from the rest of the application. This is commonly used when a component contains plugins or modules which rely on link-time registration. This property is ``FALSE`` by default. It can be set to ``TRUE`` from the component CMakeLists.txt file.


.. _cmake-file-globbing:

File Globbing & Incremental Builds


.. highl"
"ight:: cmake

The preferred way to include source files in an ESP-IDF component is to list them manually via SRCS argument to ``idf_component_register``::

  idf_component_register(SRCS library/a.c library/b.c platform/platform.c
                         ...)

This preference reflects the `CMake best practice `_ of manually listing source files. This could, however, be inconvenient when there are lots of source files to add to the build. The ESP-IDF build system provides an alternative way for s"
"pecifying source files using ``SRC_DIRS``::

  idf_component_register(SRC_DIRS library platform
                         ...)

This uses globbing behind the scenes to find source files in the specified directories. Be aware, however, that if a new source file is added and this method is used, then CMake won't know to automatically re-run and this file won't be added to the build.

The trade-off is acceptable when you're adding the file yourself, because you can trigger a clean build or run ``idf"
".py reconfigure`` to manually re-run CMake_. However, the problem gets harder when you share your project with others who may check out a new version using a source control tool like Git...

For components which are part of ESP-IDF, we use a third party Git CMake integration module (:idf_file:`/tools/cmake/third_party/GetGitRevisionDescription.cmake`) which automatically re-runs CMake any time the repository commit changes. This means if you check out a new ESP-IDF version, CMake will automatica"
"lly rerun.

For project components (not part of ESP-IDF), there are a few different options:

- If keeping your project file in Git, ESP-IDF will automatically track the Git revision and re-run CMake if the revision changes.
- If some components are kept in a third git repository (not the project repository or ESP-IDF repository), you can add a call to the ``git_describe`` function in a component CMakeLists file in order to automatically trigger re-runs of CMake when the Git revision changes.
- "
"If not using Git, remember to manually run ``idf.py reconfigure`` whenever a source file may change.
- To avoid this problem entirely, use ``SRCS`` argument to ``idf_component_register`` to list all source files in project components.

The best option will depend on your particular project and its users.


.. _build_system_metadata:

Build System Metadata


For integration into IDEs and other build systems, when CMake runs the build process generates a number of metadata files in the ``build/`` "
"directory. To regenerate these files, run ``cmake`` or ``idf.py reconfigure`` (or any other ``idf.py`` build command).

- ``compile_commands.json`` is a standard format JSON file which describes every source file which is compiled in the project. A CMake feature generates this file, and many IDEs know how to parse it.
- ``project_description.json`` contains some general information about the ESP-IDF project, configured paths, etc.
- ``flasher_args.json`` contains esptool.py arguments to flash th"
"e project's binary files. There are also ``flash_*_args`` files which can be used directly with esptool.py. See `Flash arguments`_.
- ``CMakeCache.txt`` is the CMake cache file which contains other information about the CMake process, toolchain, etc.
- ``config/sdkconfig.json`` is a JSON-formatted version of the project configuration values.
- ``config/kconfig_menus.json`` is a JSON-formatted version of the menus shown in menuconfig, for use in external IDE UIs.


JSON Configuration Server


A t"
"ool called ``kconfserver`` is provided to allow IDEs to easily integrate with the configuration system logic. ``kconfserver`` is designed to run in the background and interact with a calling process by reading and writing JSON over process stdin & stdout.

You can run ``kconfserver`` from a project via ``idf.py confserver`` or ``ninja kconfserver``, or a similar target triggered from a different build generator.

For more information about ``kconfserver``, see the `esp-idf-kconfig documentation "
"`_.


Build System Internals


Build Scripts


The listfiles for the ESP-IDF build system reside in :idf:`/tools/cmake`. The modules which implement core build system functionality are as follows:

    - build.cmake - Build related commands i.e., build initialization, retrieving/setting build properties, build processing.
    - component.cmake - Component related commands i.e., adding components, retrieving/setting component properties, registering components.
    - kconfig.cmake - Generation of"
" configuration files (sdkconfig, sdkconfig.h, sdkconfig.cmake, etc.) from Kconfig files.
    - ldgen.cmake - Generation  of  final linker script from linker fragment files.
    - target.cmake - Setting build target and toolchain file.
    - utilities.cmake - Miscellaneous helper commands.

 Aside from these files, there are two other important CMake scripts in :idf:`/tools/cmake`:

    - idf.cmake - Sets up the build and includes the core modules listed above. Included in CMake projects in order"
" to access ESP-IDF build system functionality.
    - project.cmake - Includes ``idf.cmake`` and provides a custom ``project()`` command that takes care of all the heavy lifting of building an executable. Included in the top-level CMakeLists.txt of standard ESP-IDF projects.

The rest of the files in :idf:`/tools/cmake` are support or third-party scripts used in the build process.


Build Process


This section describes the standard ESP-IDF application build process. The build process can be bro"
"ken down roughly into four phases:

.. blockdiag::
    :scale: 100%
    :caption: ESP-IDF Build System Process
    :align: center

    blockdiag idf-build-system-process {
        Initialization -> Enumeration
        Enumeration -> Processing
        Processing -> Finalization
    }


Initialization


This phase sets up necessary parameters for the build.

    - Upon inclusion of ``idf.cmake`` in ``project.cmake``, the following steps are performed:
        - Set ``IDF_PATH`` from environment v"
"ariable or inferred from path to ``project.cmake`` included in the top-level CMakeLists.txt.
        - Add :idf:`/tools/cmake` to ``CMAKE_MODULE_PATH`` and include core modules plus the various helper/third-party scripts.
        - Set build tools/executables such as default Python interpreter.
        - Get ESP-IDF git revision and store as ``IDF_VER``.
        - Set global build specifications i.e., compile options, compile definitions, include directories for all components in the build.
    "
"    - Add components in :idf:`components` to the build.
    - The initial part of the custom ``project()`` command performs the following steps:
        - Set ``IDF_TARGET`` from environment variable or CMake cache and the corresponding ``CMAKE_TOOLCHAIN_FILE`` to be used.
        - Add components in ``EXTRA_COMPONENT_DIRS`` to the build.
        - Prepare arguments for calling command ``idf_build_process()`` from variables such as ``COMPONENTS``/``EXCLUDE_COMPONENTS``, ``SDKCONFIG``, ``SDKCONFI"
"G_DEFAULTS``.

  The call to ``idf_build_process()`` command marks the end of this phase.


Enumeration

  This phase builds a final list of components to be processed in the build, and is performed in the first half of ``idf_build_process()``.

    - Retrieve each component's public and private requirements. A child process is created which executes each component's CMakeLists.txt in script mode. The values of ``idf_component_register`` REQUIRES and PRIV_REQUIRES argument is returned to the par"
"ent build process. This is called early expansion. The variable ``CMAKE_BUILD_EARLY_EXPANSION`` is defined during this step.
    - Recursively include components based on public and private requirements.


Processing


  This phase processes the components in the build, and is the second half of ``idf_build_process()``.

  - Load project configuration from sdkconfig file and generate an sdkconfig.cmake and sdkconfig.h header. These define configuration variables/macros that are accessible from t"
"he build scripts and C/C++ source/header files, respectively.
  - Include each component's ``project_include.cmake``.
  - Add each component as a subdirectory, processing its CMakeLists.txt. The component CMakeLists.txt calls the registration command, ``idf_component_register`` which adds source files, include directories, creates component library, links dependencies, etc.


Finalization

  This phase is everything after ``idf_build_process()``.

  - Create executable and link the component lib"
"raries to it.
  - Generate project metadata files such as project_description.json and display relevant information about the project built.

Browse :idf_file:`/tools/cmake/project.cmake` for more details.


.. _migrating_from_make:

Migrating from ESP-IDF GNU Make System


Some aspects of the CMake-based ESP-IDF build system are very similar to the older GNU Make-based system. The developer needs to provide values the include directories, source files etc. There is a syntactical difference, how"
"ever, as the developer needs to pass these as arguments to the registration command, ``idf_component_register``.


Automatic Conversion Tool


An automatic project conversion tool is available in `tools/cmake/convert_to_cmake.py` in ESP-IDF v4.x releases. The script was removed in v5.0 because of its `make` build system dependency.


No Longer Available in CMake


Some features are significantly different or removed in the CMake-based system. The following variables no longer exist in the CMake-"
"based build system:

- ``COMPONENT_BUILD_DIR``: Use ``CMAKE_CURRENT_BINARY_DIR`` instead.
- ``COMPONENT_LIBRARY``: Defaulted to ``$(COMPONENT_NAME).a``, but the library name could be overriden by the component. The name of the component library can no longer be overriden by the component.
- ``CC``, ``LD``, ``AR``, ``OBJCOPY``: Full paths to each tool from the gcc xtensa cross-toolchain. Use ``CMAKE_C_COMPILER``, ``CMAKE_C_LINK_EXECUTABLE``, ``CMAKE_OBJCOPY``, etc instead. `Full list here `_.
- `"
"`HOSTCC``, ``HOSTLD``, ``HOSTAR``: Full names of each tool from the host native toolchain. These are no longer provided, external projects should detect any required host toolchain manually.
- ``COMPONENT_ADD_LDFLAGS``: Used to override linker flags. Use the CMake `target_link_libraries`_ command instead.
- ``COMPONENT_ADD_LINKER_DEPS``: List of files that linking should depend on. `target_link_libraries`_ will usually infer these dependencies automatically. For linker scripts, use the provided "
"custom CMake function ``target_linker_scripts``.
- ``COMPONENT_SUBMODULES``: No longer used, the build system will automatically enumerate all submodules in the ESP-IDF repository.
- ``COMPONENT_EXTRA_INCLUDES``: Used to be an alternative to ``COMPONENT_PRIV_INCLUDEDIRS`` for absolute paths. Use ``PRIV_INCLUDE_DIRS`` argument to ``idf_component_register`` for all cases now (can be relative or absolute).
- ``COMPONENT_OBJS``: Previously, component sources could be specified as a list of object fi"
"les. Now they can be specified as a list of source files via ``SRCS`` argument to `idf_component_register`.
- ``COMPONENT_OBJEXCLUDE``: Has been replaced with ``EXCLUDE_SRCS`` argument to ``idf_component_register``. Specify source files (as absolute paths or relative to component directory), instead.
- ``COMPONENT_EXTRA_CLEAN``: Set property ``ADDITIONAL_CLEAN_FILES`` instead but note :ref:`CMake has some restrictions around this functionality `.
- ``COMPONENT_OWNBUILDTARGET`` & ``COMPONENT_OWNC"
"LEANTARGET``: Use CMake `ExternalProject`_ instead. See :ref:`component-build-full-override` for full details.
- ``COMPONENT_CONFIG_ONLY``: Call ``idf_component_register`` without any arguments instead. See `Configuration-Only Components`_.
- ``CFLAGS``, ``CPPFLAGS``, ``CXXFLAGS``: Use equivalent CMake commands instead. See `Controlling Component Compilation`_.


No Default Values


Unlike in the legacy Make-based build system, the following have no default values:

- Source directories (``COMPO"
"NENT_SRCDIRS`` variable in Make, ``SRC_DIRS`` argument to ``idf_component_register`` in CMake)
- Include directories (``COMPONENT_ADD_INCLUDEDIRS`` variable in Make, ``INCLUDE_DIRS`` argument to ``idf_component_register`` in CMake)


No Longer Necessary


- In the legacy Make-based build system, it is required to also set ``COMPONENT_SRCDIRS`` if ``COMPONENT_SRCS`` is set. In CMake, the equivalent is not necessary i.e., specifying ``SRC_DIRS`` to ``idf_component_register`` if ``SRCS`` is also sp"
"ecified (in fact, ``SRCS`` is ignored if ``SRC_DIRS`` is specified).


Flashing from Make


``make flash`` and similar targets still work to build and flash. However, project ``sdkconfig`` no longer specifies serial port and baud rate. Environment variables can be used to override these. See :ref:`flash-with-ninja-or-make` for more details.

.. _esp-idf-template: https://github.com/espressif/esp-idf-template
.. _cmake: https://cmake.org
.. _ninja: https://ninja-build.org
.. _esptool.py: https://"
"github.com/espressif/esptool/#readme
.. _CMake v3.16 documentation: https://cmake.org/cmake/help/v3.16/index.html
.. _cmake command line documentation: https://cmake.org/cmake/help/v3.16/manual/cmake.1.html#options
.. _cmake add_library: https://cmake.org/cmake/help/v3.16/command/add_library.html
.. _cmake if: https://cmake.org/cmake/help/v3.16/command/if.html
.. _cmake list: https://cmake.org/cmake/help/v3.16/command/list.html
.. _cmake project: https://cmake.org/cmake/help/v3.16/command/projec"
"t.html
.. _cmake set: https://cmake.org/cmake/help/v3.16/command/set.html
.. _cmake string: https://cmake.org/cmake/help/v3.16/command/string.html
.. _cmake faq generated files: https://gitlab.kitware.com/cmake/community/-/wikis/FAQ#how-can-i-generate-a-source-file-during-the-build
.. _ADDITIONAL_CLEAN_FILES: https://cmake.org/cmake/help/v3.16/prop_dir/ADDITIONAL_CLEAN_FILES.html
.. _ExternalProject: https://cmake.org/cmake/help/v3.16/module/ExternalProject.html
.. _cmake language variables: htt"
"ps://cmake.org/cmake/help/v3.16/manual/cmake-variables.7.html#variables-for-languages
.. _set_source_files_properties: https://cmake.org/cmake/help/v3.16/command/set_source_files_properties.html
.. _target_compile_options: https://cmake.org/cmake/help/v3.16/command/target_compile_options.html
.. _target_link_libraries: https://cmake.org/cmake/help/v3.16/command/target_link_libraries.html#command:target_link_libraries
.. _cmake_toolchain_file: https://cmake.org/cmake/help/v3.16/variable/CMAKE_TOO"
"LCHAIN_FILE.html
.. _LINK_INTERFACE_MULTIPLICITY: https://cmake.org/cmake/help/v3.16/prop_tgt/LINK_INTERFACE_MULTIPLICITY.html
.. _quirc: https://github.com/dlbeer/quirc
.. _pyenv: https://github.com/pyenv/pyenv#readme
.. _virtualenv: https://virtualenv.pypa.io/en/stable/
"
"Wi-Fi Driver




{IDF_TARGET_MAX_CONN_STA_NUM:default=""15"", esp32c2=""4"", esp32c3=""10"", esp32c6=""10""}

{IDF_TARGET_SUB_MAX_NUM_FROM_KEYS:default=""2"", esp32c3=""7"", esp32c6=""7""}

{IDF_TARGET_NAME} Wi-Fi Feature List


The following features are supported:

.. only:: esp32 or esp32s2 or esp32c3 or esp32s3

    - 4 virtual Wi-Fi interfaces, which are STA, AP, Sniffer and reserved.
    - Station-only mode, AP-only mode, station/AP-coexistence mode
    - IEEE 802.11b, IEEE 802.11g, IEEE 802.11n, and AP"
"Is to configure the protocol mode
    - WPA/WPA2/WPA3/WPA2-Enterprise/WPA3-Enterprise/WAPI/WPS and DPP
    - AMSDU, AMPDU, HT40, QoS, and other key features
    - Modem-sleep
    - The Espressif-specific ESP-NOW protocol and Long Range mode, which supports up to **1 km** of data traffic
    - Up to 20 MBit/s TCP throughput and 30 MBit/s UDP throughput over the air
    - Sniffer
    - Both fast scan and all-channel scan
    - Multiple antennas
    - Channel state information

    .. only:: SOC_WI"
"FI_NAN_SUPPORT

     - Wi-Fi Aware (NAN)

.. only:: esp32c6

    - 4 virtual Wi-Fi interfaces, which are STA, AP, Sniffer and reserved.
    - Station-only mode, AP-only mode, station/AP-coexistence mode
    - IEEE 802.11b, IEEE 802.11g, IEEE 802.11n, IEEE 802.11ax, and APIs to configure the protocol mode
    - WPA/WPA2/WPA3/WPA2-Enterprise/WPA3-Enterprise/WAPI/WPS and DPP
    - AMSDU, AMPDU, HT40, QoS, and other key features
    - Modem-sleep
    - The Espressif-specific ESP-NOW protocol and Lon"
"g Range mode, which supports up to **1 km** of data traffic
    - Up to 20 MBit/s TCP throughput and 30 MBit/s UDP throughput over the air
    - Sniffer
    - Both fast scan and all-channel scan
    - Multiple antennas
    - Channel state information
    - TWT
    - Downlink MU-MIMO
    - OFDMA
    - BSS Color

.. only:: esp32c2

    - 3 virtual Wi-Fi interfaces, which are STA, AP and Sniffer.
    - Station-only mode, AP-only mode, station/AP-coexistence mode
    - IEEE 802.11b, IEEE 802.11g, IE"
"EE 802.11n, and APIs to configure the protocol mode
    - WPA/WPA2/WPA3/WPA2-Enterprise/WPA3-Enterprise/WPS and DPP
    - AMPDU, QoS, and other key features
    - Modem-sleep
    - Up to 20 MBit/s TCP throughput and 30 MBit/s UDP throughput over the air
    - Sniffer
    - Both fast scan and all-channel scan
    - Multiple antennas


How To Write a Wi-Fi Application


Preparation
+++++++++++

Generally, the most effective way to begin your own Wi-Fi application is to select an example which is s"
"imilar to your own application, and port the useful part into your project. It is not a MUST, but it is strongly recommended that you take some time to read this article first, especially if you want to program a robust Wi-Fi application.

This article is supplementary to the Wi-Fi APIs/Examples. It describes the principles of using the Wi-Fi APIs, the limitations of the current Wi-Fi API implementation, and the most common pitfalls in using Wi-Fi. This article also reveals some design details o"
"f the Wi-Fi driver. We recommend you to select an :example:`example `.

Setting Wi-Fi Compile-time Options
++++++++++++++++++++++++++++++++++++

Refer to `Wi-Fi Menuconfig`_.

Init Wi-Fi
+++++++++++

Refer to `{IDF_TARGET_NAME} Wi-Fi station General Scenario`_ and `{IDF_TARGET_NAME} Wi-Fi AP General Scenario`_.

Start/Connect Wi-Fi
++++++++++++++++++++

Refer to `{IDF_TARGET_NAME} Wi-Fi station General Scenario`_ and `{IDF_TARGET_NAME} Wi-Fi AP General Scenario`_.

Event-Handling
++++++++++++++
"
"
Generally, it is easy to write code in ""sunny-day"" scenarios, such as `WIFI_EVENT_STA_START`_ and `WIFI_EVENT_STA_CONNECTED`_. The hard part is to write routines in ""rainy-day"" scenarios, such as `WIFI_EVENT_STA_DISCONNECTED`_. Good handling of ""rainy-day"" scenarios is fundamental to robust Wi-Fi applications. Refer to `{IDF_TARGET_NAME} Wi-Fi Event Description`_, `{IDF_TARGET_NAME} Wi-Fi station General Scenario`_, and `{IDF_TARGET_NAME} Wi-Fi AP General Scenario`_. See also the :doc:`overview"
" of the Event Loop Library in ESP-IDF `.

Write Error-Recovery Routines Correctly at All Times
++++++++++++++++++++++++++++++++++++++++++++++++++++

Just like the handling of ""rainy-day"" scenarios, a good error-recovery routine is also fundamental to robust Wi-Fi applications. Refer to `{IDF_TARGET_NAME} Wi-Fi API Error Code`_.


{IDF_TARGET_NAME} Wi-Fi API Error Code


All of the {IDF_TARGET_NAME} Wi-Fi APIs have well-defined return values, namely, the error code. The error code can be categori"
"zed into:

 - No errors, e.g., :c:macro:`ESP_OK` means that the API returns successfully.
 - Recoverable errors, such as :c:macro:`ESP_ERR_NO_MEM`.
 - Non-recoverable, non-critical errors.
 - Non-recoverable, critical errors.

Whether the error is critical or not depends on the API and the application scenario, and it is defined by the API user.

**The primary principle to write a robust application with Wi-Fi API is to always check the error code and write the error-handling code.** Generally, "
"the error-handling code can be used:

 - For recoverable errors, in which case you can write a recoverable-error code. For example, when :cpp:func:`esp_wifi_start()` returns :c:macro:`ESP_ERR_NO_MEM`, the recoverable-error code vTaskDelay can be called in order to get a microseconds' delay for another try.
 - For non-recoverable, yet non-critical errors, in which case printing the error code is a good method for error handling.
 - For non-recoverable and also critical errors, in which case ""asse"
"rt"" may be a good method for error handling. For example, if :cpp:func:`esp_wifi_set_mode()` returns ``ESP_ERR_WIFI_NOT_INIT``, it means that the Wi-Fi driver is not initialized by :cpp:func:`esp_wifi_init()` successfully. You can detect this kind of error very quickly in the application development phase.

In :component_file:`esp_common/include/esp_err.h`, ``ESP_ERROR_CHECK`` checks the return values. It is a rather commonplace error-handling code and can be used as the default error-handling c"
"ode in the application development phase. However, it is strongly recommended that API users write their own error-handling code.

{IDF_TARGET_NAME} Wi-Fi API Parameter Initialization


When initializing struct parameters for the API, one of two approaches should be followed:

- Explicitly set all fields of the parameter.
- Use get API to get current configuration first, then set application specific fields.

Initializing or getting the entire structure is very important, because most of the tim"
"e the value 0 indicates that the default value is used. More fields may be added to the struct in the future and initializing these to zero ensures the application will still work correctly after ESP-IDF is updated to a new release.

.. _wifi-programming-model:

{IDF_TARGET_NAME} Wi-Fi Programming Model


The {IDF_TARGET_NAME} Wi-Fi programming model is depicted as follows:

.. blockdiag::
    :caption: Wi-Fi Programming Model
    :align: center

    blockdiag wifi-programming-model {

        #"
" global attributes
        node_height = 60;
        node_width = 100;
        span_width = 100;
        span_height = 60;
        default_shape = roundedbox;
        default_group_color = none;

        # node labels
        TCP_STACK [label=""TCP\n stack"", fontsize=12];
        EVNT_TASK [label=""Event\n task"", fontsize=12];
        APPL_TASK [label=""Application\n task"", width = 120, fontsize=12];
        WIFI_DRV  [label=""Wi-Fi\n Driver"", width = 120, fontsize=12];
        KNOT [shape=none];

 "
"       # node connections + labels
        TCP_STACK -> EVNT_TASK [label=event];
        EVNT_TASK -> APPL_TASK [label=""callback\n or event""];

        # arrange nodes vertically
        group {
           label = ""default handler"";
           orientation = portrait;
           EVNT_TASK ` to initialize Wi-Fi and handles Wi-Fi events when necessary. Wi-Fi driver receives API calls, handles them, and posts events to the application.

Wi-Fi event handling is based on the :doc:`esp_event library `."
" Events are sent by the Wi-Fi driver to the :ref:`default event loop `. Application may handle these events in callbacks registered using :cpp:func:`esp_event_handler_register()`. Wi-Fi events are also handled by :doc:`esp_netif component ` to provide a set of default behaviors. For example, when Wi-Fi station connects to an AP, esp_netif will automatically start the DHCP client by default.


{IDF_TARGET_NAME} Wi-Fi Event Description


WIFI_EVENT_WIFI_READY
++++++++++++++++++++++++++++++++++++

"
"The Wi-Fi driver will never generate this event, which, as a result, can be ignored by the application event callback. This event may be removed in future releases.

WIFI_EVENT_SCAN_DONE
++++++++++++++++++++++++++++++++++++

The scan-done event is triggered by :cpp:func:`esp_wifi_scan_start()` and will arise in the following scenarios:

  - The scan is completed, e.g., the target AP is found successfully, or all channels have been scanned.
  - The scan is stopped by :cpp:func:`esp_wifi_scan_stop"
"()`.
  - The :cpp:func:`esp_wifi_scan_start()` is called before the scan is completed. A new scan will override the current scan and a scan-done event will be generated.

The scan-done event will not arise in the following scenarios:

  - It is a blocked scan.
  - The scan is caused by :cpp:func:`esp_wifi_connect()`.

Upon receiving this event, the event task does nothing. The application event callback needs to call :cpp:func:`esp_wifi_scan_get_ap_num()` and :cpp:func:`esp_wifi_scan_get_ap_reco"
"rds()` to fetch the scanned AP list and trigger the Wi-Fi driver to free the internal memory which is allocated during the scan **(do not forget to do this!)**.
Refer to `{IDF_TARGET_NAME} Wi-Fi Scan`_ for a more detailed description.

WIFI_EVENT_STA_START
++++++++++++++++++++++++++++++++++++

If :cpp:func:`esp_wifi_start()` returns :c:macro:`ESP_OK` and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will initialize the LwIP"
" network interface (netif). Generally, the application event callback needs to call :cpp:func:`esp_wifi_connect()` to connect to the configured AP.

WIFI_EVENT_STA_STOP
++++++++++++++++++++++++++++++++++++

If :cpp:func:`esp_wifi_stop()` returns :c:macro:`ESP_OK` and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will release the station's IP address, stop the DHCP client, remove TCP/UDP-related connections, and clear the Lw"
"IP station netif, etc. The application event callback generally does not need to do anything.

WIFI_EVENT_STA_CONNECTED
++++++++++++++++++++++++++++++++++++

If :cpp:func:`esp_wifi_connect()` returns :c:macro:`ESP_OK` and the station successfully connects to the target AP, the connection event will arise. Upon receiving this event, the event task starts the DHCP client and begins the DHCP process of getting the IP address. Then, the Wi-Fi driver is ready for sending and receiving data. This mome"
"nt is good for beginning the application work, provided that the application does not depend on LwIP, namely the IP address. However, if the application is LwIP-based, then you need to wait until the *got ip* event comes in.

WIFI_EVENT_STA_DISCONNECTED
++++++++++++++++++++++++++++++++++++

This event can be generated in the following scenarios:

  - When :cpp:func:`esp_wifi_disconnect()` or :cpp:func:`esp_wifi_stop()` is called and the station is already connected to the AP.
  - When :cpp:func:"
"`esp_wifi_connect()` is called, but the Wi-Fi driver fails to set up a connection with the AP due to certain reasons, e.g., the scan fails to find the target AP or the authentication times out. If there are more than one AP with the same SSID, the disconnected event will be raised after the station fails to connect all of the found APs.
  - When the Wi-Fi connection is disrupted because of specific reasons, e.g., the station continuously loses N beacons, the AP kicks off the station, or the AP's"
" authentication mode is changed.

Upon receiving this event, the default behaviors of the event task are:

- Shutting down the station's LwIP netif.
- Notifying the LwIP task to clear the UDP/TCP connections which cause the wrong status to all sockets. For socket-based applications, the application callback can choose to close all sockets and re-create them, if necessary, upon receiving this event.

The most common event handle code for this event in application is to call :cpp:func:`esp_wifi_co"
"nnect()` to reconnect the Wi-Fi. However, if the event is raised because :cpp:func:`esp_wifi_disconnect()` is called, the application should not call :cpp:func:`esp_wifi_connect()` to reconnect. It is the application's responsibility to distinguish whether the event is caused by :cpp:func:`esp_wifi_disconnect()` or other reasons. Sometimes a better reconnection strategy is required. Refer to `Wi-Fi Reconnect`_ and `Scan When Wi-Fi Is Connecting`_.

Another thing that deserves attention is that t"
"he default behavior of LwIP is to abort all TCP socket connections on receiving the disconnect. In most cases, it is not a problem. However, for some special applications, this may not be what they want. Consider the following scenarios:

- The application creates a TCP connection to maintain the application-level keep-alive data that is sent out every 60 seconds.
- Due to certain reasons, the Wi-Fi connection is cut off, and the `WIFI_EVENT_STA_DISCONNECTED`_ is raised. According to the current"
" implementation, all TCP connections will be removed and the keep-alive socket will be in a wrong status. However, since the application designer believes that the network layer should **ignore** this error at the Wi-Fi layer, the application does not close the socket.
- Five seconds later, the Wi-Fi connection is restored because :cpp:func:`esp_wifi_connect()` is called in the application event callback function. **Moreover, the station connects to the same AP and gets the same IPV4 address as "
"before**.
- Sixty seconds later, when the application sends out data with the keep-alive socket, the socket returns an error and the application closes the socket and re-creates it when necessary.

In above scenarios, ideally, the application sockets and the network layer should not be affected, since the Wi-Fi connection only fails temporarily and recovers very quickly. The application can enable ""Keep TCP connections when IP changed"" via LwIP menuconfig.

IP_EVENT_STA_GOT_IP
++++++++++++++++++"
"++++++++++++++++++

This event arises when the DHCP client successfully gets the IPV4 address from the DHCP server, or when the IPV4 address is changed. The event means that everything is ready and the application can begin its tasks (e.g., creating sockets).

The IPV4 may be changed because of the following reasons:

  - The DHCP client fails to renew/rebind the IPV4 address, and the station's IPV4 is reset to 0.
  - The DHCP client rebinds to a different address.
  - The static-configured IPV4"
" address is changed.

Whether the IPV4 address is changed or not is indicated by the field ``ip_change`` of ``ip_event_got_ip_t``.

The socket is based on the IPV4 address, which means that, if the IPV4 changes, all sockets relating to this IPV4 will become abnormal. Upon receiving this event, the application needs to close all sockets and recreate the application when the IPV4 changes to a valid one.

IP_EVENT_GOT_IP6
++++++++++++++++++++++++++++++++++++

This event arises when the IPV6 SLAAC s"
"upport auto-configures an address for the {IDF_TARGET_NAME}, or when this address changes. The event means that everything is ready and the application can begin its tasks, e.g., creating sockets.

IP_EVENT_STA_LOST_IP
++++++++++++++++++++++++++++++++++++

This event arises when the IPV4 address becomes invalid.

IP_EVENT_STA_LOST_IP does not arise immediately after the Wi-Fi disconnects. Instead, it starts an IPV4 address lost timer. If the IPV4 address is got before ip lost timer expires, IP_E"
"VENT_STA_LOST_IP does not happen. Otherwise, the event arises when the IPV4 address lost timer expires.

Generally, the application can ignore this event, because it is just a debug event to inform that the IPV4 address is lost.

WIFI_EVENT_AP_START
++++++++++++++++++++++++++++++++++++

Similar to `WIFI_EVENT_STA_START`_.

WIFI_EVENT_AP_STOP
++++++++++++++++++++++++++++++++++++

Similar to `WIFI_EVENT_STA_STOP`_.

WIFI_EVENT_AP_STACONNECTED
++++++++++++++++++++++++++++++++++++

Every time a stat"
"ion is connected to {IDF_TARGET_NAME} AP, the `WIFI_EVENT_AP_STACONNECTED`_ will arise. Upon receiving this event, the event task will do nothing, and the application callback can also ignore it. However, you may want to do something, for example, to get the info of the connected STA.

WIFI_EVENT_AP_STADISCONNECTED
++++++++++++++++++++++++++++++++++++

This event can happen in the following scenarios:

  - The application calls :cpp:func:`esp_wifi_disconnect()`, or :cpp:func:`esp_wifi_deauth_sta"
"()`, to manually disconnect the station.
  - The Wi-Fi driver kicks off the station, e.g., because the AP has not received any packets in the past five minutes. The time can be modified by :cpp:func:`esp_wifi_set_inactive_time()`.
  - The station kicks off the AP.

When this event happens, the event task will do nothing, but the application event callback needs to do something, e.g., close the socket which is related to this station.

WIFI_EVENT_AP_PROBEREQRECVED
++++++++++++++++++++++++++++++++"
"++++

This event is disabled by default. The application can enable it via API :cpp:func:`esp_wifi_set_event_mask()`.
When this event is enabled, it will be raised each time the AP receives a probe request.

WIFI_EVENT_STA_BEACON_TIMEOUT
++++++++++++++++++++++++++++++++++++

If the station does not receive the beacon of the connected AP within the inactive time, the beacon timeout happens, the `WIFI_EVENT_STA_BEACON_TIMEOUT`_ will arise. The application can set inactive time via API :cpp:func:`e"
"sp_wifi_set_inactive_time()`.

WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The `WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START`_ will arise at the start of connectionless module `Interval`. See :ref:`connectionless module power save `.

{IDF_TARGET_NAME} Wi-Fi Station General Scenario


Below is a ""big scenario"" which describes some small scenarios in station mode:

.. seqdiag::
    :caption: Sample Wi-Fi Event Scenarios i"
"n Station Mode
    :align: center

    seqdiag sample-scenarios-station-mode {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 140;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        MAIN_TASK  [label = ""Main\ntask""];
        APP_TASK   [label = ""App\ntask""];
        EVENT_TASK [label = ""Event\ntask""];
        LwIP_TASK  [label = ""LwIP\ntask""];
        WIFI_TASK  [label = ""Wi-Fi\ntask""];

      "
"  === 1. Init Phase ===
        MAIN_TASK  ->  LwIP_TASK   [label=""1.1> Create / init LwIP""];
        MAIN_TASK  ->  EVENT_TASK  [label=""1.2> Create / init event""];
        MAIN_TASK  ->  WIFI_TASK   [label=""1.3> Create / init Wi-Fi""];
        MAIN_TASK  ->  APP_TASK    [label=""1.4> Create app task""];
        === 2. Configure Phase ===
        MAIN_TASK  ->  WIFI_TASK   [label=""2> Configure Wi-Fi""];
        === 3. Start Phase ===
        MAIN_TASK  ->  WIFI_TASK   [label=""3.1> Start Wi-Fi""];
   "
"     EVENT_TASK  WIFI_EVENT_STA_START""];
        APP_TASK    WIFI_EVENT_STA_START""];
        === 4. Connect Phase ===
        APP_TASK   ->  WIFI_TASK   [label=""4.1> Connect Wi-Fi""];
        EVENT_TASK  WIFI_EVENT_STA_CONNECTED""];
        APP_TASK    WIFI_EVENT_STA_CONNECTED""];
        === 5. Got IP Phase ===
        EVENT_TASK ->  LwIP_TASK   [label=""5.1> Start DHCP client""];
        EVENT_TASK  IP_EVENT_STA_GOT_IP""];
        APP_TASK    IP_EVENT_STA_GOT_IP""];
        APP_TASK   ->  APP_TASK   "
" [label=""5.4> socket related init""];
        === 6. Disconnect Phase ===
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECTED""];
        APP_TASK    WIFI_EVENT_STA_DISCONNECTED""];
        APP_TASK   ->  APP_TASK    [label=""6.3> disconnect handling""];
        === 7. IP Change Phase ===
        EVENT_TASK  IP_EVENT_STA_GOT_IP""];
        APP_TASK    IP_EVENT_STA_GOT_IP""];
        APP_TASK   ->  APP_TASK    [label=""7.3> Socket error handling""];
        === 8. Deinit Phase ===
        APP_TASK   ->  WIFI_"
"TASK   [label=""8.1> Disconnect Wi-Fi""];
        APP_TASK   ->  WIFI_TASK   [label=""8.2> Stop Wi-Fi""];
        APP_TASK   ->  WIFI_TASK   [label=""8.3> Deinit Wi-Fi""];
    }
++++++++++++++++++++++++++++++

 - s1.1: The main task calls :cpp:func:`esp_netif_init()` to create an LwIP core task and initialize LwIP-related work.

 - s1.2: The main task calls :cpp:func:`esp_event_loop_create()` to create a system Event task and initialize an application event's callback function. In the scenario above, "
"the application event's callback function does nothing but relaying the event to the application task.

 - s1.3: The main task calls :cpp:func:`esp_netif_create_default_wifi_ap()` or :cpp:func:`esp_netif_create_default_wifi_sta()` to create default network interface instance binding station or AP with TCP/IP stack.

 - s1.4: The main task calls :cpp:func:`esp_wifi_init()` to create the Wi-Fi driver task and initialize the Wi-Fi driver.

 - s1.5: The main task calls OS API to create the applicati"
"on task.

Step 1.1 ~ 1.5 is a recommended sequence that initializes a Wi-Fi-/LwIP-based application. However, it is **NOT** a must-follow sequence, which means that you can create the application task in step 1.1 and put all other initialization in the application task. Moreover, you may not want to create the application task in the initialization phase if the application task depends on the sockets. Rather, you can defer the task creation until the IP is obtained.
+++++++++++++++++++++++++++++"
"++

Once the Wi-Fi driver is initialized, you can start configuring the Wi-Fi driver. In this scenario, the mode is station, so you may need to call :cpp:func:`esp_wifi_set_mode` (WIFI_MODE_STA) to configure the Wi-Fi mode as station. You can call other `esp_wifi_set_xxx` APIs to configure more settings, such as the protocol mode, the country code, and the bandwidth. Refer to `{IDF_TARGET_NAME} Wi-Fi Configuration`_.

Generally, the Wi-Fi driver should be configured before the Wi-Fi connection i"
"s set up. But this is **NOT** mandatory, which means that you can configure the Wi-Fi connection anytime, provided that the Wi-Fi driver is initialized successfully. However, if the configuration does not need to change after the Wi-Fi connection is set up, you should configure the Wi-Fi driver at this stage, because the configuration APIs (such as :cpp:func:`esp_wifi_set_protocol()`) will cause the Wi-Fi to reconnect, which may not be desirable.

If the Wi-Fi NVS flash is enabled by menuconfig,"
" all Wi-Fi configuration in this phase, or later phases, will be stored into flash. When the board powers on/reboots, you do not need to configure the Wi-Fi driver from scratch. You only need to call ``esp_wifi_get_xxx`` APIs to fetch the configuration stored in flash previously. You can also configure the Wi-Fi driver if the previous configuration is not what you want.
++++++++++++++++++++++++++++++++

 - s3.1: Call :cpp:func:`esp_wifi_start()` to start the Wi-Fi driver.
 - s3.2: The Wi-Fi driv"
"er posts `WIFI_EVENT_STA_START`_ to the event task; then, the event task will do some common things and will call the application event callback function.
 - s3.3: The application event callback function relays the `WIFI_EVENT_STA_START`_ to the application task. We recommend that you call :cpp:func:`esp_wifi_connect()`. However, you can also call :cpp:func:`esp_wifi_connect()` in other phrases after the `WIFI_EVENT_STA_START`_ arises.
+++++++++++++++++++++++++++++++++

 - s4.1: Once :cpp:func:`"
"esp_wifi_connect()` is called, the Wi-Fi driver will start the internal scan/connection process.

 - s4.2: If the internal scan/connection process is successful, the `WIFI_EVENT_STA_CONNECTED`_ will be generated. In the event task, it starts the DHCP client, which will finally trigger the DHCP process.

 - s4.3: In the above-mentioned scenario, the application event callback will relay the event to the application task. Generally, the application needs to do nothing, and you can do whatever you "
"want, e.g., print a log.

In step 4.2, the Wi-Fi connection may fail because, for example, the password is wrong, or the AP is not found. In a case like this, `WIFI_EVENT_STA_DISCONNECTED`_ will arise and the reason for such a failure will be provided. For handling events that disrupt Wi-Fi connection, please refer to phase 6.
+++++++++++++++++++++++++++++++++

 - s5.1: Once the DHCP client is initialized in step 4.2, the *got IP* phase will begin.
 - s5.2: If the IP address is successfully rece"
"ived from the DHCP server, then `IP_EVENT_STA_GOT_IP`_ will arise and the event task will perform common handling.
 - s5.3: In the application event callback, `IP_EVENT_STA_GOT_IP`_ is relayed to the application task. For LwIP-based applications, this event is very special and means that everything is ready for the application to begin its tasks, e.g., creating the TCP/UDP socket. A very common mistake is to initialize the socket before `IP_EVENT_STA_GOT_IP`_ is received. **DO NOT start the sock"
"et-related work before the IP is received.**
+++++++++++++++++++++++++++++++++

 - s6.1: When the Wi-Fi connection is disrupted, e.g., the AP is powered off or the RSSI is poor, `WIFI_EVENT_STA_DISCONNECTED`_ will arise. This event may also arise in phase 3. Here, the event task will notify the LwIP task to clear/remove all UDP/TCP connections. Then, all application sockets will be in a wrong status. In other words, no socket can work properly when this event happens.
 - s6.2: In the scenario de"
"scribed above, the application event callback function relays `WIFI_EVENT_STA_DISCONNECTED`_ to the application task. The recommended actions are: 1) call :cpp:func:`esp_wifi_connect()` to reconnect the Wi-Fi, 2) close all sockets, and 3) re-create them if necessary. For details, please refer to `WIFI_EVENT_STA_DISCONNECTED`_.
++++++++++++++++++++++++++++++++++

 - s7.1: If the IP address is changed, the `IP_EVENT_STA_GOT_IP`_ will arise with ""ip_change"" set to true.
 - s7.2: **This event is imp"
"ortant to the application. When it occurs, the timing is good for closing all created sockets and recreating them.**
++++++++++++++++++++++++++++

 - s8.1: Call :cpp:func:`esp_wifi_disconnect()` to disconnect the Wi-Fi connectivity.
 - s8.2: Call :cpp:func:`esp_wifi_stop()` to stop the Wi-Fi driver.
 - s8.3: Call :cpp:func:`esp_wifi_deinit()` to unload the Wi-Fi driver.


{IDF_TARGET_NAME} Wi-Fi AP General Scenario


Below is a ""big scenario"" which describes some small scenarios in AP mode:

 .."
" seqdiag::
    :caption: Sample Wi-Fi Event Scenarios in AP Mode
    :align: center

    seqdiag sample-scenarios-soft-ap-mode {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 140;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        MAIN_TASK  [label = ""Main\ntask""];
        APP_TASK   [label = ""App\ntask""];
        EVENT_TASK [label = ""Event\ntask""];
        LwIP_TASK  [label = ""LwIP\ntask""];
 "
"       WIFI_TASK  [label = ""Wi-Fi\ntask""];

        === 1. Init Phase ===
        MAIN_TASK  ->  LwIP_TASK   [label=""1.1> Create / init LwIP""];
        MAIN_TASK  ->  EVENT_TASK  [label=""1.2> Create / init event""];
        MAIN_TASK  ->  WIFI_TASK   [label=""1.3> Create / init Wi-Fi""];
        MAIN_TASK  ->  APP_TASK    [label=""1.4> Create app task""];
        === 2. Configure Phase ===
        MAIN_TASK  ->  WIFI_TASK   [label=""2> Configure Wi-Fi""];
        === 3. Start Phase ===
        MAIN_TAS"
"K  ->  WIFI_TASK   [label=""3.1> Start Wi-Fi""];
        EVENT_TASK  WIFI_EVENT_AP_START""];
        APP_TASK    WIFI_EVENT_AP_START""];
        === 4. Connect Phase ===
        EVENT_TASK  WIFI_EVENT_AP_STACONNECTED""];
        APP_TASK    WIFI_EVENT_AP_STACONNECTED""];
        === 5. Disconnect Phase ===
        EVENT_TASK  WIFI_EVENT_AP_STADISCONNECTED""];
        APP_TASK    WIFI_EVENT_AP_STADISCONNECTED""];
        APP_TASK   ->  APP_TASK    [label=""5.3> disconnect handling""];
        === 6. Deinit"
" Phase ===
        APP_TASK   ->  WIFI_TASK   [label=""6.1> Disconnect Wi-Fi""];
        APP_TASK   ->  WIFI_TASK   [label=""6.2> Stop Wi-Fi""];
        APP_TASK   ->  WIFI_TASK   [label=""6.3> Deinit Wi-Fi""];
    }


{IDF_TARGET_NAME} Wi-Fi Scan


Currently, the :cpp:func:`esp_wifi_scan_start()` API is supported only in station or station/AP mode.

Scan Type
+++++++++++++++++++++++++

.. list-table::
   :header-rows: 1
   :widths: 15 50
     - Description
     - Scan by sending a probe request. The "
"default scan is an active scan.
     - No probe request is sent out. Just switch to the specific channel and wait for a beacon. Application can enable it via the scan_type field of :cpp:type:`wifi_scan_config_t`.
     - This scan is applicable when there is no Wi-Fi connection in station mode. Foreground or background scanning is controlled by the Wi-Fi driver and cannot be configured by the application.
     - This scan is applicable when there is a Wi-Fi connection in station mode or in statio"
"n/AP mode. Whether it is a foreground scan or background scan depends on the Wi-Fi driver and cannot be configured by the application.
     - It scans all of the channels. If the channel field of :cpp:type:`wifi_scan_config_t` is set to 0, it is an all-channel scan.
     - It scans specific channels only. If the channel field of :cpp:type:`wifi_scan_config_t` set to 1-14, it is a specific-channel scan.

The scan modes in above table can be combined arbitrarily, so there are in total 8 different "
"scans:

 - All-Channel Background Active Scan
 - All-Channel Background Passive Scan
 - All-Channel Foreground Active Scan
 - All-Channel Foreground Passive Scan
 - Specific-Channel Background Active Scan
 - Specific-Channel Background Passive Scan
 - Specific-Channel Foreground Active Scan
 - Specific-Channel Foreground Passive Scan

Scan Configuration
+++++++++++++++++++++++++++++++++++++++

The scan type and other per-scan attributes are configured by :cpp:func:`esp_wifi_scan_start()`. The ta"
"ble below provides a detailed description of :cpp:type:`wifi_scan_config_t`.

.. list-table::
   :header-rows: 1
   :widths: 15 50
     - Description
     - If the SSID is not NULL, it is only the AP with the same SSID that can be scanned.
     - If the BSSID is not NULL, it is only the AP with the same BSSID that can be scanned.
     - If “channel” is 0, there will be an all-channel scan; otherwise, there will be a specific-channel scan.
     - If “show_hidden” is 0, the scan ignores the AP wit"
"h a hidden SSID; otherwise, the scan considers the hidden AP a normal one.
     - If “scan_type” is WIFI_SCAN_TYPE_ACTIVE, the scan is “active”; otherwise, it is a “passive” one.
     - This field is used to control how long the scan dwells on each channel.

       For passive scans, scan_time.passive designates the dwell time for each channel.

       For active scans, dwell times for each channel are listed in the table below. Here, min is short for scan time.active.min and max is short for sc"
"an_time.active.max.

       - min=0, max=0: scan dwells on each channel for 120 ms.
       - min>0, max=0: scan dwells on each channel for 120 ms.
       - min=0, max>0: scan dwells on each channel for ``max`` ms.
       - min>0, max>0: the minimum time the scan dwells on each channel is ``min`` ms. If no AP is found during this time frame, the scan switches to the next channel. Otherwise, the scan dwells on the channel for ``max`` ms.

       If you want to improve the performance of the scan, "
"you can try to modify these two parameters.


There are also some global scan attributes which are configured by API :cpp:func:`esp_wifi_set_config()`, refer to `Station Basic Configuration`_

Scan All APs on All Channels (Foreground)
+++++++++++++++++++++++++++++++++++++++++++++

Scenario:

.. seqdiag::
    :caption: Foreground Scan of all Wi-Fi Channels
    :align: center

    seqdiag foreground-scan-all-channels {
        activation = none;
        node_width = 80;
        node_height = 60;
 "
"       edge_length = 160;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        APP_TASK   [label = ""App\ntask""];
        EVENT_TASK [label = ""Event\ntask""];
        WIFI_TASK  [label = ""Wi-Fi\ntask""];

        APP_TASK   ->  WIFI_TASK  [label=""1.1 > Configure country code""];
        APP_TASK   ->  WIFI_TASK  [label=""1.2 > Scan configuration""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.1 > Scan channel 1""];
        WIFI_TASK  ->  WIFI_TASK  [label"
"=""2.2 > Scan channel 2""];
        WIFI_TASK  ->  WIFI_TASK  [label=""...""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.x > Scan channel N""];
        EVENT_TASK  WIFI_EVENT_SCAN_DONE""];
        APP_TASK    WIFI_EVENT_SCAN_DONE""];
    }


The scenario above describes an all-channel, foreground scan. The foreground scan can only occur in station mode where the station does not connect to any AP. Whether it is a foreground or background scan is totally determined by the Wi-Fi driver, and cannot be c"
"onfigured by the application.

Detailed scenario description:

Scan Configuration Phase


 - s1.1: Call :cpp:func:`esp_wifi_set_country()` to set the country info if the default country info is not what you want. Refer to `Wi-Fi Country Code`_.
 - s1.2: Call :cpp:func:`esp_wifi_scan_start()` to configure the scan. To do so, you can refer to `Scan Configuration`_. Since this is an all-channel scan, just set the SSID/BSSID/channel to 0.


Wi-Fi Driver's Internal Scan Phase


 - s2.1: The Wi-Fi dri"
"ver switches to channel 1. In this case, the scan type is WIFI_SCAN_TYPE_ACTIVE, and a probe request is broadcasted. Otherwise, the Wi-Fi will wait for a beacon from the APs. The Wi-Fi driver will stay in channel 1 for some time. The dwell time is configured in min/max time, with the default value being 120 ms.
 - s2.2: The Wi-Fi driver switches to channel 2 and performs the same operation as in step 2.1.
 - s2.3: The Wi-Fi driver scans the last channel N, where N is determined by the country co"
"de which is configured in step 1.1.

Scan-Done Event Handling Phase


 - s3.1: When all channels are scanned, `WIFI_EVENT_SCAN_DONE`_ will arise.
 - s3.2: The application's event callback function notifies the application task that `WIFI_EVENT_SCAN_DONE`_ is received. :cpp:func:`esp_wifi_scan_get_ap_num()` is called to get the number of APs that have been found in this scan. Then, it allocates enough entries and calls :cpp:func:`esp_wifi_scan_get_ap_records()` to get the AP records. Please note "
"that the AP records in the Wi-Fi driver will be freed once :cpp:func:`esp_wifi_scan_get_ap_records()` is called. Do not call :cpp:func:`esp_wifi_scan_get_ap_records()` twice for a single scan-done event. If :cpp:func:`esp_wifi_scan_get_ap_records()` is not called when the scan-done event occurs, the AP records allocated by the Wi-Fi driver will not be freed. So, make sure you call :cpp:func:`esp_wifi_scan_get_ap_records()`, yet only once.

Scan All APs on All Channels (Background)
++++++++++++++"
"++++++++++++++++++++++++++++

Scenario:

.. seqdiag::
    :caption: Background Scan of all Wi-Fi Channels
    :align: center

    seqdiag background-scan-all-channels {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 160;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        APP_TASK   [label = ""App\ntask""];
        EVENT_TASK [label = ""Event\ntask""];
        WIFI_TASK  [label = ""Wi-Fi\ntask""];

  "
"      APP_TASK   ->  WIFI_TASK  [label=""1.1 > Configure country code""];
        APP_TASK   ->  WIFI_TASK  [label=""1.2 > Scan configuration""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.1 > Scan channel 1""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.2 > Back to home channel H""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.3 > Scan channel 2""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.4 > Back to home channel H""];
        WIFI_TASK  ->  WIFI_TASK  [label=""...""];
        WIFI_TASK  ->  WIFI_T"
"ASK  [label=""2.x-1 > Scan channel N""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.x > Back to home channel H""];
        EVENT_TASK  WIFI_EVENT_SCAN_DONE""];
        APP_TASK    WIFI_EVENT_SCAN_DONE""];
    }

The scenario above is an all-channel background scan. Compared to `Scan All APs on All Channels (Foreground)`_ , the difference in the all-channel background scan is that the Wi-Fi driver will scan the back-to-home channel for 30 ms before it switches to the next channel to give the Wi-Fi co"
"nnection a chance to transmit/receive data.

Scan for Specific AP on All Channels
+++++++++++++++++++++++++++++++++++++++

Scenario:

.. seqdiag::
    :caption: Scan of specific Wi-Fi Channels
    :align: center

    seqdiag scan-specific-channels {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 160;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        APP_TASK   [label = ""App\ntask""];
        EV"
"ENT_TASK [label = ""Event\ntask""];
        WIFI_TASK  [label = ""Wi-Fi\ntask""];

        APP_TASK   ->  WIFI_TASK  [label=""1.1 > Configure country code""];
        APP_TASK   ->  WIFI_TASK  [label=""1.2 > Scan configuration""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.1 > Scan channel C1""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.2 > Scan channel C2""];
        WIFI_TASK  ->  WIFI_TASK  [label=""...""];
        WIFI_TASK  ->  WIFI_TASK  [label=""2.x > Scan channel CN, or the AP is found""];
       "
" EVENT_TASK  WIFI_EVENT_SCAN_DONE""];
        APP_TASK    WIFI_EVENT_SCAN_DONE""];
    }

This scan is similar to `Scan All APs on All Channels (Foreground)`_. The differences are:

 - s1.1: In step 1.2, the target AP will be configured to SSID/BSSID.
 - s2.1 ~ s2.N: Each time the Wi-Fi driver scans an AP, it will check whether it is a target AP or not. If the scan is ``WIFI_FAST_SCAN`` scan and the target AP is found, then the scan-done event will arise and scanning will end; otherwise, the scan "
"will continue. Please note that the first scanned channel may not be channel 1, because the Wi-Fi driver optimizes the scanning sequence.

It is a possible situation that there are multiple APs that match the target AP info, e.g., two APs with the SSID of ""ap"" are scanned. In this case, if the scan is ``WIFI_FAST_SCAN``, then only the first scanned ""ap"" will be found. If the scan is ``WIFI_ALL_CHANNEL_SCAN``, both ""ap"" will be found and the station will connect the ""ap"" according to the configur"
"ed strategy. Refer to `Station Basic Configuration`_.

You can scan a specific AP, or all of them, in any given channel. These two scenarios are very similar.

Scan in Wi-Fi Connect
+++++++++++++++++++++++++

When :cpp:func:`esp_wifi_connect()` is called, the Wi-Fi driver will try to scan the configured AP first. The scan in ""Wi-Fi Connect"" is the same as `Scan for Specific AP On All Channels`_, except that no scan-done event will be generated when the scan is completed. If the target AP is foun"
"d, the Wi-Fi driver will start the Wi-Fi connection; otherwise, `WIFI_EVENT_STA_DISCONNECTED`_ will be generated. Refer to `Scan for Specific AP On All Channels`_.

Scan in Blocked Mode
++++++++++++++++++++

If the block parameter of :cpp:func:`esp_wifi_scan_start()` is true, then the scan is a blocked one, and the application task will be blocked until the scan is done. The blocked scan is similar to an unblocked one, except that no scan-done event will arise when the blocked scan is completed."
"

Parallel Scan
+++++++++++++

Two application tasks may call :cpp:func:`esp_wifi_scan_start()` at the same time, or the same application task calls :cpp:func:`esp_wifi_scan_start()` before it gets a scan-done event. Both scenarios can happen. **However, the Wi-Fi driver does not support multiple concurrent scans adequately. As a result, concurrent scans should be avoided.** Support for concurrent scan will be enhanced in future releases, as the {IDF_TARGET_NAME}'s Wi-Fi functionality improves c"
"ontinuously.

Scan When Wi-Fi Is Connecting
+++++++++++++++++++++++++++++++

The :cpp:func:`esp_wifi_scan_start()` fails immediately if the Wi-Fi is connecting, because the connecting has higher priority than the scan. If scan fails because of connecting, the recommended strategy is to delay for some time and retry scan again. The scan will succeed once the connecting is completed.

However, the retry/delay strategy may not work all the time. Considering the following scenarios:

- The station i"
"s connecting a non-existing AP or it connects the existing AP with a wrong password, it always raises the event `WIFI_EVENT_STA_DISCONNECTED`_.
- The application calls :cpp:func:`esp_wifi_connect()` to reconnect on receiving the disconnect event.
- Another application task, e.g., the console task, calls :cpp:func:`esp_wifi_scan_start()` to do scan, the scan always fails immediately because the station keeps connecting.
- When scan fails, the application simply delays for some time and retries th"
"e scan.

In the above scenarios, the scan will never succeed because the connecting is in process. So if the application supports similar scenario, it needs to implement a better reconnection strategy. For example:

- The application can choose to define a maximum continuous reconnection counter and stop reconnecting once the counter reaches the maximum.
- The application can choose to reconnect immediately in the first N continuous reconnection, then give a delay sometime and reconnect again.

"
"The application can define its own reconnection strategy to avoid the scan starve to death. Refer to .

{IDF_TARGET_NAME} Wi-Fi Station Connecting Scenario


This scenario depicts the case if only one target AP is found in the scan phase. For scenarios where more than one AP with the same SSID is found, refer to `{IDF_TARGET_NAME} Wi-Fi Station Connecting When Multiple APs Are Found`_.

Generally, the application can ignore the connecting process. Below is a brief introduction to the process for"
" those who are really interested.

Scenario:

.. seqdiag::
    :caption: Wi-Fi Station Connecting Process
    :align: center

    seqdiag station-connecting-process {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 160;
        span_height = 5;
        default_shape = roundedbox;
        default_fontsize = 12;

        EVENT_TASK  [label = ""Event\ntask""];
        WIFI_TASK   [label = ""Wi-Fi\ntask""];
        AP          [label = ""AP""];

        "
"=== 1. Scan Phase ===
        WIFI_TASK  ->  WIFI_TASK [label=""1.1 > Scan""];
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECTED""];
        === 2. Auth Phase ===
        WIFI_TASK  ->  AP        [label=""2.1 > Auth request""];
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECTED""];
        WIFI_TASK   Auth response""];
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECTED""];
        === 3. Assoc Phase ===
        WIFI_TASK  ->  AP        [label=""3.1 > Assoc request""];
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECT"
"ED""];
        WIFI_TASK   Assoc response""];
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECTED""];
        === 4. 4-way Handshake Phase ===
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECTED""];
        WIFI_TASK   1/4 EAPOL""];
        WIFI_TASK  ->  AP        [label=""4.3 > 2/4 EAPOL""];
        EVENT_TASK  WIFI_EVENT_STA_DISCONNECTED""];
        WIFI_TASK   3/4 EAPOL""];
        WIFI_TASK  ->  AP        [label=""4.6 > 4/4 EAPOL""];
        EVENT_TASK  WIFI_EVENT_STA_CONNECTED""];
    }


Scan Phase
+++++++++"
"++++++++++++

 - s1.1: The Wi-Fi driver begins scanning in ""Wi-Fi Connect"". Refer to `Scan in Wi-Fi Connect`_ for more details.
 - s1.2: If the scan fails to find the target AP, `WIFI_EVENT_STA_DISCONNECTED`_ will arise and the reason code could either be ``WIFI_REASON_NO_AP_FOUND`` or ``WIFI_REASON_NO_AP_FOUND_W_COMPATIBLE_SECURITY`` or ``WIFI_REASON_NO_AP_FOUND_IN_AUTHMODE_THRESHOLD`` or ``WIFI_REASON_NO_AP_FOUND_IN_RSSI_THRESHOLD`` depending of the Station's configuration. Refer to `Wi-Fi Rea"
"son Code`_.

Auth Phase
+++++++++++++++++++++

 - s2.1: The authentication request packet is sent and the auth timer is enabled.
 - s2.2: If the authentication response packet is not received before the authentication timer times out, `WIFI_EVENT_STA_DISCONNECTED`_ will arise and the reason code will be ``WIFI_REASON_AUTH_EXPIRE``. Refer to `Wi-Fi Reason Code`_.
 - s2.3: The auth-response packet is received and the auth-timer is stopped.
 - s2.4: The AP rejects authentication in the response and"
" `WIFI_EVENT_STA_DISCONNECTED`_ arises, while the reason code is ``WIFI_REASON_AUTH_FAIL`` or the reasons specified by the AP. Refer to `Wi-Fi Reason Code`_.

Association Phase
+++++++++++++++++++++

 - s3.1: The association request is sent and the association timer is enabled.
 - s3.2: If the association response is not received before the association timer times out, `WIFI_EVENT_STA_DISCONNECTED`_ will arise and the reason code will be ``WIFI_REASON_ASSOC_EXPIRE``. Refer to `Wi-Fi Reason Code`"
"_.
 - s3.3: The association response is received and the association timer is stopped.
 - s3.4: The AP rejects the association in the response and `WIFI_EVENT_STA_DISCONNECTED`_ arises, while the reason code is the one specified in the association response. Refer to `Wi-Fi Reason Code`_.


Four-way Handshake Phase
++++++++++++++++++++++++++

 - s4.1: The handshake timer is enabled, and the 1/4 EAPOL is not received before the handshake timer expires. `WIFI_EVENT_STA_DISCONNECTED`_ will arise and"
" the reason code will be ``WIFI_REASON_HANDSHAKE_TIMEOUT``. Refer to `Wi-Fi Reason Code`_.
 - s4.2: The 1/4 EAPOL is received.
 - s4.3: The station replies 2/4 EAPOL.
 - s4.4: If the 3/4 EAPOL is not received before the handshake timer expires, `WIFI_EVENT_STA_DISCONNECTED`_ will arise and the reason code will be ``WIFI_REASON_HANDSHAKE_TIMEOUT``. Refer to `Wi-Fi Reason Code`_.
 - s4.5: The 3/4 EAPOL is received.
 - s4.6: The station replies 4/4 EAPOL.
 - s4.7: The station raises `WIFI_EVENT_STA"
"_CONNECTED`_.


.. _esp_wifi_reason_code:

Wi-Fi Reason Code
+++++++++++++++++++++

The table below shows the reason-code defined in {IDF_TARGET_NAME}. The first column is the macro name defined in :component_file:`esp_wifi/include/esp_wifi_types.h`. The common prefix ``WIFI_REASON`` is removed, which means that ``UNSPECIFIED`` actually stands for ``WIFI_REASON_UNSPECIFIED`` and so on. The second column is the value of the reason. This reason value is same as defined in section 9.4.1.7 of IEEE 8"
"02.11-2020. (For more information, refer to the standard mentioned above.) The last column describes the reason. Reason-codes starting from 200 are Espressif defined reason-codes and are not part of IEEE 802.11-2020.\

Also note that REASON_NO_AP_FOUND_XXX codes are mentioned in increasing order of importance. So if a single AP has a combination of the above reasons for failure, the more important one will be reported. Additionally, if there are multiple APs that satisfy the identifying criteria"
" and connecting to all of them fails for different reasons mentioned above, then the reason code reported is for the AP that failed connection due to the least important reason code, as it was the one closest to a successful connection.\

Following reason codes are renamed to their shorter form to wrap the table in page width.

- TRANSMISSION_LINK_ESTABLISHMENT_FAILED : TX_LINK_EST_FAILED
- NO_AP_FOUND_W_COMPATIBLE_SECURITY : NO_AP_FOUND_SECURITY
- NO_AP_FOUND_IN_AUTHMODE_THRESHOLD : NO_AP_FOUND"
"_AUTHMODE
- NO_AP_FOUND_IN_RSSI_THRESHOLD : NO_AP_FOUND_RSSI

.. list-table::
   :header-rows: 1
   :widths: 41 10 49
   :class: longtable
     - Value
     - Description
     - 1
     - Generally, it means an internal failure, e.g., the memory runs out, the internal TX fails, or the reason is received from the remote side.
     - 2
     - The previous authentication is no longer valid.

       For the ESP station, this reason is reported when:

       - auth is timed out.
       - the reason is"
" received from the AP.

       For the ESP AP, this reason is reported when:

       - the AP has not received any packets from the station in the past five minutes.
       - the AP is stopped by calling :cpp:func:`esp_wifi_stop()`.
       - the station is de-authed by calling :cpp:func:`esp_wifi_deauth_sta()`.
     - 3
     - De-authenticated, because the sending station is leaving (or has left).

       For the ESP station, this reason is reported when:

       - it is received from the AP.
  "
"   - 4
     - Disassociated due to inactivity.

       For the ESP station, this reason is reported when:

       - it is received from the AP.

       For the ESP AP, this reason is reported when:

       - the AP has not received any packets from the station in the past five minutes.
       - the AP is stopped by calling :cpp:func:`esp_wifi_stop()`.
       - the station is de-authed by calling :cpp:func:`esp_wifi_deauth_sta()`.
     - 5
     - Disassociated, because the AP is unable to handle "
"all currently associated STAs at the same time.

       For the ESP station, this reason is reported when:

       - it is received from the AP.

       For the ESP AP, this reason is reported when:

       - the stations associated with the AP reach the maximum number that the AP can support.
     - 6
     - Class-2 frame received from a non-authenticated STA.

       For the ESP station, this reason is reported when:

       - it is received from the AP.

       For the ESP AP, this reason is "
"reported when:

       - the AP receives a packet with data from a non-authenticated station.
     - 7
     - Class-3 frame received from a non-associated STA.

       For the ESP station, this reason is reported when:

       - it is received from the AP.

       For the ESP AP, this reason is reported when:

       - the AP receives a packet with data from a non-associated station.
     - 8
     - Disassociated, because the sending station is leaving (or has left) BSS.

       For the ESP stat"
"ion, this reason is reported when:

       - it is received from the AP.
       - the station is disconnected by :cpp:func:`esp_wifi_disconnect()` and other APIs.
     - 9
     - station requesting (re)association is not authenticated by the responding STA.

       For the ESP station, this reason is reported when:

       - it is received from the AP.

       For the ESP AP, this reason is reported when:

       - the AP receives packets with data from an associated, yet not authenticated, stat"
"ion.
     - 10
     - Disassociated, because the information in the Power Capability element is unacceptable.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 11
     - Disassociated, because the information in the Supported Channels element is unacceptable.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 12
     - AP wants us to move to another AP, sent as a part of BTM procedure. Plea"
"se note that when station is sending BTM request and moving to another AP, ROAMING reason code will be reported instead of this.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 13
     - Invalid element, i.e., an element whose content does not meet the specifications of the Standard in frame formats clause.

       For the ESP station, this reason is reported when:

       - it is received from the AP.

       For the ESP AP, this reason is"
" reported when:

       - the AP parses a wrong WPA or RSN IE.
     - 14
     - Message integrity code (MIC) failure.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 15
     - Four-way handshake times out. For legacy reasons, in ESP this reason code is replaced with ``WIFI_REASON_HANDSHAKE_TIMEOUT``.

       For the ESP station, this reason is reported when:

       - the handshake times out.
       - it is received from the AP.
     - 16
 "
"    - Group-Key Handshake times out.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 17
     - The element in the four-way handshake is different from the (Re-)Association Request/Probe and Response/Beacon frame.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
       - the station finds that the four-way handshake IE differs from the IE in the (Re-)Association Request/Probe and Response/Beaco"
"n frame.
     - 18
     - Invalid group cipher.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 19
     - Invalid pairwise cipher.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 20
     - Invalid AKMP.

       For the ESP station, this reason is reported when:
       - it is received from the AP.
     - 21
     - Unsupported RSNE version.

       For the ESP station, this reason is re"
"ported when:

       - it is received from the AP.
     - 22
     - Invalid RSNE capabilities.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 23
     - IEEE 802.1X. authentication failed.

       For the ESP station, this reason is reported when:

       - it is received from the AP.

       For the ESP AP, this reason is reported when:

       - IEEE 802.1X. authentication fails.
     - 24
     - Cipher suite rejected due to security poli"
"cies.

       For the ESP station, this reason is reported when:

       - it is received from the AP.
     - 25
     - TDLS direct-link teardown due to TDLS peer STA unreachable via the TDLS direct link.
     - 26
     - TDLS direct-link teardown for unspecified reason.
     - 27
     - Disassociated because session terminated by SSP request.
     - 28
     - Disassociated because of lack of SSP roaming agreement.
     - 29
     - Requested service rejected because of SSP cipher suite or AKM re"
"quirement.
     - 30
     - Requested service not authorized in this location.
     - 31
     - TS deleted because QoS AP lacks sufficient bandwidth for this QoS STA due to a change in BSS service characteristics or operational mode (e.g., an HT BSS change from 40 MHz channel to 20 MHz channel).
     - 32
     - Disassociated for unspecified, QoS-related reason.
     - 33
     - Disassociated because QoS AP lacks sufficient bandwidth for this QoS STA.
     - 34
     - Disassociated because exces"
"sive number of frames need to be acknowledged, but are not acknowledged due to AP transmissions and/or poor channel conditions.
     - 35
     - Disassociated because STA is transmitting outside the limits of its TXOPs.
     - 36
     - Requesting STA is leaving the BSS (or resetting).
     - 37
     - Requesting STA is no longer using the stream or session.
     - 38
     - Requesting STA received frames using a mechanism for which a setup has not been completed.
     - 39
     - Requested from"
" peer STA due to timeout
     - 40 ~ 45
     - Reserved as per IEEE80211-2020 specifications.
     - 46
     - In a Disassociation frame: Disassociated because authorized access limit reached.
     - 47
     - In a Disassociation frame: Disassociated due to external service requirements.
     - 48
     - Invalid FT Action frame count.
     - 49
     - Invalid pairwise master key identifier (PMKID).
     - 50
     - Invalid MDE.
     - 51
     - Invalid FTE
     - 67
     - TRANSMISSION_LINK_ESTA"
"BLISHMENT_FAILED will be reported when Transmission link establishment in alternative channel failed.
     - 68
     - The alternative channel is occupied.
     - 200
     - Espressif-specific Wi-Fi reason code: when the station loses N beacons continuously, it will disrupt the connection and report this reason.
     - 201
     - Espressif-specific Wi-Fi reason code: when the station fails to scan the target AP, this reason code will be reported. In case of security mismatch or station's configu"
"ration mismatch, new reason codes NO_AP_FOUND_XXX will be reported.
     - 202
     - Espressif-specific Wi-Fi reason code: the authentication fails, but not because of a timeout.
     - 203
     - Espressif-specific Wi-Fi reason code: the association fails, but not because of ASSOC_EXPIRE or ASSOC_TOOMANY.
     - 204
     - Espressif-specific Wi-Fi reason code: the handshake fails for the same reason as that in WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT.
     - 205
     - Espressif-specific Wi-Fi reaso"
"n code: the connection to the AP has failed.
     - 206
     - Espressif-specific Wi-Fi reason code: the disconnection happened due to AP's TSF reset.
     - 207
     - Espressif-specific Wi-Fi reason code: the station is roaming to another AP, this reason code is just for info, station will automatically move to another AP.
     - 208
     - Espressif-specific Wi-Fi reason code: This reason code will be reported when Assoc comeback time in association response is too high.
     - 209
     - Esp"
"ressif-specific Wi-Fi reason code: This reason code will be reported when AP did not reply of SA query sent by ESP station.
     - 210
     - Espressif-specific Wi-Fi reason code: NO_AP_FOUND_W_COMPATIBLE_SECURITY will be reported if an AP that fits identifying criteria (e.g. ssid) is found but the connection is rejected due to incompatible security configuration. These situations could be:

       - The Access Point is offering WEP security, but our station's password is not WEP-compliant.
    "
"   - The station is configured in Open mode; however, the Access Point is broadcasting in secure mode.
       - The Access Point uses Enterprise security, but we haven't set up the corresponding enterprise configuration, and vice versa.
       - SAE-PK is configured in the station configuration, but the Access Point does not support SAE-PK.
       - SAE-H2E is configured in the station configuration; however, the AP only supports WPA3-PSK or WPA3-WPA2-PSK.
       - The station is configured in s"
"ecure mode (Password or Enterprise mode); however, an Open AP is found during the scan.
       - SAE HnP is configured in the station configuration; however, the AP supports H2E only.
       - H2E is disabled in the station configuration; however, the AP is WPA3-EXT-PSK, which requires H2E support.
       - The Access Point requires PMF, but the station is not configured for PMF capable/required.
       - The station configuration requires PMF, but the AP is not configured for PMF capable/requir"
"ed.
       - The Access Point is using unsupported group management/pairwise ciphers.
       - OWE is not enabled in the station configuration, but the discovered AP is using OWE only mode.
       - The Access Point is broadcasting an invalid RSNXE in its beacons.
       - The Access Point is in Independent BSS mode.
     - 211
     - Espressif-specific Wi-Fi reason code: NO_AP_FOUND_IN_AUTHMODE_THRESHOLD will be reported if an AP that fit identifying criteria (e.g. ssid) is found but the authmo"
"de threhsold set in the wifi_config_t is not met.
     - 212
     - Espressif-specific Wi-Fi reason code: NO_AP_FOUND_IN_RSSI_THRESHOLD will be reported if an AP that fits identifying criteria (e.g. ssid) is found but the RSSI threhsold set in the wifi_config_t is not met.

Wi-Fi Reason code related to wrong password
++++++++++++++++++++++++++++++++++++++++++++++

The table below shows the Wi-Fi reason-code may related to wrong password.

.. list-table::
   :header-rows: 1
   :widths: 5 10 40
  "
"   - Value
     - Description
     - 15
     - Four-way handshake times out. Setting wrong password when STA connecting to an encrypted AP.
     - 201
     - This may related to wrong password in the two scenarios:

       - Setting password when STA connecting to an unencrypted AP.
       - Does not set password when STA connecting to an encrypted AP.
     - 204
     - Four-way handshake fails.

Wi-Fi Reason code related to low RSSI
++++++++++++++++++++++++++++++++++++++++++++++

The table belo"
"w shows the Wi-Fi reason-code may related to low RSSI.

.. list-table::
   :header-rows: 1
   :widths: 5 10 40
     - Value
     - Description
     - 212
     - The station fails to scan the target AP due to low RSSI
     - 204
     - Four-way handshake fails.


{IDF_TARGET_NAME} Wi-Fi Station Connecting When Multiple APs Are Found


This scenario is similar as `{IDF_TARGET_NAME} Wi-Fi Station Connecting Scenario`_. The difference is that the station will not raise the event `WIFI_EVENT_STA_DISC"
"ONNECTED`_ unless it fails to connect all of the found APs.

Wi-Fi Reconnect


The station may disconnect due to many reasons, e.g., the connected AP is restarted. It is the application's responsibility to reconnect. The recommended reconnection strategy is to call :cpp:func:`esp_wifi_connect()` on receiving event `WIFI_EVENT_STA_DISCONNECTED`_.

Sometimes the application needs more complex reconnection strategy:

- If the disconnect event is raised because the :cpp:func:`esp_wifi_disconnect()` "
"is called, the application may not want to do the reconnection.
- If the :cpp:func:`esp_wifi_scan_start()` may be called at anytime, a better reconnection strategy is necessary. Refer to `Scan When Wi-Fi Is Connecting`_.

Another thing that need to be considered is that the reconnection may not connect the same AP if there are more than one APs with the same SSID. The reconnection always select current best APs to connect.

Wi-Fi Beacon Timeout


The beacon timeout mechanism is used by {IDF_TARG"
"ET_NAME} station to detect whether the AP is alive or not. If the station does not receive the beacon of the connected AP within the inactive time, the beacon timeout happens. The application can set inactive time via API :cpp:func:`esp_wifi_set_inactive_time()`.

After the beacon times out, the station sends 5 probe requests to the AP. If still no probe response or beacon is received from AP, the station disconnects from the AP and raises the event `WIFI_EVENT_STA_DISCONNECTED`_.

It should be "
"considered that the timer used for beacon timeout will be reset during the scanning process. It means that the scan process will affect the triggering of the event `WIFI_EVENT_STA_BEACON_TIMEOUT`_.

{IDF_TARGET_NAME} Wi-Fi Configuration


All configurations will be stored into flash when the Wi-Fi NVS is enabled; otherwise, refer to `Wi-Fi NVS Flash`_.

Wi-Fi Mode
+++++++++++++++++++++++++
Call :cpp:func:`esp_wifi_set_mode()` to set the Wi-Fi mode.

.. list-table::
   :header-rows: 1
   :widths:"
" 15 50
     - Description
     - NULL mode: in this mode, the internal data struct is not allocated to the station and the AP, while both the station and AP interfaces are not initialized for RX/TX Wi-Fi data. Generally, this mode is used for Sniffer, or when you only want to stop both the station and the AP without calling :cpp:func:`esp_wifi_deinit()` to unload the whole Wi-Fi driver.
     - Station mode: in this mode, :cpp:func:`esp_wifi_start()` will init the internal station data, while the"
" station’s interface is ready for the RX and TX Wi-Fi data. After :cpp:func:`esp_wifi_connect()`, the station will connect to the target AP.
     - AP mode: in this mode, :cpp:func:`esp_wifi_start()` will init the internal AP data, while the AP’s interface is ready for RX/TX Wi-Fi data. Then, the Wi-Fi driver starts broad-casting beacons, and the AP is ready to get connected to other stations.
     - Station/AP coexistence mode: in this mode, :cpp:func:`esp_wifi_start()` will simultaneously init"
"ialize both the station and the AP. This is done in station mode and AP mode. Please note that the channel of the external AP, which the ESP station is connected to, has higher priority over the ESP AP channel.


Station Basic Configuration
+++++++++++++++++++++++++++++++++++++

API :cpp:func:`esp_wifi_set_config()` can be used to configure the station. And the configuration will be stored in NVS. The table below describes the fields in detail.

.. list-table::
   :header-rows: 1
   :widths: 15 "
"50
     - Description
     - This is the SSID of the target AP, to which the station wants to connect.
     - Password of the target AP.
     - For ``WIFI_FAST_SCAN`` scan, the scan ends when the first matched AP is found. For ``WIFI_ALL_CHANNEL_SCAN``, the scan finds all matched APs on all channels. The default scan is ``WIFI_FAST_SCAN``.
     - If bssid_set is 0, the station connects to the AP whose SSID is the same as the field “ssid”, while the field “bssid” is ignored. In all other cases, t"
"he station connects to the AP whose SSID is the same as the “ssid” field, while its BSSID is the same the “bssid” field .
     - This is valid only when bssid_set is 1; see field “bssid_set”.
     - If the channel is 0, the station scans the channel 1 ~ N to search for the target AP; otherwise, the station starts by scanning the channel whose value is the same as that of the “channel” field, and then scans the channel 1 ~ N but skip the specific channel to find the target AP. For example, if the"
" channel is 3, the scan order will be 3, 1, 2, 4,..., N. If you do not know which channel the target AP is running on, set it to 0.
     - This field is only for ``WIFI_ALL_CHANNEL_SCAN``.

       If the sort_method is ``WIFI_CONNECT_AP_BY_SIGNAL``, all matched APs are sorted by signal, and the AP with the best signal will be connected firstly. For example, the station wants to connect an AP whose SSID is “apxx”. If the scan finds two APs whose SSID equals to “apxx”, and the first AP’s signal is"
" -90 dBm while the second AP’s signal is -30 dBm, the station connects the second AP firstly, and it would not connect the first one unless it fails to connect the second one.

       If the sort_method is ``WIFI_CONNECT_AP_BY_SECURITY``, all matched APs are sorted by security. For example, the station wants to connect an AP whose SSID is “apxx”. If the scan finds two APs whose SSID is “apxx”, and the security of the first found AP is open while the second one is WPA2, the station connects to th"
"e second AP firstly, and it would not connect the first one unless it fails to connect the second one.
     - The threshold is used to filter the found AP. If the RSSI or security mode is less than the configured threshold, the AP will be discarded.

       If the RSSI is set to 0, it means the default threshold and the default RSSI threshold are -127 dBm. If the authmode threshold is set to 0, it means the default threshold and the default authmode threshold are open.


.. attention::

    WEP/"
"WPA security modes are deprecated in IEEE 802.11-2016 specifications and are recommended not to be used. These modes can be rejected using authmode threshold by setting threshold as WPA2 by threshold.authmode as ``WIFI_AUTH_WPA2_PSK``.

AP Basic Configuration
+++++++++++++++++++++++++++++++++++++

API :cpp:func:`esp_wifi_set_config()` can be used to configure the AP. And the configuration will be stored in NVS. The table below describes the fields in detail.

.. only:: esp32 or esp32s2 or esp32s"
"3 or esp32c3 or esp32c6

    .. list-table::
      :header-rows: 1
      :widths: 15 55
        - Description
        - SSID of AP; if the ssid[0] is 0xFF and ssid[1] is 0xFF, the AP defaults the SSID to ``ESP_aabbcc``, where “aabbcc” is the last three bytes of the AP MAC.
        - Password of AP; if the auth mode is ``WIFI_AUTH_OPEN``, this field will be ignored.
        - Length of SSID; if ssid_len is 0, check the SSID until there is a termination character. If ssid_len > 32, change it to 32"
"; otherwise, set the SSID length according to ssid_len.
        - Channel of AP; if the channel is out of range, the Wi-Fi driver defaults to channel 1. So, please make sure the channel is within the required range. For more details, refer to `Wi-Fi Country Code`_.
        - Auth mode of ESP AP; currently, ESP AP does not support AUTH_WEP. If the authmode is an invalid value, AP defaults the value to ``WIFI_AUTH_OPEN``.
        - If ssid_hidden is 1, AP does not broadcast the SSID; otherwise, it"
" does broadcast the SSID.
        - The max number of stations allowed to connect in, the default value is 10. ESP Wi-Fi supports up to {IDF_TARGET_MAX_CONN_STA_NUM} (``ESP_WIFI_MAX_CONN_NUM``) Wi-Fi connections. Please note that ESP AP and ESP-NOW share the same encryption hardware keys, so the max_connection parameter will be affected by the :ref:`CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM`. The total number of encryption hardware keys is 17, if :ref:`CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM`  32, c"
"hange it to 32; otherwise, set the SSID length according to ssid_len.
        - Channel of AP; if the channel is out of range, the Wi-Fi driver defaults to channel 1. So, please make sure the channel is within the required range. For more details, refer to `Wi-Fi Country Code`_.
        - Auth mode of ESP AP; currently, ESP AP does not support AUTH_WEP. If the authmode is an invalid value, AP defaults the value to ``WIFI_AUTH_OPEN``.
        - If ssid_hidden is 1, AP does not broadcast the SSID;"
" otherwise, it does broadcast the SSID.
        - The max number of stations allowed to connect in, the default value is 2. ESP Wi-Fi supports up to {IDF_TARGET_MAX_CONN_STA_NUM} (``ESP_WIFI_MAX_CONN_NUM``) Wi-Fi connections. Please note that ESP AP and ESP-NOW share the same encryption hardware keys, so the max_connection parameter will be affected by the :ref:`CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM`. The total number of encryption hardware keys is {IDF_TARGET_MAX_CONN_STA_NUM}, the max_connect"
"ion can be set up to ({IDF_TARGET_MAX_CONN_STA_NUM} - :ref:`CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM`).
        - Beacon interval; the value is 100 ~ 60000 ms, with default value being 100 ms. If the value is out of range, AP defaults it to 100 ms.


Wi-Fi Protocol Mode
+++++++++++++++++++++++++

Currently, the ESP-IDF supports the following protocol modes:

.. only:: esp32 or esp32s2 or esp32c3 or esp32s3

    .. list-table::
      :header-rows: 1
      :widths: 15 55
        - Description
      "
"  - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B)`` to set the station/AP to 802.11b-only mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G)`` to set the station/AP to 802.11bg mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G)`` and esp_wifi_config_11b_rate(ifx, true) to set the station/AP to 802.11g mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B| WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)`` to set the"
" station/ AP to BGN mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)`` and esp_wifi_config_11b_rate(ifx, true) to set the station/AP to 802.11gn mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B| WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_LR)`` to set the station/AP to BGN and the LR mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_LR)`` to set the station/AP only to the LR mode.

          **This mod"
"e is an Espressif-patented mode which can achieve a one-kilometer line of sight range. Please make sure both the station and the AP are connected to an ESP device.**

.. only:: esp32c6

    .. list-table::
      :header-rows: 1
      :widths: 15 55
        - Description
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B)`` to set the station/AP to 802.11b-only mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G)`` to set the station/AP to 802.11bg mod"
"e.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G)`` and ``esp_wifi_config_11b_rate(ifx, true)`` to set the station/AP to 802.11g mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B| WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)`` to set the station/ AP to BGN mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)`` and esp_wifi_config_11b_rate(ifx, true) to set the station/AP to 802.11gn mode.
        - Ca"
"ll ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B| WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_LR)`` to set the station/AP to BGN and the LR mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B| WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AX)`` to set the station/ AP to 802.11bgnax mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B| WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AX|WIFI_PROTOCOL_LR)`` to set the station/ AP to 802.11bgnax and LR"
" mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_LR)`` to set the station/AP only to the LR mode.

          **This mode is an Espressif-patented mode which can achieve a one-kilometer line of sight range. Please make sure both the station and the AP are connected to an ESP device.**

.. only:: esp32c2

    .. list-table::
      :header-rows: 1
      :widths: 15 55
        - Description
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B)`` to set the station/AP to 802."
"11b-only mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G)`` to set the station/AP to 802.11bg mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G) and esp_wifi_config_11b_rate(ifx, true)`` to set the station/AP to 802.11g mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B| WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)`` to set the station/ AP to BGN mode.
        - Call ``esp_wifi_set_protocol(ifx, WIFI_PROTOCOL_11B|"
"WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)`` and ``esp_wifi_config_11b_rate(ifx, true)`` to set the station/AP to 802.11gn mode.



.. only:: esp32 or esp32s2 or esp32c3 or esp32s3 or esp32c6

    Long Range (LR)
    +++++++++++++++++++++++++

    Long Range (LR) mode is an Espressif-patented Wi-Fi mode which can achieve a one-kilometer line of sight range. Compared to the traditional 802.11b mode, it has better reception sensitivity, stronger anti-interference ability, and longer transmission distanc"
"e.

    LR Compatibility
    

    Since LR is Espressif-unique Wi-Fi mode, only ESP32 chip series devices (except ESP32-C2) can transmit and receive the LR data. In other words, the ESP32 chip series devices (except ESP32-C2) should NOT transmit the data in LR data rate if the connected device does not support LR. The application can achieve this by configuring a suitable Wi-Fi mode. If the negotiated mode supports LR, the ESP32 chip series devices (except ESP32-C2) may transmit data in LR rate"
". Otherwise, ESP32 chip series devices (except ESP32-C2) will transmit all data in the traditional Wi-Fi data rate.

    The following table depicts the Wi-Fi mode negotiation:

    .. only:: esp32 or esp32s2 or esp32c3 or esp32s3

        ++++---+++++
        |AP\STA | BGN | BG | B | BGNLR | BGLR | BLR | LR |
        ++++===+++++
        | BGN   | BGN | BG | B | BGN   | BG   | B   | -  |
        ++++---+++++
        | BG    | BG  | BG | B | BG    | BG   | B   | -  |
        ++++---+++++
       "
" | B     | B   | B  | B | B     | B    | B   | -  |
        ++++---+++++
        | BGNLR | -   | -  | - | BGNLR | BGLR | BLR | LR |
        ++++---+++++
        | BGLR  | -   | -  | - | BGLR  | BGLR | BLR | LR |
        ++++---+++++
        | BLR   | -   | -  | - | BLR   | BLR  | BLR | LR |
        ++++---+++++
        | LR    | -   | -  | - | LR    | LR   | LR  | LR |
        ++++---+++++

    .. only:: esp32c6

        +++++---++++++
        | AP\STA  | BGNAX | BGN | BG | B | BGNAXLR | BGNLR |"
" BGLR | BLR | LR |
        +++++===++++++
        | BGNAX   | BGAX  | BGN | BG | B | BGAX    | BGN   | BG   | B   | -  |
        +++++---++++++
        | BGN     | BGN   | BGN | BG | B | BGN     | BGN   | BG   | B   | -  |
        +++++---++++++
        | BG      | BG    | BG  | BG | B | BG      | BG    | BG   | B   | -  |
        +++++---++++++
        | B       | B     | B   | B  | B | B       | B     | B    | B   | -  |
        +++++---++++++
        | BGNAXLR | -     | -   | -  | - | BGAXLR "
" | BGNLR | BGLR | BLR | LR |
        +++++---++++++
        | BGNLR   | -     | -   | -  | - | BGNLR   | BGNLR | BGLR | BLR | LR |
        +++++---++++++
        | BGLR    | -     | -   | -  | - | BGLR    | BGLR  | BGLR | BLR | LR |
        +++++---++++++
        | BLR     | -     | -   | -  | - | BLR     | BLR   | BLR  | BLR | LR |
        +++++---++++++
        | LR      | -     | -   | -  | - | LR      | LR    | LR   | LR  | LR |
        +++++---++++++

    In the above table, the row is the "
"Wi-Fi mode of AP and the column is the Wi-Fi mode of station. The ""-"" indicates Wi-Fi mode of the AP and station are not compatible.

    According to the table, the following conclusions can be drawn:

    - For LR-enabled AP of {IDF_TARGET_NAME}, it is incompatible with traditional 802.11 mode, because the beacon is sent in LR mode.
    - For LR-enabled station of {IDF_TARGET_NAME} whose mode is NOT LR-only mode, it is compatible with traditional 802.11 mode.
    - If both station and AP are E"
"SP32 series chips devices (except ESP32-C2) and both of them have enabled LR mode, the negotiated mode supports LR.

    If the negotiated Wi-Fi mode supports both traditional 802.11 mode and LR mode, it is the Wi-Fi driver's responsibility to automatically select the best data rate in different Wi-Fi modes and the application can ignore it.

    LR Impacts to Traditional Wi-Fi Device
    

    The data transmission in LR rate has no impacts on the traditional Wi-Fi device because:

    - The CC"
"A and backoff process in LR mode are consistent with 802.11 specification.
    - The traditional Wi-Fi device can detect the LR signal via CCA and do backoff.

    In other words, the transmission impact in LR mode is similar to that in 802.11b mode.

    LR Transmission Distance
    

    The reception sensitivity gain of LR is about 4 dB larger than that of the traditional 802.11b mode. Theoretically, the transmission distance is about 2 to 2.5 times the distance of 11B.

    LR Throughput
   "
" 

    The LR rate has very limited throughput, because the raw PHY data rate LR is 1/2 Mbps and 1/4 Mbps.

    When to Use LR
    

    The general conditions for using LR are:

    - Both the AP and station are Espressif devices.
    - Long distance Wi-Fi connection and data transmission is required.
    - Data throughput requirements are very small, such as remote device control.

Wi-Fi Country Code
+++++++++++++++++++++++++

Call :cpp:func:`esp_wifi_set_country()` to set the country info. Th"
"e table below describes the fields in detail. Please consult local 2.4 GHz RF operating regulations before configuring these fields.

.. list-table::
   :header-rows: 1
   :widths: 15 55
     - Description
     - Country code string. This attribute identifies the country or noncountry entity in which the station/AP is operating. If it is a country, the first two octets of this string is the two-character country info as described in the document ISO/IEC3166-1. The third octet is one of the follo"
"wing:

       - an ASCII space character, which means the regulations under which the station/AP is operating encompass all environments for the current frequency band in the country.
       - an ASCII ‘O’ character, which means the regulations under which the station/AP is operating are for an outdoor environment only.
       - an ASCII ‘I’ character, which means the regulations under which the station/AP is operating are for an indoor environment only.
       - an ASCII ‘X’ character, which me"
"ans the station/AP is operating under a noncountry entity. The first two octets of the noncountry entity is two ASCII ‘XX’ characters.
       - the binary representation of the Operating Class table number currently in use. Refer to Annex E of IEEE Std 802.11-2020.
     - Start channel. It is the minimum channel number of the regulations under which the station/AP can operate.
     - Total number of channels as per the regulations. For example, if the schan=1, nchan=13, then the station/AP can s"
"end data from channel 1 to 13.
     - Country policy. This field controls which country info will be used if the configured country info is in conflict with the connected AP’s. For more details on related policies, see the following section.


The default country info is::

    wifi_country_t config = {
        .cc = ""01"",
        .schan = 1,
        .nchan = 11,
        .policy = WIFI_COUNTRY_POLICY_AUTO,
    };

If the Wi-Fi Mode is station/AP coexist mode, they share the same configured count"
"ry info. Sometimes, the country info of AP, to which the station is connected, is different from the country info of configured. For example, the configured station has country info::

    wifi_country_t config = {
        .cc = ""JP"",
        .schan = 1,
        .nchan = 14,
        .policy = WIFI_COUNTRY_POLICY_AUTO,
    };

but the connected AP has country info::

    wifi_country_t config = {
        .cc = ""CN"",
        .schan = 1,
        .nchan = 13,
    };

then country info of connected A"
"P's is used.

The following table depicts which country info is used in different Wi-Fi modes and different country policies, and it also describes the impact on active scan.

.. list-table::
   :header-rows: 1
   :widths: 15 15 35
     - Policy
     - Description
     - WIFI_COUNTRY_POLICY_AUTO
     - If the connected AP has country IE in its beacon, the country info equals to the country info in beacon. Otherwise, use the default country info.

       For scan:

         Use active scan from 1"
" to 11 and use passive scan from 12 to 14.

       Always keep in mind that if an AP with hidden SSID and station is set to a passive scan channel, the passive scan will not find it. In other words, if the application hopes to find the AP with hidden SSID in every channel, the policy of country info should be configured to WIFI_COUNTRY_POLICY_MANUAL.
     - WIFI_COUNTRY_POLICY_MANUAL
     - Always use the configured country info.

       For scan:

         Use active scan from schan to schan+nc"
"han-1.
     - WIFI_COUNTRY_POLICY_AUTO
     - Always use the configured country info.
     - WIFI_COUNTRY_POLICY_MANUAL
     - Always use the configured country info.
     - WIFI_COUNTRY_POLICY_AUTO
     - Station: Same as station mode with policy WIFI_COUNTRY_POLICY_AUTO.
       AP: If the station does not connect to any external AP, the AP uses the configured country info. If the station connects to an external AP, the AP has the same country info as the station.
     - WIFI_COUNTRY_POLICY_MAN"
"UAL
     - Station: Same as station mode with policy WIFI_COUNTRY_POLICY_MANUAL.
       AP: Same as AP mode with policy WIFI_COUNTRY_POLICY_MANUAL.


Home Channel


In AP mode, the home channel is defined as the AP channel. In station mode, home channel is defined as the channel of AP which the station is connected to. In station/AP-coexistence mode, the home channel of AP and station must be the same, and if they are different, the station's home channel is always in priority. For example, assu"
"me that the AP is on channel 6, and the station connects to an AP whose channel is 9. Since the station's home channel has higher priority, the AP needs to switch its channel from 6 to 9 to make sure that it has the same home channel as the station. While switching channel, the {IDF_TARGET_NAME} in AP mode will notify the connected stations about the channel migration using a Channel Switch Announcement (CSA). Station that supports channel switching will transit without disconnecting and reconne"
"cting to the AP.


Wi-Fi Vendor IE Configuration
+++++++++++++++++++++++++++++++++++

By default, all Wi-Fi management frames are processed by the Wi-Fi driver, and the application can ignore them. However, some applications may have to handle the beacon, probe request, probe response, and other management frames. For example, if you insert some vendor-specific IE into the management frames, it is only the management frames which contain this vendor-specific IE that will be processed. In {IDF_TA"
"RGET_NAME}, :cpp:func:`esp_wifi_set_vendor_ie()` and :cpp:func:`esp_wifi_set_vendor_ie_cb()` are responsible for this kind of tasks.

Wi-Fi Easy Connect™ (DPP)


Wi-Fi Easy Connect\ :sup:`TM` (or Device Provisioning Protocol) is a secure and standardized provisioning protocol for configuring Wi-Fi devices. More information can be found in :doc:`esp_dpp `.

WPA2-Enterprise
+++++++++++++++++++++++++++++++++

WPA2-Enterprise is the secure authentication mechanism for enterprise wireless networks. I"
"t uses RADIUS server for authentication of network users before connecting to the Access Point. The authentication process is based on 802.1X policy and comes with different Extended Authentication Protocol (EAP) methods such as TLS, TTLS, and PEAP. RADIUS server authenticates the users based on their credentials (username and password), digital certificates, or both. When {IDF_TARGET_NAME} in station mode tries to connect an AP in enterprise mode, it sends authentication request to AP which is "
"sent to RADIUS server by AP for authenticating the station. Based on different EAP methods, the parameters can be set in configuration which can be opened using ``idf.py menuconfig``. WPA2_Enterprise is supported by {IDF_TARGET_NAME} only in station mode.

For establishing a secure connection, AP and station negotiate and agree on the best possible cipher suite to be used. {IDF_TARGET_NAME} supports 802.1X/EAP (WPA) method of AKM and Advanced encryption standard with Counter Mode Cipher Block Ch"
"aining Message Authentication protocol (AES-CCM) cipher suite. It also supports the cipher suites supported by mbedtls if `USE_MBEDTLS_CRYPTO` flag is set.

{IDF_TARGET_NAME} currently supports the following EAP methods:
  - EAP-TLS: This is a certificate-based method and only requires SSID and EAP-IDF.
  - PEAP: This is a Protected EAP method. Username and Password are mandatory.
  - EAP-TTLS: This is a credential-based method. Only server authentication is mandatory while user authentication i"
"s optional. Username and Password are mandatory. It supports different Phase2 methods, such as:
     - PAP: Password Authentication Protocol.
     - CHAP: Challenge Handshake Authentication Protocol.
     - MSCHAP and MSCHAP-V2.
  - EAP-FAST: This is an authentication method based on Protected Access Credentials (PAC) which also uses identity and password. Currently, USE_MBEDTLS_CRYPTO flag should be disabled to use this feature.

Detailed information on creating certificates and how to run wpa2"
"_enterprise example on {IDF_TARGET_NAME} can be found in :example:`wifi/wifi_enterprise`.

.. only:: SOC_WIFI_NAN_SUPPORT

    Wi-Fi Aware\ :sup:`TM` (NAN)
    

    Wi-Fi Aware\ :sup:`TM` or NAN (Neighbor Awareness Networking) is a protocol that allows Wi-Fi devices to discover services in their proximity. NAN uses direct device-to-device communication and does not require any Internet or AP connection.

    Multiple NAN devices in the vicinity will form a NAN cluster which allows them to commu"
"nicate with each other. NAN devices in a cluster synchronise their clocks and listen to each other periodically on Channel 6. Devices can advertise (Publish) or seek for (Subscribe) services within their NAN Cluster using Service Discovery protocols. Matching of services is done by service name and optionally matching filters. Once a Subscriber gets a match with a Publisher, it can either send a message (Follow-up) or establish a datapath (NDP) with the Publisher. After NDP is setup both devices"
" will obtain an IPv6 address and can use it for communication.

    Please note that NAN Datapath security is not supported i.e., the data packets will go out unencrypted. NAN uses a separate interface for Discovery and Datapath, which is other than that used for STA and AP. NAN operates in standalone mode, which means co-existence with STA or AP interface is not supported.

    Refer to ESP-IDF examples :idf_file:`examples/wifi/wifi_aware/nan_publisher/README.md` and :idf_file:`examples/wifi/wi"
"fi_aware/nan_subscriber/README.md` to setup a NAN Publisher and Subscriber.

Wireless Network Management


Wireless Network Management allows client devices to exchange information about the network topology, including information related to RF environment. This makes each client network-aware, facilitating overall improvement in the performance of the wireless network. It is part of 802.11v specification. It also enables the client to support Network assisted Roaming.
- Network assisted Roaming"
": Enables WLAN to send messages to associated clients, resulting clients to associate with APs with better link metrics. This is useful for both load balancing and in directing poorly connected clients.

Current implementation of 802.11v includes support for BSS transition management frames.

Radio Resource Measurement


Radio Resource Measurement (802.11k) is intended to improve the way traffic is distributed within a network. In a WLAN, each device normally connects to the access point (AP) th"
"at provides the strongest signal. Depending on the number and geographic locations of the subscribers, this arrangement can sometimes lead to excessive demand on one AP and underutilization of others, resulting in degradation of overall network performance. In a network conforming to 802.11k, if the AP having the strongest signal is loaded to its full capacity, a wireless device can be moved to one of the underutilized APs. Even though the signal may be weaker, the overall throughput is greater "
"because more efficient use is made of the network resources.

Current implementation of 802.11k includes support for beacon measurement report, link measurement report, and neighbor request.

Refer ESP-IDF example :idf_file:`examples/wifi/roaming/README.md` to set up and use these APIs. Example code only demonstrates how these APIs can be used, and the application should define its own algorithm and cases as required.

Fast BSS Transition

Fast BSS transition (802.11R FT), is a standard to permi"
"t continuous connectivity aboard wireless devices in motion, with fast and secure client transitions from one Basic Service Set (abbreviated BSS, and also known as a base station or more colloquially, an access point) to another performed in a nearly seamless manner **avoiding 802.1i 4 way handshake** . 802.11R specifies transitions between access points by redefining the security key negotiation protocol, allowing both the negotiation and requests for wireless resources to occur in parallel. Th"
"e key derived from the server to be cached in the wireless network, so that a reasonable number of future connections can be based on the cached key, avoiding the 802.1X process


{IDF_TARGET_NAME} station supports FT for WPA2-PSK networks. Do note that {IDF_TARGET_NAME} station only support FT over the air protocol only.

A config option :ref:`CONFIG_ESP_WIFI_11R_SUPPORT` and configuration parameter :cpp:type:`ft_enabled` in :cpp:type:`wifi_sta_config_t` is provided to enable 802.11R support fo"
"r station. Refer ESP-IDF example :idf_file:`examples/wifi/roaming/README.md` for further details.

.. only:: SOC_WIFI_FTM_SUPPORT

    Wi-Fi Location
    

    Wi-Fi Location will improve the accuracy of a device's location data beyond the Access Point, which will enable creation of new and feature-rich applications and services such as geo-fencing, network management, and navigation. One of the protocols used to determine the device location with respect to the Access Point is Fine Timing Measu"
"rement which calculates Time-of-Flight of a Wi-Fi frame.

    Fine Timing Measurement (FTM)
    +++++++++++++++++++++++++++++

    FTM is used to measure Wi-Fi Round Trip Time (Wi-Fi RTT) which is the time a Wi-Fi signal takes to travel from a device to another device and back again. Using Wi-Fi RTT, the distance between the devices can be calculated with a simple formula of `RTT * c / 2`, where c is the speed of light.

    FTM uses timestamps given by Wi-Fi interface hardware at the time of ar"
"rival or departure of frames exchanged between a pair of devices. One entity called FTM Initiator (mostly a station device) discovers the FTM Responder (can be a station or an Access Point) and negotiates to start an FTM procedure. The procedure uses multiple Action frames sent in bursts and its ACK's to gather the timestamps data. FTM Initiator gathers the data in the end to calculate an average Round-Trip-Time.

    {IDF_TARGET_NAME} supports FTM in below configuration:

    - {IDF_TARGET_NAME"
"} as FTM Initiator in station mode.
    - {IDF_TARGET_NAME} as FTM Responder in AP mode.

    Distance measurement using RTT is not accurate, and factors such as RF interference, multi-path travel, antenna orientation, and lack of calibration increase these inaccuracies. For better results, it is suggested to perform FTM between two ESP32 chip series devices (except ESP32-C2) as station and AP.

    Refer to ESP-IDF example :idf_file:`examples/wifi/ftm/README.md` for steps on how to set up and p"
"erform FTM.

{IDF_TARGET_NAME} Wi-Fi Power-saving Mode


This subsection will briefly introduce the concepts and usage related to Wi-Fi Power Saving Mode, for a more detailed introduction please refer to the :doc:`Low Power Mode User Guide `

Station Sleep
++++++++++++++++++++++

Currently, {IDF_TARGET_NAME} Wi-Fi supports the Modem-sleep mode which refers to the legacy power-saving mode in the IEEE 802.11 protocol. Modem-sleep mode works in station-only mode and the station must connect to the "
"AP first. If the Modem-sleep mode is enabled, station will switch between active and sleep state periodically. In sleep state, RF, PHY and BB are turned off in order to reduce power consumption. Station can keep connection with AP in modem-sleep mode.

Modem-sleep mode includes minimum and maximum power-saving modes. In minimum power-saving mode, station wakes up every DTIM to receive beacon. Broadcast data will not be lost because it is transmitted after DTIM. However, it cannot save much more "
"power if DTIM is short for DTIM is determined by AP.

In maximum power-saving mode, station wakes up in every listen interval to receive beacon. This listen interval can be set to be longer than the AP DTIM period. Broadcast data may be lost because station may be in sleep state at DTIM time. If listen interval is longer, more power is saved, but broadcast data is more easy to lose. Listen interval can be configured by calling API :cpp:func:`esp_wifi_set_config()` before connecting to AP.

Call "
"``esp_wifi_set_ps(WIFI_PS_MIN_MODEM)`` to enable Modem-sleep minimum power-saving mode or ``esp_wifi_set_ps(WIFI_PS_MAX_MODEM)`` to enable Modem-sleep maximum power-saving mode after calling :cpp:func:`esp_wifi_init()`. When station connects to AP, Modem-sleep will start. When station disconnects from AP, Modem-sleep will stop.

Call ``esp_wifi_set_ps(WIFI_PS_NONE)`` to disable Modem-sleep mode entirely. Disabling it increases power consumption, but minimizes the delay in receiving Wi-Fi data in"
" real time. When Modem-sleep mode is enabled, the delay in receiving Wi-Fi data may be the same as the DTIM cycle (minimum power-saving mode) or the listening interval (maximum power-saving mode).

.. only:: SOC_SUPPORT_COEXISTENCE

    Note that in coexist mode, Wi-Fi will remain active only during Wi-Fi time slice, and sleep during non Wi-Fi time slice even if ``esp_wifi_set_ps(WIFI_PS_NONE)`` is called. Please refer to :ref:`coexist policy `.

The default Modem-sleep mode is WIFI_PS_MIN_MODEM"
".

AP Sleep
+++++++++++++++++++++++++++++++

Currently, {IDF_TARGET_NAME} AP does not support all of the power-saving feature defined in Wi-Fi specification. To be specific, the AP only caches unicast data for the stations connect to this AP, but does not cache the multicast data for the stations. If stations connected to the {IDF_TARGET_NAME} AP are power-saving enabled, they may experience multicast packet loss.

In the future, all power-saving features will be supported on {IDF_TARGET_NAME} A"
"P.

Disconnected State Sleep
+++++++++++++++++++++++++++++++

Disconnected state is the duration without Wi-Fi connection between :cpp:func:`esp_wifi_start` to :cpp:func:`esp_wifi_stop`.

Currently, {IDF_TARGET_NAME} Wi-Fi supports sleep mode in disconnected state if running at station mode. This feature could be configured by Menuconfig choice :ref:`CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE`.

If :ref:`CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE` is enabled, RF, PHY and BB would be turned off i"
"n disconnected state when IDLE. The current would be same with current at modem-sleep.

The choice :ref:`CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE` would be selected by default, while it would be selected forcefully in Menuconfig at coexistence mode.

.. _connectionless-module-power-save:

Connectionless Modules Power-saving
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Connectionless modules are those Wi-Fi modules not relying on Wi-Fi connection, e.g ESP-NOW, DPP, FTM. These"
" modules start from :cpp:func:`esp_wifi_start`, working until :cpp:func:`esp_wifi_stop`.

Currently, if ESP-NOW works at station mode, its supported to sleep at both connected state and disconnected state.

Connectionless Modules TX


For each connectionless module, its supported to TX at any sleeping time without any extra configuration.

Meanwhile, :cpp:func:`esp_wifi_80211_tx` is supported at sleep as well.

Connectionless Modules RX


For each connectionless module, two parameters shall be c"
"onfigured to RX at sleep, which are `Window` and `Interval`.

At the start of `Interval` time, RF, PHY, BB would be turned on and kept for `Window` time. Connectionless Module could RX in the duration.

**Interval**

 - There is only one `Interval`. Its configured by :cpp:func:`esp_wifi_set_connectionless_interval`. The unit is milliseconds.

 - The default value of `Interval` is `ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE`.

 - Event `WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START`_ wo"
"uld be posted at the start of `Interval`. Since `Window` also starts at that moment, its recommended to TX in that event.

 - At connected state, the start of `Interval` would be aligned with TBTT.

**Window**

 - Each connectionless module has its own `Window` after start. Connectionless Modules Power-saving would work with the max one among them.

 - `Window` is configured by :cpp:func:`module_name_set_wake_window`. The unit is milliseconds.

 - The default value of `Window` is the maximum.

."
". table:: RF, PHY and BB usage under different circumstances

    ++++
    |                      | Interval                                                                                                                        |
    +                      +++
    |                      | ``ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE``   | 1 - maximum                                                               |
    +++++
    | Window | 0           | not used                                 "
"                                                                                       |
    +        ++++
    |        | 1 - maximum | default mode                                        | used periodically (Window  antenna_select[0] ---|         | --- antenna 0
    RX/TX ___                    \\____\  GPIO[1]  antenna_select[1] ---| Antenna | --- antenna 1
             \      __________   //    /  GPIO[2]  antenna_select[2] ---| Switch  | ...  ...
              \ ___|Enabled   | //        GPI"
"O[3]  antenna_select[3] ---|_________| --- antenna 15
               \   |Antenna 1 |//
                   |__________|


{IDF_TARGET_NAME} supports up to sixteen antennas through external antenna switch. The antenna switch can be controlled by up to four address pins - antenna_select[0:3]. Different input value of antenna_select[0:3] means selecting different antenna. For example, the value '0b1011' means the antenna 11 is selected. The default value of antenna_select[3:0] is '0b0000', which me"
"ans the antenna 0 is selected by default.

Up to four GPIOs are connected to the four active high antenna_select pins. {IDF_TARGET_NAME} can select the antenna by control the GPIO[0:3]. The API :cpp:func:`esp_wifi_set_ant_gpio()` is used to configure which GPIOs are connected to antenna_selects. If GPIO[x] is connected to antenna_select[x], then gpio_config->gpio_cfg[x].gpio_select should be set to 1 and gpio_config->gpio_cfg[x].gpio_num should be provided.

For the specific implementation of th"
"e antenna switch, there may be illegal values in `antenna_select[0:3]`. It means that {IDF_TARGET_NAME} may support less than sixteen antennas through the switch. For example, ESP32-WROOM-DA which uses RTC6603SP as the antenna switch, supports two antennas. Two GPIOs are connected to two active high antenna selection inputs. The value '0b01' means the antenna 0 is selected, the value '0b10' means the antenna 1 is selected. Values '0b00' and '0b11' are illegal.

Although up to sixteen antennas ar"
"e supported, only one or two antennas can be simultaneously enabled for RX/TX. The API :cpp:func:`esp_wifi_set_ant()` is used to configure which antennas are enabled.

The enabled antennas selecting algorithm is also configured by :cpp:func:`esp_wifi_set_ant()`. The RX/TX antenna mode can be :cpp:enumerator:`WIFI_ANT_MODE_ANT0`, :cpp:enumerator:`WIFI_ANT_MODE_ANT1`, or :cpp:enumerator:`WIFI_ANT_MODE_AUTO`. If the antenna mode is :cpp:enumerator:`WIFI_ANT_MODE_ANT0`, the enabled antenna 0 is sele"
"cted for RX/TX data. If the antenna mode is :cpp:enumerator:`WIFI_ANT_MODE_ANT1`, the enabled antenna 1 is selected for RX/TX data. Otherwise, Wi-Fi automatically selects the enabled antenna that has better signal.

If the RX antenna mode is :cpp:enumerator:`WIFI_ANT_MODE_AUTO`, the default antenna mode also needs to be set, because the RX antenna switching only happens when some conditions are met. For example, the RX antenna starts to switch if the RSSI is lower than -65 dBm or another antenna"
" has better signal. RX uses the default antenna if the conditions are not met. If the default antenna mode is :cpp:enumerator:`WIFI_ANT_MODE_ANT1`, the enabled antenna 1 is used as the default RX antenna, otherwise the enabled antenna 0 is used.

Some limitations need to be considered:

 - The TX antenna can be set to :cpp:enumerator:`WIFI_ANT_MODE_AUTO` only if the RX antenna mode is :cpp:enumerator:`WIFI_ANT_MODE_AUTO`, because TX antenna selecting algorithm is based on RX antenna in :cpp:enum"
"erator:`WIFI_ANT_MODE_AUTO` type.
 - When the TX antenna mode or RX antenna mode is configured to :cpp:enumerator:`WIFI_ANT_MODE_AUTO` the switching mode will easily trigger the switching phase, as long as there is deterioration of the RF signal. So in situations where the RF signal is not stable, the antenna switching will occur frequently, resulting in an RF performance that may not meet expectations.
 - Currently, Bluetooth® does not support the multiple antennas feature, so please do not use"
" multiple antennas related APIs.

Following is the recommended scenarios to use the multiple antennas:

 - The applications can always choose to select a specified antenna or implement their own antenna selecting algorithm, e.g., selecting the antenna mode based on the information collected by the application. Refer to ESP-IDF example :idf_file:`examples/wifi/antenna/README.md` for the antenna selecting algorithm design.
 - Both RX/TX antenna modes are configured to WIFI_ANT_MODE_ANT0 or WIFI_AN"
"T_MODE_ANT1.


Wi-Fi Multiple Antennas Configuration
+++++++++++++++++++++++++++++++++++++

Generally, following steps can be taken to configure the multiple antennas:

- Configure which GPIOs are connected to the antenna_selects. For example, if four antennas are supported and GPIO20/GPIO21 are connected to antenna_select[0]/antenna_select[1], the configurations look like:

.. code-block:: c

    wifi_ant_gpio_config_t ant_gpio_config = {
        .gpio_cfg[0] = { .gpio_select = 1, .gpio_num = 2"
"0 },
        .gpio_cfg[1] = { .gpio_select = 1, .gpio_num = 21 }
    };

- Configure which antennas are enabled and how RX/TX use the enabled antennas. For example, if antenna1 and antenna3 are enabled, the RX needs to select the better antenna automatically and uses antenna1 as its default antenna, the TX always selects the antenna3. The configuration looks like:

.. code-block:: c

    wifi_ant_config_t config = {
        .rx_ant_mode = WIFI_ANT_MODE_AUTO,
        .rx_ant_default = WIFI_ANT_AN"
"T0,
        .tx_ant_mode = WIFI_ANT_MODE_ANT1,
        .enabled_ant0 = 1,
        .enabled_ant1 = 3
    };

.. only:: SOC_WIFI_CSI_SUPPORT

    Wi-Fi Channel State Information
    

    Channel state information (CSI) refers to the channel information of a Wi-Fi connection. In {IDF_TARGET_NAME}, this information consists of channel frequency responses of sub-carriers and is estimated when packets are received from the transmitter. Each channel frequency response of sub-carrier is recorded by two"
" bytes of signed characters. The first one is imaginary part and the second one is real part. There are up to three fields of channel frequency responses according to the type of received packet. They are legacy long training field (LLTF), high throughput LTF (HT-LTF), and space time block code HT-LTF (STBC-HT-LTF). For different types of packets which are received on channels with different state, the sub-carrier index and total bytes of signed characters of CSI are shown in the following table"
".

    ++++++
    | channel     | secondary channel  |                   none                  |                           below                        |                            above                         |
    +++++++++
    | packet      | signal mode        |   non HT    |            HT             |  non HT  |                      HT                     |  non HT  |                       HT                      |
    +             ++++++++++
    | information | channel bandwidth  |    2"
"0 MHz   |           20 MHz          |   20 MHz |      20 MHz     |            40 MHz         |   20 MHz |       20 MHz      |            40 MHz         |
    +             +++++++++++++++
    |             | STBC               |  non STBC   |  non STBC   |     STBC    | non STBC | non STBC | STBC |  non STBC   |     STBC    | non STBC | non STBC |  STBC  |  non STBC   |     STBC    |
    ++++++++++++++++
    | sub-carrier | LLTF               | 0~31, -32~-1| 0~31, -32~-1| 0~31, -32~-1|   0~63   "
"|   0~63   | 0~63 |     0~63    |     0~63    |  -64~-1  |  -64~-1  | -64~-1 |    -64~-1   |    -64~-1   |
    +             +++++++++++++++
    | index       | HT-LTF             |      -      | 0~31, -32~-1| 0~31, -32~-1|     -    |   0~63   | 0~62 | 0~63, -64~-1| 0~60, -60~-1|     -    |  -64~-1  | -62~-1 | 0~63, -64~-1| 0~60, -60~-1|
    +             +++++++++++++++
    |             | STBC-HT-LTF        |      -      |      -      | 0~31, -32~-1|     -    |     -    | 0~62 |       -     | "
"0~60, -60~-1|     -    |     -    | -62~-1 |       -     | 0~60, -60~-1|
    ++++++++++++++++
    | total bytes                      |     128     |     256     |     384     |    128   |    256   | 380  |      384    |      612    |    128   |    256   |   376  |      384    |      612    |
    +++++++++++++++

    All of the information in the table can be found in the structure wifi_csi_info_t.

        - Secondary channel refers to secondary_channel field of rx_ctrl field.
        - Signal m"
"ode of packet refers to sig_mode field of rx_ctrl field.
        - Channel bandwidth refers to cwb field of rx_ctrl field.
        - STBC refers to stbc field of rx_ctrl field.
        - Total bytes refers to len field.
        - The CSI data corresponding to each Long Training Field (LTF) type is stored in a buffer starting from the buf field. Each item is stored as two bytes: imaginary part followed by real part. The order of each item is the same as the sub-carrier in the table. The order of "
"LTF is: LLTF, HT-LTF, STBC-HT-LTF. However, all 3 LTFs may not be present, depending on the channel and packet information (see above).
        - If first_word_invalid field of :cpp:type:`wifi_csi_info_t` is true, it means that the first four bytes of CSI data is invalid due to a hardware limitation in {IDF_TARGET_NAME}.
        - More information like RSSI, noise floor of RF, receiving time and antenna is in the rx_ctrl field.

    When imaginary part and real part data of sub-carrier are used,"
" please refer to the table below.

    +++++
    | PHY standard    | Sub-carrier range | Pilot sub-carrier            | Sub-carrier (total/data) |
    +++++
    | 802.11a/g       | -26 to +26        | -21, -7, +7, +21             | 52 total, 48 usable      |
    +++++
    | 802.11n, 20 MHz | -28 to +28        | -21, -7, +7, +21             | 56 total, 52 usable      |
    +++++
    | 802.11n, 40 MHz | -57 to +57        | -53, -25, -11, +11, +25, +53 | 114 total, 108 usable    |
    +++++

    .."
" note::

        - For STBC packet, CSI is provided for every space-time stream without CSD (cyclic shift delay). As each cyclic shift on the additional chains shall be -200 ns, only the CSD angle of first space-time stream is recorded in sub-carrier 0 of HT-LTF and STBC-HT-LTF for there is no channel frequency response in sub-carrier 0. CSD[10:0] is 11 bits, ranging from -pi to pi.

        - If LLTF, HT-LTF, or STBC-HT-LTF is not enabled by calling API :cpp:func:`esp_wifi_set_csi_config()`, th"
"e total bytes of CSI data will be fewer than that in the table. For example, if LLTF and HT-LTF is not enabled and STBC-HT-LTF is enabled, when a packet is received with the condition above/HT/40MHz/STBC, the total bytes of CSI data is 244 ((61 + 60) * 2 + 2 = 244. The result is aligned to four bytes, and the last two bytes are invalid).

    Wi-Fi Channel State Information Configure
    

    To use Wi-Fi CSI, the following steps need to be done.

        - Select Wi-Fi CSI in menuconfig. Go to"
" ``Menuconfig`` > ``Components config`` > ``Wi-Fi`` > ``Wi-Fi CSI (Channel State Information)``.
        - Set CSI receiving callback function by calling API :cpp:func:`esp_wifi_set_csi_rx_cb()`.
        - Configure CSI by calling API :cpp:func:`esp_wifi_set_csi_config()`.
        - Enable CSI by calling API :cpp:func:`esp_wifi_set_csi()`.

    The CSI receiving callback function runs from Wi-Fi task. So, do not do lengthy operations in the callback function. Instead, post necessary data to a qu"
"eue and handle it from a lower priority task. Because station does not receive any packet when it is disconnected and only receives packets from AP when it is connected, it is suggested to enable sniffer mode to receive more CSI data by calling :cpp:func:`esp_wifi_set_promiscuous()`.

Wi-Fi HT20/40


.. only:: esp32 or esp32s2 or esp32c3 or esp32s3 or esp32c6

    {IDF_TARGET_NAME} supports Wi-Fi bandwidth HT20 or HT40 and does not support HT20/40 coexist. :cpp:func:`esp_wifi_set_bandwidth()` ca"
"n be used to change the default bandwidth of station or AP. The default bandwidth for {IDF_TARGET_NAME} station and AP is HT40.

    In station mode, the actual bandwidth is firstly negotiated during the Wi-Fi connection. It is HT40 only if both the station and the connected AP support HT40, otherwise it is HT20. If the bandwidth of connected AP is changes, the actual bandwidth is negotiated again without Wi-Fi disconnecting.

    Similarly, in AP mode, the actual bandwidth is negotiated between"
" AP and the stations that connect to the AP. It is HT40 if the AP and one of the stations support HT40, otherwise it is HT20.

    In station/AP coexist mode, the station/AP can configure HT20/40 seperately. If both station and AP are negotiated to HT40, the HT40 channel should be the channel of station because the station always has higher priority than AP in {IDF_TARGET_NAME}. For example, the configured bandwidth of AP is HT40, the configured primary channel is 6, and the configured secondary"
" channel is 10. The station is connected to an router whose primary channel is 6 and secondary channel is 2, then the actual channel of AP is changed to primary 6 and secondary 2 automatically.

    Theoretically, the HT40 can gain better throughput because the maximum raw physicial (PHY) data rate for HT40 is 150 Mbps while it is 72 Mbps for HT20. However, if the device is used in some special environment, e.g., there are too many other Wi-Fi devices around the {IDF_TARGET_NAME} device, the per"
"formance of HT40 may be degraded. So if the applications need to support same or similar scenarios, it is recommended that the bandwidth is always configured to HT20.

.. only:: esp32c2

    {IDF_TARGET_NAME} supports Wi-Fi bandwidth HT20 and does not support Wi-Fi bandwidth HT40 or HT20/40 coexist.

Wi-Fi QoS


{IDF_TARGET_NAME} supports all the mandatory features required in WFA Wi-Fi QoS Certification.

Four ACs (Access Category) are defined in Wi-Fi specification, and each AC has its own pri"
"ority to access the Wi-Fi channel. Moreover, a map rule is defined to map the QoS priority of other protocol, e.g., 802.11D or TCP/IP precedence is mapped to Wi-Fi AC.

The table below describes how the IP Precedences are mapped to Wi-Fi ACs in {IDF_TARGET_NAME}. It also indicates whether the AMPDU is supported for this AC. The table is sorted from high to low priority. That is to say, the AC_VO has the highest priority.

++++
| IP Precedence    | Wi-Fi AC               |  Support AMPDU? |
++++
"
"| 6, 7             | AC_VO (Voice)          |  No             |
++++
| 4, 5             | AC_VI (Video)          |  Yes            |
++++
| 3, 0             | AC_BE (Best Effort)    |  Yes            |
++++
| 1, 2             | AC_BK (Background)     |  Yes            |
++++

The application can make use of the QoS feature by configuring the IP precedence via socket option IP_TOS. Here is an example to make the socket to use VI queue::

    const int ip_precedence_vi = 4;
    const int ip_preced"
"ence_offset = 5;
    int priority = (ip_precedence_vi `.

Peak Wi-Fi Dynamic Buffer
++++++++++++++++++++++++++++++

The Wi-Fi driver supports several types of buffer (refer to `Wi-Fi Buffer Configure`_). However, this section is about the usage of the dynamic Wi-Fi buffer only.
The peak heap memory that Wi-Fi consumes is the **theoretically-maximum memory** that the Wi-Fi driver consumes. Generally, the peak memory depends on:

- :math:`b_{rx}` the number of dynamic RX buffers that are configure"
"d
- :math:`b_{tx}` the number of dynamic TX buffers that are configured
- :math:`m_{rx}` the maximum packet size that the Wi-Fi driver can receive
- :math:`m_{tx}` the maximum packet size that the Wi-Fi driver can send

So, the peak memory that the Wi-Fi driver consumes (:math:`p`) can be calculated with the following formula:

.. math::

    p = (b_{rx} * m_{rx}) + (b_{tx} * m_{tx})

Generally, the dynamic TX long buffers and dynamic TX long long buffers can be ignored, because they are managem"
"ent frames which only have a small impact on the system.

.. _How-to-improve-Wi-Fi-performance:

How to Improve Wi-Fi Performance


The performance of {IDF_TARGET_NAME} Wi-Fi is affected by many parameters, and there are mutual constraints between each parameter. A proper configuration cannot only improve performance, but also increase available memory for applications and improve stability.

This section briefly explains the operating mode of the Wi-Fi/LwIP protocol stack and the role of each p"
"arameter. It also gives several recommended configuration ranks to help choose the appropriate rank according to the usage scenario.

Protocol Stack Operation Mode
++++++++++++++++++++++++++++++++++

.. figure:: ../../_static/api-guides-WiFi-driver-how-to-improve-WiFi-performance.png
    :align: center

    {IDF_TARGET_NAME} datapath

The {IDF_TARGET_NAME} protocol stack is divided into four layers: Application, LwIP, Wi-Fi, and Hardware.

 - During receiving, hardware puts the received packet i"
"nto DMA buffer, and then transfers it into the RX buffer of Wi-Fi and LwIP in turn for related protocol processing, and finally to the application layer. The Wi-Fi RX buffer and the LwIP RX buffer shares the same buffer by default. In other words, the Wi-Fi forwards the packet to LwIP by reference by default.

 - During sending, the application copies the messages to be sent into the TX buffer of the LwIP layer for TCP/IP encapsulation. The messages will then be passed to the TX buffer of the Wi"
"-Fi layer for MAC encapsulation and wait to be sent.

Parameters
++++++++++++++

Increasing the size or number of the buffers mentioned above properly can improve Wi-Fi performance. Meanwhile, it will reduce available memory to the application. The following is an introduction to the parameters that users need to configure:

**RX direction:**

 - :ref:`CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM`
    This parameter indicates the number of DMA buffer at the hardware layer. Increasing this parameter will"
" increase the sender's one-time receiving throughput, thereby improving the Wi-Fi protocol stack ability to handle burst traffic.

 - :ref:`CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM`
    This parameter indicates the number of RX buffer in the Wi-Fi layer. Increasing this parameter will improve the performance of packet reception. This parameter needs to match the RX buffer size of the LwIP layer.

 - :ref:`CONFIG_ESP_WIFI_RX_BA_WIN`
    This parameter indicates the size of the AMPDU BA Window at the"
" receiving end. This parameter should be configured to the smaller value between twice of :ref:`CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM` and :ref:`CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM`.

 - :ref:`CONFIG_LWIP_TCP_WND_DEFAULT`
    This parameter represents the RX buffer size of the LwIP layer for each TCP stream. Its value should be configured to the value of WIFI_DYNAMIC_RX_BUFFER_NUM (KB) to reach a high and stable performance. Meanwhile, in case of multiple streams, this value needs to be reduced"
" proportionally.

**TX direction:**

 - :ref:`CONFIG_ESP_WIFI_TX_BUFFER`
    This parameter indicates the type of TX buffer, it is recommended to configure it as a dynamic buffer, which can make full use of memory.

 - :ref:`CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM`
    This parameter indicates the number of TX buffer on the Wi-Fi layer. Increasing this parameter will improve the performance of packet sending. The parameter value needs to match the TX buffer size of the LwIP layer.

 - :ref:`CONFIG"
"_LWIP_TCP_SND_BUF_DEFAULT`
    This parameter represents the TX buffer size of the LwIP layer for each TCP stream. Its value should be configured to the value of WIFI_DYNAMIC_TX_BUFFER_NUM (KB) to reach a high and stable performance. In case of multiple streams, this value needs to be reduced proportionally.

**Throughput optimization by placing code in IRAM:**

.. only:: esp32 or esp32s2

    - :ref:`CONFIG_ESP_WIFI_IRAM_OPT`
        If this option is enabled, some Wi-Fi functions are moved to "
"IRAM, improving throughput. This increases IRAM usage by 15 kB.

    - :ref:`CONFIG_ESP_WIFI_RX_IRAM_OPT`
        If this option is enabled, some Wi-Fi RX functions are moved to IRAM, improving throughput. This increases IRAM usage by 16 kB.

 - :ref:`CONFIG_LWIP_IRAM_OPTIMIZATION`
    If this option is enabled, some LwIP functions are moved to IRAM, improving throughput. This increases IRAM usage by 13 kB.

.. only:: esp32c6

    - :ref:`CONFIG_ESP_WIFI_IRAM_OPT`
        If this option is enabl"
"ed, some Wi-Fi functions are moved to IRAM, improving throughput. This increases IRAM usage by 13 kB.

    - :ref:`CONFIG_ESP_WIFI_RX_IRAM_OPT`
        If this option is enabled, some Wi-Fi RX functions are moved to IRAM, improving throughput. This increases IRAM usage by 7 kB.

 - :ref:`CONFIG_LWIP_IRAM_OPTIMIZATION`
    If this option is enabled, some LwIP functions are moved to IRAM, improving throughput. This increases IRAM usage by 14 kB.

.. only:: esp32s2

    **CACHE:**

     - :ref:`CON"
"FIG_ESP32S2_INSTRUCTION_CACHE_SIZE`
        Configure the size of the instruction Cache.

     - :ref:`CONFIG_ESP32S2_INSTRUCTION_CACHE_LINE_SIZE`
        Configure the width of the instruction Cache bus.

.. only:: esp32s3

    **CACHE:**

     - :ref:`CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE`
        Configure the size of the instruction Cache.

     - :ref:`CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE`
        Configure the size of the instruction Cache bus.

     - :ref:`CONFIG_ESP32S3_ICACHE_ASS"
"OCIATED_WAYS`
        Configure the associated ways of the instruction Cache.

     - :ref:`CONFIG_ESP32S3_DATA_CACHE_SIZE`
        Configure the size of the Data Cache.

     - :ref:`CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE`
        Configure the line size of the Data Cache.

     - :ref:`CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS`
        Configure the associated ways of the Data Cache.

.. note::
    The buffer size mentioned above is fixed as 1.6 KB.

How to Configure Parameters
++++++++++++++++++++++"
"++++++

The memory of {IDF_TARGET_NAME} is shared by protocol stack and applications.

Here, several configuration ranks are given. In most cases, the user should select a suitable rank for parameter configuration according to the size of the memory occupied by the application.

The parameters not mentioned in the following table should be set to the default.

.. only:: esp32

     .. list-table::
        :header-rows: 1
        :widths: 10 5 5 10 5 5 10 5
          - Iperf
          - TX prior
"
"          - High-performance
          - RX prior
          - Default
          - Memory saving
          - Minimum
          - 37.1
          - 113.8
          - 123.3
          - 145.5
          - 144.5
          - 170.2
          - 185.2
          - 16
          - 6
          - 6
          - 6
          - 6
          - 6
          - 4
          - 64
          - 16
          - 24
          - 34
          - 20
          - 12
          - 8
          - 64
          - 28
          - 24
          -"
" 18
          - 20
          - 12
          - 8
          - 32
          - 8
          - 12
          - 12
          - 10
          - 6
          - Disable
          - 65
          - 28
          - 24
          - 18
          - 20
          - 12
          - 8
          - 65
          - 16
          - 24
          - 34
          - 20
          - 12
          - 8
          - 15
          - 15
          - 15
          - 15
          - 15
          - 15
          - 15
          - 16
          - 16
 "
"         - 16
          - 16
          - 16
          - 16
          - 16
          - 13
          - 13
          - 13
          - 13
          - 13
          - 13
          - 13
          - 74.6
          - 50.8
          - 46.5
          - 39.9
          - 44.2
          - 33.8
          - 25.6
          - 63.6
          - 35.5
          - 42.3
          - 48.5
          - 40.5
          - 30.1
          - 27.8
          - 76.2
          - 75.1
          - 74.1
          - 72.4
          - 69."
"6
          - 64.1
          - 36.5
          - 83.1
          - 66.3
          - 75.1
          - 75.6
          - 73.1
          - 65.3
          - 54.7


.. only:: esp32s2

     .. list-table::
        :header-rows: 1
        :widths: 10 10 10 10 10 10
          - Iperf
          - High-performance
          - Default
          - Memory saving
          - Minimum
          - 4.1
          - 24.2
          - 78.4
          - 86.5
          - 116.4
          - 8
          - 6
          - 6
    "
"      - 4
          - 3
          - 24
          - 18
          - 12
          - 8
          - 6
          - 24
          - 18
          - 12
          - 8
          - 6
          - 12
          - 9
          - 6
          - 4
          - 3
          - 24
          - 18
          - 12
          - 8
          - 6
          - 24
          - 18
          - 12
          - 8
          - 6
          - 15
          - 15
          - 15
          - 15
          - 0
          - 16
          - 16
         "
" - 16
          - 0
          - 0
          - 13
          - 13
          - 0
          - 0
          - 0
          - 16
          - 16
          - 16
          - 16
          - 8
          - 16
          - 16
          - 16
          - 16
          - 16
          - 37.6
          - 33.1
          - 22.5
          - 12.2
          - 5.5
          - 31.5
          - 28.1
          - 20.1
          - 13.1
          - 7.2
          - 58.1
          - 57.3
          - 28.1
          - 22.6
         "
" - 8.7
          - 78.1
          - 66.7
          - 65.3
          - 53.8
          - 28.5

.. only:: esp32c3

     .. list-table::
        :header-rows: 1
        :widths: 10 10 10 15
          - Iperf
          - Default
          - Minimum
          - 59
          - 160
          - 180
          - 20
          - 8
          - 3
          - 40
          - 16
          - 6
          - 40
          - 16
          - 6
          - 32
          - 16
          - 6
          - 40
          - 16
    "
"      - 6
          - 40
          - 16
          - 6
          - 13
          - 13
          - 0
          - 38.1
          - 27.2
          - 20.4
          - 35.3
          - 24.2
          - 17.4
          - 40.6
          - 38.9
          - 34.1
          - 52.4
          - 44.5
          - 44.2

.. only:: esp32c6

     .. list-table::
        :header-rows: 1
        :widths: 10 10 10 15
          - Iperf
          - Default
          - Minimum
          - 223
          - 276
          - 29"
"9
          - 20
          - 8
          - 3
          - 40
          - 16
          - 6
          - 40
          - 16
          - 6
          - 32
          - 16
          - 6
          - 40
          - 16
          - 6
          - 40
          - 16
          - 6
          - 13
          - 13
          - 0
          - 30.5
          - 25.9
          - 16.4
          - 27.8
          - 21.6
          - 14.3
          - 37.8
          - 36.1
          - 34.6
          - 41.5
          - 36.8
    "
"      - 36.7

.. only:: esp32c2

     .. list-table::
        :header-rows: 1
        :widths: 10 10 10 15
          - Iperf
          - Default
          - Minimum
          - 37
          - 56
          - 84
          - 14
          - 7
          - 3
          - 18
          - 14
          - 6
          - 18
          - 14
          - 6
          - 16
          - 12
          - 6
          - 18
          - 14
          - 6
          - 18
          - 14
          - 6
          - 13
          - "
"13
          - 0
          - 21.6
          - 21.4
          - 14.3
          - 19.1
          - 17.9
          - 12.4
          - 26.4
          - 26.3
          - 25.0
          - 32.3
          - 31.5
          - 27.7

.. only:: esp32s3

     .. list-table::
        :header-rows: 1
        :widths: 25 20 25 25
          - Iperf
          - Default
          - Minimum
          - 133.9
          - 183.9
          - 273.6
          - 24
          - 8
          - 3
          - 64
          - 32
"
"          - 6
          - 64
          - 32
          - 6
          - 32
          - 16
          - 6
          - 64
          - 32
          - 6
          - 64
          - 32
          - 6
          - 15
          - 15
          - 15
          - 16
          - 16
          - 16
          - 13
          - 13
          - 0
          - 32
          - 32
          - 16
          - 32
          - 32
          - 32
          - 8
          - 8
          - 4
          - 83.93
          - 64.28
        "
"  - 23.17
          - 73.98
          - 60.39
          - 18.11
          - 98.69
          - 96.28
          - 48.78
          - 88.58
          - 86.57
          - 59.45

.. only:: esp32 or esp32s3

    .. note::
        The test was performed with a single stream in a shielded box using an ASUS RT-N66U router.
        {IDF_TARGET_NAME}'s CPU is dual core with 240 MHz. {IDF_TARGET_NAME}'s flash is in QIO mode with 80 MHz.

.. only:: esp32s2

    .. note::
        The test was performed with a "
"single stream in a shielded box using an ASUS RT-N66U router.
        {IDF_TARGET_NAME}'s CPU is single core with 240 MHz. {IDF_TARGET_NAME}'s flash is in QIO mode with 80 MHz.

.. only:: esp32c3

    .. note::
        The test was performed with a single stream in a shielded box using an ASUS RT-N66U router.
        {IDF_TARGET_NAME}'s CPU is single core with 160 MHz. {IDF_TARGET_NAME}'s flash is in QIO mode with 80 MHz.

.. only:: esp32c6

    .. note::
        The test was performed with a si"
"ngle stream in a shielded box using an XIAOMI AX-6000 router.
        {IDF_TARGET_NAME}'s CPU is single core with 160 MHz. {IDF_TARGET_NAME}'s flash is in QIO mode with 80 MHz.

.. only:: esp32c2

    .. note::
        The test was performed with a single stream in a shielded box using an Redmi RM2100 router.
        {IDF_TARGET_NAME}'s CPU is single core with 120 MHz. {IDF_TARGET_NAME}'s flash is in QIO mode with 60 MHz.

.. only:: esp32

    **Ranks:**

     - **Iperf rank**
        {IDF_TARGE"
"T_NAME} extreme performance rank used to test extreme performance.

     - **High-performance rank**
        The {IDF_TARGET_NAME}'s high-performance configuration rank, suitable for scenarios where the application occupies less memory and has high-performance requirements. In this rank, users can choose to use the RX prior rank or the TX prior rank according to the usage scenario.

     - **Default rank**
        {IDF_TARGET_NAME}'s default configuration rank, the available memory, and performa"
"nce are in balance.

     - **Memory saving rank**
        This rank is suitable for scenarios where the application requires a large amount of memory, and the transceiver performance will be reduced in this rank.

     - **Minimum rank**
        This is the minimum configuration rank of {IDF_TARGET_NAME}. The protocol stack only uses the necessary memory for running. It is suitable for scenarios where there is no requirement for performance and the application requires lots of space.

.. only::"
" esp32s2

    **Ranks:**

     - **Iperf rank**
        {IDF_TARGET_NAME} extreme performance rank used to test extreme performance.

     - **High-performance rank**
        The {IDF_TARGET_NAME}'s high-performance configuration rank, suitable for scenarios where the application occupies less memory and has high-performance requirements.

     - **Default rank**
        {IDF_TARGET_NAME}'s default configuration rank, the available memory, and performance are in balance.

     - **Memory saving "
"rank**
        This rank is suitable for scenarios where the application requires a large amount of memory, and the transceiver performance will be reduced in this rank.

     - **Minimum rank**
        This is the minimum configuration rank of {IDF_TARGET_NAME}. The protocol stack only uses the necessary memory for running. It is suitable for scenarios where there is no requirement for performance and the application requires lots of space.

.. only:: esp32c3 or esp32s3 or esp32c6

    **Ranks:"
"**

     - **Iperf rank**
        {IDF_TARGET_NAME} extreme performance rank used to test extreme performance.

     - **Default rank**
        {IDF_TARGET_NAME}'s default configuration rank, the available memory, and performance are in balance.

     - **Minimum rank**
        This is the minimum configuration rank of {IDF_TARGET_NAME}. The protocol stack only uses the necessary memory for running. It is suitable for scenarios where there is no requirement for performance and the application re"
"quires lots of space.

.. only:: SOC_SPIRAM_SUPPORTED

    Using PSRAM
    ++++++++++++++++++++++++++++

    PSRAM is generally used when the application takes up a lot of memory. In this mode, the :ref:`CONFIG_ESP_WIFI_TX_BUFFER` is forced to be static. :ref:`CONFIG_ESP_WIFI_STATIC_TX_BUFFER_NUM` indicates the number of DMA buffers at the hardware layer, and increasing this parameter can improve performance.
    The following are the recommended ranks for using PSRAM:

    .. only:: esp32

    "
"    .. list-table::
             :header-rows: 1
             :widths: 15 10 10 15 10
               - Iperf
               - Default
               - Memory saving
               - Minimum
               - 113.8
               - 152.4
               - 181.2
               - 202.6
               - 16
               - 8
               - 4
               - 2
               - 128
               - 128
               - 128
               - 128
               - 16
               - 8
               - 4"
"
               - 2
               - 16
               - 16
               - 8
               - Disable
               - 65
               - 65
               - 65
               - 65
               - 65
               - 65
               - 65
               - 65
               - 15
               - 15
               - 15
               - 0
               - 16
               - 16
               - 0
               - 0
               - 13
               - 0
               - 0
               - 0
  "
"             - 37.5
               - 31.7
               - 21.7
               - 14.6
               - 31.5
               - 29.8
               - 26.5
               - 21.1
               - 69.1
               - 31.5
               - 27.1
               - 24.1
               - 40.1
               - 38.5
               - 37.5
               - 36.9

    .. only:: esp32s2

        .. list-table::
             :header-rows: 1
             :widths: 10 10 10 10 15
               - Iperf
             "
"  - Default
               - Memory saving
               - Minimum
               - 70.6
               - 96.4
               - 118.8
               - 148.2
               - 8
               - 8
               - 6
               - 4
               - 64
               - 64
               - 64
               - 64
               - 16
               - 8
               - 6
               - 4
               - 16
               - 6
               - 6
               - Disable
               - 32
      "
"         - 32
               - 32
               - 32
               - 32
               - 32
               - 32
               - 32
               - 15
               - 15
               - 15
               - 0
               - 16
               - 16
               - 0
               - 0
               - 13
               - 0
               - 0
               - 0
               - 16
               - 16
               - 16
               - 8
               - 16
               - 16
             "
"  - 16
               - 16
               - 8
               - 8
               - 8
               - 8
               - 32
               - 32
               - 32
               - 32
               - 40.1
               - 29.2
               - 20.1
               - 8.9
               - 21.9
               - 16.8
               - 14.8
               - 9.6
               - 50.1
               - 25.7
               - 22.4
               - 10.2
               - 45.3
               - 43.1
           "
"    - 28.5
               - 15.1

        .. note::
            Reaching peak performance may cause task watchdog. It is a normal phenomenon considering the CPU may have no time for lower priority tasks.

    .. only:: esp32s3

        **PSRAM with 4 lines:**

          .. list-table::
             :header-rows: 1
             :widths: 25 20 25 25 25
               - Iperf
               - Default
               - Memory saving
               - Minimum
               - 50.3
               - 158."
"7
               - 198.2
               - 228.9
               - 24
               - 8
               - 6
               - 4
               - 85
               - 64
               - 32
               - 32
               - 32
               - 32
               - 6
               - 4
               - 32
               - 16
               - 12
               - Disable
               - 85
               - 32
               - 32
               - 32
               - 85
               - 32
            "
"   - 32
               - 32
               - 15
               - 15
               - 15
               - 0
               - 16
               - 16
               - 0
               - 0
               - 13
               - 0
               - 0
               - 0
               - 16
               - 16
               - 16
               - 16
               - 32
               - 16
               - 16
               - 16
               - 32
               - 16
               - 16
               - 1"
"6
               - 8
               - 8
               - 8
               - 8
               - 64
               - 16
               - 16
               - 16
               - 32
               - 32
               - 32
               - 32
               - 8
               - 8
               - 8
               - 8
               - 93.1
               - 62.5
               - 41.3
               - 42.7
               - 88.9
               - 46.5
               - 46.2
               - 37.9
          "
"     - 106.4
               - 106.2
               - 60.7
               - 50
               - 99.8
               - 92.6
               - 94.3
               - 53.3

        **PSRAM with 8 lines:**

          .. list-table::
             :header-rows: 1
             :widths: 25 20 25 25 25
               - Iperf
               - Default
               - Memory saving
               - Minimum
               - 49.1
               - 151.3
               - 215.3
               - 243.6
             "
"  - 24
               - 8
               - 6
               - 4
               - 85
               - 64
               - 32
               - 32
               - 32
               - 32
               - 6
               - 4
               - 32
               - 16
               - 12
               - Disable
               - 85
               - 32
               - 32
               - 32
               - 85
               - 32
               - 32
               - 32
               - 15
             "
"  - 15
               - 15
               - 0
               - 16
               - 16
               - 0
               - 0
               - 13
               - 0
               - 0
               - 0
               - 16
               - 16
               - 16
               - 16
               - 32
               - 16
               - 16
               - 16
               - 32
               - 16
               - 16
               - 16
               - 8
               - 8
               - 8
  "
"             - 8
               - 64
               - 16
               - 16
               - 16
               - 32
               - 32
               - 32
               - 32
               - 8
               - 8
               - 8
               - 8
               - 93.3
               - 58.4
               - 37.1
               - 35.6
               - 86.1
               - 43.6
               - 42.5
               - 35
               - 104.7
               - 82.2
               - 60.4
      "
"         - 47.9
               - 104.6
               - 104.8
               - 104
               - 55.7


Wi-Fi Menuconfig


Wi-Fi Buffer Configure
+++++++++++++++++++++++

If you are going to modify the default number or type of buffer, it would be helpful to also have an overview of how the buffer is allocated/freed in the data path. The following diagram shows this process in the TX direction:

.. blockdiag::
    :caption: TX Buffer Allocation
    :align: center

    blockdiag buffer_allocat"
"ion_tx {

        # global attributes
        node_height = 60;
        node_width = 100;
        span_width = 50;
        span_height = 20;
        default_shape = roundedbox;

        # labels of diagram nodes
        APPL_TASK [label=""Application\n task"", fontsize=12];
        LwIP_TASK [label=""LwIP\n task"", fontsize=12];
        WIFI_TASK [label=""Wi-Fi\n task"", fontsize=12];

        # labels of description nodes
        APPL_DESC [label=""1> User data"", width=120, height=25, shape=note, colo"
"r=yellow];
        LwIP_DESC [label=""2> Pbuf"", width=120, height=25, shape=note, color=yellow];
        WIFI_DESC [label=""3> Dynamic (Static)\n TX Buffer"", width=150, height=40, shape=note, color=yellow];

        # node connections
        APPL_TASK -> LwIP_TASK -> WIFI_TASK
        APPL_DESC -> LwIP_DESC -> WIFI_DESC [style=none]
    }


Description:

 - The application allocates the data which needs to be sent out.
 - The application calls TCPIP-/Socket-related APIs to send the user data. The"
"se APIs will allocate a PBUF used in LwIP, and make a copy of the user data.
 - When LwIP calls a Wi-Fi API to send the PBUF, the Wi-Fi API will allocate a ""Dynamic Tx Buffer"" or ""Static Tx Buffer"", make a copy of the LwIP PBUF, and finally send the data.

The following diagram shows how buffer is allocated/freed in the RX direction:

.. blockdiag::
    :caption: RX Buffer Allocation
    :align: center

    blockdiag buffer_allocation_rx {

        # global attributes
        node_height = 60;
 "
"       node_width = 100;
        span_width = 40;
        span_height = 20;
        default_shape = roundedbox;

        # labels of diagram nodes
        APPL_TASK [label=""Application\n task"", fontsize=12];
        LwIP_TASK [label=""LwIP\n task"", fontsize=12];
        WIFI_TASK [label=""Wi-Fi\n task"", fontsize=12];
        WIFI_INTR [label=""Wi-Fi\n interrupt"", fontsize=12];

        # labels of description nodes
        APPL_DESC [label=""4> User\n Data Buffer"", height=40, shape=note, color=yello"
"w];
        LwIP_DESC [label=""3> Pbuf"", height=40, shape=note, color=yellow];
        WIFI_DESC [label=""2> Dynamic\n RX Buffer"", height=40, shape=note, color=yellow];
        INTR_DESC [label=""1> Static\n RX Buffer"", height=40, shape=note, color=yellow];

        # node connections
        APPL_TASK <- LwIP_TASK <- WIFI_TASK <- WIFI_INTR
        APPL_DESC <- LwIP_DESC <- WIFI_DESC <- INTR_DESC [style=none]
    }

Description:

 - The Wi-Fi hardware receives a packet over the air and puts the pac"
"ket content to the ""Static Rx Buffer"", which is also called ""RX DMA Buffer"".
 - The Wi-Fi driver allocates a ""Dynamic Rx Buffer"", makes a copy of the ""Static Rx Buffer"", and returns the ""Static Rx Buffer"" to hardware.
 - The Wi-Fi driver delivers the packet to the upper-layer (LwIP), and allocates a PBUF for holding the ""Dynamic Rx Buffer"".
 - The application receives data from LwIP.

The diagram shows the configuration of the Wi-Fi internal buffer.

.. list-table::
   :header-rows: 1
   :widths"
": 10 10 10 10 25
     - Alloc Type
     - Default
     - Configurable
     - Description
     - Static
     - 10 * 1600 Bytes
     - Yes
     - This is a kind of DMA memory. It is initialized in :cpp:func:`esp_wifi_init()` and freed in :cpp:func:`esp_wifi_deinit()`. The ‘Static Rx Buffer’ forms the hardware receiving list. Upon receiving a frame over the air, hardware writes the frame into the buffer and raises an interrupt to the CPU. Then, the Wi-Fi driver reads the content from the buffer and"
" returns the buffer back to the list.

       If needs be, the application can reduce the memory statically allocated by Wi-Fi. It can reduce this value from 10 to 6 to save 6400 Bytes of memory. It is not recommended to reduce the configuration to a value less than 6 unless the AMPDU feature is disabled.
     - Dynamic
     - 32
     - Yes
     - The buffer length is variable and it depends on the received frames’ length. When the Wi-Fi driver receives a frame from the ‘Hardware Rx Buffer’, the"
" ‘Dynamic Rx Buffer’ needs to be allocated from the heap. The number of the Dynamic Rx Buffer, configured in the menuconfig, is used to limit the total un-freed Dynamic Rx Buffer number.
     - Dynamic
     - 32
     - Yes
     - This is a kind of DMA memory. It is allocated to the heap. When the upper-layer (LwIP) sends packets to the Wi-Fi driver, it firstly allocates a ‘Dynamic TX Buffer’ and makes a copy of the upper-layer buffer.

       The Dynamic and Static TX Buffers are mutually exclus"
"ive.
     - Static
     - 16 * 1600Bytes
     - Yes
     - This is a kind of DMA memory. It is initialized in :cpp:func:`esp_wifi_init()` and freed in :cpp:func:`esp_wifi_deinit()`. When the upper-layer (LwIP) sends packets to the Wi-Fi driver, it firstly allocates a ‘Static TX Buffer’ and makes a copy of the upper-layer buffer.

       The Dynamic and Static TX Buffer are mutually exclusive.

       The TX buffer must be a DMA buffer. For this reason, if PSRAM is enabled, the TX buffer must be "
"static.
     - Dynamic
     - 8
     - NO
     - Wi-Fi driver’s internal buffer.
     - Dynamic
     - 32
     - NO
     - Wi-Fi driver’s internal buffer.
     - Dynamic
     - 32
     - NO
     - Wi-Fi driver’s internal buffer.

Wi-Fi NVS Flash
+++++++++++++++++++++

If the Wi-Fi NVS flash is enabled, all Wi-Fi configurations set via the Wi-Fi APIs will be stored into flash, and the Wi-Fi driver will start up with these configurations the next time it powers on/reboots. However, the application"
" can choose to disable the Wi-Fi NVS flash if it does not need to store the configurations into persistent memory, or has its own persistent storage, or simply due to debugging reasons, etc.

Wi-Fi Aggregate MAC Protocol Data Unit (AMPDU)
++++++++++++++++++++++++++++++++++++++++++++++++++++++

{IDF_TARGET_NAME} supports both receiving and transmitting AMPDU, and the AMPDU can greatly improve the Wi-Fi throughput.

Generally, the AMPDU should be enabled. Disabling AMPDU is usually for debugging p"
"urposes.

Troubleshooting


Please refer to a separate document with :doc:`wireshark-user-guide`.

.. toctree::
    :hidden:

    wireshark-user-guide
"
"Bluetooth® Overview




This document provides an architecture overview of the Bluetooth stack in ESP-IDF and some quick links to related documents and application examples.

.. only:: esp32

    {IDF_TARGET_NAME} supports Dual-Mode Bluetooth 4.2 and is certified for Bluetooth 4.2.

.. only:: esp32c3 or esp32s3

    {IDF_TARGET_NAME} supports Bluetooth 5.0 (LE) and is certified for Bluetooth LE 5.0.

.. only:: esp32c2 or esp32c6 or esp32h2

    {IDF_TARGET_NAME} supports Bluetooth 5.0 (LE) and i"
"s certified for Bluetooth LE 5.3.

The Bluetooth stack in ESP-IDF is a layered architecture that enables Bluetooth functionality on {IDF_TARGET_NAME} chip series. The table below shows its architecture.

.. only:: esp32 or esp32s3 or esp32c3 or esp32c6

    .. figure:: ../../_static/bluetooth-architecture.png
        :align: center
        :scale: 90%
        :alt: {IDF_TARGET_NAME} Bluetooth Stack Architecture

        {IDF_TARGET_NAME} Bluetooth Stack Architecture

.. only:: esp32c2

    .. fi"
"gure:: ../../_static/bluetooth-architecture-no-ble-mesh.png
        :align: center
        :scale: 90%
        :alt: {IDF_TARGET_NAME} Bluetooth Stack Architecture

        {IDF_TARGET_NAME} Bluetooth Stack Architecture

.. only:: esp32h2

    .. figure:: ../../_static/bluetooth-architecture-no-blufi.png
        :align: center
        :scale: 90%
        :alt: {IDF_TARGET_NAME} Bluetooth Stack Architecture

        {IDF_TARGET_NAME} Bluetooth Stack Architecture

The table below shows whether the"
" Bluetooth modules are supported in a specific chip series.

.. list-table::
    :width: 100%
    :widths: auto
    :header-rows: 1
      - Controller
      - ESP-Bluedroid
      - ESP-NimBLE
      - ESP-BLE-MESH
      - BluFi
      - Y
      - Y
      - Y
      - Y
      - Y
      - \–
      - \–
      - \–
      - \–
      - \–
      - Y
      - Y
      - Y
      - Y
      - Y
      - Y
      - Y
      - Y
      - \–
      - Y
      - Y
      - Y
      - Y
      - Y
      - Y
      - Y
      -"
" Y
      - Y
      - Y
      - Y
      - Y
      - Y
      - Y
      - Y
      - \–

The following sections briefly describe each layer and provide quick links to the related documents and application examples.


ESP Bluetooth Controller


At the bottom layer is ESP Bluetooth Controller, which encompasses various modules such as PHY, Baseband, Link Controller, Link Manager, Device Manager, and HCI. It handles hardware interface management and link management. It provides functions in the form of"
" libraries and is accessible through APIs. This layer directly interacts with the hardware and low-level Bluetooth protocols.

- :doc:`API reference `
- :example:`Application examples `


Hosts


There are two hosts, ESP-Bluedroid and ESP-NimBLE. The major difference between them is as follows:

- Although both support Bluetooth LE, ESP-NimBLE requires less heap and flash size.

.. only:: esp32

  - ESP-Bluedroid supports both Classic Bluetooth and Bluetooth LE, while ESP-NimBLE only supports Bl"
"uetooth LE.


ESP-Bluedroid


ESP-Bluedroid is a modified version of the native Android Bluetooth stack, Bluedroid. It consists of two layers: the Bluetooth Upper Layer (BTU) and the Bluetooth Transport Controller layer (BTC). The BTU layer is responsible for processing bottom layer Bluetooth protocols such as L2CAP, GATT/ATT, SMP, GAP, and other profiles. The BTU layer provides an interface prefixed with ""bta"". The BTC layer is mainly responsible for providing a supported interface, prefixed wi"
"th ""esp"", to the application layer, processing GATT-based profiles and handling miscellaneous tasks. All the APIs are located in the ESP_API layer. Developers should use the Bluetooth APIs prefixed with ""esp"".

.. only:: esp32

  ESP-Bluedroid for {IDF_TARGET_NAME} supports Classic Bluetooth and Bluetooth LE.

.. only:: not esp32

  ESP-Bluedroid for {IDF_TARGET_NAME} supports Bluetooth LE only. Classic Bluetooth is not supported.

- API references

  - :doc:`../api-reference/bluetooth/bt_common"
"`
  - :doc:`Bluetooth LE `

  .. only:: esp32

    - :doc:`../api-reference/bluetooth/classic_bt`

- :example:`Application examples `


ESP-NimBLE


ESP-NimBLE is a host stack built on top of the NimBLE host stack developed by Apache Mynewt. The NimBLE host stack is ported for {IDF_TARGET_NAME} chip series and FreeRTOS. The porting layer is kept clean by maintaining all the existing APIs of NimBLE along with a single ESP-NimBLE API for initialization, making it simpler for the application develo"
"pers.

ESP-NimBLE supports Bluetooth LE only. Classic Bluetooth is not supported.

- `Apache Mynewt NimBLE User Guide `__
- API references

  - `NimBLE API references `__
  - :doc:`ESP-NimBLE API references for initialization `

- :example:`Application examples `


Profiles


Above the host stacks are the profile implementations by Espressif and some common profiles. Depending on your configuration, these profiles can run on ESP-Bluedroid or ESP-NimBLE.


.. only:: SOC_BLE_MESH_SUPPORTED

  ESP-"
"BLE-MESH
  

  Built on top of Zephyr Bluetooth Mesh stack, the ESP-BLE-MESH implementation supports device provisioning and node control. It also supports such node features as Proxy, Relay, Low power and Friend.

  - :doc:`ESP-BLE-MESH documentation `: feature list, get started, architecture, description of application examples, frequently asked questions, etc.
  - :example:`Application examples `


.. only:: SOC_BLUFI_SUPPORTED

  BluFi
  

  The BluFi for {IDF_TARGET_NAME} is a Wi-Fi network"
" configuration function via Bluetooth channel. It provides a secure protocol to pass Wi-Fi configuration and credentials to {IDF_TARGET_NAME}. Using this information, {IDF_TARGET_NAME} can then connect to an AP or establish a softAP.

  - :doc:`BluFi documentation `
  - :example:`Application examples `


Applications


At the uppermost layer are applications. You can build your own applications on top of the ESP-Bluedroid and ESP-NimBLE stacks, leveraging the provided APIs and profiles to create"
" Bluetooth-enabled applications tailored to specific use cases.
"
"BluFi




Overview


The BluFi for {IDF_TARGET_NAME} is a Wi-Fi network configuration function via Bluetooth channel. It provides a secure protocol to pass Wi-Fi configuration and credentials to {IDF_TARGET_NAME}. Using this information, {IDF_TARGET_NAME} can then connect to an AP or establish a SoftAP.

Fragmenting, data encryption, and checksum verification in the BluFi layer are the key elements of this process.

You can customize symmetric encryption, asymmetric encryption, and checksum supp"
"ort customization. Here we use the DH algorithm for key negotiation, 128-AES algorithm for data encryption, and CRC16 algorithm for checksum verification.

The BluFi Flow


The BluFi networking flow includes the configuration of the SoftAP and Station.

The following uses Station as an example to illustrate the core parts of the procedure, including broadcast, connection, service discovery, negotiation of the shared key, data transmission, and connection status backhaul.

.. note::

The Flow Cha"
"rt of BluFi


.. seqdiag::
    :caption: BluFi Flow Chart
    :align: center

    seqdiag blufi {
        activation = none;
        node_width = 80;
        node_height = 60;
        edge_length = 380;
        span_height = 10;
        default_fontsize = 12;

        Phone  {IDF_TARGET_NAME} [label=""Create GATT connection""];
        Phone -> {IDF_TARGET_NAME} [label=""Negotiate key procedure""];
        Phone  {IDF_TARGET_NAME} [label=""CTRL: Set {IDF_TARGET_NAME} to Phone Security mode""];
       "
" Phone -> {IDF_TARGET_NAME} [label=""DATA: SSID""];
        Phone -> {IDF_TARGET_NAME} [label=""DATA: Password""];
        Phone -> {IDF_TARGET_NAME} [label=""DATA: Other information, such as CA certification""];
        Phone -> {IDF_TARGET_NAME} [label=""CTRL: Connect to AP""];
        Phone >>>>

BluFi Service UUID: 0xFFFF, 16 bit

BluFi (the mobile > {IDF_TARGET_NAME}): 0xFF01, writable

Blufi ({IDF_TARGET_NAME} > the mobile phone): 0xFF02, readable and callable
"
"SPI Flash and External SPI RAM Configuration


This page is a guide for configuring SPI Flash and external SPI RAM. Supported frequency and mode combination, error handling are also elaborated.

Terminology


      
Term               Definition
      
**SPI**            Serial Peripheral Interface
**MSPI**           Memory SPI Peripheral, SPI Peripheral dedicated for memory
**SDR**            Single Data Rate
**DDR**            Double Data Rate
**line mode**      Number of signals used to trans"
"fer data in the data phase of SPI transactions. e.g., for 4-bit-mode, the speed of the data phase would be 4 bit per clock cycle.
**FxRx**           F stands for Flash, R stands for PSRAM, x stands for line mode. e.g., F4R4 stands for an {IDF_TARGET_NAME} with Quad Flash and Quad PSRAM
      

.. note::

    On {IDF_TARGET_NAME}, MSPI stands for the SPI0/1. SPI0 and SPI1 share a common SPI bus. The main Flash and PSRAM are connected to the MSPI peripheral. CPU accesses them via Cache.


.. _flas"
"h-psram-configuration:

How to Configure Flash and PSRAM


``idf.py menuconfig`` is used to open the configuration menu.

Configure the Flash


The Flash related configurations are under ``Serial flasher config`` menu.

Configure the PSRAM


To enable PSRAM, please enable the :ref:`CONFIG_SPIRAM` under ``Component config / Hardware Settings`` menu. Then all the PSRAM related configurations will be visible under ``SPI RAM config`` menu.

.. note::

    Configuration 1 of Flash and PSRAM should be"
" selected according to your actual hardware.

    For the reset of the above configurations:

    - Flash and PSRAM share the same internal clock.
    - Quad Flash only supports STR mode. Octal Flash may support either/both STR/DTR modes under OPI mode, depending on the flash model and the vendor.
    - Quad PSRAM only supports STR mode, while Octal PSRAM only supports DTR mode.

    Therefore, some limitations should be noticed when configuring configuration 2, 3 and 4 of Flash, and configurati"
"on 2 of PSRAM. Please refer to :ref:`All Supported Modes and Speeds `

.. note::

    If a board with Octal Flash resets before the second-stage bootloader, please refer to :ref:`Error Handling Chapter `


.. _flash-psram-combination:

All Supported Modes and Speeds


.. note::

    For MSPI DDR mode, the data are sampled on both the positive edge and the negative edge. e.g., if a Flash is set to 80 MHz and DDR mode, then the final speed of the Flash is 160 MHz. This is faster than the Flash set"
"ting to 120 Mhz and STR mode.

.. important::

    120 MHz DDR mode is an experimental feature. You will only see it when:

    - :ref:`CONFIG_IDF_EXPERIMENTAL_FEATURES` is enabled

    With above step, you will find 120 MHz option is visible.

    Risks:

    If your chip powers on at a certain temperature, then after the temperature increases or decreases over 20 celsius degree, the accesses to/from PSRAM/Flash will crash randomly. Flash access crash will lead to program crash.

    Note 20 ce"
"lsius degree is not a totally correct number. This value may changes among chips.

F8R8 Hardware


   
 Group   Flash mode      Group   PSRAM mode
   
 A       120 MHz DDR     A       120 MHz DDR
 A       120 MHz SDR     A
 B       80 MHz DDR      B       80 MHz DDR
 C       80 MHz SDR      C       40 MHz DDR
 C       40 MHz DDR      C
 C        --do-not-confirm burn_efuse FLASH_TYPE 1

.. note::

    This step is irreversible. Please do check if your hardware is actually using an Octal Flash.
"
"RF Coexistence




Overview


ESP boards now support three modules: Bluetooth (BT & BLE), IEEE802.15.4, and Wi-Fi. Each type of board has only one 2.4 GHz ISM band RF module, shared by two or three modules. Consequently, a module cannot receive or transmit data while another module is engaged in data transmission or reception. In such scenarios, {IDF_TARGET_NAME} employs the time-division multiplexing method to manage the reception and transmission of packets.


Supported Coexistence Scenario fo"
"r {IDF_TARGET_NAME}


.. only:: SOC_WIFI_SUPPORTED and SOC_BLE_SUPPORTED

  .. table:: Supported Features of Wi-Fi and BLE Coexistence

      ++++++++
      |                            |BLE                                      |
      +                            +++++
      |                            |Scan |Advertising |Connecting |Connected |
      ++++++++
      | Wi-Fi |STA     |Scan       |Y    |Y           |Y          |Y         |
      +       +        ++++++
      |       |        |Co"
"nnecting |Y    |Y           |Y          |Y         |
      +       +        ++++++
      |       |        |Connected  |Y    |Y           |Y          |Y         |
      +       +++++++
      |       |SOFTAP  |TX Beacon  |Y    |Y           |Y          |Y         |
      +       +        ++++++
      |       |        |Connecting |C1   |C1          |C1         |C1        |
      +       +        ++++++
      |       |        |Connected  |C1   |C1          |C1         |C1        |
      +       +++++"
"++
      |       |Sniffer |RX         |C1   |C1          |C1         |C1        |
      +       +++++++
      |       |ESP-NOW |RX         |S    |S           |S          |S         |
      +       +        ++++++
      |       |        |TX         |Y    |Y           |Y          |Y         |
      ++++++++


.. only:: esp32

  .. table:: Supported Features of Wi-Fi and Classic Bluetooth (BT) Coexistence

      +++++++++
      |                            |BR/EDR                                   "
"          |
      +                            ++++++
      |                            |Inquiry |Inquiry scan |Page |Page scan | Connected |
      +++++++++
      | Wi-Fi |STA     |Scan       |Y       |Y            |Y    |Y         |Y          |
      +       +        +++++++
      |       |        |Connecting |Y       |Y            |Y    |Y         |Y          |
      +       +        +++++++
      |       |        |Connected  |Y       |Y            |Y    |Y         |Y          |
      +     "
"  ++++++++
      |       |SOFTAP  |TX Beacon  |Y       |Y            |Y    |Y         |Y          |
      +       +        +++++++
      |       |        |Connecting |C1      |C1           |C1   |C1        |C1         |
      +       +        +++++++
      |       |        |Connected  |C1      |C1           |C1   |C1        |C1         |
      +       ++++++++
      |       |Sniffer |RX         |C1      |C1           |C1   |C1        |C1         |
      +       ++++++++
      |       |ESP-NOW |R"
"X         |S       |S            |S    |S         |S          |
      +       +        +++++++
      |       |        |TX         |Y       |Y            |Y    |Y         |Y          |
      +++++++++

.. only:: SOC_IEEE802154_SUPPORTED

  .. table:: Supported Features of Thread (IEEE802.15.4) and BLE Coexistence

      +++++++
      |                          |BLE                                      |
      +                          +++++
      |                          |Scan |Advertising |Co"
"nnecting |Connected |
      +++++++
      | Thread |Scan             |X    |Y           |Y          |Y         |
      +        ++++++
      |        |Connecting       |X    |Y           |Y          |Y         |
      +        ++++++
      |        |Connected        |X    |Y           |Y          |Y         |
      +        ++++++
      |        |Connected        |     |            |           |          |
      |        |(high throughput)|X    |C1          |C1         |C1        |
      +++++++"
"

.. note::

  Y: supported and performance is stable
  C1: supported but the performance is unstable
  X: not supported
  S: supported and performance is stable in STA mode, otherwise not supported


Coexistence Mechanism and Policy


Coexistence Mechanism


The RF resource allocation mechanism is based on priority. As shown below, both Bluetooth module and Wi-Fi module request RF resources from the coexistence module, and the coexistence module decides who will use the RF resource based on the"
"ir priority.

.. blockdiag::
    :scale: 100%
    :caption: Coexistence Mechanism
    :align: center

    blockdiag {

      # global attributes
      node_height = 60;
      node_width = 120;
      span_width = 100;
      span_height = 60;
      default_shape = roundedbox;
      default_group_color = none;

      # node labels
       Wi-Fi [shape = box];
       Bluetooth [shape = box];
       Coexistence [shape = box, label = 'Coexistence module'];
       RF [shape = box, label = 'RF module'];
"
"
      # node connections
       Wi-Fi -> Coexistence;
       Bluetooth  -> Coexistence;
       Coexistence -> RF;
    }


.. _coexist_policy:

Coexistence Policy


Coexistence Period and Time Slice
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. only:: esp32

  Wi-Fi, BT, and BLE have their fixed time slice to use the RF. A coexistence period is divided into 3 time slices in the order of Wi-Fi, BT, and BLE. In the Wi-Fi slice, Wi-Fi's request to the coexistence arbitration module will have higher "
"priority. Similarly, BT/BLE can enjoy higher priority at their own time slices. The duration of the coexistence period and the proportion of each time slice are divided into four categories according to the Wi-Fi status:


.. only:: SOC_WIFI_SUPPORTED and SOC_BLE_SUPPORTED and not esp32

  Wi-Fi and BLE have their fixed time slice to use the RF. In the Wi-Fi time slice, Wi-Fi will send a higher priority request to the coexistence arbitration module. Similarly, BLE can enjoy higher priority at th"
"eir own time slice. The duration of the coexistence period and the proportion of each time slice are divided into four categories according to the Wi-Fi status:

.. only:: SOC_IEEE802154_SUPPORTED

  Currently, the only supported strategy ensures that the priority of BLE always takes precedence over IEEE802.15.4.

.. list::

  :esp32: 1) IDLE status: the coexistence of BT and BLE is controlled by Bluetooth module.
  :SOC_WIFI_SUPPORTED and SOC_BLE_SUPPORTED and not esp32: 1) IDLE status: RF modu"
"le is controlled by Bluetooth module.
  #) CONNECTED status: the coexistence period starts at the Target Beacon Transmission Time (TBTT) and is more than 100 ms.
  #) SCAN status: Wi-Fi slice and coexistence period are longer than in the CONNECTED status. To ensure Bluetooth performance, the Bluetooth time slice will also be adjusted accordingly.
  #) CONNECTING status: Wi-Fi slice is longer than in the CONNECTED status. To ensure Bluetooth performance, the Bluetooth time slice will also be adju"
"sted accordingly.


According to the coexistence logic, different coexistence periods and time slice strategies will be selected based on the Wi-Fi and Bluetooth usage scenarios. A Coexistence policy corresponding to a certain usage scenarios is called a ""coexistence scheme"". For example, the scenario of Wi-Fi CONNECTED and BLE CONNECTED has a corresponding coexistence scheme. In this scheme, the time slices of Wi-Fi and BLE in a coexistence period each account for 50%. The time allocation is sh"
"own in the following figure:

.. figure:: ../../_static/coexist_wifi_connected_and_ble_connected_time_slice.png
    :align: center
    :alt: Time Slice Under the Status of Wi-Fi CONNECTED and BLE CONNECTED
    :figclass: align-center

    Time Slice Under the Status of Wi-Fi CONNECTED and BLE CONNECTED


Dynamic Priority
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The coexistence module assigns varying priorities to different statuses of each module, and these priorities are dynamic. For example, in every N B"
"LE Advertising events, there is always one event with high priority. If a high-priority BLE Advertising event occurs within the Wi-Fi time slice, the right to use the RF may be preempted by BLE.

.. only:: SOC_WIFI_SUPPORTED

    Wi-Fi Connectionless Modules Coexistence
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    To some extent, some combinations of connectionless power-saving parameters `Window` and `Interval` would lead to extra Wi-Fi priority request out of Wi-Fi time sl"
"ice. It`s for obtaining RF resources at coexistence for customized parameters, while leading to impact on Bluetooth performance.

    If connectionless power-saving parameters are configured with default values, the coexistence module would perform in stable mode and the behaviour above would not happen. So please configure Wi-Fi connectionless power-saving parameters to default values unless you have plenty of coexistence performance tests for customized parameters.

    Please refer to :ref:`c"
"onnectionless module power save ` to get more detail.


How to Use the Coexistence Feature


Coexistence API


For most coexistence cases, {IDF_TARGET_NAME} will switch the coexistence status automatically without calling API. However, {IDF_TARGET_NAME} provides two APIs for the coexistence of BLE MESH and Wi-Fi. When the status of BLE MESH changes, call :code:`esp_coex_status_bit_clear` to clear the previous status first and then call :code:`esp_coex_status_bit_set` to set the current status.

"
"
BLE MESH Coexistence Status
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

As the firmware of Wi-Fi and Bluetooth are not aware of the current scenario of the upper layer application, some coexistence schemes require application code to call the coexistence API to take effect. The application layer needs to pass the working status of BLE MESH to the coexistence module for selecting the coexistence scheme.

  - ESP_COEX_BLE_ST_MESH_CONFIG: network is provisioning
  - ESP_COEX_BLE_ST_MESH_TRAFFIC: data is t"
"ransmitting
  - ESP_COEX_BLE_ST_MESH_STANDBY: in idle status with no significant data interaction


Coexistence API Error Codes


All coexistence APIs have custom return values, i.e., error codes. These error codes can be categorized as:

  - No error. For example, the return value ESP_OK siginifies the API returned successfully.
  - Recoverable errors. For example, the return value ESP_ERR_INVALID_ARG signifies API parameter errors.


Setting Coexistence Compile-time Options


.. list::

  - Af"
"ter writing the coexistence program, you must check  :ref:`CONFIG_ESP_COEX_SW_COEXIST_ENABLE` option through menuconfig to open coexistence configuration on software, otherwise the coexistence function mentioned above cannot be used.
  :esp32: - To ensure better communication performance of Wi-Fi and Bluetooth in the case of coexistence, run the task of the Wi-Fi protocol stack, the task of the Bluetooth Controller and Host protocol stack on different CPUs. You can use :ref:`CONFIG_BTDM_CTRL_PIN"
"NED_TO_CORE_CHOICE` and :ref:`CONFIG_BT_BLUEDROID_PINNED_TO_CORE_CHOICE` (or :ref:`CONFIG_BT_NIMBLE_PINNED_TO_CORE_CHOICE`) to put the tasks of the Bluetooth controller and the host protocol stack on the same CPU, and then use :ref:`CONFIG_ESP_WIFI_TASK_CORE_ID` to place the task of the Wi-Fi protocol stack on another CPU.
  :esp32s3: - To ensure better communication performance of Wi-Fi and Bluetooth in the case of coexistence, run the task of the Wi-Fi protocol stack, the task of the Bluetooth"
" Controller and Host protocol stack on different CPUs. You can use :ref:`CONFIG_BT_CTRL_PINNED_TO_CORE_CHOICE` and :ref:`CONFIG_BT_BLUEDROID_PINNED_TO_CORE_CHOICE` (or :ref:`CONFIG_BT_NIMBLE_PINNED_TO_CORE_CHOICE` ）to put the tasks of the Bluetooth controller and the host protocol stack on the same CPU, and then use :ref:`CONFIG_ESP_WIFI_TASK_CORE_ID` to place the task of the Wi-Fi protocol stack on another CPU.
  :esp32: - In the case of coexistence, BLE SCAN may be interrupted by Wi-Fi and Wi-"
"Fi releases RF resources before the end of the current BLE scan window. In order to make BLE acquire RF resources again within the current scan window, you can check the FULL SCAN configuration option through :ref:`CONFIG_BTDM_CTRL_FULL_SCAN_SUPPORTED`.
  :esp32c3 or esp32s3: - When using LE Coded PHY during a BLE connection, to avoid affecting Wi-Fi performance due to the long duration of Bluetooth packets, you can select `BT_CTRL_COEX_PHY_CODED_TX_RX_TLIM_EN` in the sub-options of :ref:`CONFIG"
"_BT_CTRL_COEX_PHY_CODED_TX_RX_TLIM` to limit the maximum time of TX/RX.
  :esp32c2 or esp32c6: - When using LE Coded PHY during a BLE connection, to avoid affecting Wi-Fi performance due to the long duration of Bluetooth packets, you can select `BT_LE_COEX_PHY_CODED_TX_RX_TLIM_EN` in the sub-options of :ref:`CONFIG_BT_LE_COEX_PHY_CODED_TX_RX_TLIM` to limit the maximum time of TX/RX.
  :SOC_BT_SUPPORTED or SOC_WIFI_SUPPORTED: - You can reduce the memory consumption by configuring the following op"
"tions on menuconfig.

    .. only:: SOC_BT_SUPPORTED

      - :ref:`CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY`: enable the configuration of dynamic memory for Bluetooth protocol stack.

    .. only:: SOC_WIFI_SUPPORTED

      - :ref:`CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM`: reduce the number of Wi-Fi static RX buffers.
      - :ref:`CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM`: reduce the number of Wi-Fi dynamic RX buffers.
      - :ref:`CONFIG_ESP_WIFI_TX_BUFFER`: enable the configuration of dynamic allocation "
"TX buffers.
      - :ref:`CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM`: reduce the number of Wi-Fi dynamic TX buffers.
      - :ref:`CONFIG_ESP_WIFI_TX_BA_WIN`: reduce the number of Wi-Fi Block Ack TX windows.
      - :ref:`CONFIG_ESP_WIFI_RX_BA_WIN`: reduce the number of Wi-Fi Block Ack RX windows.
      - :ref:`CONFIG_ESP_WIFI_MGMT_SBUF_NUM`: reduce the number of Wi-Fi Management Short Buffer.
      - :ref:`CONFIG_ESP_WIFI_RX_IRAM_OPT`: turning off this configuration option will reduce the IRAM memo"
"ry by approximately 17 KB.
      - :ref:`CONFIG_LWIP_TCP_SND_BUF_DEFAULT`: reduce the default TX buffer size for TCP sockets.
      - :ref:`CONFIG_LWIP_TCP_WND_DEFAULT`:  reduce the default size of the RX window for TCP sockets.
      - :ref:`CONFIG_LWIP_TCP_RECVMBOX_SIZE`: reduce the size of the TCP receive mailbox. Receive mailbox buffers data within active connections and handles data flow during connections。
      - :ref:`CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE`: reduce the size of the TCP accept ma"
"ilbox. Accept mailbox queues incoming connection requests and manages the initiation of new connections.
      - :ref:`CONFIG_LWIP_UDP_RECVMBOX_SIZE`: reduce the size of the UDP receive mailbox.
      - :ref:`CONFIG_LWIP_TCPIP_RECVMBOX_SIZE`: reduce the size of TCPIP task receive mailbox.


.. note::

    As the coexistence configuration option relies on the presence of any two enabled modules, please ensure that both modules are activated before configuring any coexistence features.
"
"
USB Serial/JTAG Controller Console




Generally, ESP chips implement a serial port using UART and can be connected to a serial console emulator on a host/PC via an external USB-UART bridge chip. However, on ESP chips that contain a USB Serial/JTAG Controller, the CDC-ACM portion of the controller implements a serial port that is connected directly to a host/PC, thus does not require an external USB-UART bridge chip.

{IDF_TARGET_NAME} contains a USB Serial/JTAG Controller providing the followi"
"ng functions:

.. note::

  The USB Serial/JTAG Controller is a fixed-function USB device that is implemented entirely in hardware, meaning that it cannot be reconfigured to perform any function other than a serial port and JTAG debugging functionality. This is in contrast to the USB OTG controllers in some ESP chips that can be configured to perform the function of multiple types of USB devices.

Hardware Requirements


{IDF_TARGET_USB_DP_GPIO:default=""Not Updated!"",esp32c3=""19"",esp32s3=""20"", e"
"sp32c6=""13"", esp32h2=""27""}
{IDF_TARGET_USB_DM_GPIO:default=""Not Updated!"",esp32c3=""18"",esp32s3=""19"", esp32c6=""12"", esp32h2=""26""}

Connect {IDF_TARGET_NAME} to the USB port as follows:

.. list-table::
    :header-rows: 1
    :widths: 40 60
    :align: center
      - USB
      - D+ (green)
      - D- (white)
      - GND (black)
      - +5V (red)

Some development boards may offer a USB connector for the USB Serial/JTAG Controller. In that case, no extra connections are required.

Software Configu"
"ration


The USB Serial/JTAG Controller can be used as the serial port by selecting ``CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG`` in the :ref:`CONFIG_ESP_CONSOLE_UART` option. Once selected, building and flashing the project can occur as usual.

Alternatively, you can access the output through the ``usb_serial_jtag`` port but make sure ``CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG`` is selected in the :ref:`CONFIG_ESP_CONSOLE_SECONDARY`.

.. warning::

    Besides output, if you also want to input or "
"use REPL with the console, please select ``CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG``.

Uploading the Application


The USB Serial/JTAG Controller is able to put the {IDF_TARGET_NAME} into download mode automatically. Simply flash as usual, but specify the USB Serial/JTAG Controller port on your system: ``idf.py flash -p PORT``, where ``PORT`` is the name of the proper port.

.. note::

    The USB Serial/JTAG Controller's serial port usually appears:

    - as ``/dev/ttyACM*`` on Linux
    - as ``/de"
"v/cu*`` on Mac
    - as a ``COM*`` port in the Windows Device Manager

Limitations


{IDF_TARGET_BOOT_PIN:default = ""Not Updated!"", esp32c3 = ""GPIO9"", esp32s3 = ""GPIO0"", esp32c6 = ""GPIO9""}

There are several limitations to the USB Serial/JTAG console feature. The significance of these limitations depends on the type of application being developed, and the development workflow.

{IDF_TARGET_BOOT_PIN:default = ""Not Updated!"", esp32c3 = ""GPIO9"", esp32s3 = ""GPIO0"", esp32c6 = ""GPIO9""}

USB Pin Reconf"
"iguration


If the application accidentally reconfigures the USB peripheral pins or disables the USB Serial/JTAG Controller, the device disappears from the system. After fixing the issue in the application, you need to manually put the {IDF_TARGET_NAME} into download mode by pulling low {IDF_TARGET_BOOT_PIN} and resetting the chip.

If the application enters Deep-sleep mode, the USB Serial/JTAG device disappears from the system.

Data Buffering


For data transmitted from {IDF_TARGET_NAME} to PC"
" Terminal (e.g., stdout, logs), the {IDF_TARGET_NAME} first writes to a small internal buffer. After this buffer becomes full (for example, if no PC Terminal is connected), the {IDF_TARGET_NAME} does a one-time wait of 50 ms for the PC Terminal to request the data. This can appear as a very brief pause in your application.

For data transmitted from the PC Terminal to {IDF_TARGET_NAME} (e.g., console commands), many PC Terminals wait for the {IDF_TARGET_NAME} to ingest the bytes before allowing "
"you to send more data. This is in contrast to using a USB-to-Serial (UART) bridge chip, which always ingests the bytes and sends them to a (possibly not listening) {IDF_TARGET_NAME}.

.. note::

    In rare cases, it is possible that data sent from {IDF_TARGET_NAME} to the host gets 'stuck' in host memory. Sending more data will get it 'unstuck', but if the application does not send more data, depending on the driver, this data needs to be flushed to the host manually. The non-blocking (default)"
" driver and the VFS implementation will flush automatically after a newline. The blocking (interrupt-based) driver will automatically flush when its transmit buffer becomes empty.

Sleep Mode Considerations


The USB Serial/JTAG controller and its associated USB PHY are driven by particular clocks (e.g., APB and USB PHY clock) and belong to a particular power domain (e.g., digital power domain). Thus, any change to the clock and power domains associated with the USB Serial/JTAG controller, such "
"as entering different sleep modes, can affect the controller's operation.

Deep-sleep


When entering Deep-sleep, both the USB Serial/JTAG controller and the USB PHY are powered off, leading to the USB PHY's D+ line no longer being pulled up. As a result:

- When entering Deep-sleep, the USB Serial/JTAG device appears disconnected from the host/PC (even if the USB cable is still physically connected).
- When exiting Deep-sleep, the USB Serial/JTAG device reconnects to the host/PC.

Light-sleep

"
"
.. only:: not SOC_USB_SERIAL_JTAG_SUPPORT_LIGHT_SLEEP

When entering Light-sleep, the APB and USB PHY clock are gated. Thus, the USB Serial/JTAG controller is no longer able to receive or respond to any USB transactions from the connected host (including periodic CDC Data IN transactions). As a result:

- when entering Light-sleep, the USB Serial/JTAG device is unresponsive to the host/PC's USB CDC driver. The host/PC may then report the USB Serial/JTAG device as disconnected or erroneous (even"
" if the USB cable is still physically connected).
- when exiting Light-sleep, it is possible that the host/PC does not re-enumerate (i.e., reconnect) the USB Serial/JTAG device given that the USB PHY's D+ line remains pulled up state during Light-sleep. Users may need to physically disconnect and then reconnect the USB cable.

Automatic and Manual Sleep Entry


If users enter sleep manually (via :cpp:func:`esp_light_sleep_start` or :cpp:func:`esp_deep_sleep_start`), users should be cognizant of "
"the fact that USB Serial/JTAG controller does not work during sleep. ESP-IDF **does not add any safety check to reject entry to sleep** even if the USB Serial/JTAG controller is connected. In the case where sleep is entered while the USB Serial/JTAG controller is connected, the connection can be re-established by unplugging and re-plugging the USB cable.

If users enter sleep automatically (via :cpp:func:`esp_pm_configure`), enabling the :ref:`CONFIG_USJ_NO_AUTO_LS_ON_CONNECTION` option allows t"
"he {IDF_TARGET_NAME} to automatically detect whether the USB Serial/JTAG controller is currently connected to a host, and prevent automatic entry to sleep as long as the connection persists. However, note that this option increases power consumption.
"
"Reproducible Builds


Introduction


ESP-IDF build system has support for `reproducible builds`_.

When reproducible builds are enabled, the application built with ESP-IDF does not depend on the build environment. Both the .elf file and .bin files of the application remains exactly the same, even if the following variables change:

- Directory where the project is located
- Directory where ESP-IDF is located (``IDF_PATH``)
- Build time

Reasons for Non-Reproducible Builds


There are several rea"
"sons why an application may depend on the build environment, even when the same source code and tools versions are used.

- In C code, ``__FILE__`` preprocessor macro is expanded to the full path of the source file.
- ``__DATE__`` and ``__TIME__`` preprocessor macros are expanded to compilation date and time.
- When the compiler generates object files, it adds sections with debug information. These sections help debuggers, like GDB, to locate the source code which corresponds to a particular loc"
"ation in the machine code. These sections typically contain paths of relevant source files. These paths may be absolute, and will include the path to ESP-IDF or to the project.

There are also other possible reasons, such as unstable order of inputs and non-determinism in the build system.

Enabling Reproducible Builds in ESP-IDF


Reproducible builds can be enabled in ESP-IDF using :ref:`CONFIG_APP_REPRODUCIBLE_BUILD` option.

This option is disabled by default. It can be enabled in ``menuconfi"
"g``.

The option may also be added into ``sdkconfig.defaults``. If adding the option into ``sdkconfig.defaults``, delete the ``sdkconfig`` file and run the build again. See :ref:`custom-sdkconfig-defaults` for more information.

How Reproducible Builds Are Achieved


ESP-IDF achieves reproducible builds using the following measures:

- In ESP-IDF source code, ``__DATE__`` and ``__TIME__`` macros are not used when reproducible builds are enabled. Note, if the application source code uses these ma"
"cros, the build will not be reproducible.
- ESP-IDF build system passes a set of ``-fmacro-prefix-map`` and ``-fdebug-prefix-map`` flags to replace base paths with placeholders:

    - Path to ESP-IDF is replaced with ``/IDF``
    - Path to the project is replaced with ``/IDF_PROJECT``
    - Path to the build directory is replaced with ``/IDF_BUILD``
    - Paths to components are replaced with ``/COMPONENT_NAME_DIR`` (where ``NAME`` is the name of the component)

- Build date and time are not in"
"cluded into the :ref:`application  metadata structure ` and :ref:`bootloader metadata structure ` if :ref:`CONFIG_APP_REPRODUCIBLE_BUILD` is enabled.
- ESP-IDF build system ensures that source file lists, component lists and other sequences are sorted before passing them to CMake. Various other parts of the build system, such as the linker script generator also perform sorting to ensure that same output is produced regardless of the environment.

Reproducible Builds and Debugging


When reproduc"
"ible builds are enabled, file names included in debug information sections are altered as shown in the previous section. Due to this fact, the debugger (GDB) is not able to locate the source files for the given code location.

This issue can be solved using GDB ``set substitute-path`` command. For example, by adding the following command to GDB init script, the altered paths can be reverted to the original ones::

    set substitute-path /COMPONENT_FREERTOS_DIR /home/user/esp/esp-idf/components/"
"freertos

ESP-IDF build system generates a file with the list of such ``set substitute-path`` commands automatically during the build process. The file is called ``prefix_map_gdbinit`` and is located in the project ``build`` directory.

When :ref:`idf.py gdb ` is used to start debugging, this additional gdbinit file is automatically passed to GDB. When launching GDB manually or from and IDE, please pass this additional gdbinit script to GDB using ``-x build/prefix_map_gdbinit`` argument.

Factor"
"s Which Still Affect Reproducible Builds


Note that the built application still depends on:

- ESP-IDF version
- Versions of the build tools (CMake, Ninja) and the cross-compiler

:doc:`tools/idf-docker-image` can be used to ensure that these factors do not affect the build.


.. _reproducible builds: https://reproducible-builds.org/docs/definition/
"
"Linker Script Generation




Overview


There are several :ref:`memory regions ` where code and data can be placed. Code and read-only data are placed by default in flash, writable data in RAM, etc. However, it is sometimes necessary to change these default placements.

For example, it may be necessary to place:

.. list::
    :SOC_RTC_MEM_SUPPORTED: * code in RTC memory for use in a wake stub.
    :SOC_ULP_SUPPORTED: * code in RTC memory for use by the ULP coprocessor.

With the linker script g"
"eneration mechanism, it is possible to specify these placements at the component level within ESP-IDF. The component presents information on how it would like to place its symbols, objects or the entire archive. During build, the information presented by the components are collected, parsed and processed; and the placement rules generated is used to link the app.

Quick Start


This section presents a guide for quickly placing code/data to RAM and RTC memory - placements ESP-IDF provides out-of-"
"the-box.

For this guide, suppose we have the following::

    components
    └── my_component
        ├── CMakeLists.txt
        ├── Kconfig
        ├── src/
        │   ├── my_src1.c
        │   ├── my_src2.c
        │   └── my_src3.c
        └── my_linker_fragment_file.lf

- a component named ``my_component`` that is archived as library ``libmy_component.a`` during build
- three source files archived under the library, ``my_src1.c``, ``my_src2.c`` and ``my_src3.c`` which are compiled as ``my_"
"src1.o``, ``my_src2.o`` and ``my_src3.o``, respectively
- under ``my_src1.o``, the function ``my_function1`` is defined; under ``my_src2.o``, the function ``my_function2`` is defined
- there is bool-type config ``PERFORMANCE_MODE`` (y/n) and int type config ``PERFORMANCE_LEVEL`` (with range 0-3) in ``my_component``'s Kconfig

Creating and Specifying a Linker Fragment File


Before anything else, a linker fragment file needs to be created. A linker fragment file is simply a text file with a ``.lf"
"`` extension upon which the desired placements will be written. After creating the file, it is then necessary to present it to the build system. The instructions for the build systems supported by ESP-IDF are as follows:

In the component's ``CMakeLists.txt`` file, specify argument ``LDFRAGMENTS`` in the ``idf_component_register`` call. The value of ``LDFRAGMENTS`` can either be an absolute path or a relative path from the component directory to the created linker fragment file.

.. code-block::"
" cmake

    # file paths relative to CMakeLists.txt
    idf_component_register(...
                           LDFRAGMENTS ""path/to/linker_fragment_file.lf"" ""path/to/another_linker_fragment_file.lf""
                           ...
                           )


Specifying Placements


It is possible to specify placements at the following levels of granularity:

    - object file (``.obj`` or ``.o`` files)
    - symbol (function/variable)
    - archive (``.a`` files)

.. _ldgen-placing-object-files"
" :

Placing Object Files
""""""""""""""""""""""""""""""""""""""""

Suppose the entirety of ``my_src1.o`` is performance-critical, so it is desirable to place it in RAM. On the other hand, the entirety of ``my_src2.o`` contains symbols needed coming out of deep sleep, so it needs to be put under RTC memory.

In the linker fragment file, we can write:

.. code-block:: none

    [mapping:my_component]
    archive: libmy_component.a
    entries:
        my_src1 (noflash)     # places all my_src1 code/read-only data und"
"er IRAM/DRAM
        my_src2 (rtc)         # places all my_src2 code/ data and read-only data under RTC fast memory/RTC slow memory

What happens to ``my_src3.o``? Since it is not specified, default placements are used for ``my_src3.o``. More on default placements :ref:`here `.

Placing Symbols
""""""""""""""""""""""""""""""""

Continuing our example, suppose that among functions defined under ``object1.o``, only ``my_function1`` is performance-critical; and under ``object2.o``, only ``my_function2`` needs to e"
"xecute after the chip comes out of deep sleep. This could be accomplished by writing:

.. code-block:: none

    [mapping:my_component]
    archive: libmy_component.a
    entries:
        my_src1:my_function1 (noflash)
        my_src2:my_function2 (rtc)

The default placements are used for the rest of the functions in ``my_src1.o`` and ``my_src2.o`` and the entire ``object3.o``. Something similar can be achieved for placing data by writing the variable name instead of the function name, like so:"
":

       my_src1:my_variable (noflash)

.. warning::

    There are :ref:`limitations` in placing code/data at symbol granularity. In order to ensure proper placements, an alternative would be to group relevant code and data into source files, and :ref:`use object-granularity placements`.

Placing Entire Archive
""""""""""""""""""""""""""""""""""""""""""""""

In this example, suppose that the entire component archive needs to be placed in RAM. This can be written as:

.. code-block:: none

    [mapping:my_component]
"
"    archive: libmy_component.a
    entries:

Similarly, this places the entire component in RTC memory:

.. code-block:: none

    [mapping:my_component]
    archive: libmy_component.a
    entries:


.. _ldgen-conditional-placements:

Configuration-Dependent Placements
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Suppose that the entire component library should only have special placement when a certain condition is true; for example, when ``CONFIG_PERFORMANCE_MODE == y``. This could be written as:

.. c"
"ode-block:: none

    [mapping:my_component]
    archive: libmy_component.a
    entries:
        if PERFORMANCE_MODE = y:
        else:

For a more complex config-dependent placement, suppose the following requirements: when ``CONFIG_PERFORMANCE_LEVEL == 1``, only ``object1.o`` is put in RAM; when ``CONFIG_PERFORMANCE_LEVEL == 2``, ``object1.o`` and ``object2.o``; and when ``CONFIG_PERFORMANCE_LEVEL == 3`` all object files under the archive are to be put into RAM. When these three are false howe"
"ver, put entire library in RTC memory. This scenario is a bit contrived, but, it can be written as:

.. code-block:: none

    [mapping:my_component]
    archive: libmy_component.a
    entries:
        if PERFORMANCE_LEVEL = 1:
            my_src1 (noflash)
        elif PERFORMANCE_LEVEL = 2:
            my_src1 (noflash)
            my_src2 (noflash)
        elif PERFORMANCE_LEVEL = 3:
            my_src1 (noflash)
            my_src2 (noflash)
            my_src3 (noflash)
        else:

Nesti"
"ng condition-checking is also possible. The following is equivalent to the snippet above:

.. code-block:: none

    [mapping:my_component]
    archive: libmy_component.a
    entries:
        if PERFORMANCE_LEVEL  0:
            if PERFORMANCE_LEVEL >= 1:
                object1 (noflash)
                if PERFORMANCE_LEVEL >= 2:
                    object2 (noflash)
                    if PERFORMANCE_LEVEL >= 3:
                        object2 (noflash)
        else:

.. _ldgen-default-placeme"
"nts:

The 'default' Placements


Up until this point, the term  'default placements' has been mentioned as fallback placements when the placement rules ``rtc`` and ``noflash`` are not specified. It is important to note that the tokens ``noflash`` or ``rtc`` are not merely keywords, but are actually entities called fragments, specifically :ref:`schemes `.

In the same manner as ``rtc`` and ``noflash`` are schemes, there exists a ``default`` scheme which defines what the default placement rules sh"
"ould be. As the name suggests, it is where code and data are usually placed, i.e., code/constants is placed in flash, variables placed in RAM, etc.  More on the default scheme :ref:`here `.

.. note::

    For an example of an ESP-IDF component using the linker script generation mechanism, see :component_file:`freertos/CMakeLists.txt`. ``freertos`` uses this to place its object files to the instruction RAM for performance reasons.

This marks the end of the quick start guide. The following text "
"discusses the internals of the mechanism in a little bit more detail. The following sections should be helpful in creating custom placements or modifying default behavior.

Linker Script Generation Internals


Linking is the last step in the process of turning C/C++ source files into an executable. It is performed by the toolchain's linker, and accepts linker scripts which specify code/data placements, among other things. With the linker script generation mechanism, this process is no different,"
" except that the linker script passed to the linker is dynamically generated from: (1) the collected :ref:`linker fragment files ` and (2) :ref:`linker script template `.

.. note::

    The tool that implements the linker script generation mechanism lives under :idf:`tools/ldgen`.

.. _ldgen-linker-fragment-files :

Linker Fragment Files


As mentioned in the quick start guide, fragment files are simple text files with the ``.lf`` extension containing the desired placements. This is a simplifie"
"d description of what fragment files contain, however. What fragment files actually contain are 'fragments'. Fragments are entities which contain pieces of information which, when put together, form placement rules that tell where to place sections of object files in the output binary. There are three types of fragments: :ref:`sections `, :ref:`scheme ` and :ref:`mapping `.

Grammar
""""""""""""""

The three fragment types share a common grammar:

.. code-block:: none

    [type:name]
    key: value
  "
"  key:
        value
        value
        value
        ...

- type: Corresponds to the fragment type, can either be ``sections``, ``scheme`` or ``mapping``.
- name: The name of the fragment, should be unique for the specified fragment type.
- key, value: Contents of the fragment; each fragment type may support different keys and different grammars for the key values.

    - For :ref:`sections ` and :ref:`scheme `, the only supported key is ``entries``
    - For :ref:`mappings `, both ``archive"
"`` and ``entries`` are supported.

.. note::

    In cases where multiple fragments of the same type and name are encountered, an exception is thrown.

.. note::

    The only valid characters for fragment names and keys are alphanumeric characters and underscore.

.. _ldgen-condition-checking :

**Condition Checking**

Condition checking enable the linker script generation to be configuration-aware. Depending on whether expressions involving configuration values are true or not, a particular se"
"t of values for a key can be used. The evaluation uses ``eval_string`` from kconfiglib package and adheres to its required syntax and limitations. Supported operators are as follows:

    - comparison
        - LessThan ````
        - MoreThanOrEqualTo ``>=``
        - Equal ``=``
        - NotEqual ``!=``
    - logical
        - Or ``||``
        - And ``&&``
        - Negation ``!``
    - grouping
        - Parenthesis ``()``

Condition checking behaves as you would expect an ``if...elseif/eli"
"f...else`` block in other languages. Condition-checking is possible for both key values and entire fragments. The two sample fragments below are equivalent:

.. code-block:: none

    # Value for keys is dependent on config
    [type:name]
    key_1:
        if CONDITION = y:
            value_1
        else:
            value_2
    key_2:
        if CONDITION = y:
            value_a
        else:
            value_b

.. code-block:: none

    # Entire fragment definition is dependent on config"
"
    if CONDITION = y:
        [type:name]
        key_1:
            value_1
        key_2:
            value_a
    else:
        [type:name]
        key_1:
            value_2
        key_2:
            value_b

**Comments**

Comment in linker fragment files begin with ``#``. Like in other languages, comment are used to provide helpful descriptions and documentation and are ignored during processing.

Types
""""""""""

.. _ldgen-sections-fragment :

**Sections**

Sections fragments defines a list o"
"f object file sections that the GCC compiler emits. It may be a default section (e.g., ``.text``, ``.data``) or it may be user defined section through the ``__attribute__`` keyword.

The use of an optional '+' indicates the inclusion of the section in the list, as well as sections that start with it. This is the preferred method over listing both explicitly.

.. code-block:: none

    [sections:name]
    entries:
        .section+
        .section
        ...

Example:

.. code-block:: none

   "
" # Non-preferred
    [sections:text]
    entries:
        .text
        .text.*
        .literal
        .literal.*

    # Preferred, equivalent to the one above
    [sections:text]
    entries:
        .text+              # means .text and .text.*
        .literal+           # means .literal and .literal.*

.. _ldgen-scheme-fragment :

**Scheme**

Scheme fragments define what ``target`` a sections fragment is assigned to.

.. code-block:: none

    [scheme:name]
    entries:
        sections ->"
" target
        sections -> target
        ...

Example:

.. code-block:: none

    [scheme:noflash]
    entries:
        text -> iram0_text          # the entries under the sections fragment named text will go to iram0_text
        rodata -> dram0_data        # the entries under the sections fragment named rodata will go to dram0_data

.. _ldgen-default-scheme:

The ``default`` scheme

There exists a special scheme with the name ``default``. This scheme is special because catch-all placement ru"
"les are generated from its entries. This means that, if one of its entries is ``text -> flash_text``, the placement rule will be generated for the target ``flash_text``.

.. code-block:: none

    *(.literal .literal.* .text .text.*)

These catch-all rules then effectively serve as fallback rules for those whose mappings were not specified.


The ``default scheme`` is defined in :component_file:`esp_system/app.lf`. The ``noflash`` and ``rtc`` scheme fragments which are
built-in schemes reference"
"d in the quick start guide are also defined in this file.


.. _ldgen-mapping-fragment :

**Mapping**

Mapping fragments define what scheme fragment to use for mappable entities, i.e., object files, function names, variable names, archives.

.. code-block:: none

    [mapping:name]
    archive: archive                # output archive file name, as built (i.e., libxxx.a)
    entries:
        object:symbol (scheme)      # symbol granularity
        object (scheme)             # object granularity
"
"
There are three levels of placement granularity:

    - symbol: The object file name and symbol name are specified. The symbol name can be a function name or a variable name.
    - object: Only the object file name is specified.
    - archive: ``*`` is specified, which is a short-hand for all the object files under the archive.

To know what an entry means, let us expand a sample object-granularity placement:

.. code-block:: none

    object (scheme)

Then expanding the scheme fragment from it"
"s entries definitions, we have:

.. code-block:: none

    object (sections -> target,
            sections -> target,
            ...)

Expanding the sections fragment with its entries definition:

.. code-block:: none

    object (.section,      # given this object file
            .section,      # put its sections listed here at this
            ... -> target, # target

            .section,
            .section,      # same should be done for these sections
            ... -> target,

      "
"      ...)           # and so on

Example:

.. code-block:: none

    [mapping:map]
    archive: libfreertos.a
    entries:

Aside from the entity and scheme, flags can also be specified in an entry. The following flags are supported (note: <> = argument name, [] = optional):

    Align the placement by the amount specified in ``alignment``. Generates

.. code-block::none

    . = ALIGN()

    before and/or after (depending whether ``pre``, ``post`` or both are specified) the input section descr"
"iption generated from the mapping fragment entry. If neither 'pre' or 'post' is specified, the alignment command is generated before the input section description. Order sensitive.

    Emits ``SORT_BY_NAME``, ``SORT_BY_ALIGNMENT``, ``SORT_BY_INIT_PRIORITY`` or ``SORT`` in the input section description.

    Possible values for ``sort_by_first`` and ``sort_by_second`` are: ``name``, ``alignment``, ``init_priority``.

    If both ``sort_by_first`` and ``sort_by_second`` are not specified, the inp"
"ut sections are sorted by name. If both are specified, then the nested sorting follows the same rules discussed in https://sourceware.org/binutils/docs/ld/Input-Section-Wildcards.html.

    Prevent the linker from discarding the placement by surrounding the input section description with KEEP command. See https://sourceware.org/binutils/docs/ld/Input-Section-Keep.html for more details.

4.SURROUND()

    Generate symbols before and after the placement. The generated symbols follow the naming ``_"
"_start`` and ``__end``. For example, if ``name`` == sym1,

.. code-block::none

    _sym1_start = ABSOLUTE(.)
    ...
    _sym2_end = ABSOLUTE(.)

    These symbols can then be referenced from C/C++ code. Order sensitive.

When adding flags, the specific ``section -> target`` in the scheme needs to be specified. For multiple ``section -> target``, use a comma as a separator. For example,

.. code-block:: none

    # Notes:
    # A. semicolon after entity-scheme
    # B. comma before section2 -> "
"target2
    # C. section1 -> target1 and section2 -> target2 should be defined in entries of scheme1
    entity1 (scheme1);
        section1 -> target1 KEEP() ALIGN(4, pre, post),
        section2 -> target2 SURROUND(sym) ALIGN(4, post) SORT()

Putting it all together, the following mapping fragment, for example,

.. code-block:: none

    [mapping:name]
    archive: lib1.a
    entries:
        obj1 (noflash);
            rodata -> dram0_data KEEP() SORT() ALIGN(8) SURROUND(my_sym)

generates an"
" output on the linker script:

.. code-block:: none

    . = ALIGN(8)
    _my_sym_start = ABSOLUTE(.)
    KEEP(lib1.a:obj1.*( SORT(.rodata) SORT(.rodata.*) ))
    _my_sym_end = ABSOLUTE(.)

Note that ALIGN and SURROUND, as mentioned in the flag descriptions, are order sensitive. Therefore, if for the same mapping fragment these two are switched, the following is generated instead:

.. code-block:: none

    _my_sym_start = ABSOLUTE(.)
    . = ALIGN(8)
    KEEP(lib1.a:obj1.*( SORT(.rodata) SORT(."
"rodata.*) ))
    _my_sym_end = ABSOLUTE(.)

.. _ldgen-symbol-granularity-placements :

On Symbol-Granularity Placements
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Symbol granularity placements is possible due to compiler flags ``-ffunction-sections`` and ``-ffdata-sections``. ESP-IDF compiles with these flags by default.
If the user opts to remove these flags, then the symbol-granularity placements will not work. Furthermore, even with the presence of these flags, there are still other limitations to kee"
"p in mind due to the dependence on the compiler's emitted output sections.

For example, with ``-ffunction-sections``, separate sections are emitted for each function; with section names predictably constructed i.e., ``.text.{func_name}`` and ``.literal.{func_name}``. This is not the case for string literals within the function, as they go to pooled or generated section names.

With ``-fdata-sections``, for global scope data the compiler predictably emits either ``.data.{var_name}``, ``.rodata.{"
"var_name}`` or ``.bss.{var_name}``; and so ``Type I`` mapping entry works for these.
However, this is not the case for static data declared in function scope, as the generated section name is a result of mangling the variable name with some other information.

.. _ldgen-linker-script-template :

Linker Script Template


The linker script template is the skeleton in which the generated placement rules are put into. It is an otherwise ordinary linker script, with a specific marker syntax that indi"
"cates where the generated placement rules are placed.

To reference the placement rules collected under a ``target`` token, the following syntax is used:

.. only:: SOC_MEM_NON_CONTIGUOUS_SRAM

    .. code-block:: none

        arrays[target]      /* refers to objects under the SURROUND keyword */
        mapping[target]     /* refers to all other data */

.. only:: not SOC_MEM_NON_CONTIGUOUS_SRAM

    .. code-block:: none

        mapping[target]

Example:

The example below is an excerpt from "
"a possible linker script template. It defines an output section ``.iram0.text``, and inside is a marker referencing the target ``iram0_text``.

.. only:: SOC_MEM_NON_CONTIGUOUS_SRAM

    .. code-block:: none

        .iram0.text :
        {
            /* Code marked as runnning out of IRAM */
            _iram_text_start = ABSOLUTE(.);

            /* Markers referencing iram0_text */
            arrays[iram0_text]
            mapping[iram0_text]

            _iram_text_end = ABSOLUTE(.);
     "
"   } > iram0_0_seg

.. only:: not SOC_MEM_NON_CONTIGUOUS_SRAM

    .. code-block:: none

        .iram0.text :
        {
            /* Code marked as runnning out of IRAM */
            _iram_text_start = ABSOLUTE(.);

            /* Marker referencing iram0_text */
            mapping[iram0_text]

            _iram_text_end = ABSOLUTE(.);
        } > iram0_0_seg

Suppose the generator collected the fragment definitions below:

.. code-block:: none

    [sections:text]
        .text+
        .l"
"iteral+

    [sections:iram]
        .iram1+

    [scheme:default]
    entries:
        text -> flash_text
        iram -> iram0_text

    [scheme:noflash]
    entries:
        text -> iram0_text

    [mapping:freertos]
    archive: libfreertos.a
    entries:

Then the corresponding excerpt from the generated linker script will be as follows:

.. code-block:: c

    .iram0.text :
    {
        /* Code marked as runnning out of IRAM */
        _iram_text_start = ABSOLUTE(.);

        /* Placement"
" rules generated from the processed fragments, placed where the marker was in the template */
        *(.iram1 .iram1.*)
        *libfreertos.a:(.literal .text .literal.* .text.*)

        _iram_text_end = ABSOLUTE(.);
    } > iram0_0_seg

``*libfreertos.a:(.literal .text .literal.* .text.*)``

    Rule generated from the entry ``* (noflash)`` of the ``freertos`` mapping fragment. All ``text`` sections of all object files under the archive ``libfreertos.a`` will be collected under the target ``i"
"ram0_text`` (as per the ``noflash`` scheme) and placed wherever in the template ``iram0_text`` is referenced by a marker.

``*(.iram1 .iram1.*)``

    Rule generated from the default scheme entry ``iram -> iram0_text``. Since the default scheme specifies an ``iram -> iram0_text`` entry, it too is placed wherever ``iram0_text`` is referenced by a marker. Since it is a rule generated from the default scheme, it comes first among all other rules collected under the same target name.

.. only:: not "
"esp32c5

    The linker script template currently used is :component_file:`esp_system/ld/{IDF_TARGET_PATH_NAME}/sections.ld.in`; the generated output script ``sections.ld`` is put under its build directory.

.. only:: esp32c5

    The linker script template currently used is :component_file:`esp_system/ld/esp32c5/beta3/sections.ld.in`; the generated output script ``sections.ld`` is put under its build directory.
"
"Application Level Tracing Library




Overview


ESP-IDF provides a useful feature for program behavior analysis: application level tracing. It is implemented in the corresponding library and can be enabled in menuconfig. This feature allows to transfer arbitrary data between host and {IDF_TARGET_NAME} via JTAG, UART, or USB interfaces with small overhead on program execution. It is possible to use JTAG and UART interfaces simultaneously. The UART interface is mostly used for connection with SEG"
"GER SystemView tool (see `SystemView `_).

Developers can use this library to send application-specific state of execution to the host and receive commands or other types of information from the opposite direction at runtime. The main use cases of this library are:

Tracing components used when working over JTAG interface are shown in the figure below.

.. figure:: ../../_static/app_trace-overview.jpg
    :align: center
    :alt: Tracing Components When Working Over JTAG

    Tracing Components "
"Used When Working Over JTAG


Modes of Operation


The library supports two modes of operation:

**Post-mortem mode:** This is the default mode. The mode does not need interaction with the host side. In this mode, tracing module does not check whether the host has read all the data from *HW UP BUFFER*, but directly overwrites old data with the new ones. This mode is useful when only the latest trace data is interesting to the user, e.g., for analyzing program's behavior just before the crash. Th"
"e host can read the data later on upon user request, e.g., via special OpenOCD command in case of working via JTAG interface.

**Streaming mode:** Tracing module enters this mode when the host connects to {IDF_TARGET_NAME}. In this mode, before writing new data to *HW UP BUFFER*, the tracing module checks that whether there is enough space in it and if necessary, waits for the host to read data and free enough memory. Maximum waiting time is controlled via timeout values passed by users to corre"
"sponding API routines. So when application tries to write data to the trace buffer using the finite value of the maximum waiting time, it is possible that this data will be dropped. This is especially true for tracing from time critical code (ISRs, OS scheduler code, etc.) where infinite timeouts can lead to system malfunction. In order to avoid loss of such critical data, developers can enable additional data buffering via menuconfig option :ref:`CONFIG_APPTRACE_PENDING_DATA_SIZE_MAX`. This mac"
"ro specifies the size of data which can be buffered in above conditions. The option can also help to overcome situation when data transfer to the host is temporarily slowed down, e.g., due to USB bus congestions. But it will not help when the average bitrate of the trace data stream exceeds the hardware interface capabilities.


Configuration Options and Dependencies


Using of this feature depends on two components:

.. note::

    In order to achieve higher data rates and minimize the number o"
"f dropped packets, it is recommended to optimize the setting of JTAG clock frequency, so that it is at maximum and still provides stable operation of JTAG. See :ref:`jtag-debugging-tip-optimize-jtag-speed`.

There are two additional menuconfig options not mentioned above:


How to Use This Library


This library provides APIs for transferring arbitrary data between the host and {IDF_TARGET_NAME}. When enabled in menuconfig, the target application tracing module is initialized automatically at th"
"e system startup, so all what the user needs to do is to call corresponding APIs to send, receive or flush the data.


.. _app_trace-application-specific-tracing:

Application Specific Tracing


In general, users should decide what type of data should be transferred in every direction and how these data must be interpreted (processed). The following steps must be performed to transfer data between the target and the host:

    .. code-block:: c

        #include ""esp_app_trace.h""
        ...
   "
"     char buf[] = ""Hello World!"";
        esp_err_t res = esp_apptrace_write(ESP_APPTRACE_DEST_TRAX, buf, strlen(buf), ESP_APPTRACE_TMO_INFINITE);
        if (res != ESP_OK) {
            ESP_LOGE(TAG, ""Failed to write data to host!"");
            return res;
        }

    ``esp_apptrace_write()`` function uses memcpy to copy user data to the internal buffer. In some cases, it can be more optimal to use ``esp_apptrace_buffer_get()`` and ``esp_apptrace_buffer_put()`` functions. They allow develo"
"pers to allocate buffer and fill it themselves. The following piece of code shows how to do this.

    .. code-block:: c

        #include ""esp_app_trace.h""
        ...
        int number = 10;
        char *ptr = (char *)esp_apptrace_buffer_get(ESP_APPTRACE_DEST_TRAX, 32, 100/*tmo in us*/);
        if (ptr == NULL) {
            ESP_LOGE(TAG, ""Failed to get buffer!"");
            return ESP_FAIL;
        }
        sprintf(ptr, ""Here is the number %d"", number);
        esp_err_t res = esp_apptra"
"ce_buffer_put(ESP_APPTRACE_DEST_TRAX, ptr, 100/*tmo in us*/);
        if (res != ESP_OK) {
            /* in case of error host tracing tool (e.g., OpenOCD) will report incomplete user buffer */
            ESP_LOGE(TAG, ""Failed to put buffer!"");
            return res;
        }

    Also according to his needs, the user may want to receive data from the host. Piece of code below shows an example on how to do this.

    .. code-block:: c

        #include ""esp_app_trace.h""
        ...
        c"
"har buf[32];
        char down_buf[32];
        size_t sz = sizeof(buf);

        /* config down buffer */
        esp_apptrace_down_buffer_config(down_buf, sizeof(down_buf));
        /* check for incoming data and read them if any */
        esp_err_t res = esp_apptrace_read(ESP_APPTRACE_DEST_TRAX, buf, &sz, 0/*do not wait*/);
        if (res != ESP_OK) {
            ESP_LOGE(TAG, ""Failed to read data from host!"");
            return res;
        }
        if (sz > 0) {
            /* we have d"
"ata, process them */
            ...
        }

    ``esp_apptrace_read()`` function uses memcpy to copy host data to user buffer. In some casesm it can be more optimal to use ``esp_apptrace_down_buffer_get()`` and ``esp_apptrace_down_buffer_put()`` functions. They allow developers to occupy chunk of read buffer and process it in-place. The following piece of code shows how to do this.

    .. code-block:: c

        #include ""esp_app_trace.h""
        ...
        char down_buf[32];
        uint3"
"2_t *number;
        size_t sz = 32;

        /* config down buffer */
        esp_apptrace_down_buffer_config(down_buf, sizeof(down_buf));
        char *ptr = (char *)esp_apptrace_down_buffer_get(ESP_APPTRACE_DEST_TRAX, &sz, 100/*tmo in us*/);
        if (ptr == NULL) {
            ESP_LOGE(TAG, ""Failed to get buffer!"");
            return ESP_FAIL;
        }
        if (sz > 4) {
            number = (uint32_t *)ptr;
            printf(""Here is the number %d"", *number);
        } else {
      "
"      printf(""No data"");
        }
        esp_err_t res = esp_apptrace_down_buffer_put(ESP_APPTRACE_DEST_TRAX, ptr, 100/*tmo in us*/);
        if (res != ESP_OK) {
            /* in case of error host tracing tool (e.g., OpenOCD) will report incomplete user buffer */
            ESP_LOGE(TAG, ""Failed to put buffer!"");
            return res;
        }


OpenOCD Application Level Tracing Commands
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

*HW UP BUFFER* is shared between user data blocks and th"
"e filling of the allocated memory is performed on behalf of the API caller (in task or ISR context). In multithreading environment, it can happen that the task/ISR which fills the buffer is preempted by another high priority task/ISR. So it is possible that the user data preparation process is not completed at the moment when that chunk is read by the host. To handle such conditions, the tracing module prepends all user data chunks with header which contains the allocated user buffer size (2 byt"
"es) and the length of the actually written data (2 bytes). So the total length of the header is 4 bytes. OpenOCD command which reads trace data reports error when it reads incomplete user data chunk, but in any case, it puts the contents of the whole user chunk (including unfilled area) to the output file.

Below is the description of available OpenOCD application tracing commands.

.. note::

    Currently, OpenOCD does not provide commands to send arbitrary user data to the target.


Command u"
"sage:

``esp apptrace [start ] | [stop] | [status] | [dump  ]``

Sub-commands:

``start``
    Start tracing (continuous streaming).
``stop``
    Stop tracing.
``status``
    Get tracing status.
``dump``
    Dump all data from  (post-mortem dump).


Start command syntax:

  ``start  [poll_period [trace_size [stop_tmo [wait4halt [skip_size]]]]``

``outfile``
    Path to file to save data from both CPUs. This argument should have the following format: ``file://path/to/file``.
``poll_period``
    Da"
"ta polling period (in ms) for available trace data. If greater than 0, then command runs in non-blocking mode. By default, 1 ms.
``trace_size``
    Maximum size of data to collect (in bytes). Tracing is stopped after specified amount of data is received. By default, -1 (trace size stop trigger is disabled).
``stop_tmo``
    Idle timeout (in sec). Tracing is stopped if there is no data for specified period of time. By default, -1 (disable this stop trigger). Optionally set it to value longer than"
" longest pause between tracing commands from target.
``wait4halt``
    If 0, start tracing immediately, otherwise command waits for the target to be halted (after reset, by breakpoint etc.) and then automatically resumes it and starts tracing. By default, 0.
``skip_size``
    Number of bytes to skip at the start. By default, 0.

.. note::

    If ``poll_period`` is 0, OpenOCD telnet command line will not be available until tracing is stopped. You must stop it manually by resetting the board or p"
"ressing Ctrl+C in OpenOCD window (not one with the telnet session). Another option is to set ``trace_size`` and wait until this size of data is collected. At this point, tracing stops automatically.

Command usage examples:

.. highlight:: none

    ::

        esp apptrace start file://trace.log 1 2048 5 0 0

    The tracing data will be retrieved and saved in non-blocking mode. This process will stop automatically after 2048 bytes are collected, or if no data are available for more than 5 seco"
"nds.

    .. note::

        Tracing data is buffered before it is made available to OpenOCD. If you see ""Data timeout!"" message, then it is likely that the target is not sending enough data to empty the buffer to OpenOCD before the timeout. Either increase the timeout or use the function ``esp_apptrace_flush()`` to flush the data on specific intervals.

    ::

        esp apptrace start file://trace.log 1 -1 -1 0 0

    There is no limitation on the size of collected data and there is no data "
"timeout set. This process may be stopped by issuing ``esp apptrace stop`` command on OpenOCD telnet prompt, or by pressing Ctrl+C in OpenOCD window.

    ::

        esp apptrace start file://trace.log 0 -1 -1 0 0

    OpenOCD telnet command line prompt will not be available until tracing is stopped. To stop tracing, press Ctrl+C in the OpenOCD window.

    ::

        esp apptrace start file://trace.log 0 2048 -1 1 0

    To configure tracing immediately after reset, use the OpenOCD ``reset hal"
"t`` command.


.. _app_trace-logging-to-host:

Logging to Host


ESP-IDF implements a useful feature: logging to the host via application level tracing library. This is a kind of semihosting when all `ESP_LOGx` calls send strings to be printed to the host instead of UART. This can be useful because ""printing to host"" eliminates some steps performed when logging to UART. Most part of the work is done on the host.

By default, ESP-IDF's logging library uses vprintf-like function to write formatted"
" output to dedicated UART. In general, it involves the following steps:

Though the implementation of the vprintf-like function can be optimized to a certain level, all steps above have to be performed in any case and every step takes some time (especially item 3). So it frequently occurs that with additional log added to the program to identify the problem, the program behavior is changed and the problem cannot be reproduced. And in the worst cases, the program cannot work normally at all and e"
"nds up with an error or even hangs.

Possible ways to overcome this problem are to use higher UART bitrates (or another faster interface) and/or to move string formatting procedure to the host.

The application level tracing feature can be used to transfer log information to the host using ``esp_apptrace_vprintf`` function. This function does not perform full parsing of the format string and arguments. Instead, it just calculates the number of arguments passed and sends them along with the forma"
"t string address to the host. On the host, log data is processed and printed out by a special Python script.


Limitations
""""""""""""""""""""""

Current implementation of logging over JTAG has some limitations:


How To Use It
""""""""""""""""""""""""""

In order to use logging via trace module, users need to perform the following steps:


Log Trace Processor Command Options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Command usage:

``logtrace_proc.py [-h] [--no-errors]  ``

Positional arguments:

``trace_file``
    Path t"
"o log trace file.
``elf_file``
    Path to program ELF file.

Optional arguments:

``-h``, ``--help``
    Show this help message and exit.
``--no-errors``, ``-n``
    Do not print errors.


.. _app_trace-system-behaviour-analysis-with-segger-systemview:

System Behavior Analysis with SEGGER SystemView


Another useful ESP-IDF feature built on top of application tracing library is the system level tracing which produces traces compatible with SEGGER SystemView tool (see `SystemView `_). SEGGER Sy"
"stemView is a real-time recording and visualization tool that allows to analyze runtime behavior of an application. It is possible to view events in real-time through the UART interface.


How To Use It
""""""""""""""""""""""""""

Support for this feature is enabled by ``Component config`` > ``Application Level Tracing`` > ``FreeRTOS SystemView Tracing`` (:ref:`CONFIG_APPTRACE_SV_ENABLE`) menuconfig option. There are several other options enabled under the same menu:

    - Trace Buffer Overflow Event
    - "
"ISR Enter Event
    - ISR Exit Event
    - ISR Exit to Scheduler Event
    - Task Start Execution Event
    - Task Stop Execution Event
    - Task Start Ready State Event
    - Task Stop Ready State Event
    - Task Create Event
    - Task Terminate Event
    - System Idle Event
    - Timer Enter Event
    - Timer Exit Event

ESP-IDF has all the code required to produce SystemView compatible traces, so users can just configure necessary project options (see above), build, download the image to t"
"arget, and use OpenOCD to collect data as described in the previous sections.


OpenOCD SystemView Tracing Command Options
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Command usage:

``esp sysview [start ] | [stop] | [status]``

Sub-commands:

``start``
    Start tracing (continuous streaming).
``stop``
    Stop tracing.
``status``
    Get tracing status.

Start command syntax:

  ``start  [outfile2] [poll_period [trace_size [stop_tmo]]]``

``outfile1``
    Path to file to save data from PRO CPU"
". This argument should have the following format: ``file://path/to/file``.
``outfile2``
    Path to file to save data from APP CPU. This argument should have the following format: ``file://path/to/file``.
``poll_period``
    Data polling period (in ms) for available trace data. If greater than 0, then command runs in non-blocking mode. By default, 1 ms.
``trace_size``
    Maximum size of data to collect (in bytes). Tracing is stopped after specified amount of data is received. By default, -1 (tr"
"ace size stop trigger is disabled).
``stop_tmo``
    Idle timeout (in sec). Tracing is stopped if there is no data for specified period of time. By default, -1 (disable this stop trigger).

.. note::

    If ``poll_period`` is 0, OpenOCD telnet command line will not be available until tracing is stopped. You must stop it manually by resetting the board or pressing Ctrl+C in the OpenOCD window (not the one with the telnet session). Another option is to set ``trace_size`` and wait until this size "
"of data is collected. At this point, tracing stops automatically.

Command usage examples:

.. highlight:: none

    ::

        esp sysview start file://pro-cpu.SVDat file://app-cpu.SVDat

    The tracing data will be retrieved and saved in non-blocking mode. To stop this process, enter ``esp sysview stop`` command on OpenOCD telnet prompt, optionally pressing Ctrl+C in the OpenOCD window.

    ::

        esp sysview start file://pro-cpu.SVDat file://app-cpu.SVDat 0 -1 -1

    OpenOCD telnet c"
"ommand line prompt will not be available until tracing is stopped. To stop tracing, press Ctrl+C in the OpenOCD window.


Data Visualization
""""""""""""""""""""""""""""""""""""

After trace data are collected, users can use a special tool to visualize the results and inspect behavior of the program.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    Unfortunately, SystemView does not support tracing from multiple cores. So when tracing from {IDF_TARGET_NAME} with JTAG interfaces in the dual-core mode, two files are g"
"enerated: one for PRO CPU and another for APP CPU. Users can load each file into separate instances of the tool. For tracing over UART, users can select ``Component config`` > ``Application Level Tracing`` > ``FreeRTOS SystemView Tracing`` in menuconfig Pro or App to choose which CPU has to be traced.

It is uneasy and awkward to analyze data for every core in separate instance of the tool. Fortunately, there is an Eclipse plugin called *Impulse* which can load several trace files, thus making i"
"t possible to inspect events from both cores in one view. Also, this plugin has no limitation of 1,000,000 events as compared to the free version of SystemView.

Good instructions on how to install, configure, and visualize data in Impulse from one core can be found `here `_.

.. note::

    ESP-IDF uses its own mapping for SystemView FreeRTOS events IDs, so users need to replace the original file mapping ``$SYSVIEW_INSTALL_DIR/Description/SYSVIEW_FreeRTOS.txt`` with ``$IDF_PATH/tools/esp_app_tr"
"ace/SYSVIEW_FreeRTOS.txt``. Also, contents of that ESP-IDF-specific file should be used when configuring SystemView serializer using the above link.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    Configure Impulse for Dual Core Traces
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    After installing Impulse and ensuring that it can successfully load trace files for each core in separate tabs, users can add special Multi Adapter port and load both files into one view. To do this, users need to do t"
"he following steps in Eclipse:

    .. note::

        If you have problems with visualization (no data is shown or strange behaviors of zoom action are observed), you can try to delete current signal hierarchy and double-click on the necessary file or port. Eclipse will ask you to create a new signal hierarchy.


.. _app_trace-gcov-source-code-coverage:

Gcov (Source Code Coverage)


Basics of Gcov and Gcovr
""""""""""""""""""""""""""""""""""""""""""""""""

Source code coverage is data indicating the count and frequen"
"cy of every program execution path that has been taken within a program's runtime. `Gcov `_ is a GCC tool that, when used in concert with the compiler, can generate log files indicating the execution count of each line of a source file. The `Gcovr `_ tool is a utility for managing Gcov and generating summarized code coverage results.

Generally, using Gcov to compile and run programs on the host will undergo these steps:


Gcov and Gcovr in ESP-IDF
""""""""""""""""""""""""""""""""""""""""""""""""""""""

Using Gcov in ESP-"
"IDF is complicated due to the fact that the program is running remotely from the host (i.e., on the target). The code coverage data (i.e., the ``.gcda`` files) is initially stored on the target itself. OpenOCD is then used to dump the code coverage data from the target to the host via JTAG during runtime. Using Gcov in ESP-IDF can be split into the following steps.


.. _app_trace-gcov-setup-project:

Setting Up a Project for Gcov
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Compiler Option
~~~~~~~~~~~~~~~

I"
"n order to obtain code coverage data in a project, one or more source files within the project must be compiled with the ``--coverage`` option. In ESP-IDF, this can be achieved at the component level or the individual source file level:

- To cause all source files in a component to be compiled with the ``--coverage`` option, you can add ``target_compile_options(${COMPONENT_LIB} PRIVATE --coverage)`` to the ``CMakeLists.txt`` file of the component.
- To cause a select number of source files (e.g"
"., ``source1.c`` and ``source2.c``) in the same component to be compiled with the ``--coverage`` option, you can add ``set_source_files_properties(source1.c source2.c PROPERTIES COMPILE_FLAGS --coverage)`` to the ``CMakeLists.txt`` file of the component.

When a source file is compiled with the ``--coverage`` option (e.g., ``gcov_example.c``), the compiler will generate the ``gcov_example.gcno`` file in the project's build directory.


Project Configuration
~~~~~~~~~~~~~~~~~~~~~

Before building"
" a project with source code coverage, make sure that the following project configuration options are enabled by running ``idf.py menuconfig``.

- Enable the application tracing module by selecting ``Trace Memory`` for the :ref:`CONFIG_APPTRACE_DESTINATION1` option.
- Enable Gcov to the host via the :ref:`CONFIG_APPTRACE_GCOV_ENABLE`.


.. _app_trace-gcov-dumping-data:

Dumping Code Coverage Data
""""""""""""""""""""""""""""""""""""""""""""""""""""

Once a project has been complied with the ``--coverage`` option and flash"
"ed onto the target, code coverage data will be stored internally on the target (i.e., in trace memory) whilst the application runs. The process of transferring code coverage data from the target to the host is known as dumping.

The dumping of coverage data is done via OpenOCD (see :doc:`JTAG Debugging ` on how to setup and run OpenOCD). A dump is triggered by issuing commands to OpenOCD, therefore a telnet session to OpenOCD must be opened to issue such commands (run ``telnet localhost 4444``)."
" Note that GDB could be used instead of telnet to issue commands to OpenOCD, however all commands issued from GDB will need to be prefixed as ``mon ``.

When the target dumps code coverage data, the ``.gcda`` files are stored in the project's build directory. For example, if ``gcov_example_main.c`` of the ``main`` component is compiled with the ``--coverage`` option, then dumping the code coverage data would generate a ``gcov_example_main.gcda`` in ``build/esp-idf/main/CMakeFiles/__idf_main.dir/"
"gcov_example_main.c.gcda``. Note that the ``.gcno`` files produced during compilation are also placed in the same directory.

The dumping of code coverage data can be done multiple times throughout an application's lifetime. Each dump will simply update the ``.gcda`` file with the newest code coverage information. Code coverage data is accumulative, thus the newest data will contain the total execution count of each code path over the application's entire lifetime.

ESP-IDF supports two methods "
"of dumping code coverage data form the target to the host:


Instant Run-Time Dump
~~~~~~~~~~~~~~~~~~~~~

An Instant Run-Time Dump is triggered by calling the ``{IDF_TARGET_NAME} gcov`` OpenOCD command (via a telnet session). Once called, OpenOCD will immediately preempt the {IDF_TARGET_NAME}'s current state and execute a built-in ESP-IDF Gcov debug stub function. The debug stub function will handle the dumping of data to the host. Upon completion, the {IDF_TARGET_NAME} will resume its current s"
"tate.


Hard-coded Dump
~~~~~~~~~~~~~~~

A Hard-coded Dump is triggered by the application itself by calling :cpp:func:`esp_gcov_dump` from somewhere within the application. When called, the application will halt and wait for OpenOCD to connect and retrieve the code coverage data. Once :cpp:func:`esp_gcov_dump` is called, the host must execute the ``esp gcov dump`` OpenOCD command (via a telnet session). The ``esp gcov dump`` command will cause OpenOCD to connect to the {IDF_TARGET_NAME}, retrie"
"ve the code coverage data, then disconnect from the {IDF_TARGET_NAME}, thus allowing the application to resume. Hard-coded Dumps can also be triggered multiple times throughout an application's lifetime.

Hard-coded dumps are useful if code coverage data is required at certain points of an application's lifetime by placing :cpp:func:`esp_gcov_dump` where necessary (e.g., after application initialization, during each iteration of an application's main loop).

GDB can be used to set a breakpoint o"
"n :cpp:func:`esp_gcov_dump`, then call ``mon esp gcov dump`` automatically via the use a ``gdbinit`` script (see Using GDB from :ref:`jtag-debugging-using-debugger-command-line`).

The following GDB script will add a breakpoint at :cpp:func:`esp_gcov_dump`, then call the ``mon esp gcov dump`` OpenOCD command.

.. code-block:: none

    b esp_gcov_dump
    commands
    mon esp gcov dump
    end


.. note::
    Note that all OpenOCD commands should be invoked in GDB as: ``mon ``.


.. _app_trace-g"
"cov-generate-report:

Generating Coverage Report
""""""""""""""""""""""""""""""""""""""""""""""""""""

Once the code coverage data has been dumped, the ``.gcno``, ``.gcda`` and the source files can be used to generate a code coverage report. A code coverage report is simply a report indicating the number of times each line in a source file has been executed.

Both Gcov and Gcovr can be used to generate code coverage reports. Gcov is provided along with the Xtensa toolchain, whilst Gcovr may need to be installed separatel"
"y. For details on how to use Gcov or Gcovr, refer to `Gcov documentation `_ and `Gcovr documentation `_.


Adding Gcovr Build Target to Project
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To make report generation more convenient, users can define additional build targets in their projects such that the report generation can be done with a single build command.

Add the following lines to the ``CMakeLists.txt`` file of your project.

.. code-block:: none

    include($ENV{IDF_PATH}/tools/cmake/gcov.cm"
"ake)
    idf_create_coverage_report(${CMAKE_CURRENT_BINARY_DIR}/coverage_report)
    idf_clean_coverage_report(${CMAKE_CURRENT_BINARY_DIR}/coverage_report)

The following commands can now be used:
"
"Fatal Errors




.. _Overview:

Overview


In certain situations, the execution of the program can not be continued in a well-defined way. In ESP-IDF, these situations include:

- CPU Exceptions: |CPU_EXCEPTIONS_LIST|
- System level checks and safeguards:

  .. list::

     - :doc:`Interrupt watchdog ` timeout
     - :doc:`Task watchdog ` timeout (only fatal if :ref:`CONFIG_ESP_TASK_WDT_PANIC` is set)
     - Cache access error
     :SOC_MEMPROT_SUPPORTED: - Memory protection fault
     - Brownou"
"t detection event
     - Stack overflow
     - Stack smashing protection check
     - Heap integrity check
     - Undefined behavior sanitizer (UBSAN) checks

- Failed assertions, via ``assert``, ``configASSERT`` and similar macros.

This guide explains the procedure used in ESP-IDF for handling these errors, and provides suggestions on troubleshooting the errors.

Panic Handler


Every error cause listed in the `Overview`_ will be handled by the *panic handler*.

The panic handler will start by"
" printing the cause of the error to the console. For CPU exceptions, the message will be similar to

.. parsed-literal::

    Guru Meditation Error: Core 0 panic'ed (|ILLEGAL_INSTR_MSG|). Exception was unhandled.

For some of the system level checks (interrupt watchdog, cache access error), the message will be similar to

.. parsed-literal::

    Guru Meditation Error: Core 0 panic'ed (|CACHE_ERR_MSG|). Exception was unhandled.

In all cases, the error cause will be printed in parentheses. See `"
"Guru Meditation Errors`_ for a list of possible error causes.

Subsequent behavior of the panic handler can be set using :ref:`CONFIG_ESP_SYSTEM_PANIC` configuration choice. The available options are:

- Print registers and reboot (``CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT``) — default option.

  This will print register values at the point of the exception, print the backtrace, and restart the chip.

- Print registers and halt (``CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT``)

  Similar to the above option"
", but halt instead of rebooting. External reset is required to restart the program.

- Silent reboot (``CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT``)

  Do not print registers or backtrace, restart the chip immediately.

- Invoke GDB Stub (``CONFIG_ESP_SYSTEM_PANIC_GDBSTUB``)

  Start GDB server which can communicate with GDB over console UART port. This option will only provide read-only debugging or post-mortem debugging. See `GDB Stub`_ for more details.

.. note::

  The ``CONFIG_ESP_SYSTEM_PANIC"
"_GDBSTUB`` choice in the configuration option :ref:`CONFIG_ESP_SYSTEM_PANIC` is only available when the component ``esp_gdbstub`` is included in the build.

The behavior of the panic handler is affected by three other configuration options.

- If :ref:`CONFIG_ESP_DEBUG_OCDAWARE` is enabled (which is the default), the panic handler will detect whether a JTAG debugger is connected. If it is, execution will be halted and control will be passed to the debugger. In this case, registers and backtrace "
"are not dumped to the console, and GDBStub / Core Dump functions are not used.

- If the :doc:`Core Dump ` feature is enabled, then the system state (task stacks and registers) will be dumped to either Flash or UART, for later analysis.

- If :ref:`CONFIG_ESP_PANIC_HANDLER_IRAM` is disabled (disabled by default), the panic handler code is placed in flash memory, not IRAM. This means that if ESP-IDF crashes while flash cache is disabled, the panic handler will automatically re-enable flash cache "
"before running GDB Stub or Core Dump. This adds some minor risk, if the flash cache status is also corrupted during the crash.

  If this option is enabled, the panic handler code (including required UART functions) is placed in IRAM, and hence will decrease the usable memory space in SRAM. But this may be necessary to debug some complex issues with crashes while flash cache is disabled (for example, when writing to SPI flash) or when flash cache is corrupted when an exception is triggered.

- I"
"f :ref:`CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS` is enabled (disabled by default) and set to a number higher than 0, the panic handler will delay the reboot for that amount of time in seconds. This can help if the tool used to monitor serial output does not provide a possibility to stop and examine the serial output. In that case, delaying the reboot will allow users to examine and debug the panic handler output (backtrace, etc.) for the duration of the delay. After the delay, the device wi"
"ll reboot. The reset reason is preserved.

The following diagram illustrates the panic handler behavior:

.. blockdiag::
    :scale: 100%
    :caption: Panic Handler Flowchart (click to enlarge)
    :align: center

    blockdiag panic-handler {
        orientation = portrait;
        edge_layout = flowchart;
        default_group_color = white;
        node_width = 160;
        node_height = 60;

        cpu_exception [label = ""CPU Exception"", shape=roundedbox];
        sys_check [label = ""Cache"
" error,\nInterrupt WDT,\nabort()"", shape=roundedbox];
        check_ocd [label = ""JTAG debugger\nconnected?"", shape=diamond, height=80];
        print_error_cause [label = ""Print error/\nexception cause""];
        use_jtag [label = ""Send signal to\nJTAG debugger"", shape=roundedbox];
        dump_registers [label = ""Print registers\nand backtrace""];
        check_coredump [label = ""Core dump\nenabled?"", shape=diamond, height=80];
        do_coredump [label = ""Core dump\nto UART or Flash""];
      "
"  check_gdbstub [label = ""GDB Stub\nenabled?"", shape=diamond, height=80];
        do_gdbstub [label = ""Start GDB Stub"", shape=roundedbox];
        halt [label = ""Halt"", shape=roundedbox];
        reboot [label = ""Reboot"", shape=roundedbox];
        check_halt [label = ""Halt?"", shape=diamond, height=80];

        group {cpu_exception, sys_check};

        cpu_exception -> print_error_cause;
        sys_check -> print_error_cause;
        print_error_cause -> check_ocd;
        check_ocd -> use_jt"
"ag [label = ""Yes""];
        check_ocd -> dump_registers [label = ""No""];
        dump_registers -> check_coredump
        check_coredump -> do_coredump [label = ""Yes""];
        do_coredump -> check_gdbstub;
        check_coredump -> check_gdbstub [label = ""No""];
        check_gdbstub -> check_halt [label = ""No""];
        check_gdbstub -> do_gdbstub [label = ""Yes""];
        check_halt -> halt [label = ""Yes""];
        check_halt -> reboot [label = ""No""];
    }

Register Dump and Backtrace


Unless "
"the ``CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT`` option is enabled, the panic handler prints some of the CPU registers, and the backtrace, to the console

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    ::

        Core 0 register dump:
        PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030
        A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc
        A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9   "
"   : 0x3ffb5000
        A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8
        A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014  EXCCAUSE: 0x0000001d
        EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff

        Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

    ::

        Core  0 register dump:
        MEPC    : 0x420048b4  RA      : 0x420048b4  SP "
"     : 0x3fc8f2f0  GP      : 0x3fc8a600
        TP      : 0x3fc8a2ac  T0      : 0x40057fa6  T1      : 0x0000000f  T2      : 0x00000000
        S0/FP   : 0x00000000  S1      : 0x00000000  A0      : 0x00000001  A1      : 0x00000001
        A2      : 0x00000064  A3      : 0x00000004  A4      : 0x00000001  A5      : 0x00000000
        A6      : 0x42001fd6  A7      : 0x00000000  S2      : 0x00000000  S3      : 0x00000000
        S4      : 0x00000000  S5      : 0x00000000  S6      : 0x00000000  S7    "
"  : 0x00000000
        S8      : 0x00000000  S9      : 0x00000000  S10     : 0x00000000  S11     : 0x00000000
        T3      : 0x00000000  T4      : 0x00000000  T5      : 0x00000000  T6      : 0x00000000
        MSTATUS : 0x00001881  MTVEC   : 0x40380001  MCAUSE  : 0x00000007  MTVAL   : 0x00000000
        MHARTID : 0x00000000

The register values printed are the register values in the exception frame, i.e., values at the moment when the CPU exception or another fatal error has occurred.

A Regi"
"ster dump is not printed if the panic handler has been executed as a result of an ``abort()`` call.

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    In some cases, such as interrupt watchdog timeout, the panic handler may print additional CPU registers (EPC1-EPC4) and the registers/backtrace of the code running on the other CPU.

    The backtrace line contains PC:SP pairs, where PC is the Program Counter and SP is Stack Pointer, for each stack frame of the current task. If a fatal error happens in"
"side an ISR, the backtrace may include PC:SP pairs both from the task which was interrupted, and from the ISR.

If :doc:`IDF Monitor ` is used, Program Counter values will be converted to code locations (function name, file name, and line number), and the output will be annotated with additional lines:

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    ::

        Core 0 register dump:
        PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030
        0x400e14ed: a"
"pp_main at /Users/user/esp/example/main/main.cpp:36

        A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc
        A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x3ffb5000
        A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8
        0x40082d1c: _calloc_r at /Users/user/esp/esp-idf/components/newlib/syscalls.c:51

        A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014"
"  EXCCAUSE: 0x0000001d
        EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff

        Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050
        0x400e14ed: app_main at /Users/user/esp/example/main/main.cpp:36

        0x400d0802: main_task at /Users/user/esp/esp-idf/components/{IDF_TARGET_PATH_NAME}/cpu_start.c:470

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

    ::

        Core  0 register dump:
        MEPC    : 0x420048b4  RA      : 0x420048b4  SP   "
"   : 0x3fc8f2f0  GP      : 0x3fc8a600
        0x420048b4: app_main at /Users/user/esp/example/main/hello_world_main.c:20

        0x420048b4: app_main at /Users/user/esp/example/main/hello_world_main.c:20

        TP      : 0x3fc8a2ac  T0      : 0x40057fa6  T1      : 0x0000000f  T2      : 0x00000000
        S0/FP   : 0x00000000  S1      : 0x00000000  A0      : 0x00000001  A1      : 0x00000001
        A2      : 0x00000064  A3      : 0x00000004  A4      : 0x00000001  A5      : 0x00000000
        A"
"6      : 0x42001fd6  A7      : 0x00000000  S2      : 0x00000000  S3      : 0x00000000
        0x42001fd6: uart_write at /Users/user/esp/esp-idf/components/vfs/vfs_uart.c:201

        S4      : 0x00000000  S5      : 0x00000000  S6      : 0x00000000  S7      : 0x00000000
        S8      : 0x00000000  S9      : 0x00000000  S10     : 0x00000000  S11     : 0x00000000
        T3      : 0x00000000  T4      : 0x00000000  T5      : 0x00000000  T6      : 0x00000000
        MSTATUS : 0x00001881  MTVEC   : "
"0x40380001  MCAUSE  : 0x00000007  MTVAL   : 0x00000000
        MHARTID : 0x00000000

    Moreover, :doc:`IDF Monitor ` is also capable of generating and printing a backtrace thanks to the stack dump provided by the board in the panic handler.
    The output looks like this:

    ::

        Backtrace:

        0x42006686 in bar (ptr=ptr@entry=0x0) at ../main/hello_world_main.c:18
        18      *ptr = 0x42424242;
        #0  0x42006686 in bar (ptr=ptr@entry=0x0) at ../main/hello_world_main.c:18"
"
        #1  0x42006692 in foo () at ../main/hello_world_main.c:22
        #2  0x420066ac in app_main () at ../main/hello_world_main.c:28
        #3  0x42015ece in main_task (args=) at /Users/user/esp/components/freertos/port/port_common.c:142
        #4  0x403859b8 in vPortEnterCritical () at /Users/user/esp/components/freertos/port/riscv/port.c:130
        #5  0x00000000 in ?? ()
        Backtrace stopped: frame did not save the PC

    While the backtrace above is very handy, it requires the "
"user to use :doc:`IDF Monitor `. Thus, in order to generate and print a backtrace while using another monitor program, it is possible to activate :ref:`CONFIG_ESP_SYSTEM_USE_EH_FRAME` option from the menuconfig.

    This option will let the compiler generate DWARF information for each function of the project. Then, when a CPU exception occurs, the panic handler will parse these data and determine the backtrace of the task that failed. The output looks like this:

    ::

        Backtrace: 0x42"
"009e9a:0x3fc92120 0x42009ea6:0x3fc92120 0x42009ec2:0x3fc92130 0x42024620:0x3fc92150 0x40387d7c:0x3fc92160 0xfffffffe:0x3fc92170

    These ``PC:SP`` pairs represent the PC (Program Counter) and SP (Stack Pointer) for each stack frame of the current task.


    The main benefit of the :ref:`CONFIG_ESP_SYSTEM_USE_EH_FRAME` option is that the backtrace is generated by the board itself (without the need for :doc:`IDF Monitor `). However, the option's drawback is that it results in an increase of the"
" compiled binary's size (ranging from 20% to 100% increase in size). Furthermore, this option causes debug information to be included within the compiled binary. Therefore, users are strongly advised not to enable this option in mass/final production builds.

To find the location where a fatal error has happened, look at the lines which follow the ""Backtrace"" line. Fatal error location is the top line, and subsequent lines show the call stack.

.. _GDB-Stub:

GDB Stub


If the ``CONFIG_ESP_SYSTE"
"M_PANIC_GDBSTUB`` option is enabled, the panic handler will not reset the chip when a fatal error happens. Instead, it will start a GDB remote protocol server, commonly referred to as GDB Stub. When this happens, a GDB instance running on the host computer can be instructed to connect to the {IDF_TARGET_NAME} UART port.

If :doc:`IDF Monitor ` is used, GDB is started automatically when a GDB Stub prompt is detected on the UART. The output looks like this::

    Entering gdb stub now.
    $T0b#e6"
"GNU gdb (crosstool-NG crosstool-ng-1.22.0-80-gff1f415) 7.10
    Copyright (C) 2015 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later 
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.  Type ""show copying""
    and ""show warranty"" for details.
    This GDB was configured as ""--host=x86_64-build_apple-darwin16.3.0 --target={IDF_TARGET_TOOLCHAIN_PREFIX}"".
    Type ""show configuration"" for confi"
"guration details.
    For bug reporting instructions, please see:
    .
    Find the GDB manual and other documentation resources online at:
    .
    For help, type ""help"".
    Type ""apropos word"" to search for commands related to ""word""...
    Reading symbols from /Users/user/esp/example/build/example.elf...done.
    Remote debugging using /dev/cu.usbserial-31301
    0x400e1b41 in app_main ()
        at /Users/user/esp/example/main/main.cpp:36
    36      *((int*) 0) = 0;
    (gdb)

The GDB pr"
"ompt can be used to inspect CPU registers, local and static variables, and arbitrary locations in memory. It is not possible to set breakpoints, change the PC, or continue execution. To reset the program, exit GDB and perform an external reset: Ctrl-T Ctrl-R in IDF Monitor, or using the external reset button on the development board.

.. _RTC-Watchdog-Timeout:

RTC Watchdog Timeout

{IDF_TARGET_RTCWDT_RTC_RESET:default=""Not updated"", esp32=""RTCWDT_RTC_RESET"", esp32s2=""RTCWDT_RTC_RST"", esp32s3=""R"
"TCWDT_RTC_RST"", esp32c3=""RTCWDT_RTC_RST"", esp32c2=""RTCWDT_RTC_RST"", esp32c6=""LP_WDT_SYS"", esp32h2=""LP_WDT_SYS"", esp32p4=""LP_WDT_SYS""}

The RTC watchdog is used in the startup code to keep track of execution time and it also helps to prevent a lock-up caused by an unstable power source. It is enabled by default (see :ref:`CONFIG_BOOTLOADER_WDT_ENABLE`). If the execution time is exceeded, the RTC watchdog will restart the system. In this case, the ROM bootloader will print a message with the ``RTC"
" Watchdog Timeout`` reason for the reboot.

::

    rst:0x10 ({IDF_TARGET_RTCWDT_RTC_RESET})


The RTC watchdog covers the execution time from the first stage bootloader (ROM bootloader) to application startup. It is initially set in the ROM bootloader, then configured in the bootloader with the :ref:`CONFIG_BOOTLOADER_WDT_TIME_MS` option (9000 ms by default). During the application initialization stage, it is reconfigured because the source of the slow clock may have changed, and finally disabl"
"ed right before the ``app_main()`` call. There is an option :ref:`CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE` which prevents the RTC watchdog from being disabled before ``app_main``. Instead, the RTC watchdog remains active and must be fed periodically in your application's code.

.. _Guru-Meditation-Errors:

Guru Meditation Errors


.. Note to editor: titles of the following section need to match exception causes printed by the panic handler. Do not change the titles (insert spaces, reword, etc"
".) unless the panic handler messages are also changed.

.. Note to translator: When translating this section, avoid translating the following section titles. ""Guru Meditation"" in the title of this section should not be translated either. Keep these two notes when translating.

This section explains the meaning of different error causes, printed in parens after the ``Guru Meditation Error: Core panic'ed`` message.

.. note::

  See the `Guru Meditation Wikipedia article `_ for historical origins "
"of ""Guru Meditation"".


|ILLEGAL_INSTR_MSG|


This CPU exception indicates that the instruction which was executed was not a valid instruction. The most common reasons for this error include:

- FreeRTOS task function has returned. In FreeRTOS, if a task function needs to terminate, it should call :cpp:func:`vTaskDelete` and delete itself, instead of returning.

- Failure to read next instruction from SPI flash. This usually happens if:

  - Application has reconfigured the SPI flash pins as som"
"e other function (GPIO, UART, etc.). Consult the Hardware Design Guidelines and the datasheet for the chip or module for details about the SPI flash pins.

  - Some external device has accidentally been connected to the SPI flash pins, and has interfered with communication between {IDF_TARGET_NAME} and SPI flash.

- In C++ code, exiting from a non-void function without returning a value is considered to be an undefined behavior. When optimizations are enabled, the compiler will often omit the ep"
"ilogue in such functions. This most often results in an |ILLEGAL_INSTR_MSG| exception. By default, ESP-IDF build system enables ``-Werror=return-type`` which means that missing return statements are treated as compile time errors. However if the application project disables compiler warnings, this issue might go undetected and the |ILLEGAL_INSTR_MSG| exception will occur at run time.

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    InstrFetchProhibited
    

    This CPU exception indicates that th"
"e CPU could not read an instruction because the address of the instruction does not belong to a valid region in instruction RAM or ROM.

    Usually, this means an attempt to call a function pointer, which does not point to valid code. ``PC`` (Program Counter) register can be used as an indicator: it will be zero or will contain a garbage value (not ``0x4xxxxxxx``).

    LoadProhibited, StoreProhibited
    

    These CPU exceptions happen when an application attempts to read from or write to an"
" invalid memory location. The address which has been written/read is found in the ``EXCVADDR`` register in the register dump. If this address is zero, it usually means that the application has attempted to dereference a NULL pointer. If this address is close to zero, it usually means that the application has attempted to access a member of a structure, but the pointer to the structure is NULL. If this address is something else (garbage value, not in ``0x3fxxxxxx`` - ``0x6xxxxxxx`` range), it lik"
"ely means that the pointer used to access the data is either not initialized or has been corrupted.

    IntegerDivideByZero
    

    Application has attempted to do an integer division by zero.

    LoadStoreAlignment
    

    Application has attempted to read or write a memory location, and the address alignment does not match the load/store size. For example, a 32-bit read can only be done from a 4-byte aligned address, and a 16-bit write can only be done to a 2-byte aligned address.

    L"
"oadStoreError
    

    This exception may happen in the following cases:

    - If the application has attempted to do an 8- or 16- bit read to, or write from, a memory region which only supports 32-bit reads/writes. For example, dereferencing a ``char*`` pointer to instruction memory (IRAM, IROM) will result in such an error.

    - If the application has attempted to write to a read-only memory region, such as IROM or DROM.

    Unhandled Debug Exception
    

    This CPU exception happens w"
"hen the instruction ``BREAK`` is executed.

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

    Instruction Address Misaligned
    

    This CPU exception indicates that the address of the instruction to execute is not 2-byte aligned.

    Instruction Access Fault, Load Access Fault, Store Access Fault
    

    This CPU exception happens when application attempts to execute, read from or write to an invalid memory location. The address which was written/read is found in ``MTVAL`` register in the regis"
"ter dump. If this address is zero, it usually means that application attempted to dereference a NULL pointer. If this address is close to zero, it usually means that application attempted to access member of a structure, but the pointer to the structure was NULL. If this address is something else (garbage value, not in ``0x3fxxxxxx`` - ``0x6xxxxxxx`` range), it likely means that the pointer used to access the data was either not initialized or was corrupted.

    Breakpoint
    

    This CPU ex"
"ception happens when the instruction ``EBREAK`` is executed. See also :ref:`FreeRTOS-End-Of-Stack-Watchpoint`.

    Load Address Misaligned, Store Address Misaligned
    

    Application has attempted to read or write memory location, and address alignment did not match load/store size. For example, 32-bit load can only be done from 4-byte aligned address, and 16-bit load can only be done from a 2-byte aligned address.

Interrupt Watchdog Timeout on CPU0/CPU1


Indicates that an interrupt watch"
"dog timeout has occurred. See :doc:`Watchdogs ` for more information.

|CACHE_ERR_MSG|


In some situations, ESP-IDF will temporarily disable access to external SPI Flash and SPI RAM via caches. For example, this happens when spi_flash APIs are used to read/write/erase/mmap regions of SPI Flash. In these situations, tasks are suspended, and interrupt handlers not registered with ``ESP_INTR_FLAG_IRAM`` are disabled. Make sure that any interrupt handlers registered with this flag have all the code"
" and data in IRAM/DRAM. Refer to the :ref:`SPI flash API documentation ` for more details.

.. only:: SOC_MEMPROT_SUPPORTED

    Memory Protection Fault
    

    {IDF_TARGET_NAME} Permission Control feature is used in ESP-IDF to prevent the following types of memory access:

    Such operations are not necessary for most programs. Prohibiting such operations typically makes software vulnerabilities harder to exploit. Applications which rely on dynamic loading or self-modifying code may disable "
"this protection using :ref:`CONFIG_ESP_SYSTEM_MEMPROT_FEATURE` Kconfig option.

    When the fault occurs, the panic handler reports the address of the fault and the type of memory access that caused it.

Other Fatal Errors


.. only:: SOC_BOD_SUPPORTED

    Brownout
    

    {IDF_TARGET_NAME} has a built-in brownout detector, which is enabled by default. The brownout detector can trigger a system reset if the supply voltage goes below a safe level. The brownout detector can be configured using"
" :ref:`CONFIG_ESP_BROWNOUT_DET` and :ref:`CONFIG_ESP_BROWNOUT_DET_LVL_SEL` options.

    When the brownout detector triggers, the following message is printed::

        Brownout detector was triggered

    The chip is reset after the message is printed.

    Note that if the supply voltage is dropping at a fast rate, only part of the message may be seen on the console.


Corrupt Heap


ESP-IDF's heap implementation contains a number of run-time checks of the heap structure. Additional checks ("""
"Heap Poisoning"") can be enabled in menuconfig. If one of the checks fails, a message similar to the following will be printed::

    CORRUPT HEAP: Bad tail at 0x3ffe270a. Expected 0xbaad5678 got 0xbaac5678
    assertion ""head != NULL"" failed: file ""/Users/user/esp/esp-idf/components/heap/multi_heap_poisoning.c"", line 201, function: multi_heap_free
    abort() was called at PC 0x400dca43 on core 0

Consult :doc:`Heap Memory Debugging ` documentation for further information.

|STACK_OVERFLOW|


.."
" only:: SOC_ASSIST_DEBUG_SUPPORTED

    Hardware Stack Guard
    """"""""""""""""""""""""""""""""""""""""

    {IDF_TARGET_NAME} has an integrated assist-debug module that can watch the SP register to ensure that it is within the bounds of allocated stack memory. The assist-debug module needs to set new stack bounds on every interrupt handling and FreeRTOS context switch. This can have a small impact on performance.

    Here are some additional details about the assist-debug module:

    - Implemented in hardware
"
"    - Watches Stack Pointer register value
    - Requires no additional CPU time or memory while watching stack bounds

    When the assist-debug module detects a stack overflow, the panic handler will run and display a message that resembles the following:

    .. parsed-literal::

        Guru Meditation Error: Core 0 panic'ed (Stack protection fault).

    Hardware stack guard can be disabled using :ref:`CONFIG_ESP_SYSTEM_HW_STACK_GUARD` options.

.. _FreeRTOS-End-Of-Stack-Watchpoint:

FreeRT"
"OS End of Stack Watchpoint
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

ESP-IDF provides a custom FreeRTOS stack overflow detecting mechanism based on watchpoints. Every time FreeRTOS switches task context, one of the watchpoints is set to watch the last 32 bytes of stack.

Generally, this may cause the watchpoint to be triggered up to 28 bytes earlier than expected. The value 32 is chosen because it is larger than the stack canary size in FreeRTOS (20 bytes). Adopting this approach ensures that the watchp"
"oint triggers before the stack canary is corrupted, not after.

.. note::
    Not every stack overflow is guaranteed to trigger the watchpoint. It is possible that the task writes to memory beyond the stack canary location, in which case the watchpoint will not be triggered.

If watchpoint triggers, the message will be similar to:

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    ::

        Debug exception reason: Stack canary watchpoint triggered (task_name)

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV"
"

    ::

        Guru Meditation Error: Core  0 panic'ed (Breakpoint). Exception was unhandled.

This feature can be enabled by using the :ref:`CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK` option.


FreeRTOS Stack Checks
""""""""""""""""""""""""""""""""""""""""""

See :ref:`CONFIG_FREERTOS_CHECK_STACKOVERFLOW`

Stack Smashing


Stack smashing protection (based on GCC ``-fstack-protector*`` flags) can be enabled in ESP-IDF using :ref:`CONFIG_COMPILER_STACK_CHECK_MODE` option. If stack smashing is detected, message simil"
"ar to the following will be printed::

    Stack smashing protect failure!

    abort() was called at PC 0x400d2138 on core 0

    Backtrace: 0x4008e6c0:0x3ffc1780 0x4008e8b7:0x3ffc17a0 0x400d2138:0x3ffc17c0 0x400e79d5:0x3ffc17e0 0x400e79a7:0x3ffc1840 0x400e79df:0x3ffc18a0 0x400e2235:0x3ffc18c0 0x400e1916:0x3ffc18f0 0x400e19cd:0x3ffc1910 0x400e1a11:0x3ffc1930 0x400e1bb2:0x3ffc1950 0x400d2c44:0x3ffc1a80
    0

The backtrace should point to the function where stack smashing has occurred. Check the"
" function code for unbounded access to local arrays.

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

    .. |CPU_EXCEPTIONS_LIST| replace:: Illegal Instruction, Load/Store Alignment Error, Load/Store Prohibited error, Double Exception.
    .. |ILLEGAL_INSTR_MSG| replace:: IllegalInstruction
    .. |CACHE_ERR_MSG| replace:: Cache disabled but cached memory region accessed
    .. |STACK_OVERFLOW| replace:: Stack overflow

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

    .. |CPU_EXCEPTIONS_LIST| replace:: Ill"
"egal Instruction, Load/Store Alignment Error, Load/Store Prohibited error.
    .. |ILLEGAL_INSTR_MSG| replace:: Illegal instruction
    .. |CACHE_ERR_MSG| replace:: Cache error
    .. |STACK_OVERFLOW| replace:: Stack overflow

Undefined Behavior Sanitizer (UBSAN) Checks


Undefined behavior sanitizer (UBSAN) is a compiler feature which adds run-time checks for potentially incorrect operations, such as:

- overflows (multiplication overflow, signed integer overflow)
- shift base or exponent error"
"s (e.g., shift by more than 32 bits)
- integer conversion errors

See `GCC documentation `_ of ``-fsanitize=undefined`` option for the complete list of supported checks.

Enabling UBSAN
""""""""""""""""""""""""""""

UBSAN is disabled by default. It can be enabled at file, component, or project level by adding the ``-fsanitize=undefined`` compiler option in the build system.

When enabling UBSAN for code which uses the SOC hardware register header files (``soc/xxx_reg.h``), it is recommended to disable shift-b"
"ase sanitizer using ``-fno-sanitize=shift-base`` option. This is due to the fact that ESP-IDF register header files currently contain patterns which cause false positives for this specific sanitizer option.

To enable UBSAN at project level, add the following code at the end of the project's ``CMakeLists.txt`` file::

    idf_build_set_property(COMPILE_OPTIONS ""-fsanitize=undefined"" ""-fno-sanitize=shift-base"" APPEND)

Alternatively, pass these options through the ``EXTRA_CFLAGS`` and ``EXTRA_CXX"
"FLAGS`` environment variables.

Enabling UBSAN results in significant increase of code and data size. Most applications, except for the trivial ones, will not fit into the available RAM of the microcontroller when UBSAN is enabled for the whole application. Therefore it is recommended that UBSAN is instead enabled for specific components under test.

To enable UBSAN for a specific component (``component_name``) from the project's ``CMakeLists.txt`` file, add the following code at the end of the "
"file::

    idf_component_get_property(lib component_name COMPONENT_LIB)
    target_compile_options(${lib} PRIVATE ""-fsanitize=undefined"" ""-fno-sanitize=shift-base"")

.. note::

  See the build system documentation for more information about :ref:`build properties ` and :ref:`component properties `.

To enable UBSAN for a specific component (``component_name``) from ``CMakeLists.txt`` of the same component, add the following at the end of the file::

    target_compile_options(${COMPONENT_LIB} P"
"RIVATE ""-fsanitize=undefined"" ""-fno-sanitize=shift-base"")

UBSAN Output
""""""""""""""""""""""""

When UBSAN detects an error, a message and the backtrace are printed, for example::

    Undefined behavior of type out_of_bounds

    Backtrace:0x4008b383:0x3ffcd8b0 0x4008c791:0x3ffcd8d0 0x4008c587:0x3ffcd8f0 0x4008c6be:0x3ffcd950 0x400db74f:0x3ffcd970 0x400db99c:0x3ffcd9a0

When using :doc:`IDF Monitor `, the backtrace will be decoded to function names and source code locations, pointing to the location wher"
"e the issue has happened (here it is ``main.c:128``)::

    0x4008b383: panic_abort at /path/to/esp-idf/components/esp_system/panic.c:367

    0x4008c791: esp_system_abort at /path/to/esp-idf/components/esp_system/system_api.c:106

    0x4008c587: __ubsan_default_handler at /path/to/esp-idf/components/esp_system/ubsan.c:152

    0x4008c6be: __ubsan_handle_out_of_bounds at /path/to/esp-idf/components/esp_system/ubsan.c:223

    0x400db74f: test_ub at main.c:128

    0x400db99c: app_main at main.c"
":56 (discriminator 1)

The types of errors reported by UBSAN can be as follows:


.. list-table::
  :widths: 40 60
  :header-rows: 1
    - Meaning
    - Incorrect pointer value: null, unaligned, not compatible with the given type.
    - Integer overflow during addition, subtraction, multiplication, negation.
    - Integer division by 0 or ``INT_MIN``.
    - Overflow in left or right shift operators.
    - Access outside of bounds of an array.
    - Unreachable code executed.
    - Non-void funct"
"ion has reached its end without returning a value (C++ only).
    - Size of variable length array is not positive.
    - Value of ``bool`` or ``enum`` (C++ only) variable is invalid (out of bounds).
    - Null argument passed to a function which is declared with a ``nonnull`` attribute.
    - Null value returned from a function which is declared with ``returns_nonnull`` attribute.
    - ``__builtin_unreachable`` function called.
    - Overflow in pointer arithmetic.
"
"OpenThread




`OpenThread `_ is an IP stack running on the 802.15.4 MAC layer which features mesh network and low power consumption.

Modes of the OpenThread Stack


OpenThread can run under the following modes on Espressif chips:

Standalone Node
+++++++++++++++

The full OpenThread stack and the application layer run on the same chip. This mode is available on chips with 15.4 radio such as ESP32-H2 and ESP32-C6.

Radio Co-Processor (RCP)
++++++++++++++++++++++++

The chip is connected to anot"
"her host running the OpenThread IP stack. It sends and receives 15.4 packets on behalf of the host. This mode is available on chips with 15.4 radio such as ESP32-H2 and ESP32-C6. The underlying transport between the chip and the host can be SPI or UART. For the sake of latency, we recommend using SPI as the underlying transport.

OpenThread Host
+++++++++++++++

For chips without a 15.4 radio, it can be connected to an RCP and run OpenThread under host mode. This mode enables OpenThread on Wi-Fi"
" chips such as ESP32, ESP32-S2, ESP32-S3, and ESP32-C3. The following diagram shows how devices work under different modes:

.. blockdiag::
    :caption: OpenThread device modes
    :align: center

    blockdiag openthread-device-modes {

        # global attributes
        node_height = 90;
        node_width = 220;
        span_width = 100
        default_shape = roundedbox;
        default_group_color = none;

        # node labels
        HOST_NODE [label=""OpenThread \nhost\n(ESP32)"", fontsi"
"ze=14];
        RCP [label=""Radio \nCo-Processor\n(ESP32-H2)"", fontsize=14];
        STANDALONE [label=""Standalone \nnode\n (ESP32-H2)"", fontsize=14];

        # node connections + labels
        RCP -> STANDALONE [label=""15.4 radio"", dir=both, style=dashed];

        # arrange nodes vertically
        group {
           orientation = portrait;
           HOST_NODE -> RCP [label=""SPI"", dir=both];
        }
    }


How to Write an OpenThread Application


The OpenThread :example:`openthread/ot_cl"
"i` example is a good place to start at. It demonstrates basic OpenThread initialization and simple socket-based server and client.

Before OpenThread Initialization
++++++++++++++++++++++++++++++++

- s1.1: The main task calls :cpp:func:`esp_vfs_eventfd_register` to initialize the eventfd virtual file system. The eventfd file system is used for task notification in the OpenThread driver.

- s1.2: The main task calls :cpp:func:`nvs_flash_init` to initialize the NVS where the Thread network data i"
"s stored.

- s1.3: **Optional**. The main task calls :cpp:func:`esp_netif_init` only when it wants to create the network interface for Thread.

- s1.4: The main task calls :cpp:func:`esp_event_loop_create` to create the system Event task and initialize an application event's callback function.

OpenThread Stack Initialization
+++++++++++++++++++++++++++++++

- s2.1: Call :cpp:func:`esp_openthread_init` to initialize the OpenThread stack.

OpenThread Network Interface Initialization
+++++++++++++"
"++++++++++++++++++++++++++++++

The whole stage is **optional** and only required if the application wants to create the network interface for Thread.

- s3.1: Call :cpp:func:`esp_netif_new` with ``ESP_NETIF_DEFAULT_OPENTHREAD`` to create the interface.
- s3.2: Call :cpp:func:`esp_openthread_netif_glue_init` to create the OpenThread interface handlers.
- s3.3: Call :cpp:func:`esp_netif_attach` to attach the handlers to the interface.

The OpenThread Main Loop
++++++++++++++++++++++++

- s4.3: Ca"
"ll :cpp:func:`esp_openthread_launch_mainloop` to launch the OpenThread main loop. Note that this is a busy loop and does not return until the OpenThread stack is terminated.

Calling OpenThread APIs
++++++++++++++++++++++++

The OpenThread APIs are not thread-safe. When calling OpenThread APIs from other tasks, make sure to hold the lock with :cpp:func:`esp_openthread_lock_acquire` and release the lock with :cpp:func:`esp_openthread_lock_release` afterwards.

Deinitialization
++++++++++++++++

T"
"he following steps are required to deinitialize the OpenThread stack:

- Call :cpp:func:`esp_netif_destroy` and :cpp:func:`esp_openthread_netif_glue_deinit` to deinitialize the OpenThread network interface if you have created one.
- Call :cpp:func:`esp_openthread_deinit` to deinitialize the OpenThread stack.

The OpenThread Border Router


The OpenThread border router connects the Thread network with other IP networks. It provides IPv6 connectivity, service registration, and commission functiona"
"lity.

To launch an OpenThread border router on an ESP chip, you need to connect an RCP to a Wi-Fi capable chip such as ESP32.

Calling :cpp:func:`esp_openthread_border_router_init` during the initialization launches all the border routing functionalities.

You may refer to the :example:`openthread/ot_br` example and the README for further border router details.
"
"Application Startup Flow




This note explains various steps which happen before ``app_main`` function of an ESP-IDF application is called.

The high level view of startup process is as follows:

This process is explained in detail in the following sections.

.. _first-stage-bootloader:

First Stage Bootloader


.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    After SoC reset, PRO CPU will start running immediately, executing reset vector code, while APP CPU will be held in reset. During startup pr"
"ocess, PRO CPU does all the initialization. APP CPU reset is de-asserted in the ``call_start_cpu0`` function of application startup code. Reset vector code is located in the mask ROM of the {IDF_TARGET_NAME} chip and cannot be modified.

.. only:: not SOC_HP_CPU_HAS_MULTIPLE_CORES

    After SoC reset, the CPU will start running immediately to perform initialization. The reset vector code is located in the mask ROM of the {IDF_TARGET_NAME} chip and cannot be modified.

Startup code called from t"
"he reset vector determines the boot mode by checking ``GPIO_STRAP_REG`` register for bootstrap pin states. Depending on the reset reason, the following takes place:

.. list::

    :SOC_RTC_MEM_SUPPORTED: #. Reset from deep sleep: if the value in ``RTC_CNTL_STORE6_REG`` is non-zero, and CRC value of RTC memory in ``RTC_CNTL_STORE7_REG`` is valid, use ``RTC_CNTL_STORE6_REG`` as an entry point address and jump immediately to it. If ``RTC_CNTL_STORE6_REG`` is zero, or ``RTC_CNTL_STORE7_REG`` contai"
"ns invalid CRC, or once the code called via ``RTC_CNTL_STORE6_REG`` returns, proceed with boot as if it was a power-on reset. **Note**: to run customized code at this point, a deep sleep stub mechanism is provided. Please see :doc:`deep sleep ` documentation for this.

    #. For power-on reset, software SoC reset, and watchdog SoC reset: check the ``GPIO_STRAP_REG`` register if a custom boot mode (such as UART Download Mode) is requested. If this is the case, this custom loader mode is executed"
" from ROM. Otherwise, proceed with boot as if it was due to software CPU reset. Consult {IDF_TARGET_NAME} datasheet for a description of SoC boot modes and how to execute them.

    #. For software CPU reset and watchdog CPU reset: configure SPI flash based on EFUSE values, and attempt to load the code from flash. This step is described in more detail in the next paragraphs.

.. note::

    During normal boot modes the RTC watchdog is enabled when this happens, so if the process is interrupted o"
"r stalled then the watchdog will reset the SOC automatically and repeat the boot process. This may cause the SoC to strap into a new boot mode, if the strapping GPIOs have changed.

.. only:: esp32

    Second stage bootloader binary image is loaded from flash starting at address {IDF_TARGET_CONFIG_BOOTLOADER_OFFSET_IN_FLASH}. If :doc:`/security/secure-boot-v1` is in use then the first 4 kB sector of flash is used to store secure boot IV and digest of the bootloader image. Otherwise, this sector"
" is unused.

.. only:: esp32s2

    Second stage bootloader binary image is loaded from flash starting at address {IDF_TARGET_CONFIG_BOOTLOADER_OFFSET_IN_FLASH}. The 4 kB sector of flash before this address is unused.

.. only:: esp32p4

    Second stage bootloader binary image is loaded from flash starting at address {IDF_TARGET_CONFIG_BOOTLOADER_OFFSET_IN_FLASH}. The 8 kB sector of flash before this address is reserved for the key manager for use with flash encryption (AES-XTS).

.. only:: not"
" (esp32 or esp32s2 or esp32p4)

    Second stage bootloader binary image is loaded from the start of flash at offset {IDF_TARGET_CONFIG_BOOTLOADER_OFFSET_IN_FLASH}.

.. TODO: describe application binary image format, describe optional flash configuration commands.

.. _second-stage-bootloader:

Second Stage Bootloader


In ESP-IDF, the binary image which resides at offset {IDF_TARGET_CONFIG_BOOTLOADER_OFFSET_IN_FLASH} in flash is the second stage bootloader. Second stage bootloader source code i"
"s available in :idf:`components/bootloader` directory of ESP-IDF. Second stage bootloader is used in ESP-IDF to add flexibility to flash layout (using partition tables), and allow for various flows associated with flash encryption, secure boot, and over-the-air updates (OTA) to take place.

When the first stage bootloader is finished checking and loading the second stage bootloader, it jumps to the second stage bootloader entry point found in the binary image header.

Second stage bootloader rea"
"ds the partition table found by default at offset {IDF_TARGET_CONFIG_PARTITION_TABLE_OFFSET} (:ref:`configurable value `). See :doc:`partition tables ` documentation for more information. The bootloader finds factory and OTA app partitions. If OTA app partitions are found in the partition table, the bootloader consults the ``otadata`` partition to determine which one should be booted. See :doc:`/api-reference/system/ota` for more information.

For a full description of the configuration options "
"available for the ESP-IDF bootloader, see :doc:`bootloader`.

For the selected partition, second stage bootloader reads the binary image from flash one segment at a time:

- For segments with load addresses in internal :ref:`iram` or :ref:`dram`, the contents are copied from flash to the load address.
- For segments which have load addresses in :ref:`drom` or :ref:`irom` regions, the flash MMU is configured to provide the correct mapping from the flash to the load address.

.. only:: esp32

    "
"Note that the second stage bootloader configures flash MMU for both PRO and APP CPUs, but it only enables flash MMU for PRO CPU. Reason for this is that second stage bootloader code is loaded into the memory region used by APP CPU cache. The duty of enabling cache for APP CPU is passed on to the application.

Once all segments are processed - meaning code is loaded and flash MMU is set up, second stage bootloader verifies the integrity of the application and then jumps to the application entry p"
"oint found in the binary image header.

.. _application-startup:

Application Startup


Application startup covers everything that happens after the app starts executing and before the ``app_main`` function starts running inside the main task. This is split into three stages:

- Port initialization of hardware and basic C runtime environment.
- System initialization of software services and FreeRTOS.
- Running the main task and calling ``app_main``.

.. note::

   Understanding all stages of ESP"
"-IDF app initialization is often not necessary. To understand initialization from the application developer's perspective only, skip forward to :ref:`app-main-task`.

Port Initialization


ESP-IDF application entry point is ``call_start_cpu0`` function found in :idf_file:`components/esp_system/port/cpu_start.c`. This function is executed by the second stage bootloader, and never returns.

This port-layer initialization function initializes the basic C Runtime Environment (""CRT"") and performs ini"
"tial configuration of the SoC's internal hardware:

.. list::

   - Reconfigure CPU exceptions for the app (allowing app interrupt handlers to run, and causing :doc:`fatal-errors` to be handled using the options configured for the app rather than the simpler error handler provided by ROM).
   - If the option :ref:`CONFIG_BOOTLOADER_WDT_ENABLE` is not set then the RTC watchdog timer is disabled.
   - Initialize internal memory (data & bss).
   - Finish configuring the MMU cache.
   :SOC_SPIRAM_SU"
"PPORTED: - Enable PSRAM if configured.
   - Set the CPU clocks to the frequencies configured for the project.
   :SOC_MEMPROT_SUPPORTED: - Initialize memory protection if configured.
   :esp32: - Reconfigure the main SPI flash based on the app header settings (necessary for compatibility with bootloader versions before ESP-IDF V4.0, see :ref:`bootloader-compatibility`).
   :SOC_HP_CPU_HAS_MULTIPLE_CORES: - If the app is configured to run on multiple cores, start the other core and wait for it to"
" initialize as well (inside the similar ""port layer"" initialization function ``call_start_cpu1``).

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    Once ``call_start_cpu0`` completes running, it calls the ""system layer"" initialization function ``start_cpu0`` found in :idf_file:`components/esp_system/startup.c`. Other cores will also complete port-layer initialization and call ``start_other_cores`` found in the same file.

.. only:: not SOC_HP_CPU_HAS_MULTIPLE_CORES

    Once ``call_start_cpu0`` com"
"pletes running, it calls the ""system layer"" initialization function ``start_cpu0`` found in :idf_file:`components/esp_system/startup.c`.

System Initialization


The main system initialization function is ``start_cpu0``. By default, this function is weak-linked to the function ``start_cpu0_default``. This means that it is possible to override this function to add some additional initialization steps.

The primary system initialization stage includes:

.. list::

   - Log information about this a"
"pplication (project name, :ref:`app-version`, etc.) if default log level enables this.
   - Initialize the heap allocator (before this point all allocations must be static or on the stack).
   - Initialize newlib component syscalls and time functions.
   - Configure the brownout detector.
   - Setup libc stdin, stdout, and stderr according to the :ref:`serial console configuration `.
   :esp32: - Perform any security-related checks, including burning efuses that should be burned for this configu"
"ration (including :ref:`disabling ROM download mode on ESP32 V3 `, :ref:`CONFIG_ESP32_DISABLE_BASIC_ROM_CONSOLE`).
   :not esp32: - Perform any security-related checks, including burning efuses that should be burned for this configuration (including :ref:`permanently limiting ROM download modes `).
   - Initialize SPI flash API support.
   - Call global C++ constructors and any C functions marked with ``__attribute__((constructor))``.

Secondary system initialization allows individual components"
" to be initialized. If a component has an initialization function annotated with the ``ESP_SYSTEM_INIT_FN`` macro, it will be called as part of secondary initialization. Component initialization functions have priorities assigned to them to ensure the desired initialization order. The priorities are documented in :component_file:`esp_system/system_init_fn.txt` and ``ESP_SYSTEM_INIT_FN`` definition in source code are checked against this file.

.. _app-main-task:

Running the Main Task


After al"
"l other components are initialized, the main task is created and the FreeRTOS scheduler starts running.

After doing some more initialization tasks (that require the scheduler to have started), the main task runs the application-provided function ``app_main`` in the firmware.

The main task that runs ``app_main`` has a fixed RTOS priority (one higher than the minimum) and a :ref:`configurable stack size `.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

   The main task core affinity is also configura"
"ble: :ref:`CONFIG_ESP_MAIN_TASK_AFFINITY`.

Unlike normal FreeRTOS tasks (or embedded C ``main`` functions), the ``app_main`` task is allowed to return. If this happens, The task is cleaned up and the system will continue running with other RTOS tasks scheduled normally. Therefore, it is possible to implement ``app_main`` as either a function that creates other application tasks and then returns, or as a main application task itself.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    Second Core Star"
"tup
    

    A similar but simpler startup process happens on the APP CPU:

    When running system initialization, the code on PRO CPU sets the entry point for APP CPU, de-asserts APP CPU reset, and waits for a global flag to be set by the code running on APP CPU, indicating that it has started. Once this is done, APP CPU jumps to ``call_start_cpu1`` function in :idf_file:`components/esp_system/port/cpu_start.c`.

    While PRO CPU does initialization in ``start_cpu0`` function, APP CPU runs `"
"`start_cpu_other_cores`` function. Similar to ``start_cpu0``, this function is weak-linked and defaults to the ``start_cpu_other_cores_default`` function but can be replaced with a different function by the application.

    The ``start_cpu_other_cores_default`` function does some core-specific system initialization and then waits for the PRO CPU to start the FreeRTOS scheduler, at which point it executes ``esp_startup_start_app_other_cores`` which is another weak-linked function defaulting to `"
"`esp_startup_start_app_other_cores_default``.

    By default ``esp_startup_start_app_other_cores_default`` does nothing but spin in a busy-waiting loop until the scheduler of the PRO CPU triggers an interrupt to start the RTOS scheduler on the APP CPU.
"
"Unit Testing in {IDF_TARGET_NAME}




ESP-IDF provides the following methods to test software.

- Target based tests using a central unit test application which runs on the {IDF_TARGET_PATH_NAME}. These tests use the `Unity `_ unit test framework. They can be integrated into an ESP-IDF component by placing them in the component's ``test`` subdirectory. This document mainly introduces this target based tests.

- Linux-host based unit tests in which part of the hardware can be abstracted via mocks"
". Currently, Linux-host based tests are still under development and only a small fraction of IDF components support them. More information on running IDF applications on the host can be found here: :doc:`Running Applications on the Host Machine `.

Normal Test Cases


Unit tests are located in the ``test`` subdirectory of a component. Tests are written in C, and a single C source file can contain multiple test cases. Test files start with the word ""test"".

Each test file should include the ``uni"
"ty.h`` header and the header for the C module to be tested.

Tests are added in a function in the C file as follows:

.. code-block:: c

    TEST_CASE(""test name"", ""[module name]"")
    {
            // Add test here
    }

- The first argument is a descriptive name for the test.
- The second argument is an identifier in square brackets. Identifiers are used to group related test, or tests with specific properties.

.. note::
    There is no need to add a main function with ``UNITY_BEGIN()`` and "
"``​UNITY_END()`` in each test case. ``unity_platform.c`` will run ``UNITY_BEGIN()`` autonomously, and run the test cases, then call ``​UNITY_END()``.

The ``test`` subdirectory should contain a :ref:`component CMakeLists.txt `, since they are themselves components (i.e., a test component). ESP-IDF uses the Unity test framework located in the ``unity`` component. Thus, each test component should specify the ``unity`` component as a component requirement using the ``REQUIRES`` argument. Normally, "
"components :ref:`should list their sources manually `; for component tests however, this requirement is relaxed and the use of the ``SRC_DIRS`` argument in ``idf_component_register`` is advised.

Overall, the minimal ``test`` subdirectory ``CMakeLists.txt`` file should contain the following:

.. code:: cmake

    idf_component_register(SRC_DIRS "".""
                           INCLUDE_DIRS "".""
                           REQUIRES unity)

See http://www.throwtheswitch.org/unity for more information "
"about writing tests in Unity.


Multi-device Test Cases


The normal test cases will be executed on one DUT (Device Under Test). However, components that require some form of communication (e.g., GPIO, SPI) require another device to communicate with, thus cannot be tested through normal test cases. Multi-device test cases involve writing multiple test functions, and running them on multiple DUTs.

The following is an example of a multi-device test case:

.. code-block:: c

    void gpio_master_t"
"est()
    {
        gpio_config_t slave_config = {
                .pin_bit_mask = 1 `_ to help make running unit-tests more convenient and efficient. If you need to run tests in CI or run multiple tests in a row we recommend checking out this project. For more information see `Pytest-embedded Docs `_ and :doc:`/contribute/esp-idf-tests-with-pytest`.


After flashing reset the {IDF_TARGET_NAME} and it will boot the unit test app.

When unit test app is idle, press ""Enter"" will make it print test"
" menu with all available tests::

    Here's the test menu, pick your combo:
    (1)     ""esp_ota_begin() verifies arguments"" [ota]
    (2)     ""esp_ota_get_next_update_partition logic"" [ota]
    (3)     ""Verify bootloader image in flash"" [bootloader_support]
    (4)     ""Verify unit test app image"" [bootloader_support]
    (5)     ""can use new and delete"" [cxx]
    (6)     ""can call virtual functions"" [cxx]
    (7)     ""can use static initializers for non-POD types"" [cxx]
    (8)     ""can use s"
"td::vector"" [cxx]
    (9)     ""static initialization guards work as expected"" [cxx]
    (10)    ""global initializers run in the correct order"" [cxx]
    (11)    ""before scheduler has started, static initializers work correctly"" [cxx]
    (12)    ""adc2 work with wifi"" [adc]
    (13)    ""gpio master/slave test example"" [ignore][misc][test_env=UT_T2_1][multi_device]
            (1)     ""gpio_master_test""
            (2)     ""gpio_slave_test""
    (14)    ""SPI Master clockdiv calculation routines"" [s"
"pi]
    (15)    ""SPI Master test"" [spi][ignore]
    (16)    ""SPI Master test, interaction of multiple devs"" [spi][ignore]
    (17)    ""SPI Master no response when switch from host1 (SPI2) to host2 (SPI3)"" [spi]
    (18)    ""SPI Master DMA test, TX and RX in different regions"" [spi]
    (19)    ""SPI Master DMA test: length, start, not aligned"" [spi]
    (20)    ""reset reason check for deepsleep"" [{IDF_TARGET_PATH_NAME}][test_env=UT_T2_1][multi_stage]
            (1)     ""trigger_deepsleep""
      "
"      (2)     ""check_deepsleep_reset_reason""

The normal case will print the case name and description. Master-slave cases will also print the sub-menu (the registered test function names).

Test cases can be run by inputting one of the following:

- Test case name in quotation marks to run a single test case
- Test case index to run a single test case
- Module name in square brackets to run all test cases for a specific module
- An asterisk to run all test cases

``[multi_device]`` and ``[multi"
"_stage]`` tags tell the test runner whether a test case is a multiple devices or multiple stages of test case. These tags are automatically added by ```TEST_CASE_MULTIPLE_STAGES`` and ``TEST_CASE_MULTIPLE_DEVICES`` macros.

After you select a multi-device test case, it will print sub-menu::

    Running gpio master/slave test example...
    gpio master/slave test example
            (1)     ""gpio_master_test""
            (2)     ""gpio_slave_test""

You need to input a number to select the test ru"
"nning on the DUT.

Similar to multi-device test cases, multi-stage test cases will also print sub-menu::

    Running reset reason check for deepsleep...
    reset reason check for deepsleep
            (1)     ""trigger_deepsleep""
            (2)     ""check_deepsleep_reset_reason""

First time you execute this case, input ``1`` to run first stage (trigger deepsleep). After DUT is rebooted and able to run test cases, select this case again and input ``2`` to run the second stage. The case only pas"
"ses if the last stage passes and all previous stages trigger reset.


.. _cache-compensated-timer:

Timing Code with Cache Compensated Timer


Instructions and data stored in external memory (e.g., SPI Flash and SPI RAM) are accessed through the CPU's unified instruction and data cache. When code or data is in cache, access is very fast (i.e., a cache hit).

However, if the instruction or data is not in cache, it needs to be fetched from external memory (i.e., a cache miss). Access to external m"
"emory is significantly slower, as the CPU must execute stall cycles whilst waiting for the instruction or data to be retrieved from external memory. This can cause the overall code execution speed to vary depending on the number of cache hits or misses.

Code and data placements can vary between builds, and some arrangements may be more favorable with regards to cache access (i.e., minimizing cache misses). This can technically affect execution speed, however these factors are usually irrelevant"
" as their effect 'average out' over the device's operation.

The effect of the cache on execution speed, however, can be relevant in benchmarking scenarios (especially micro benchmarks). There might be some variability in measured time between runs and between different builds. A technique for eliminating for some of the variability is to place code and data in instruction or data RAM (IRAM/DRAM), respectively. The CPU can access IRAM and DRAM directly, eliminating the cache out of the equation."
" However, this might not always be viable as the size of IRAM and DRAM is limited.

The cache compensated timer is an alternative to placing the code/data to be benchmarked in IRAM/DRAM. This timer uses the processor's internal event counters in order to determine the amount of time spent on waiting for code/data in case of a cache miss, then subtract that from the recorded wall time.

  .. code-block:: c

    // Start the timer
    ccomp_timer_start();

    // Function to time
    func_code_to_"
"time();

    // Stop the timer, and return the elapsed time in microseconds relative to
    // ccomp_timer_start
    int64_t t = ccomp_timer_stop();


One limitation of the cache compensated timer is that the task that benchmarked functions should be pinned to a core. This is due to each core having its own event counters that are independent of each other. For example, if ``ccomp_timer_start`` gets called on one core, put to sleep by the scheduler, wakes up, and gets rescheduled on the other co"
"re, then the corresponding ``ccomp_timer_stop`` will be invalid.

.. _mocks:

Mocks


.. note::
    Currently, mocking is only possible with some selected components when running on the Linux host. In the future, we plan to make essential components in IDF mock-able. This will also include mocking when running on the {IDF_TARGET_NAME}.

One of the biggest problems regarding unit testing on embedded systems are the strong hardware dependencies. Running unit tests directly on the {IDF_TARGET_NAME}"
" can be especially difficult for higher layer components for the following reasons:

- Decreased test reliability due to lower layer components and/or hardware setup.
- Increased difficulty in testing edge cases due to limitations of lower layer components and/or hardware setup
- Increased difficulty in identifying the root cause due to the large number of dependencies influencing the behavior

When testing a particular component, (i.e., the component under test), mocking allows the dependencies"
" of the component under test to be substituted (i.e., mocked) entirely in software. Through mocking, hardware details are emulated and specified at run time, but only if necessary. To allow mocking, ESP-IDF integrates the `CMock `_ mocking framework as a component. With the addition of some CMake functions in the ESP-IDF build system, it is possible to conveniently mock the entirety (or a part) of an IDF component.

Ideally, all components that the component under test is dependent on should be "
"mocked, thus allowing the test environment complete control over all interactions with the component under test. However, if mocking all dependent components becomes too complex or too tedious (e.g., because you need to mock too many function calls) you have the following options:

.. list::
    - Include more ""real"" IDF code in the tests. This may work but increases the dependency on the ""real"" code's behavior. Furthermore, once a test fails, you may not know if the failure is in your actual co"
"de under test or the ""real"" IDF code.
    - Re-evaluate the design of the code under test and attempt to reduce its dependencies by dividing the code under test into more manageable components. This may seem burdensome but it is quite common that unit tests expose software design weaknesses. Fixing design weaknesses will not only help with unit testing in the short term, but will help future code maintenance as well.

Refer to :component_file:`cmock/CMock/docs/CMock_Summary.md` for more details "
"on how CMock works and how to create and use mocks.

Requirements


Mocking with CMock requires ``Ruby`` on the host machine. Furthermore, since mocking currently only works on the Linux target, the requirements of the latter also need to be fulfilled:

.. include:: inc/linux-host-requirements.rst

Mock a Component


If a mocked component, called a *component mock*, is already available in ESP-IDF, then it can be used right away as long as it satisfies the required functionality. Refer to :ref:`"
"component-linux-mock-support` to see which components are mocked already. Then refer to :ref:`adjustments_for_mocks` in order to use the component mock.

It is necessary to create component mocks if they are not yet provided in ESP-IDF. To create a component mock, the component needs to be overwritten in a particular way. Overriding a component entails creating a component with the exact same name as the original component, then letting the build system discover it later than the original compon"
"ent (see :ref:`Multiple components with the same name ` for more details).

In the component mock, the following parts are specified:

.. list::
    - The headers providing the functions to generate mocks for
    - Include paths of the aforementioned headers
    - Dependencies of the mock component (this is necessary e.g. if the headers include files from other components)

All these parts have to be specified using the IDF build system function ``idf_component_mock``. You can use the IDF build "
"system function ``idf_component_get_property`` with the tag ``COMPONENT_OVERRIDEN_DIR`` to access the component directory of the original component and then register the mock component parts using ``idf_component_mock``:

.. code:: none

    idf_component_get_property(original_component_dir  COMPONENT_OVERRIDEN_DIR)
    ...
    idf_component_mock(INCLUDE_DIRS ""${original_component_dir}/include""
        REQUIRES freertos
        MOCK_HEADER_FILES ${original_component_dir}/include/header_containin"
"g_functions_to_mock.h)

The component mock also requires a separate ``mock`` directory containing a ``mock_config.yaml`` file that configures CMock. A simple ``mock_config.yaml`` could look like this:

  .. code-block:: yaml

    :cmock:
      :plugins:
        - expect
        - expect_any_args

For more details about the CMock configuration yaml file, have a look at :component_file:`cmock/CMock/docs/CMock_Summary.md`.

Note that the component mock does not have to mock the original component i"
"n its entirety. As long as the test project's dependencies and dependencies of other code to the original components are satisfied by the component mock, partial mocking is adequate. In fact, most of the component mocks in IDF in ``tools/mocks`` are only partially mocking the original component.

Examples of component mocks can be found under :idf:`tools/mocks` in the IDF directory. General information on how to *override an IDF component* can be found in :ref:`Multiple components with the same "
"name `. There are several examples for testing code while mocking dependencies with CMock (non-exhaustive list):

- :component_file:`unit test for the NVS Page class `.
- :component_file:`unit test for esp_event `.
- :component_file:`unit test for mqtt `.

.. _adjustments_for_mocks:

Adjustments in Unit Test


The unit test needs to inform the cmake build system to mock dependent components (i.e., it needs to override the original component with the mock component). This is done by either placin"
"g the component mock into the project's ``components`` directory or adding the mock component's directory using the following line in the project's root ``CMakeLists.txt``:

  .. code:: cmake

    list(APPEND EXTRA_COMPONENT_DIRS """")

Both methods will override existing components in ESP-IDF with the component mock. The latter is particularly convenient if you use component mocks that are already supplied by IDF.

Users can refer to the ``esp_event`` host-based unit test and its :component_file:"
"`esp_event/host_test/esp_event_unit_test/CMakeLists.txt` as an example of a component mock.
"
"Wi-Fi Security




{IDF_TARGET_NAME} Wi-Fi Security Features


- Support for Protected Management Frames (PMF)
- Support for WPA3-Personal
- Support for Opportunistic Wireless Encryption (OWE)

In addition to traditional security methods (WEP/WPA-TKIP/WPA2-CCMP), {IDF_TARGET_NAME} Wi-Fi supports state-of-the-art security protocols, namely Protected Management Frames (PMF), Wi-Fi Protected Access 3 and Enhanced Open™ based on Opportunistic Wireless Encryption. WPA3 provides better privacy and rob"
"ustness against known attacks on traditional modes. Enhanced Open™ enhances the security and privacy of users connecting to open (public) Wireless Networks without authentication.

Protected Management Frames (PMF)


Introduction
++++++++++++

In Wi-Fi, management frames such as beacons, probes, authentication/deauthentication, and association/disassociation are used by non-AP stations to scan and connect to an AP. Unlike data frames, these frames are sent unencrypted.

An attacker can use eaves"
"dropping and packet injection to send spoofed authentication/deauthentication or association/disassociation frames at the right time, leading to attacks such as Denial-of-Service (DOS) and man-in-the-middle.

PMF provides protection against these attacks by encrypting unicast management frames and providing integrity checks for broadcast management frames. These include deauthentication, disassociation, and robust management frames. It also provides a Secure Association (SA) teardown mechanism t"
"o prevent spoofed association/authentication frames from disconnecting already connected clients.

There are three types of PMF configuration modes on both the station and AP sides:

 - PMF Optional
 - PMF Required
 - PMF Disabled

API & Usage
+++++++++++

{IDF_TARGET_NAME} supports PMF in both the station and SoftAP mode. For both, the default mode is PMF Optional. For even higher security, PMF Required mode can be enabled by setting the ``required`` flag in ``pmf_cfg`` while using the :cpp:fun"
"c:`esp_wifi_set_config` API. This results in the device only connecting to a PMF-enabled device and rejecting others. PMF Optional can be disabled using :cpp:func:`esp_wifi_disable_pmf_config` API. If SoftAP is started in WPA3 or WPA2/WPA3 mixed mode, trying to disable PMF results in an error.

.. attention::

    ``capable`` flag in ``pmf_cfg`` is deprecated and set to ``true`` internally. This is to take the additional security benefit of PMF whenever possible.

Wi-Fi Enterprise


Introduction"
"
++++++++++++

Enterprise security is the secure authentication mechanism for enterprise wireless networks. It uses the RADIUS server for authentication of network users before connecting to the Access Point (AP). The authentication process is based on 802.1X policy and comes with different Extended Authentication Protocol (EAP) methods such as TLS, TTLS, PEAP, and EAP-FAST. RADIUS server authenticates the users based on their credentials (username and password), digital certificates, or both.

"
".. note::

  {IDF_TARGET_NAME} supports Wi-Fi Enterprise only in station mode.

{IDF_TARGET_NAME} supports **WPA2-Enterprise** and **WPA3-Enterprise**. WPA3-Enterprise builds upon the foundation of WPA2-Enterprise with the additional requirement of using Protected Management Frames (PMF) and server certificate validation on all WPA3 connections. **WPA3-Enterprise also offers an additional secure mode using 192-bit minimum-strength security protocols and cryptographic tools to better protect sens"
"itive data.** The 192-bit security mode offered by WPA3-Enterprise ensures the right combination of cryptographic tools is used and sets a consistent baseline of security within a WPA3 network. WPA3-Enterprise 192-bit mode is only supported by modules having :c:macro:`SOC_WIFI_GCMP_SUPPORT` support. Enable :ref:`CONFIG_ESP_WIFI_SUITE_B_192` flag to support WPA3-Enterprise with 192-bit mode.

{IDF_TARGET_NAME} supports the following EAP methods:
  - EAP-TLS: This is a certificate-based method and"
" only requires SSID and EAP-IDF.
  - PEAP: This is a Protected EAP method. Usernames and passwords are mandatory.
  - EAP-TTLS: This is a credential-based method. Only server authentication is mandatory while user authentication is optional. Username and Password are mandatory. It supports different Phase2 methods, such as:
     - PAP: Password Authentication Protocol.
     - CHAP: Challenge Handshake Authentication Protocol.
     - MSCHAP and MSCHAP-V2.
  - EAP-FAST: This is an authentication m"
"ethod based on Protected Access Credentials (PAC) which also uses identity and password. Currently, :ref:`CONFIG_ESP_WIFI_MBEDTLS_TLS_CLIENT` flag should be disabled to use this feature.

Example :example:`wifi/wifi_enterprise` demonstrates all the supported Wi-Fi Enterprise methods except EAP-FAST. Please refer :example:`wifi/wifi_eap_fast` for the EAP-FAST example. EAP method can be selected from the Example Configuration menu in ``idf.py menuconfig``. Refer to :idf_file:`examples/wifi/wifi_en"
"terprise/README.md` for information on how to generate certificates and run the example.

WPA3-Personal


Introduction
++++++++++++

Wi-Fi Protected Access-3 (WPA3) is a set of enhancements to Wi-Fi access security intended to replace the current WPA2 standard. It includes new features and capabilities that offer significantly better protection against different types of attacks. It improves upon WPA2-Personal in the following ways:

  - WPA3 uses Simultaneous Authentication of Equals (SAE), whi"
"ch is a password-authenticated key agreement method based on Diffie-Hellman key exchange. Unlike WPA2, the technology is resistant to offline-dictionary attacks, where the attacker attempts to determine a shared password based on a captured 4-way handshake without any further network interaction.
  - Disallows outdated protocols such as TKIP, which is susceptible to simple attacks like MIC key recovery attacks.
  - Mandates Protected Management Frames (PMF), which provides protection for unicast"
" and multicast robust management frames which include Disassoc and Deauth frames. This means that the attacker cannot disrupt an established WPA3 session by sending forged Assoc frames to the AP or Deauth/Disassoc frames to the station.
  - Provides forward secrecy, which means the captured data cannot be decrypted even if the password is compromised after data transmission.

{IDF_TARGET_NAME} station also supports following additional Wi-Fi CERTIFIED WPA3™ features:

 - **Transition Disable** :"
" WPA3 defines transition modes for client devices so that they can connect to a network even when some of the APs in that network do not support the strongest security mode. Client device implementations typically configure network profiles in a transition mode by default. However, such a client device could be subject to an active downgrade attack in which the attacker causes the client device to use a lower security mode in order to exploit a vulnerability with that mode. WPA3 has introduced t"
"he Transition Disable feature to mitigate such attacks, by enabling client devices to change from a transition mode to an ""only"" mode when connecting to a network, once that network indicates it fully supports the higher security mode. Enable :cpp:type:`transition_disable` in :cpp:type:`wifi_sta_config_t` to enable this feature for {IDF_TARGET_NAME} station.

 - **SAE PUBLIC-KEY (PK)** : As the password at small public networks is shared with multiple users, it may be relatively easy for an atta"
"cker to find out the password, which is sufficient to launch an evil twin attack. Such attacks are prevented by an extension to WPA3-Personal called SAE-PK. The SAE-PK authentication exchange is very similar to the regular SAE exchange, with the addition of a digital signature sent by the AP to the client device. The client device validates the public key asserted by the AP based on the password fingerprint and verifies the signature using the public key. So even if the attacker knows the passwo"
"rd, it does not know the private key to generate a valid signature, and therefore the client device is protected against an evil twin attack. Enable :ref:`CONFIG_ESP_WIFI_ENABLE_SAE_PK` and :cpp:type:`sae_pk_mode` in :cpp:type:`wifi_sta_config_t` to add support of SAE PK for {IDF_TARGET_NAME} station.

 - **SAE PWE Methods**: {IDF_TARGET_NAME} station as well as SoftAP supports SAE Password Element derivation method `Hunting And Pecking` and `Hash to Element (H2E)`. H2E is computationally effici"
"ent as it uses fewer iterations than Hunt and Peck, and also it mitigates side-channel attacks. These can be configured using the parameter :cpp:type:`sae_pwe_h2e` from :cpp:type:`wifi_sta_config_t` and :cpp:type:`wifi_ap_config_t` for station and SoftAP respectively. Hunt and peck, H2E both can be enabled by using :cpp:enumerator:`WPA3_SAE_PWE_BOTH` configuration.

Please refer to the `Security `_ section of Wi-Fi Alliance's official website for further details.

Setting up WPA3 Personal with {"
"IDF_TARGET_NAME}
+++++++++++++++++++++++++++++++++++++++++++++++

A configuration option :ref:`CONFIG_ESP_WIFI_ENABLE_WPA3_SAE` is provided to enable/disable WPA3 for the station. By default, it is kept enabled. If disabled, {IDF_TARGET_NAME} will not be able to establish a WPA3 connection. Also under the Wi-Fi component, a configuration option :ref:`CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT` is provided to enable/disable WPA3 for SoftAP. Additionally, since PMF is mandated by WPA3 protocol, PMF Option"
"al is set by default for station and SoftAP. PMF Required can be configured using Wi-Fi configuration. For WPA3 SoftAP, PMF Required is mandatory and will be configured and stored in NVS implicitly if not specified by the user.

Refer to `Protected Management Frames (PMF)`_ on how to set this mode.

After configuring all required settings for the WPA3-Personal station, application developers need not worry about the underlying security mode of the AP. WPA3-Personal is now the highest supported p"
"rotocol in terms of security, so it is automatically selected for the connection whenever available. For example, if an AP is configured to be in WPA3 Transition Mode, where it advertises as both WPA2 and WPA3 capable, the station chooses WPA3 for the connection with the above settings.

After configuring all required setting for WPA3-Personal SoftAP, application developers have to set ``WIFI_AUTH_WPA3_PSK`` for `authmode` in :cpp:type:`wifi_ap_config_t` to start AP in WPA3 security. SoftAP can "
"be also configured to use ``WIFI_AUTH_WPA2_WPA3_PSK`` mixed mode.

Note that binary size will be increased by about 6.5 kilobytes after enabling :ref:`CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT`.

Wi-Fi Enhanced Open™


Introduction
++++++++++++

Enhanced Open™ is used for providing security and privacy to users connecting to open (public) wireless networks, particularly in scenarios where user authentication is not desired or distribution of credentials impractical. Each user is provided with unique in"
"dividual encryption keys that protect data exchange between a user device and the Wi-Fi network. Protected Management Frames further protect management traffic between the access point and the user device. Enhanced Open™ is based on the Opportunistic Wireless Encryption (OWE) standard. OWE Transition Mode enables a seamless transition from Open unencrypted WLANs to OWE WLANs without adversely impacting the end-user experience.

.. note::

  {IDF_TARGET_NAME} supports Wi-Fi Enhanced Open™ only in"
" station mode.


Setting up OWE with {IDF_TARGET_NAME}
++++++++++++++++++++++++++++++++++++++

A configuration option :ref:`CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA` and configuration parameter :cpp:type:`owe_enabled` in :cpp:type:`wifi_sta_config_t` is provided to enable OWE support for the station. To use OWE transition mode, along with the configuration provided above, `authmode` from :cpp:type:`wifi_scan_threshold_t` should be set to ``WIFI_AUTH_OPEN``.
"
"Device Firmware Upgrade via USB




Typically, the firmware of the {IDF_TARGET_NAME} is flashed via the chip's serial port. However, flashing via the serial port requires a USB to serial converter chip (e.g., CP210x or FTDI) to be connected to the {IDF_TARGET_NAME} (see :doc:`Establish Serial Connection with {IDF_TARGET_NAME} ` for more details). The {IDF_TARGET_NAME} contains a USB OTG peripheral making it possible to connect the {IDF_TARGET_NAME} to the host directly via USB (thus not requirin"
"g a USB to serial converter chip).

Device Firmware Upgrade (DFU) is a mechanism for upgrading the firmware of the {IDF_TARGET_NAME} directly via the Universal Serial Bus (USB). However, enabling Secure Boot or flash encryption disables the USB-OTG USB stack in the ROM, disallowing updates via the serial emulation or DFU on that port.

- :ref:`get-started-get-prerequisites` of the Getting Started Guide introduces the software requirements of DFU.
- Section :ref:`api_guide_dfu_build` describes ho"
"w to build firmware for DFU with ESP-IDF.
- Section :ref:`api_guide_dfu_flash` deals with flashing the firmware.


USB Connection


The necessary connections for the {IDF_TARGET_NAME}'s internal USB PHY (transceiver) are shown in the following table:

.. list-table::
   :header-rows: 1
   :widths: 25 20
     - USB
     - D+ (green)
     - D- (white)
     - GND (black)
     - +5V (red)

.. warning::

    Some cables are wired up with non-standard colors and some drivers are able to work with swap"
"ped D+ and D- connections. Please try to swap the cables connecting to D+ and D- if your device is not detected.

.. only:: esp32s3

    By default, the :doc:`USB_SERIAL_JTAG ` module is connected to the {IDF_TARGET_NAME}'s internal USB PHY, while the USB OTG peripheral can be used only if an external USB PHY is connected. Since DFU is provided via the USB OTG peripheral, it cannot be used through the internal PHY in this configuration.

    However, users can permanently switch the internal USB"
" PHY to work with USB OTG peripheral instead of USB_SERIAL_JTAG by burning the ``USB_PHY_SEL`` eFuse. See *{IDF_TARGET_NAME} Technical Reference Manual* [`PDF `__] for more details about USB_SERIAL_JTAG and USB OTG.

.. note::

    The {IDF_TARGET_NAME} chip needs to be in bootloader mode before it can be detected as a DFU device and flash. This can be achieved by pulling GPIO0 down (e.g., pressing the BOOT button), pulling RESET down for a moment, and releasing GPIO0.


.. _api_guide_dfu_build:"
"

Building the DFU Image


The command below will create a DFU image named ``dfu.bin`` that is placed in the project's ``build`` directory::

    idf.py dfu

.. note::

    Do not forget to set the target chip by ``idf.py set-target`` before running ``idf.py dfu``. Otherwise, you might create an image for a different chip or receive an error message like ``unknown target 'dfu'``.


.. _api_guide_dfu_flash:

Flashing the DFU Image


The command below will download the DFU image into the {IDF_TARG"
"ET_NAME}::

    idf.py dfu-flash

The command relies on `dfu-util `_. Please see :ref:`get-started-get-prerequisites` for installing ``dfu-util``. ``dfu-util`` needs additional setup for :ref:`api_guide_dfu_flash_win` or setting up an :ref:`api_guide_dfu_flash_udev`. macOS users should be able to use ``dfu-util`` without further setup.

If there are more boards with the same chip connected then ``idf.py dfu-list`` can be used to list the available devices, for example::

    Found Runtime: [303a"
":0002] ver=0723, devnum=4, cfg=1, intf=2, path=""1-10"", alt=0, name=""UNKNOWN"", serial=""0""
    Found Runtime: [303a:0002] ver=0723, devnum=6, cfg=1, intf=2, path=""1-2"", alt=0, name=""UNKNOWN"", serial=""0""

Consequently, the desired device can be selected for flashing by the ``--path`` argument. For example, the devices listed above can be flashed individually by the following commands::

    idf.py dfu-flash --path 1-10
    idf.py dfu-flash --path 1-2

.. note::

    The vendor and product identific"
"ators are set based on the selected chip target by the ``idf.py set-target`` command and they are not selectable during the ``idf.py dfu-flash`` call.

See :ref:`api_guide_dfu_flash_errors` and their solutions.


.. _api_guide_dfu_flash_udev:

Udev Rule (Linux Only)


Udev is a device manager for the Linux kernel. It allows us to run ``dfu-util`` (and ``idf.py dfu-flash``) without ``sudo`` for gaining access to the chip.

Create file ``/etc/udev/rules.d/40-dfuse.rules`` with the following conten"
"t::

    SUBSYSTEMS==""usb"", ATTRS{idVendor}==""303a"", ATTRS{idProduct}==""00??"", GROUP=""plugdev"", MODE=""0666""

.. note::

    Please check the output of the command ``groups``. The user has to be a member of the `GROUP` specified above. You may use some other existing groups for this purpose (e.g., `uucp` on some systems instead of `plugdev`) or create a new group for this purpose.

Restart your computer so the previous setting could take into affect or run ``sudo udevadm trigger`` to force manual"
"ly udev to trigger your new rule.


.. _api_guide_dfu_flash_win:

USB Drivers (Windows Only)


``dfu-util`` uses `libusb` to access the device. You have to register on Windows the device with the `WinUSB` driver.

Please see the `libusb wiki `_ for more details.

The drivers can be installed by the `Zadig tool `_. Please make sure that the device is in download mode before you run the tool and that it detects the {IDF_TARGET_NAME} device before you install the drivers. The Zadig tool might detec"
"t several USB interfaces of {IDF_TARGET_NAME}. Please install the WinUSB driver only for the interface where there is no driver installed (probably it is Interface 2) and do not re-install the driver for the other interface.

.. warning::

    The manual installation of the driver in Device Manager of Windows is not recommended because the flashing might not work properly.


.. _api_guide_dfu_flash_errors:

Common Errors and Known Issues


- ``dfu-util: command not found`` might indicate that th"
"e tool has not been installed or is not available from the terminal. An easy way of checking the tool is running ``dfu-util --version``. Please see :ref:`get-started-get-prerequisites` for installing ``dfu-util``.

- The reason for ``No DFU capable USB device available`` could be that the USB driver was not properly installed on Windows (see :ref:`api_guide_dfu_flash_win`), udev rule was not setup on Linux (see :ref:`api_guide_dfu_flash_udev`) or the device is not in bootloader mode.

- Flashing"
" with ``dfu-util`` on Windows fails on the first attempt with error ``Lost device after RESET?``. Please retry the flashing and it should succeed the next time.


.. only:: SOC_SUPPORTS_SECURE_DL_MODE

    Secure Download Mode
    

    When Secure Download Mode is enabled, DFU is no longer possible. Please see :doc:`Flash Encryption ` guide for more details.
"
"C++ Support




.. highlight:: cpp

ESP-IDF is primarily written in C and provides C APIs. However, ESP-IDF supports development of applications in C++. This document covers various topics relevant to C++ development.

The following C++ features are supported:

- :ref:`cplusplus_exceptions`
- :ref:`cplusplus_multithreading`
- :ref:`cplusplus_rtti`
- :doc:`thread-local-storage` (``thread_local`` keyword)
- All C++ features implemented by GCC, except for some :ref:`cplusplus_limitations`. See `GCC"
" documentation `_ for details on features implemented by GCC.


``esp-idf-cxx`` Component


`esp-idf-cxx `_ component provides higher-level C++ APIs for some of the ESP-IDF features. This component is available from the `ESP-IDF Component Registry `_.


C++ Language Standard


By default, ESP-IDF compiles C++ code with C++23 language standard with GNU extensions (``-std=gnu++23``).

To compile the source code of a certain component using a different language standard, set the desired compiler fl"
"ag in the component's ``CMakeLists.txt`` file:

.. code-block:: cmake

    idf_component_register( ... )
    target_compile_options(${COMPONENT_LIB} PRIVATE -std=gnu++11)

Use ``PUBLIC`` instead of ``PRIVATE`` if the public header files of the component also need to be compiled with the same language standard.


.. _cplusplus_multithreading:

Multithreading


C++ threads, mutexes, and condition variables are supported. C++ threads are built on top of pthreads, which in turn wrap FreeRTOS tasks.
"
"
See :example:`cxx/pthread` for an example of creating threads in C++.

.. note::

    The destructor of `std::jthread `_ can only safely be called from a task that has been created by :ref:`posix_thread_api` or by the `C++ threading library API `_.


.. _cplusplus_exceptions:

Exception Handling


Support for C++ Exceptions in ESP-IDF is disabled by default, but can be enabled using the :ref:`CONFIG_COMPILER_CXX_EXCEPTIONS` option.

If an exception is thrown, but there is no ``catch`` block, th"
"e program is terminated by the ``abort`` function, and the backtrace is printed. See :doc:`fatal-errors` for more information about backtraces.

C++ Exceptions should **only** be used for exceptional cases, i.e., something happening unexpectedly and occurs rarely, such as events that happen less frequently than 1/100 times. **Do not** use them for control flow (see also the section about resource usage below). For more information on how to use C++ Exceptions, see the `ISO C++ FAQ `_ and `CPP Co"
"re Guidelines `_.

See :example:`cxx/exceptions` for an example of C++ exception handling.


C++ Exception Handling and Resource Usage


Enabling exception handling normally increases application binary size by a few KB.

Additionally, it may be necessary to reserve some amount of RAM for the exception emergency memory pool. Memory from this pool is used if it is not possible to allocate an exception object from the heap.

The amount of memory in the emergency pool can be set using the :ref:`CON"
"FIG_COMPILER_CXX_EXCEPTIONS_EMG_POOL_SIZE` variable.

Some additional stack memory (around 200 bytes) is also used if and only if a C++ Exception is actually thrown, because it requires calling some functions from the top of the stack to initiate exception handling.

The run time of code using C++ exceptions depends on what actually happens at run time.

- If no exception is thrown, the code tends to be somewhat faster since there is no need to check error codes.
- If an exception is thrown, the"
" run time of the code that handles exceptions is orders of magnitude slower than code returning an error code.

If an exception is thrown, the run time of the code that unwinds the stack is orders of magnitude slower than code returning an error code. The significance of the increased run time will depend on the application's requirements and implementation of error handling (e.g., requiring user input or messaging to a cloud). As a result, exception-throwing code should never be used in real-ti"
"me critical code paths.


.. _cplusplus_rtti:

Runtime Type Information (RTTI)


Support for RTTI in ESP-IDF is disabled by default, but can be enabled using :ref:`CONFIG_COMPILER_CXX_RTTI` option.

Enabling this option compiles all C++ files with RTTI support enabled, which allows using ``dynamic_cast`` conversion and ``typeid`` operator. Enabling this option typically increases the binary size by tens of kB.

See :example:`cxx/rtti` for an example of using RTTI in ESP-IDF.


Developing in C++
"
"

The following sections provide tips on developing ESP-IDF applications in C++.


Combining C and C++ Code


When an application is developed using both C and C++, it is important to understand the concept of `language linkage `_.

In order for a C++ function to be callable from C code, it has to be both **declared** and **defined** with C linkage (``extern ""C""``):

.. code-block:: cpp

    // declaration in the .h file:
    #ifdef __cplusplus
    extern ""C"" {
    #endif

    void my_cpp_func(v"
"oid);

    #ifdef __cplusplus
    }
    #endif

    // definition in a .cpp file:
    extern ""C"" void my_cpp_func(void) {
        // ...
    }


In order for a C function to be callable from C++, it has to be **declared** with C linkage:

.. code-block:: c

    // declaration in .h file:
    #ifdef __cplusplus
    extern ""C"" {
    #endif

    void my_c_func(void);

    #ifdef __cplusplus
    }
    #endif

    // definition in a .c file:
    void my_c_func(void) {
        // ...
    }


Defining "
"``app_main`` in C++


ESP-IDF expects the application entry point, ``app_main``, to be defined with C linkage. When ``app_main`` is defined in a .cpp source file, it has to be designated as ``extern ""C""``:

.. code-block:: cpp

    extern ""C"" void app_main()
    {
    }


.. _cplusplus_designated_initializers:

Designated Initializers


Many of the ESP-IDF components use :ref:`api_reference_config_structures` as arguments to the initialization functions. ESP-IDF examples written in C routinely u"
"se `designated initializers `_ to fill these structures in a readable and a maintainable way.

C and C++ languages have different rules with regards to the designated initializers. For example, C++23 (currently the default in ESP-IDF) does not support out-of-order designated initialization, nested designated initialization, mixing of designated initializers and regular initializers, and designated initialization of arrays. Therefore, when porting ESP-IDF C examples to C++, some changes to the st"
"ructure initializers may be necessary. See the `C++ aggregate initialization reference `_ for more details.


``iostream``


``iostream`` functionality is supported in ESP-IDF, with a couple of caveats:


.. _cplusplus_limitations:

Limitations


- Linker script generator does not support function level placements for functions with C++ linkage.
- Various section attributes (such as ``IRAM_ATTR``) are ignored when used with template functions.
- Vtables are placed into Flash and are not accessib"
"le when the flash cache is disabled. Therefore, virtual function calls should be avoided in :ref:`iram-safe-interrupt-handlers`. Placement of Vtables cannot be adjusted using the linker script generator, yet.
- C++ filesystem (``std::filesystem``) features are not supported.


What to Avoid


Do not use ``setjmp``/``longjmp`` in C++. ``longjmp`` blindly jumps up the stack without calling any destructors, easily introducing undefined behavior and memory leaks. Use C++ exceptions instead, they gua"
"rantee correctly calling destructors. If you cannot use C++ exceptions, use alternatives (except ``setjmp``/``longjmp`` themselves) such as simple return codes.
"
"Current Consumption Measurement of Modules


{IDF_TARGET_SOC_BOOT_PIN:default=""Not updated"", esp32=""IO0"", esp32s2=""IO0"", esp32s3=""IO0"", esp32c3=""IO9"", esp32c2=""IO9"", ""esp32c6""=""IO9"", ""esp32h2""=""IO9""}

You may want to know the current consumption of a `module `__ in deep-sleep mode, :doc:`other power-saving modes `, and active mode to develop some applications sensitive to power consumption. This section introduces how to measure the current consumption of a module running such an application.


"
"Notes to Measurement


Can We Use a Development Board?


.. only:: esp32c6

    For {IDF_TARGET_NAME}, you can use development boards such as `ESP32-C6-DevKitC-1 `__ and `ESP32-C6-DevKitM-1 `__ to measure current consumption of corresponding modules as these development boards are equipped with headers, which can be used to measure current drawn by modules.

.. only:: esp32h2

    For {IDF_TARGET_NAME}, you can use development boards such as `ESP32-H2-DevKitM-1 `__ to measure current consumption"
" of corresponding modules as these development boards are equipped with headers, which can be used to measure current drawn by modules.

.. only:: esp32c6 or esp32h2

    With such development boards, you can measure current consumption of modules in deep-sleep mode by flashing chips with the :example:`deep_sleep ` example. However, you can also measure current of bare modules equipped with {IDF_TARGET_NAME} chip using the following method.

.. only:: esp32 or esp32s2 or esp32s3 or esp32c2 or es"
"p32c3

    For {IDF_TARGET_NAME}, using a development board directly to measure current consumption of the corresponding module is not recommended, as some circuits still consume power on the board even when you flash the chip with the :example:`deep_sleep ` example. Therefore, you need to cut off the power supply circuit to the module to measure the module's current. This method is inconvenient and increases measurement costs.


How to Choose an Appropriate Ammeter?


In the :example:`deep_slee"
"p ` example, the module will be woken up every 20 seconds. In deep-sleep mode, the current in the module is just several microamps (μA), while in active mode, the current is in the order of milliamps (mA). The high dynamic current range makes accurate measurement difficult. Ordinary ammeters cannot dynamically switch the measurement range fast enough.

Additionally, ordinary ammeters have a relatively high internal resistance, resulting in a significant voltage drop. This may cause the module to"
" enter an unstable state, as it is powered by a voltage smaller than the minimum required voltage supply.

Therefore, an ammeter suitable for measuring current in deep-sleep mode should have low internal resistance and, ideally, switch current ranges dynamically. We recommend two options: the `Joulescope ammeter `__ and the `Power Profiler Kit II from Nordic `__.


Joulescope Ammeter
""""""""""""""""""""""""""""""""""""

The Joulescope ammeter combines high-speed sampling and rapid dynamic current range switching"
" to provide accurate and seamless current and energy measurements, even for devices with rapidly varying current consumption. Joulescope accurately measures electrical current over nine orders of magnitude from amps down to nanoamps. This wide range allows for accurate and precise current measurements for devices. Additionally, Joulescope has a total voltage drop of 25 mV at 1 A, which keeps the module running normally. These two features make Joulescope a perfect option for measuring the module"
" switching between deep-sleep mode and wake-up mode.

Joulescope has no display screen. You need to connect it to a PC to visualize the current waveforms of the measured module. For specific instructions, please follow the documentation provided by the manufacturer.


Nordic Power Profiler Kit II
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The Nordic Power Profiler Kit II has an advanced analog measurement unit with a high dynamic measurement range. This allows for accurate power consumption measurements for "
"the entire range typically seen in low-power embedded applications, all the way from single μAs to 1 A. The resolution varies between 100 nA and 1 mA, depending on the measurement range, and is high enough to detect small spikes often seen in low-power optimized systems.


Hardware Connection


To measure the power consumption of a bare module, you need an `ESP-Prog `__ to flash the :example:`deep_sleep ` example to the module and power the module during measurement, a suitable ammeter (here we "
"use the Joulescope ammeter), a computer, and of course a bare module with necessary jumper wires. For the connection, please refer to the following figure.

.. figure:: /../_static/hardware_connection_power_measure.png
    :align: center
    :scale: 80%
    :alt: Hardware Connection (click to enlarge)

    Hardware Connection (click to enlarge)

Please connect the pins of **UART TX**, **UART RX**, **SPI Boot**, **Enable**, and **Ground** on the measured module with corresponding pins on ESP-Prog"
", and connect the **VPROG** pin on ESP-Prog with the **IN+** port on the Joulescope ammeter and connect its **OUT+** port with the **Power supply (3V3)** pin on the measured module. For the specific names of these pins in different modules, please refer to the list below.

.. list-table:: Pin Names of Modules Based on {IDF_TARGET_NAME} Chip
    :header-rows: 1
    :widths: 50 50
    :align: center
      - Pin Name
      - TXD0
      - RXD0
      - {IDF_TARGET_SOC_BOOT_PIN}
      - EN
      - 3V3"
"
      - GND

.. only:: esp32

    For modules based on the ESP32 chip, the names of UART TX and UART RX pins may also be U0TXD and U0RXD.

.. only:: esp32c2

    For modules based on the ESP32-C2 chip, the names of UART TX and UART RX pins may also be TXD and RXD.

.. only:: esp32c3

    For modules based on the ESP32-C3 chip, the names of UART TX and UART RX pins may also be TXD and RXD, TX and RX, or TX0 and RX0.

For details of the pin names, please refer to the `datasheet of specific module"
" `__.


Measurement Steps


ESP32-S3-WROOM-1 is used as an example in the measurement, and other modules can be measured similarly. For the specific current consumption of chips in different modes, please refer to the Current Consumption subsection in the corresponding `chip datasheet `__.

You can refer to the following steps to measure the current in deep-sleep mode.

- Connect the aforementioned devices according to the hardware connection.

- Flash the :example:`deep_sleep ` example to the m"
"odule. For details, please refer to :doc:`Start a Project on Linux and macOS ` for a computer with Linux or macOS system or :doc:`Start a Project on Windows ` for a computer with Windows system.

.. only:: esp32 or esp32s2 or esp32s3

    Please note that when you configure the example by running ``idf.py menuconfig``, you need to disable ``Enable touch wake up`` in the ``Example Configuration`` to reduce the bottom current.

.. only:: esp32

    For modules with an external resistor on GPIO12 ("
"such as ESP32-WROVER-E/IE), you should call :cpp:func:`rtc_gpio_isolate` before going into deep sleep. This is to isolate the GPIO12 pin from external circuits to further minimize current consumption. Please note, for other modules, you do not have to call this function, otherwise, you may get abnormal results.

- By default, the module will be woken up every 20 seconds (you can change the timing by modifying the code of this example). To check if the example runs as expected, you can monitor th"
"e module operation by running ``idf.py -p PORT monitor`` (please replace PORT with your serial port name).

- Open the Joulescope software to see the current waveform as shown in the image below.

From the waveforms, you can obtain that the current of the module in deep-sleep mode is 8.14 μA. In addition, you can also see the current of the module in active mode, which is about 23.88 mA. The waveforms also show that the average power consumption during deep-sleep mode is 26.85 μW, and the averag"
"e power consumption during active mode is 78.32 mW.

.. figure:: /../_static/current_measure_waveform.png
    :align: center
    :scale: 100%
    :alt: Current Waveform of ESP32-S3-WROOM-1 (click to enlarge)

    Current Waveform of ESP32-S3-WROOM-1 (click to enlarge)

The figure below shows the total power consumption of one cycle is 6.37 mW.

.. figure:: /../_static/power_measure_waveform.png
    :align: center
    :scale: 100%
    :alt: Power Consumption of ESP32-S3-WROOM-1 (click to enlarge)"
"

    Power Consumption of ESP32-S3-WROOM-1 (click to enlarge)

By referring to these power consumption in different modes, you can estimate the power consumption of your applications and choose the appropriate power source.
"
"ESP-WIFI-MESH




This guide provides information regarding the ESP-WIFI-MESH protocol. Please see the :doc:`ESP-WIFI-MESH API Reference ` for more information about API usage.

..  Overview 

Overview


ESP-WIFI-MESH is a networking protocol built atop the Wi-Fi protocol. ESP-WIFI-MESH allows numerous devices (henceforth referred to as nodes) spread over a large physical area (both indoors and outdoors) to be interconnected under a single WLAN (Wireless Local-Area Network). ESP-WIFI-MESH is sel"
"f-organizing and self-healing meaning the network can be built and maintained autonomously.

The ESP-WIFI-MESH guide is split into the following sections:


..  Introduction 

.. _mesh-introduction:

Introduction


.. figure:: ../../_static/mesh-traditional-network-architecture.png
    :align: center
    :alt: Diagram of Traditional Network Architecture
    :figclass: align-center

    Traditional Wi-Fi Network Architecture

A traditional infrastructure Wi-Fi network is a point-to-multipoint net"
"work where a single central node known as the access point (AP) is directly connected to all other nodes known as stations. The AP is responsible for arbitrating and forwarding transmissions between the stations. Some APs also relay transmissions to/from an external IP network via a router. Traditional infrastructure Wi-Fi networks suffer the disadvantage of limited coverage area due to the requirement that every station must be in range to directly connect with the AP. Furthermore, traditional "
"Wi-Fi networks are susceptible to overloading as the maximum number of stations permitted in the network is limited by the capacity of the AP.

.. figure:: ../../_static/mesh-esp-wifi-mesh-network-architecture.png
    :align: center
    :alt: Diagram of ESP-WIFI-MESH Network Architecture
    :figclass: align-center

    ESP-WIFI-MESH Network Architecture

ESP-WIFI-MESH differs from traditional infrastructure Wi-Fi networks in that nodes are not required to connect to a central node. Instead, nod"
"es are permitted to connect with neighboring nodes. Nodes are mutually responsible for relaying each others transmissions. This allows an ESP-WIFI-MESH network to have much greater coverage area as nodes can still achieve interconnectivity without needing to be in range of the central node. Likewise, ESP-WIFI-MESH is also less susceptible to overloading as the number of nodes permitted on the network is no longer limited by a single central node.


..  ESP-WIFI-MESH Concepts 

.. _mesh-concepts:"
"

ESP-WIFI-MESH Concepts


Terminology


.. list-table::
   :header-rows: 1
   :widths: 25 75
     - Description
     - Any device that **is** or **can be** part of an ESP-WIFI-MESH network
     - The top node in the network
     - A node X is a child node when it is connected to another node Y where the connection makes node X more distant from the root node than node Y (in terms of number of connections).
     - The converse notion of a child node
     - Any node reachable by repeated proceedi"
"ng from parent to child
     - Nodes that share the same parent node
     - A traditional Wi-Fi association between an AP and a station. A node in ESP-WIFI-MESH will use its station interface to associate with the softAP interface of another node, thus forming a connection. The connection process includes the authentication and association processes in Wi-Fi.
     - The connection from a node to its parent node
     - The connection from a node to one of its child nodes
     - The portion of the"
" path between source and destination nodes that corresponds to a single wireless connection. A data packet that traverses a single connection is known as **single-hop** whereas traversing multiple connections is known as **multi-hop**.
     - A subnetwork is subdivision of an ESP-WIFI-MESH network which consists of a node and all of its descendant nodes. Therefore the subnetwork of the root node consists of all nodes in an ESP-WIFI-MESH network.
     - Media Access Control Address used to unique"
"ly identify each node or router within an ESP-WIFI-MESH network.
     - Distribution System (External IP Network)

Tree Topology


ESP-WIFI-MESH is built atop the infrastructure Wi-Fi protocol and can be thought of as a networking protocol that combines many individual Wi-Fi networks into a single WLAN. In Wi-Fi, stations are limited to a single connection with an AP (upstream connection) at any time, whilst an AP can be simultaneously connected to multiple stations (downstream connections). How"
"ever ESP-WIFI-MESH allows nodes to simultaneously act as a station and an AP. Therefore a node in ESP-WIFI-MESH can have **multiple downstream connections using its softAP interface**, whilst simultaneously having **a single upstream connection using its station interface**. This naturally results in a tree network topology with a parent-child hierarchy consisting of multiple layers.

.. figure:: ../../_static/mesh-tree-topology.png
    :align: center
    :alt: Diagram of ESP-WIFI-MESH Tree Topo"
"logy
    :figclass: align-center

    ESP-WIFI-MESH Tree Topology

ESP-WIFI-MESH is a multiple hop (multi-hop) network meaning nodes can transmit packets to other nodes in the network through one or more wireless hops. Therefore, nodes in ESP-WIFI-MESH not only transmit their own packets, but simultaneously serve as relays for other nodes. Provided that a path exists between any two nodes on the physical layer (via one or more wireless hops), any pair of nodes within an ESP-WIFI-MESH network can"
" communicate.

.. note::

    The size (total number of nodes) in an ESP-WIFI-MESH network is dependent on the maximum number of layers permitted in the network, and the maximum number of downstream connections each node can have. Both of these variables can be configured to limit the size of the network.

Node Types


.. figure:: ../../_static/mesh-node-types.png
    :align: center
    :alt: Diagram of ESP-WIFI-MESH Node Types
    :figclass: align-center

    ESP-WIFI-MESH Node Types

**Root No"
"de:** The root node is the top node in the network and serves as the only interface between the ESP-WIFI-MESH network and an external IP network. The root node is connected to a conventional Wi-Fi router and relays packets to/from the external IP network to nodes within the ESP-WIFI-MESH network. **There can only be one root node within an ESP-WIFI-MESH network** and the root node's upstream connection may only be with the router. Referring to the diagram above, node A is the root node of the ne"
"twork.

**Leaf Nodes:** A leaf node is a node that is not permitted to have any child nodes (no downstream connections). Therefore a leaf node can only transmit or receive its own packets, but cannot forward the packets of other nodes. If a node is situated on the network's maximum permitted layer, it will be assigned as a leaf node. This prevents the node from forming any downstream connections thus ensuring the network does not add an extra layer. Some nodes without a softAP interface (station"
" only) will also be assigned as leaf nodes due to the requirement of a softAP interface for any downstream connections. Referring to the diagram above, nodes L/M/N are situated on the networks maximum permitted layer hence have been assigned as leaf nodes .

**Intermediate Parent Nodes:** Connected nodes that are neither the root node or a leaf node are intermediate parent nodes. An intermediate parent node must have a single upstream connection (a single parent node), but can have zero to multi"
"ple downstream connections (zero to multiple child nodes). Therefore an intermediate parent node can transmit and receive packets, but also forward packets sent from its upstream and downstream connections. Referring to the diagram above, nodes B to J are intermediate parent nodes. **Intermediate parent nodes without downstream connections such as nodes E/F/G/I/J are not equivalent to leaf nodes** as they are still permitted to form downstream connections in the future.

**Idle Nodes:** Nodes th"
"at have yet to join the network are assigned as idle nodes. Idle nodes will attempt to form an upstream connection with an intermediate parent node or attempt to become the root node under the correct circumstances (see `Automatic Root Node Selection`_). Referring to the diagram above, nodes K and O are idle nodes.

Beacon Frames & RSSI Thresholding


Every node in ESP-WIFI-MESH that is able to form downstream connections (i.e., has a softAP interface) will periodically transmit Wi-Fi beacon fra"
"mes. A node uses beacon frames to allow other nodes to detect its presence and know of its status. Idle nodes will listen for beacon frames to generate a list of potential parent nodes, one of which the idle node will form an upstream connection with. ESP-WIFI-MESH uses the Vendor Information Element to store metadata such as:

- Node Type (Root, Intermediate Parent, Leaf, Idle)
- Current layer of Node
- Maximum number of layers permitted in the network
- Current number of child nodes
- Maximum "
"number of downstream connections to accept

The signal strength of a potential upstream connection is represented by RSSI (Received Signal Strength Indication) of the beacon frames of the potential parent node. To prevent nodes from forming a weak upstream connection, ESP-WIFI-MESH implements an RSSI threshold mechanism for beacon frames. If a node detects a beacon frame with an RSSI below a preconfigured threshold, the transmitting node will be disregarded when forming an upstream connection.

"
".. figure:: ../../_static/mesh-beacon-frame-rssi.png
    :align: center
    :alt: Diagram of the Effects of RSSI Thresholding
    :figclass: align-center

    Effects of RSSI Thresholding

**Panel A** of the illustration above demonstrates how the RSSI threshold affects the number of parent node candidates an idle node has.

**Panel B** of the illustration above demonstrates how an RF shielding object can lower the RSSI of a potential parent node. Due to the RF shielding object, the area in whic"
"h the RSSI of node X is above the threshold is significantly reduced. This causes the idle node to disregard node X even though node X is physically adjacent. The idle node will instead form an upstream connection with the physically distant node Y due to a stronger RSSI.

.. note::

    Nodes technically still receive all beacon frames on the MAC layer. The RSSI threshold is an ESP-WIFI-MESH feature that simply filters out all received beacon frames that are below the preconfigured threshold.

"
"Preferred Parent Node


When an idle node has multiple parent nodes candidates (potential parent nodes), the idle node will form an upstream connection with the **preferred parent node**. The preferred parent node is determined based on the following criteria:

- Which layer the parent node candidate is situated on
- The number of downstream connections (child nodes) the parent node candidate currently has

The selection of the preferred parent node will always prioritize the parent node candida"
"te on the shallowest layer of the network (including the root node). This helps minimize the total number of layers in an ESP-WIFI-MESH network when upstream connections are formed. For example, given a second layer node and a third layer node, the second layer node will always be preferred.

If there are multiple parent node candidates within the same layer, the parent node candidate with the least child nodes will be preferred. This criteria has the effect of balancing the number of downstream"
" connections amongst nodes of the same layer.

.. figure:: ../../_static/mesh-preferred-parent-node.png
    :align: center
    :alt: Diagram of Preferred Parent Node Selection
    :figclass: align-center

    Preferred Parent Node Selection

**Panel A** of the illustration above demonstrates an example of how the idle node G selects a preferred parent node given the five parent node candidates B/C/D/E/F. Nodes on the shallowest layer are preferred, hence nodes B/C are prioritized since they are "
"second layer nodes whereas nodes D/E/F are on the third layer. Node C is selected as the preferred parent node due it having fewer downstream connections (fewer child nodes) compared to node B.

**Panel B** of the illustration above demonstrates the case where the root node is within range of the idle node G. In other words, the root node's beacon frames are above the RSSI threshold when received by node G. The root node is always the shallowest node in an ESP-WIFI-MESH network hence is always t"
"he preferred parent node given multiple parent node candidates.

.. note::

    Users may also define their own algorithm for selecting a preferred parent node, or force a node to only connect with a specific parent node (see the :example:`Mesh Manual Networking Example `).

Routing Tables


Each node within an ESP-WIFI-MESH network will maintain its individual routing table used to correctly route ESP-WIFI-MESH packets (see `ESP-WIFI-MESH Packet`_) to the correct destination node. The routing t"
"able of a particular node will **consist of the MAC addresses of all nodes within the particular node's subnetwork** (including the MAC address of the particular node itself). Each routing table is internally partitioned into multiple subtables with each subtable corresponding to the subnetwork of each child node.

.. figure:: ../../_static/mesh-routing-tables-example.png
    :align: center
    :alt: Diagram of ESP-WIFI-MESH Routing Tables Example
    :figclass: align-center

    ESP-WIFI-MESH R"
"outing Tables Example

Using the diagram above as an example, the routing table of node B would consist of the MAC addresses of nodes B to I (i.e., equivalent to the subnetwork of node B). Node B's routing table is internally partitioned into two subtables containing of nodes C to F and nodes G to I (i.e., equivalent to the subnetworks of nodes C and G respectively).

**ESP-WIFI-MESH utilizes routing tables to determine whether an ESP-WIFI-MESH packet should be forwarded upstream or downstream b"
"ased on the following rules.**

**1.** If the packet's destination MAC address is within the current node's routing table and is not the current node, select the subtable that contains the destination MAC address and forward the data packet downstream to the child node corresponding to the subtable.

**2.** If the destination MAC address is not within the current node's routing table, forward the data packet upstream to the current node's parent node. Doing so repeatedly will result in the packe"
"t arriving at the root node where the routing table should contain all nodes within the network.

.. note::

    Users can call :cpp:func:`esp_mesh_get_routing_table` to obtain a node's routing table, or :cpp:func:`esp_mesh_get_routing_table_size` to obtain the size of a node's routing table.  :cpp:func:`esp_mesh_get_subnet_nodes_list` can be used to obtain the corresponding subtable of a specific child node. Likewise :cpp:func:`esp_mesh_get_subnet_nodes_num` can be used to obtain the size of th"
"e subtable.


..  Building a Mesh Network 

.. _mesh-building-a-network:

Building a Network


General Process


.. warning::

    Before the ESP-WIFI-MESH network building process can begin, certain parts of the configuration must be uniform across each node in the network (see :cpp:type:`mesh_cfg_t`). Each node must be configured with **the same Mesh Network ID, router configuration, and softAP configuration**.

An ESP-WIFI-MESH network building process involves selecting a root node, then for"
"ming downstream connections layer by layer until all nodes have joined the network. The exact layout of the network can be dependent on factors such as root node selection, parent node selection, and asynchronous power-on reset. However, the ESP-WIFI-MESH network building process can be generalized into the following steps:

.. figure:: ../../_static/mesh-network-building.png
    :align: center
    :alt: Diagram of ESP-WIFI-MESH Network Building Process
    :figclass: align-center

    ESP-WIFI-"
"MESH Network Building Process
""""""""""""""""""""""""""""""""""""""""""""
The root node can be designated during configuration (see section on `User Designated Root Node`_), or dynamically elected based on the signal strength between each node and the router (see `Automatic Root Node Selection`_). Once selected, the root node will connect with the router and begin allowing downstream connections to form. Referring to the figure above, node A is selected to be the root node hence node A forms an upstream connection w"
"ith the router.
""""""""""""""""""""""""""""""""""""""""""""""""""
Once the root node has connected to the router, idle nodes in range of the root node will begin connecting with the root node thereby forming the second layer of the network. Once connected, the second layer nodes become intermediate parent nodes (assuming maximum permitted layers > 2) hence the next layer to form. Referring to the figure above, nodes B to D are in range of the root node. Therefore nodes B to D form upstream connections with the root nod"
"e and become intermediate parent nodes.
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
The remaining idle nodes will connect with intermediate parent nodes within range thereby forming a new layer in the network. Once connected, the idles nodes become intermediate parent node or leaf nodes depending on the networks maximum permitted layers. This step is repeated until there are no more idle nodes within the network or until the maximum permitted layer of the network has been reached. Referring to the figure a"
"bove, nodes E/F/G connect with nodes B/C/D respectively and become intermediate parent nodes themselves.
""""""""""""""""""""""""""""""""""""""""""""
To prevent the network from exceeding the maximum permitted number of layers, nodes on the maximum layer will automatically become leaf nodes once connected. This prevents any other idle node from connecting with the leaf node thereby prevent a new layer form forming. However if an idle node has no other potential parent node, it will remain idle indefinitely. Referring"
" to the figure above, the network's number of maximum permitted layers is set to four. Therefore when node H connects, it becomes a leaf node to prevent any downstream connections from forming.

Automatic Root Node Selection


The automatic selection of a root node involves an election process amongst all idle nodes based on their signal strengths with the router. Each idle node will transmit their MAC addresses and router RSSI values via Wi-Fi beacon frames. **The MAC address is used to uniquel"
"y identify each node in the network** whilst the **router RSSI** is used to indicate a node's signal strength with reference to the router.

Each node will then simultaneously scan for the beacon frames from other idle nodes. If a node detects a beacon frame with a stronger router RSSI, the node will begin transmitting the contents of that beacon frame (i.e., voting for the node with the stronger router RSSI). The process of transmission and scanning will repeat for a preconfigured minimum numbe"
"r of iterations (10 iterations by default) and result in the beacon frame with the strongest router RSSI being propagated throughout the network.

After all iterations, each node will individually check for its **vote percentage** (``number of votes/number of nodes participating in election``) to determine if it should become the root node. **If a node has a vote percentage larger than a preconfigured threshold (90% by default), the node will become a root node**.

The following diagram demonstr"
"ates how an ESP-WIFI-MESH network is built when the root node is automatically selected.

.. figure:: ../../_static/mesh-root-node-election-example.png
    :align: center
    :alt: Diagram of Root Node Election Process Example
    :figclass: align-center

    Root Node Election Example

**1.** On power-on reset, each node begins transmitting beacon frames consisting of their own MAC addresses and their router RSSIs.

**2.** Over multiple iterations of transmission and scanning, the beacon frame "
"with the strongest router RSSI is propagated throughout the network. Node C has the strongest router RSSI (-10 dB) hence its beacon frame is propagated throughout the network. All nodes participating in the election vote for node C thus giving node C a vote percentage of 100%. Therefore node C becomes a root node and connects with the router.

**3.** Once Node C has connected with the router, nodes A/B/D/E connectwith node C as it is the preferred parent node (i.e., the shallowest node). Nodes A"
"/B/D/E form the second layer of the network.

**4.** Node F and G connect with nodes D and E respectively and the network building process is complete.

.. note::

    The minimum number of iterations for the election process can be configured using :cpp:func:`esp_mesh_set_attempts`. Users should adjust the number of iterations based on the number of nodes within the network (i.e., the larger the network the larger number of scan iterations required).

.. warning::

    **Vote percentage thresho"
"ld** can also be configured using :cpp:func:`esp_mesh_set_vote_percentage`. Setting a low vote percentage threshold **can result in two or more nodes becoming root nodes** within the same ESP-WIFI-MESH network leading to the building of multiple networks. If such is the case, ESP-WIFI-MESH has internal mechanisms to autonomously resolve the **root node conflict**. The networks of the multiple root nodes will be combined into a single network with a single root node. However, root node conflicts "
"where two or more root nodes have the same router SSID but different router BSSID are not handled.

User Designated Root Node


The root node can also be designated by user which will entail the designated root node to directly connect with the router and forgo the election process. When a root node is designated, all other nodes within the network must also forgo the election process to prevent the occurrence of a root node conflict. The following diagram demonstrates how an ESP-WIFI-MESH netwo"
"rk is built when the root node is designated by the user.

.. figure:: ../../_static/mesh-root-node-designated-example.png
    :align: center
    :alt: Diagram of Root Node Designation Process Example
    :figclass: align-center

    Root Node Designation Example (Root Node = A, Max Layers = 4)

**1.** Node A is designated the root node by the user therefore directly connects with the router. All other nodes forgo the election process.

**2.** Nodes C/D connect with node A as their preferred par"
"ent node. Both nodes form the second layer of the network.

**3.** Likewise, nodes B/E connect with node C, and node F connects with node D. Nodes B/E/F form the third layer of the network.

**4.** Node G connects with node E, forming the fourth layer of the network. However the maximum permitted number of layers in this network is configured as four, therefore node G becomes a leaf node to prevent any new layers from forming.

.. note::

    When designating a root node, the root node should ca"
"ll :cpp:func:`esp_mesh_set_parent` in order to directly connect with the router. Likewise, all other nodes should call :cpp:func:`esp_mesh_fix_root` to forgo the election process.

Parent Node Selection


By default, ESP-WIFI-MESH is self organizing meaning that each node will autonomously select which potential parent node to form an upstream connection with. The autonomously selected parent node is known as the preferred parent node. The criteria used for selecting the preferred parent node is"
" designed to reduce the number of layers in the ESP-WIFI-MESH network and to balance the number of downstream connections between potential parent nodes (see section on `Preferred Parent Node`_).

However ESP-WIFI-MESH also allows users to disable self-organizing behavior which will allow users to define their own criteria for parent node selection, or to configure nodes to have designated parent nodes (see the :example:`Mesh Manual Networking Example `).

Asynchronous Power-on Reset


ESP-WIFI-"
"MESH network building can be affected by the order in which nodes power-on. If certain nodes within the network power-on asynchronously (i.e., separated by several minutes), **the final structure of the network could differ from the ideal case where all nodes are powered on synchronously**. Nodes that are delayed in powering on will adhere to the following rules:

**Rule 1:** If a root node already exists in the network, the delayed node will not attempt to elect a new root node, even if it has "
"a stronger RSSI with the router. The delayed node will instead join the network like any other idle node by connecting with a preferred parent node. If the delayed node is the designated root node, all other nodes in the network will remain idle until the delayed node powers-on.

**Rule 2:** If a delayed node forms an upstream connection and becomes an intermediate parent node, it may also become the new preferred parent of other nodes (i.e., being a shallower node). This will cause the other no"
"des to switch their upstream connections to connect with the delayed node (see `Parent Node Switching`_).

**Rule 3:** If an idle node has a designated parent node which is delayed in powering-on, the idle node will not attempt to form any upstream connections in the absence of its designated parent node. The idle node will remain idle indefinitely until its designated parent node powers-on.

The following example demonstrates the effects of asynchronous power-on with regards to network building"
".

.. figure:: ../../_static/mesh-asynchronous-power-on-example.png
    :align: center
    :alt: Diagram of Asynchronous Power On Example
    :figclass: align-center

    Network Building with Asynchronous Power On Example

**1.** Nodes A/C/D/F/G/H are powered-on synchronously and begin the root node election process by broadcasting their MAC addresses and router RSSIs. Node A is elected as the root node as it has the strongest RSSI.

**2.** Once node A becomes the root node, the remaining nodes"
" begin forming upstream connections layer by layer with their preferred parent nodes. The result is a network with five layers.

**3.** Node B/E are delayed in powering-on but neither attempt to become the root node even though they have stronger router RSSIs (-20 dB and -10 dB) compared to node A. Instead both delayed nodes form upstream connections with their preferred parent nodes A and C respectively. Both nodes B/E become intermediate parent nodes after connecting.

**4.** Nodes D/G switch "
"their upstream connections as node B is the new preferred parent node due to it being on a shallower layer (second layer node). Due to the switch, the resultant network has three layers instead of the original five layers.

**Synchronous Power-On:** Had all nodes powered-on synchronously, node E would have become the root node as it has the strongest router RSSI (-10 dB). This would result in a significantly different network layout compared to the network formed under the conditions of asynchro"
"nous power-on. **However the synchronous power-on network layout can still be reached if the user manually switches the root node** (see :cpp:func:`esp_mesh_waive_root`).

.. note::

    Differences in parent node selection caused by asynchronous power-on are  autonomously corrected for to some extent in ESP-WIFI-MESH (see `Parent Node Switching`_)

Loop-back Avoidance, Detection, and Handling


A loop-back is the situation where a particular node forms an upstream connection with one of its des"
"cendant nodes (a node within the particular node's subnetwork). This results in a circular connection path thereby breaking the tree topology. ESP-WIFI-MESH prevents loop-back during parent selection by excluding nodes already present in the selecting node's routing table (see `Routing Tables`_) thus prevents a particular node from attempting to connect to any node within its subnetwork.

In the event that a loop-back occurs, ESP-WIFI-MESH utilizes a path verification mechanism and energy transf"
"er mechanism to detect the loop-back occurrence. The parent node of the upstream connection that caused the loop-back will then inform the child node of the loop-back and initiate a disconnection.

..  Network Management 

.. _mesh-managing-a-network:

Managing a Network


**ESP-WIFI-MESH is a self healing network meaning it can detect and correct for failures in network routing**. Failures occur when a parent node with one or more child nodes breaks down, or when the connection between a parent"
" node and its child nodes becomes unstable. Child nodes in ESP-WIFI-MESH will autonomously select a new parent node and form an upstream connection with it to maintain network interconnectivity. ESP-WIFI-MESH can handle both Root Node Failures and Intermediate Parent Node Failures.

Root Node Failure


If the root node breaks down, the nodes connected with it (second layer nodes) will promptly detect the failure of the root node. The second layer nodes will initially attempt to reconnect with th"
"e root node. However after multiple failed attempts, the second layer nodes will initialize a new round of root node election. **The second layer node with the strongest router RSSI will be elected as the new root node** whilst the remaining second layer nodes will form an upstream connection with the new root node (or a neighboring parent node if not in range).

If the root node and multiple downstream layers simultaneously break down (e.g., root node, second layer, and third layer), the shallo"
"west layer that is still functioning will initialize the root node election. The following example illustrates an example of self healing from a root node break down.

.. figure:: ../../_static/mesh-root-node-failure.png
    :align: center
    :alt: Diagram of Self Healing From Root Node Failure
    :figclass: align-center

    Self Healing From Root Node Failure

**1.** Node C is the root node of the network. Nodes A/B/D/E are second layer nodes connected to node C.

**2.** Node C breaks down. "
"After multiple failed attempts to reconnect, the second layer nodes begin the election process by broadcasting their router RSSIs. Node B has the strongest router RSSI.

**3.** Node B is elected as the root node and begins accepting downstream connections. The remaining second layer nodes A/D/E form upstream connections with node B thus the network is healed and can continue operating normally.

.. note::

    If a designated root node breaks down, the remaining nodes **will not autonomously att"
"empt to elect a new root node** as an election process will never be attempted whilst a designated root node is used.

Intermediate Parent Node Failure


If an intermediate parent node breaks down, the disconnected child nodes will initially attempt to reconnect with the parent node. After multiple failed attempts to reconnect, each child node will begin to scan for potential parent nodes (see `Beacon Frames & RSSI Thresholding`_).

If other potential parent nodes are available, each child node "
"will individually select a new preferred parent node (see `Preferred Parent Node`_) and form an upstream connection with it. If there are no other potential parent nodes for a particular child node, it will remain idle indefinitely.

The following diagram illustrates an example of self healing from an Intermediate Parent Node break down.

.. figure:: ../../_static/mesh-parent-node-failure.png
    :align: center
    :alt: Diagram of Self Healing From Intermediate Parent Node Failure
    :figclass"
": align-center

    Self Healing From Intermediate Parent Node Failure

**1.** The following branch of the network consists of nodes A to G.

**2.** Node C breaks down. Nodes F/G detect the break down and attempt to reconnect with node C. After multiple failed attempts to reconnect, nodes F/G begin to select a new preferred parent node.

**3.** Node G is out of range from any other parent node hence remains idle for the time being. Node F is in range of nodes B/E, however node B is selected as i"
"t is the shallower node. Node F becomes an intermediate parent node after connecting with Node B thus node G can connect with node F. The network is healed, however the network routing as been affected and an extra layer has been added.

.. note::

    If a child node has a designated parent node that breaks down, the child node will make no attempt to connect with a new parent node. The child node will remain idle indefinitely.

Root Node Switching


ESP-WIFI-MESH does not automatically switch "
"the root node unless the root node breaks down. Even if the root node's router RSSI degrades to the point of disconnection, the root node will remain unchanged. Root node switching is the act of explicitly starting a new election such that a node with a stronger router RSSI will be elected as the new root node. This can be a useful method of adapting to degrading root node performance.

To trigger a root node switch, the current root node must explicitly call :cpp:func:`esp_mesh_waive_root` to t"
"rigger a new election. The current root node will signal all nodes within the network to begin transmitting and scanning for beacon frames (see `Automatic Root Node Selection`_) **whilst remaining connected to the network (i.e., not idle)**. If another node receives more votes than the current root node, a root node switch will be initiated. **The root node will remain unchanged otherwise**.

A newly elected root node sends a **switch request** to the current root node which in turn will respond"
" with an acknowledgment signifying both nodes are ready to switch. Once the acknowledgment is received, the newly elected root node will disconnect from its parent and promptly form an upstream connection with the router thereby becoming the new root node of the network. The previous root node will disconnect from the router **whilst maintaining all of its downstream connections** and enter the idle state. The previous root node will then begin scanning for potential parent nodes and selecting a"
" preferred parent.

The following diagram illustrates an example of a root node switch.

.. figure:: ../../_static/mesh-root-node-switch-example.png
    :align: center
    :alt: Diagram of Root Node Switch Example
    :figclass: align-center

    Root Node Switch Example

**1.** Node C is the current root node but has degraded signal strength with the router (-85db). The node C triggers a new election and all nodes begin transmitting and scanning for beacon frames **whilst still being connected*"
"*.

**2.** After multiple rounds of transmission and scanning, node B is elected as the new root node. Node B sends node C a **switch request** and node C responds with an acknowledgment.

**3.** Node B disconnects from its parent and connects with the router becoming the network's new root node. Node C disconnects from the router, enters the idle state, and begins scanning for and selecting a new preferred parent node. **Node C maintains all its downstream connections throughout this process**."
"

**4.** Node C selects node B as its preferred parent node, forms an upstream connection, and becomes a second layer node. The network layout is similar after the switch as node C still maintains the same subnetwork. However each node in node C's subnetwork has been placed one layer deeper as a result of the switch. `Parent Node Switching`_ may adjust the network layout afterwards if any nodes have a new preferred parent node as a result of the root node switch.

.. note::

    Root node switch"
"ing must require an election hence is only supported when using a self-organized ESP-WIFI-MESH network. In other words, root node switching cannot occur if a designated root node is used.

Parent Node Switching


Parent Node Switching entails a child node switching its upstream connection to another parent node of a shallower layer. **Parent Node Switching occurs autonomously** meaning that a child node will change its upstream connection automatically if a potential parent node of a shallower l"
"ayer becomes available (i.e., due to a `Asynchronous Power-on Reset`_).

All potential parent nodes periodically transmit beacon frames (see `Beacon Frames & RSSI Thresholding`_) allowing for a child node to scan for the availability of a shallower parent node. Due to parent node switching, a self-organized ESP-WIFI-MESH network can dynamically adjust its network layout to ensure each connection has a good RSSI and that the number of layers in the network is minimized.


..  Data Transmission 

"
".. _mesh-data-transmission:

Data Transmission


ESP-WIFI-MESH Packet


ESP-WIFI-MESH network data transmissions use ESP-WIFI-MESH packets. ESP-WIFI-MESH packets are **entirely contained within the frame body of a Wi-Fi data frame**. A multi-hop data transmission in an ESP-WIFI-MESH network will involve a single ESP-WIFI-MESH packet being carried over each wireless hop by a different Wi-Fi data frame.

The following diagram shows the structure of an ESP-WIFI-MESH packet and its relation with a W"
"i-Fi data frame.

.. figure:: ../../_static/mesh-packet.png
    :align: center
    :alt: Diagram of ESP-WIFI-MESH Packet
    :figclass: align-center

    ESP-WIFI-MESH Packet

**The header** of an ESP-WIFI-MESH packet contains the MAC addresses of the source and destination nodes. The options field contains information pertaining to the special types of ESP-WIFI-MESH packets such as a group transmission or a packet originating from the external IP network (see :c:macro:`MESH_OPT_SEND_GROUP` and "
":c:macro:`MESH_OPT_RECV_DS_ADDR`).

**The payload** of an ESP-WIFI-MESH packet contains the actual application data. This data can be raw binary data, or encoded under an application layer protocol such as HTTP, MQTT, and JSON (see :cpp:type:`mesh_proto_t`).

.. note::

    When sending an ESP-WIFI-MESH packet to the external IP network, the destination address field of the header will contain the IP address and port of the target server rather than the MAC address of a node (see :cpp:type:`mesh"
"_addr_t`). Furthermore the root node will handle the formation of the outgoing TCP/IP packet.

Group Control & Multicasting


Multicasting is a feature that allows a single ESP-WIFI-MESH packet to be transmitted simultaneously to multiple nodes within the network. Multicasting in ESP-WIFI-MESH can be achieved by either specifying a list of target nodes, or specifying a preconfigured group of nodes. Both methods of multicasting are called via :cpp:func:`esp_mesh_send`.

To multicast by specifying"
" a list of target nodes, users must first set the ESP-WIFI-MESH packet's destination address to the **Multicast-Group Address** (``01:00:5E:xx:xx:xx``). This signifies that the ESP-WIFI-MESH packet is a multicast packet with a group of addresses, and that the address should be obtained from the header options. Users must then list the MAC addresses of the target nodes as options (see :cpp:type:`mesh_opt_t` and :c:macro:`MESH_OPT_SEND_GROUP`). This method of multicasting requires no prior setup b"
"ut can incur a large amount of overhead data as each target node's MAC address must be listed in the options field of the header.

Multicasting by group allows a ESP-WIFI-MESH packet to be transmitted to a preconfigured group of nodes. Each grouping is identified by a unique ID, and a node can be placed into a group via :cpp:func:`esp_mesh_set_group_id`. Multicasting to a group involves setting the destination address of the ESP-WIFI-MESH packet to the target group ID. Furthermore, the :c:macro:"
"`MESH_DATA_GROUP` flag must set. Using groups to multicast incurs less overhead, but requires nodes to previously added into groups.

.. note::

    During a multicast, all nodes within the network still receive the ESP-WIFI-MESH packet on the MAC layer. However, nodes not included in the MAC address list or the target group will simply filter out the packet.

Broadcasting


Broadcasting is a feature that allows a single ESP-WIFI-MESH packet to be transmitted simultaneously to all nodes within t"
"he network. Each node essentially forwards a broadcast packet to all of its upstream and downstream connections such that the packet propagates throughout the network as quickly as possible. However, ESP-WIFI-MESH utilizes the following methods to avoid wasting bandwidth during a broadcast.

**1.** When an intermediate parent node receives a broadcast packet from its parent, it will forward the packet to each of its child nodes whilst storing a copy of the packet for itself.

**2.** When an inte"
"rmediate parent node is the source node of the broadcast, it will transmit the broadcast packet upstream to is parent node and downstream to each of its child nodes.

**3.** When an intermediate parent node receives a broadcast packet from one of its child nodes, it will forward the packet to its parent node and each of its remaining child nodes whilst storing a copy of the packet for itself.

**4.** When a leaf node is the source node of a broadcast, it will directly transmit the packet to its "
"parent node.

**5.** When the root node is the source node of a broadcast, the root node will transmit the packet to all of its child nodes.

**6.** When the root node receives a broadcast packet from one of its child nodes, it will forward the packet to each of its remaining child nodes whilst storing a copy of the packet for itself.

**7.** When a node receives a broadcast packet with a source address matching its own MAC address, the node will discard the broadcast packet.

**8.** When an int"
"ermediate parent node receives a broadcast packet from its parent node which was originally transmitted from one of its child nodes, it will discard the broadcast packet

Upstream Flow Control


ESP-WIFI-MESH relies on parent nodes to control the upstream data flow of their immediate child nodes. To prevent a parent node's message buffer from overflowing due to an overload of upstream transmissions, a parent node will allocate a quota for upstream transmissions known as a **receiving window** fo"
"r each of its child nodes. **Each child node must apply for a receiving window before it is permitted to transmit upstream**. The size of a receiving window can be dynamically adjusted. An upstream transmission from a child node to the parent node consists of the following steps:

**1.** Before each transmission, the child node sends a window request to its parent node. The window request consists of a sequence number which corresponds to the child node's data packet that is pending transmission"
".

**2.** The parent node receives the window request and compares the sequence number with the sequence number of the previous packet sent by the child node. The comparison is used to calculate the size of the receiving window which is transmitted back to the child node.

**3.** The child node transmits the data packet in accordance with the window size specified by the parent node. If the child node depletes its receiving window, it must obtain another receiving windows by sending a request be"
"fore it is permitted to continue transmitting.

.. note::

    ESP-WIFI-MESH does not support any downstream flow control.

.. warning::

    Due to `Parent Node Switching`_, packet loss may occur during upstream transmissions.

Due to the fact that the root node acts as the sole interface to an external IP network, it is critical that downstream nodes are aware of the root node's connection status with the external IP network. Failing to do so can lead to nodes attempting to pass data upstream "
"to the root node whilst it is disconnected from the IP network. This results in unnecessary transmissions and packet loss. ESP-WIFI-MESH address this issue by providing a mechanism to stabilize the throughput of outgoing data based on the connection status between the root node and the external IP network. The root node can broadcast its external IP network connection status to all other nodes by calling :cpp:func:`esp_mesh_post_toDS_state`.

Bi-Directional Data Stream


The following diagram il"
"lustrates the various network layers involved in an ESP-WIFI-MESH Bidirectional Data Stream.

.. figure:: ../../_static/mesh-bidirectional-data-stream.png
    :align: center
    :alt: Diagram of ESP-WIFI-MESH Bidirectional Data Stream
    :figclass: align-center

    ESP-WIFI-MESH Bidirectional Data Stream

Due to the use of `Routing Tables`_, **ESP-WIFI-MESH is able to handle pack forwarding entirely on the mesh layer**. A TCP/IP layer is only required on the root node when it transmits/receive"
"s a packet to/from an external IP network.


..  Channel Switching 

.. _mesh-channel-switching:

Channel Switching


Background


In traditional Wi-Fi networks, **channels** are predetermined frequency ranges. In an infrastructure basic service set (BSS), the serving AP and its connected stations must be on the same operating channels (1 to 14) in which beacons are transmitted. Physically adjacent BSS (Basic Service Sets) operating on the same channel can lead to interference and degraded perfo"
"rmance.

In order to allow a BSS adapt to changing physical layer conditions and maintain performance, Wi-Fi contains mechanisms for **network channel switching**. A network channel switch is an attempt to move a BSS to a new operating channel whilst minimizing disruption to the BSS during this process. However it should be recognized that a channel switch may be unsuccessful in  moving all stations to the new operating channel.

In an infrastructure Wi-Fi network, network channel switches are t"
"riggered by the AP with the aim of having the AP and all connected stations synchronously switch to a new channel. Network channel switching is implemented by embedding a **Channel Switch Announcement (CSA)** element within the AP's periodically transmitted beacon frames. The CSA element is used to advertise to all connected stations regarding an upcoming network channel switch and will be included in multiple beacon frames up until the switch occurs.

A CSA element contains information regardin"
"g the **New Channel Number** and a **Channel Switch Count** which indicates the number of beacon frame intervals (TBTTs) remaining until the network channel switch occurs. Therefore, the Channel Switch Count is decremented every beacon frame and allows connected stations to synchronize their channel switch with the AP.

ESP-WIFI-MESH Network Channel Switching


ESP-WIFI-MESH Network Channel Switching also utilize beacon frames that contain a CSA element. However, being a multi-hop network makes "
"the switching process in ESP-WIFI-MESH is more complex due to the fact that a beacon frame might not be able to reach all nodes within the network (i.e., in a single hop). Therefore, an ESP-WIFI-MESH network relies on nodes to forward the CSA element so that it is propagated throughout the network.

When an intermediate parent node with one or more child nodes receives a beacon frame containing a CSA, the node will forward the CSA element by including the element in its next transmitted beacon f"
"rame (i.e., with the same **New Channel Number** and **Channel Switch Count**). Given that all nodes within an ESP-WIFI-MESH network receive the same CSA, the nodes can synchronize their channel switches using the Channel Switch Count, albeit with a short delay due to CSA element forwarding.

An ESP-WIFI-MESH network channel switch can be triggered by either the router or the root node.

Root Node Triggered
""""""""""""""""""""""""""""""""""""""
**A root node triggered channel switch can only occur when the ESP-WI"
"FI-MESH network is not connected to a router**. By calling :cpp:func:`esp_mesh_switch_channel`, the root node will set an initial Channel Switch Count value and begin including a CSA element in its beacon frames. Each CSA element is then received by second layer nodes, and forwarded downstream in their own beacon frames.

Router Triggered
""""""""""""""""""""""""""""""""
When an ESP-WIFI-MESH network is connected to a router, the entire network must use the same channel as the router. Therefore, **the root node"
" will not be permitted to trigger a channel switch when it is connected to a router**.

When the root node receives beacon frame containing a CSA element from the router, **the root node will set Channel Switch Count value in the CSA element to a custom value before forwarding it downstream via beacon frames**. It will also decrement the Channel Switch Count of subsequent CSA elements relative to the custom value. This custom value can be based on factors such as the number of network layers, th"
"e current number of nodes etc.

The setting the Channel Switch Count value to a custom value is due to the fact that the ESP-WIFI-MESH network and its router may have a different and varying beacon intervals. Therefore, the Channel Switch Count value provided by the router is irrelevant to an ESP-WIFI-MESH network. By using a custom value, nodes within the ESP-WIFI-MESH network are able to switch channels synchronously relative to the ESP-WIFI-MESH network's beacon interval. However, this will a"
"lso result in the ESP-WIFI-MESH network's channel switch being unsynchronized with the channel switch of the router and its connected stations.

Impact of Network Channel Switching


- Due to the ESP-WIFI-MESH network channel switch being unsynchronized with the router's channel switch, there will be a **temporary channel discrepancy** between the ESP-WIFI-MESH network and the router.
    - The ESP-WIFI-MESH network's channel switch time is dependent on the ESP-WIFI-MESH network's beacon interva"
"l and the root node's custom Channel Switch Count value.
    - The channel discrepancy prevents any data exchange between the root node and the router during that ESP-WIFI-MESH network's switch.
    - In the ESP-WIFI-MESH network, the root node and intermediate parent nodes will request their connected child nodes to stop transmissions until the channel switch takes place by setting the **Channel Switch Mode** field in the CSA element to 1.
    - Frequent router triggered network channel switche"
"s can degrade the ESP-WIFI-MESH network's performance. Note that this can be caused by the ESP-WIFI-MESH network itself (e.g., due to wireless medium contention with ESP-WIFI-MESH network). If this is the case, users should disable the automatic channel switching on the router and use a specified channel instead.

- When there is a **temporary channel discrepancy**, the root node remains technically connected to the router.
    - Disconnection occurs after the root node fails to receive any beac"
"on frames or probe responses from the router over a fixed number of router beacon intervals.
    - Upon disconnection, the root node will automatically re-scan all channels for the presence of a router.

- If the root node is unable to receive any of the router's CSA beacon frames (e.g., due to short switch time given by the router), the router will switch channels without the ESP-WIFI-MESH network's knowledge.
    - After the router switches channels, the root node will no longer be able to rec"
"eive the router's beacon frames and probe responses and result in a disconnection after a fixed number of beacon intervals.
    - The root node will re-scan all channels for the router after disconnection.
    - The root node will maintain downstream connections throughout this process.

.. note::

    Although ESP-WIFI-MESH network channel switching aims to move all nodes within the network to a new operating channel, it should be recognized that a channel switch might not successfully move all"
" nodes (e.g., due to reasons such as node failures).

Channel and Router Switching Configuration


ESP-WIFI-MESH allows for autonomous channel switching to be enabled/disabled via configuration. Likewise, autonomous router switching (i.e., when a root node autonomously connects to another router) can also be enabled/disabled by configuration. Autonomous channel switching and router switching is dependent on the following configuration parameters and run-time conditions.

**Allow Channel Switch:*"
"* This parameter is set via the ``allow_channel_switch`` field of the :cpp:type:`mesh_cfg_t` structure and permits an ESP-WIFI-MESH network to dynamically switch channels when set.

**Preset Channel:** An ESP-WIFI-MESH network can have a preset channel by setting the ``channel`` field of the :cpp:type:`mesh_cfg_t` structure to the desired channel number. If this field is unset, the ``allow_channel_switch`` parameter is overridden such that channel switches are always permitted.

**Allow Router S"
"witch:** This parameter is set via the ``allow_router_switch`` field of the :cpp:type:`mesh_router_t` and permits an ESP-WIFI-MESH to dynamically switch to a different router when set.

**Preset Router BSSID:** An ESP-WIFI-MESH network can have a preset router by setting the ``bssid`` field of the :cpp:type:`mesh_router_t` structure to the
BSSID of the desired router. If this field is unset, the ``allow_router_switch`` parameter is overridden such that router switches are always permitted.

**Ro"
"ot Node Present:** The presence of a root node will can also affect whether or a channel or router switch is permitted.

The following table illustrates how the different combinations of parameters/conditions affect whether channel switching and/or router switching is permitted. Note that `X` represents a ""do not care"" for the parameter.

.. list-table::
    :widths: 15 15 15 15 15 15
    :header-rows: 1
      - Allow Channel Switch
      - Preset Router BSSID
      - Allow Router Switch
      -"
" Root Node Present
      - Permitted Switches？
      - X
      - N
      - X
      - X
      - Channel and Router
      - X
      - Y
      - N
      - X
      - Channel Only
      - X
      - Y
      - Y
      - X
      - Channel and Router
      - Y
      - N
      - X
      - X
      - Channel and Router
      - N
      - N
      - X
      - N
      - Router Only
      - N
      - N
      - X
      - Y
      - Channel and Router
      - Y
      - Y
      - N
      - X
      - Channel Only
   "
"   - N
      - Y
      - N
      - N
      - N
      - N
      - Y
      - N
      - Y
      - Channel Only
      - Y
      - Y
      - Y
      - X
      - Channel and Router
      - N
      - Y
      - Y
      - N
      - Router Only
      - N
      - Y
      - Y
      - Y
      - Channel and Router

..  Performance 

.. _mesh-network-performance:

Performance


The performance of an ESP-WIFI-MESH network can be evaluated based on multiple metrics such as the following:

**Network Building Time"
":** The amount of time taken to build an ESP-WIFI-MESH network from scratch.

**Healing Time:** The amount of time taken for the network to detect a node break down and carry out appropriate actions to heal the network (such as generating a new root node or forming new connections).

**Per-hop latency:** The latency of data transmission over one wireless hop. In other words, the time taken to transmit a data packet from a parent node to a child node or vice versa.

**Network Node Capacity:** The"
" total number of nodes the ESP-WIFI-MESH network can simultaneously support. This number is determined by the maximum number of downstream connections a node can accept and the maximum number of layers permissible in the network.

The following table lists the common performance figures of an ESP-WIFI-MESH network:
"
":orphan:

General Notes About ESP-IDF Programming




This page has been split into two new pages:

- :doc:`startup`
- :doc:`memory-types`
"
".. highlight:: c

Error Handling




Overview


Identifying and handling run-time errors is important for developing robust applications. There can be multiple kinds of run-time errors:

- Recoverable errors:

  - Errors indicated by functions through return values (error codes)
  - C++ exceptions, thrown using ``throw`` keyword

- Unrecoverable (fatal) errors:

  - Failed assertions (using ``assert`` macro and equivalent methods, see :ref:`assertions`) and ``abort()`` calls.
  - CPU exceptions:"
" access to protected regions of memory, illegal instruction, etc.
  - System level checks: watchdog timeout, cache access error, stack overflow, stack smashing, heap corruption, etc.

This guide explains ESP-IDF error handling mechanisms related to recoverable errors, and provides some common error handling patterns.

For instructions on diagnosing unrecoverable errors, see :doc:`Fatal Errors `.


Error Codes


The majority of ESP-IDF-specific functions use :cpp:type:`esp_err_t` type to return e"
"rror codes. :cpp:type:`esp_err_t` is a signed integer type. Success (no error) is indicated with ``ESP_OK`` code, which is defined as zero.

Various ESP-IDF header files define possible error codes using preprocessor defines. Usually these defines start with ``ESP_ERR_`` prefix. Common error codes for generic failures (out of memory, timeout, invalid argument, etc.) are defined in ``esp_err.h`` file. Various components in ESP-IDF may define additional error codes for specific situations.

For th"
"e complete list of error codes, see :doc:`Error Code Reference `.


Converting Error Codes to Error Messages


For each error code defined in ESP-IDF components, :cpp:type:`esp_err_t` value can be converted to an error code name using :cpp:func:`esp_err_to_name` or :cpp:func:`esp_err_to_name_r` functions. For example, passing ``0x101`` to :cpp:func:`esp_err_to_name` will return ""ESP_ERR_NO_MEM"" string. Such strings can be used in log output to make it easier to understand which error has happene"
"d.

Additionally, :cpp:func:`esp_err_to_name_r` function will attempt to interpret the error code as a `standard POSIX error code `_, if no matching ``ESP_ERR_`` value is found. This is done using ``strerror_r`` function. POSIX error codes (such as ``ENOENT``, ``ENOMEM``) are defined in ``errno.h`` and are typically obtained from ``errno`` variable. In ESP-IDF this variable is thread-local: multiple FreeRTOS tasks have their own copies of ``errno``. Functions which set ``errno`` only modify its "
"value for the task they run in.

This feature is enabled by default, but can be disabled to reduce application binary size. See :ref:`CONFIG_ESP_ERR_TO_NAME_LOOKUP`. When this feature is disabled, :cpp:func:`esp_err_to_name` and :cpp:func:`esp_err_to_name_r` are still defined and can be called. In this case, :cpp:func:`esp_err_to_name` will return ``UNKNOWN ERROR``, and :cpp:func:`esp_err_to_name_r` will return ``Unknown error 0xXXXX(YYYYY)``, where ``0xXXXX`` and ``YYYYY`` are the hexadecimal a"
"nd decimal representations of the error code, respectively.


.. _esp-error-check-macro:

``ESP_ERROR_CHECK`` Macro


:c:macro:`ESP_ERROR_CHECK` macro serves similar purpose as ``assert``, except that it checks :cpp:type:`esp_err_t` value rather than a ``bool`` condition. If the argument of :c:macro:`ESP_ERROR_CHECK` is not equal :c:macro:`ESP_OK`, then an error message is printed on the console, and ``abort()`` is called.

Error message will typically look like this::

    ESP_ERROR_CHECK faile"
"d: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdf

    file: ""/Users/user/esp/example/main/main.c"" line 20
    func: app_main
    expression: sdmmc_card_init(host, &card)

    Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050

.. note:: If :doc:`ESP-IDF monitor ` is used, addresses in the backtrace will be converted to file names and line numbers.

- The first line mentions the error code as a hexadecimal value, and the identifier used for this e"
"rror in source code. The latter depends on :ref:`CONFIG_ESP_ERR_TO_NAME_LOOKUP` option being set. Address in the program where error has occured is printed as well.

- Subsequent lines show the location in the program where :c:macro:`ESP_ERROR_CHECK` macro was called, and the expression which was passed to the macro as an argument.

- Finally, backtrace is printed. This is part of panic handler output common to all fatal errors. See :doc:`Fatal Errors ` for more information about the backtrace.
"
"

.. _esp-error-check-without-abort-macro:

``ESP_ERROR_CHECK_WITHOUT_ABORT`` Macro


:c:macro:`ESP_ERROR_CHECK_WITHOUT_ABORT` macro serves similar purpose as ``ESP_ERROR_CHECK``, except that it will not call ``abort()``.


.. _esp-return-on-error-macro:

``ESP_RETURN_ON_ERROR`` Macro


:c:macro:`ESP_RETURN_ON_ERROR` macro checks the error code, if the error code is not equal :c:macro:`ESP_OK`, it prints the message and returns.


.. _esp-goto-on-error-macro:

``ESP_GOTO_ON_ERROR`` Macro


:c:ma"
"cro:`ESP_GOTO_ON_ERROR` macro checks the error code, if the error code is not equal :c:macro:`ESP_OK`, it prints the message, sets the local variable `ret` to the code, and then exits by jumping to `goto_tag`.


.. _esp-return-on-false-macro:

``ESP_RETURN_ON_FALSE`` Macro


:c:macro:`ESP_RETURN_ON_FALSE` macro checks the condition, if the condition is not equal `true`, it prints the message and returns with the supplied `err_code`.


.. _esp-goto-on-false-macro:

``ESP_GOTO_ON_FALSE`` Macro


:"
"c:macro:`ESP_GOTO_ON_FALSE` macro checks the condition, if the condition is not equal `true`, it prints the message, sets the local variable `ret` to the supplied `err_code`, and then exits by jumping to `goto_tag`.


.. _check_macros_examples:

``CHECK MACROS Examples``


Some examples::

    static const char* TAG = ""Test"";

    esp_err_t test_func(void)
    {
        esp_err_t ret = ESP_OK;

        ESP_ERROR_CHECK(x);                                         // err message printed if `x` is n"
"ot `ESP_OK`, and then `abort()`.
        ESP_ERROR_CHECK_WITHOUT_ABORT(x);                           // err message printed if `x` is not `ESP_OK`, without `abort()`.
        ESP_RETURN_ON_ERROR(x, TAG, ""fail reason 1"");               // err message printed if `x` is not `ESP_OK`, and then function returns with code `x`.
        ESP_GOTO_ON_ERROR(x, err, TAG, ""fail reason 2"");            // err message printed if `x` is not `ESP_OK`, `ret` is set to `x`, and then jumps to `err`.
        ESP_RETU"
"RN_ON_FALSE(a, err_code, TAG, ""fail reason 3"");     // err message printed if `a` is not `true`, and then function returns with code `err_code`.
        ESP_GOTO_ON_FALSE(a, err_code, err, TAG, ""fail reason 4"");  // err message printed if `a` is not `true`, `ret` is set to `err_code`, and then jumps to `err`.

    err:
        // clean up
        return ret;
    }

.. note::

     If the option :ref:`CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT` in Kconfig is enabled, the err message will be disca"
"rded, while the other action works as is.

     The ``ESP_RETURN_XX`` and ``ESP_GOTO_xx`` macros cannot be called from ISR. While there are ``xx_ISR`` versions for each of them, e.g., `ESP_RETURN_ON_ERROR_ISR`, these macros could be used in ISR.


Error Handling Patterns


   - retry the call after some time;
   - attempt to de-initialize the driver and re-initialize it again;
   - fix the error condition using an out-of-band mechanism (e.g reset an external peripheral which is not responding).
"
"
   Example::

        esp_err_t err;
        do {
            err = sdio_slave_send_queue(addr, len, arg, timeout);
            // keep retrying while the sending queue is full
        } while (err == ESP_ERR_TIMEOUT);
        if (err != ESP_OK) {
            // handle other errors
        }

   Example::

        sdmmc_card_t* card = calloc(1, sizeof(sdmmc_card_t));
        if (card == NULL) {
            return ESP_ERR_NO_MEM;
        }
        esp_err_t err = sdmmc_card_init(host, &card);
  "
"      if (err != ESP_OK) {
            // Clean up
            free(card);
            // Propagate the error to the upper layer (e.g., to notify the user).
            // Alternatively, application can define and return custom error code.
            return err;
        }

   Terminating the application in case of an error is usually undesirable behavior for middleware components, but is sometimes acceptable at application level.

   Many ESP-IDF examples use ``ESP_ERROR_CHECK`` to handle error"
"s from various APIs. This is not the best practice for applications, and is done to make example code more concise.

   Example::

        ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan));


C++ Exceptions


See :ref:`cplusplus_exceptions`.
"
"Bootloader




The ESP-IDF Software Bootloader performs the following functions:

Bootloader is located at the address {IDF_TARGET_CONFIG_BOOTLOADER_OFFSET_IN_FLASH} in the flash.

For a full description of the startup process including the ESP-IDF bootloader, see :doc:`startup`.

.. _bootloader-compatibility:

Bootloader Compatibility


It is recommended to update to newer :doc:`versions of ESP-IDF `: when they are released. The OTA (over the air) update process can flash new apps in the field "
"but cannot flash a new bootloader. For this reason, the bootloader supports booting apps built from newer versions of ESP-IDF.

The bootloader does not support booting apps from older versions of ESP-IDF. When updating ESP-IDF manually on an existing product that might need to downgrade the app to an older version, keep using the older ESP-IDF bootloader binary as well.

.. note::

   If testing an OTA update for an existing product in production, always test it using the same ESP-IDF bootloader"
" binary that is deployed in production.

.. only:: esp32

    Before ESP-IDF V2.1
    

    Bootloaders built from very old versions of ESP-IDF (before ESP-IDF V2.1) perform less hardware configuration than newer versions. When using a bootloader from these early ESP-IDF versions and building a new app, enable the config option :ref:`CONFIG_APP_COMPATIBLE_PRE_V2_1_BOOTLOADERS`.

    Before ESP-IDF V3.1
    

    Bootloaders built from versions of ESP-IDF before V3.1 do not support MD5 checksums "
"in the partition table binary. When using a bootloader from these ESP-IDF versions and building a new app, enable the config option :ref:`CONFIG_APP_COMPATIBLE_PRE_V3_1_BOOTLOADERS`.

    Before ESP-IDF V5.1
    

    Bootloaders built from versions of ESP-IDF prior to V5.1 do not support :ref:`CONFIG_ESP_SYSTEM_ESP32_SRAM1_REGION_AS_IRAM`. When using a bootloader from these ESP-IDF versions and building a new app, you should not use this option.


SPI Flash Configuration


Each ESP-IDF applicat"
"ion or bootloader .bin file contains a header with :ref:`CONFIG_ESPTOOLPY_FLASHMODE`, :ref:`CONFIG_ESPTOOLPY_FLASHFREQ`, :ref:`CONFIG_ESPTOOLPY_FLASHSIZE` embedded in it. These are used to configure the SPI flash during boot.

The :ref:`first-stage-bootloader` in ROM reads the :ref:`second-stage-bootloader` header information from flash and uses this infomation to load the rest of the :ref:`second-stage-bootloader` from flash. However, at this time the system clock speed is lower than configured"
" and not all flash modes are supported. When the :ref:`second-stage-bootloader` then runs, it will reconfigure the flash using values read from the currently selected app binary's header (and NOT from the :ref:`second-stage-bootloader` header). This allows an OTA update to change the SPI flash settings in use.

.. only:: esp32

   Bootloaders prior to ESP-IDF V4.0 used the bootloader's own header to configure the SPI flash, meaning these values could not be changed in an update. To maintain comp"
"atibility with older bootloaders, the app re-initializes the flash settings during app startup using the configuration found in the app header.

Log Level


The default bootloader log level is ""Info"". By setting the :ref:`CONFIG_BOOTLOADER_LOG_LEVEL` option, it is possible to increase or decrease this level. This log level is separate from the log level used in the app (see :doc:`/api-reference/system/log`).

Reducing bootloader log verbosity can improve the overall project boot time by a small "
"amount.

Factory Reset


Sometimes it is desirable to have a way for the device to fall back to a known-good state, in case of some problem with an update.

To roll back to the original ""factory"" device configuration and clear any user settings, configure the config item :ref:`CONFIG_BOOTLOADER_FACTORY_RESET` in the bootloader.

The factory reset mechanism allows the device to be factory reset in two ways:

- Clear one or more data partitions. The :ref:`CONFIG_BOOTLOADER_DATA_FACTORY_RESET` opti"
"on allows users to specify which data partitions will be erased when the factory reset is executed.

  Users can specify the names of partitions as a comma-delimited list with optional spaces for readability. (Like this: ``nvs, phy_init, nvs_custom``).

  Make sure that the names of partitions specified in the option are the same as those found in the partition table. Partitions of type ""app"" cannot be specified here.

- Boot from ""factory"" app partition. Enabling the :ref:`CONFIG_BOOTLOADER_OTA"
"_DATA_ERASE` option will cause the device to boot from the default ""factory"" app partition after a factory reset (or if there is no factory app partition in the partition table then the default ota app partition is selected instead). This reset process involves erasing the OTA data partition which holds the currently selected OTA partition slot. The ""factory"" app partition slot (if it exists) is never updated via OTA, so resetting to this allows reverting to a ""known good"" firmware application.
"
"
Either or both of these configuration options can be enabled independently.

In addition, the following configuration options control the reset condition:

- :ref:`CONFIG_BOOTLOADER_NUM_PIN_FACTORY_RESET`- The input GPIO number used to trigger a factory reset. This GPIO must be pulled low or high (configurable) on reset to trigger this.

- :ref:`CONFIG_BOOTLOADER_HOLD_TIME_GPIO`- this is hold time of GPIO for reset/test mode (by default 5 seconds). The GPIO must be held continuously for this pe"
"riod of time after reset before a factory reset or test partition boot (as applicable) is performed.

- :ref:`CONFIG_BOOTLOADER_FACTORY_RESET_PIN_LEVEL` - configure whether a factory reset should trigger on a high or low level of the GPIO. If the GPIO has an internal pullup then this is enabled before the pin is sampled, consult the {IDF_TARGET_NAME} datasheet for details on pin internal pullups.

.. only:: SOC_RTC_FAST_MEM_SUPPORTED

    If an application needs to know if the factory reset has "
"occurred, users can call the function :cpp:func:`bootloader_common_get_rtc_retain_mem_factory_reset_state`.

    - If the status is read as true, the function will return the status, indicating that the factory reset has occurred. The function then resets the status to false for subsequent factory reset judgement.
    - If the status is read as false, the function will return the status, indicating that the factory reset has not occurred, or the memory where this status is stored is invalid.

  "
"  Note that this feature reserves some RTC FAST memory (the same size as the :ref:`CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP` feature).

.. only:: not SOC_RTC_FAST_MEM_SUPPORTED

    Sometimes an application needs to know if the factory reset has occurred. The {IDF_TARGET_NAME} chip does not have RTC FAST memory, so there is no API to detect it. Instead, there is a workaround: you need an NVS partition that will be erased by the bootloader if factory reset occurs (add this partition to :ref:"
"`CONFIG_BOOTLOADER_DATA_FACTORY_RESET`). In this NVS partition, create a ""factory_reset_state"" token that will be increased in the application. If the ""factory_reset_state"" is 0 then the factory reset has occurred.

.. _bootloader_boot_from_test_firmware:

Boot from Test Firmware


It is possible to write a special firmware app for testing in production, and boot this firmware when needed. The project partition table will need a dedicated app partition entry for this testing app, type ``app`` an"
"d subtype ``test`` (see :doc:`/api-guides/partition-tables`).

Implementing a dedicated test app firmware requires creating a totally separate ESP-IDF project for the test app (each project in ESP-IDF only builds one app). The test app can be developed and tested independently of the main project, and then integrated at production testing time as a pre-compiled .bin file which is flashed to the address of the main project's test app partition.

To support this functionality in the main project's"
" bootloader, set the configuration item :ref:`CONFIG_BOOTLOADER_APP_TEST` and configure the following three items:

- :ref:`CONFIG_BOOTLOADER_NUM_PIN_APP_TEST` - GPIO number to boot test partition. The selected GPIO will be configured as an input with internal pull-up enabled. This GPIO must be pulled low or high (configurable) on reset to trigger this.

  Once the GPIO input is released and the device has been rebooted, the default boot sequence will be enabled again to boot the factory partiti"
"on or any OTA app partition slot.

- :ref:`CONFIG_BOOTLOADER_HOLD_TIME_GPIO` - this is the hold time of GPIO for reset/test mode (by default 5 seconds). The GPIO must be held continuously for this period of time after reset before a factory reset or test partition boot (as applicable) is performed.

- :ref:`CONFIG_BOOTLOADER_APP_TEST_PIN_LEVEL` - configure whether a test partition boot should trigger on a high or low level of the GPIO. If the GPIO has an internal pull-up, then this is enabled be"
"fore the pin is sampled. Consult the {IDF_TARGET_NAME} datasheet for details on pin internal pull-ups.

Rollback


Rollback and anti-rollback features must be configured in the bootloader as well.

Consult the :ref:`app_rollback` and :ref:`anti-rollback` sections in the :doc:`OTA API reference document `.

.. _bootloader-watchdog:

Watchdog


The chips come equipped with two groups of watchdog timers: Main System Watchdog Timer (MWDT_WDT) and RTC Watchdog Timer (RTC_WDT). Both watchdog timer gro"
"ups are enabled when the chip is powered up. However, in the bootloader, they will both be disabled. If :ref:`CONFIG_BOOTLOADER_WDT_ENABLE` is set (which is the default behavior), RTC_WDT is re-enabled. It tracks the time from the bootloader is enabled until the user's main function is called. In this scenario, RTC_WDT remains operational and will automatically reset the chip if no application successfully starts within 9 seconds. This functionality is particularly useful in preventing lockups c"
"aused by an unstable power source during startup.

- The timeout period can be adjusted by setting :ref:`CONFIG_BOOTLOADER_WDT_TIME_MS` and recompiling the bootloader.
- The RTC Watchdog can be disabled in the bootloader by disabling the :ref:`CONFIG_BOOTLOADER_WDT_ENABLE` setting and recompiling the bootloader. This is not recommended.
- See :ref:`app-hardware-watchdog-timers` to learn how RTC_WDT is used in the application.

.. _bootloader-size:

Bootloader Size


{IDF_TARGET_MAX_BOOTLOADER_SI"
"ZE:default = ""64 KB (0x10000 bytes)"", esp32 = ""48 KB (0xC000 bytes)""}
{IDF_TARGET_MAX_PARTITION_TABLE_OFFSET:default = ""0x12000"", esp32 = ""0xE000""}
.. Above is calculated as 0x1000 at start of flash + IDF_TARGET_MAX_BOOTLOADER_SIZE + 0x1000 signature sector

When enabling additional bootloader functions, including :doc:`/security/flash-encryption` or Secure Boot, and especially if setting a high :ref:`CONFIG_BOOTLOADER_LOG_LEVEL` level, then it is important to monitor the bootloader .bin file's "
"size.

When using the default :ref:`CONFIG_PARTITION_TABLE_OFFSET` value 0x8000, the size limit is {IDF_TARGET_CONFIG_PARTITION_TABLE_OFFSET} bytes.

If the bootloader binary is too large, then the bootloader build will fail with an error ""Bootloader binary size [..] is too large for partition table offset"". If the bootloader binary is flashed anyhow then the {IDF_TARGET_NAME} will fail to boot - errors will be logged about either invalid partition table or invalid bootloader checksum.

Options "
"to work around this are:

- Set :ref:`bootloader compiler optimization ` back to ""Size"" if it has been changed from this default value.
- Reduce :ref:`bootloader log level `. Setting log level to Warning, Error or None all significantly reduce the final binary size (but may make it harder to debug).
- Set :ref:`CONFIG_PARTITION_TABLE_OFFSET` to a higher value than 0x8000, to place the partition table later in the flash. This increases the space available for the bootloader. If the :doc:`partitio"
"n table ` CSV file contains explicit partition offsets, they will need changing so no partition has an offset lower than ``CONFIG_PARTITION_TABLE_OFFSET + 0x1000``. (This includes the default partition CSV files supplied with ESP-IDF.)

When Secure Boot V2 is enabled, there is also an absolute binary size limit of {IDF_TARGET_MAX_BOOTLOADER_SIZE} (excluding the 4 KB signature), because the bootloader is first loaded into a fixed size buffer for verification.

.. only:: SOC_RTC_FAST_MEM_SUPPORTED"
"

    Fast Boot from Deep-Sleep
    

    The bootloader has the :ref:`CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP` option which allows the wake-up time from Deep-sleep to be reduced (useful for reducing power consumption). This option is available when :ref:`CONFIG_SECURE_BOOT` option is disabled. Reduction of time is achieved due to the lack of image verification. During the first boot, the bootloader stores the address of the application being launched in the RTC FAST memory. And during the"
" awakening, this address is used for booting without any checks, thus fast loading is achieved.

Custom Bootloader


The current bootloader implementation allows a project to extend it or modify it. There are two ways of doing it: by implementing hooks or by overriding it. Both ways are presented in :example:`custom_bootloader` folder in ESP-IDF examples:

In the bootloader space, you cannot use the drivers and functions from other components. If necessary, then the required functionality should"
" be placed in the project's `bootloader_components` directory (note that this will increase its size).

If the bootloader grows too large then it can collide with the partition table, which is flashed at offset 0x8000 by default. Increase the :ref:`partition table offset ` value to place the partition table later in the flash. This increases the space available for the bootloader.
"
"Anatomy of Core Dump Image




A core dump file's format can be configured to use the ELF format, or a legacy binary format. The ELF format is recommended for all new designs as it provides more information regarding the software's state at the moment the crash occurs, e.g., CPU registers and memory contents.

The memory state embeds a snapshot of all tasks mapped in the memory space of the program. The CPU state contains register values when the core dump has been generated. The core dump file "
"uses a subset of the ELF structures to register this information.

Loadable ELF segments are used to store the process' memory state, while ELF notes (``ELF.PT_NOTE``) are used to store the process' metadata (e.g., PID, registers, signal etc). In particular, the CPU's status is stored in a note with a special name and type (``CORE``, ``NT_PRSTATUS type``).

Here is an overview of the core dump layout:

.. figure:: ../../_static/core_dump_format_elf.png
    :align: center
    :alt: Core Dump ELF "
"Image Format
    :figclass: align-center

    Core Dump ELF Image Format

.. figure:: ../../_static/core_dump_format_bin.png
    :align: center
    :alt: Core Dump Binary Image Format
    :figclass: align-center

    Core Dump Binary Image Format

.. note::

    The format of the image file shown in the above pictures represents the current version of the image and can be changed in future releases.


Overview of Implementation


The figure below describes some basic aspects related to the imple"
"mentation of the core dump:

.. figure:: ../../_static/core_dump_impl.png
    :align: center
    :alt: Core Dump Implementation Overview
    :figclass: align-center

    Core Dump Implementation Overview

.. note::

    The diagram above hides some details and represents the current implementation of the core dump which can be changed later.
"
"Partition Tables




Overview


A single {IDF_TARGET_NAME}'s flash can contain multiple apps, as well as many different kinds of data (calibration data, filesystems, parameter storage, etc). For this reason a partition table is flashed to (:ref:`default offset `) 0x8000 in the flash.

The partition table length is 0xC00 bytes, as we allow a maximum of 95 entries. An MD5 checksum, used for checking the integrity of the partition table at runtime, is appended after the table data. Thus, the partit"
"ion table occupies an entire flash sector, which size is 0x1000 (4 KB). As a result, any partition following it must be at least located at (:ref:`default offset `) + 0x1000.

Each entry in the partition table has a name (label), type (app, data, or something else), subtype and the offset in flash where the partition is loaded.

The simplest way to use the partition table is to open the project configuration menu (``idf.py menuconfig``) and choose one of the simple predefined partition tables un"
"der :ref:`CONFIG_PARTITION_TABLE_TYPE`:

In both cases the factory app is flashed at offset 0x10000. If you execute `idf.py partition-table` then it will print a summary of the partition table.

Built-in Partition Tables


Here is the summary printed for the ""Single factory app, no OTA"" configuration::

  # ESP-IDF Partition Table
  # Name,   Type, SubType, Offset,  Size, Flags
  nvs,      data, nvs,     0x9000,  0x6000,
  phy_init, data, phy,     0xf000,  0x1000,
  factory,  app,  factory, 0x10"
"000, 1M,

Here is the summary printed for the ""Factory app, two OTA definitions"" configuration::

  # ESP-IDF Partition Table
  # Name,   Type, SubType, Offset,  Size, Flags
  nvs,      data, nvs,     0x9000,  0x4000,
  otadata,  data, ota,     0xd000,  0x2000,
  phy_init, data, phy,     0xf000,  0x1000,
  factory,  app,  factory, 0x10000,  1M,
  ota_0,    app,  ota_0,   0x110000, 1M,
  ota_1,    app,  ota_1,   0x210000, 1M,

Creating Custom Tables


If you choose ""Custom partition table CSV"" in"
" menuconfig then you can also enter the name of a CSV file (in the project directory) to use for your partition table. The CSV file can describe any number of definitions for the table you need.

The CSV format is the same format as printed in the summaries shown above. However, not all fields are required in the CSV. For example, here is the ""input"" CSV for the OTA partition table::

  # Name,   Type, SubType,  Offset,   Size,  Flags
  nvs,      data, nvs,      0x9000,  0x4000
  otadata,  data,"
" ota,      0xd000,  0x2000
  phy_init, data, phy,      0xf000,  0x1000
  factory,  app,  factory,  0x10000,  1M
  ota_0,    app,  ota_0,    ,         1M
  ota_1,    app,  ota_1,    ,         1M
  nvs_key,  data, nvs_keys, ,        0x1000

Name Field
~~~~~~~~~~

Name field can be any meaningful name. It is not significant to the {IDF_TARGET_NAME}. The maximum length of names is 16 bytes, including one null terminator. Names longer than the maximum length will be truncated.

Type Field
~~~~~~~~~~
"
"
Partition type field can be specified as ``app`` (0x00) or ``data`` (0x01). Or it can be a number 0-254 (or as hex 0x00-0xFE). Types 0x00-0x3F are reserved for ESP-IDF core functions.

If your app needs to store data in a format not already supported by ESP-IDF, then please add a custom partition type value in the range 0x40-0xFE.

See :cpp:type:`esp_partition_type_t` for the enum definitions for ``app`` and ``data`` partitions.

If writing in C++ then specifying a application-defined partition"
" type requires casting an integer to :cpp:type:`esp_partition_type_t` in order to use it with the :ref:`partition API`. For example::

    static const esp_partition_type_t APP_PARTITION_TYPE_A = (esp_partition_type_t)0x40;

The ESP-IDF bootloader ignores any partition types other than ``app`` (0x00) and ``data`` (0x01).

SubType
~~~~~~~
{IDF_TARGET_ESP_PHY_REF:default = "":ref:`CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION`"", esp32p4, esp32c5=""NOT UPDATED YET""}

The 8-bit SubType field is specific to a "
"given partition type. ESP-IDF currently only specifies the meaning of the subtype field for ``app`` and ``data`` partition types.

See enum :cpp:type:`esp_partition_subtype_t` for the full list of subtypes defined by ESP-IDF, including the following:

  - ``factory`` (0x00) is the default app partition. The bootloader will execute the factory app unless there it sees a partition of type data/ota, in which case it reads this partition to determine which OTA image to boot.

    - OTA never updates"
" the factory partition.
    - If you want to conserve flash usage in an OTA project, you can remove the factory partition and use ``ota_0`` instead.

  - ``ota_0`` (0x10) ... ``ota_15`` (0x1F) are the OTA app slots. When :doc:`OTA ` is in use, the OTA data partition configures which app slot the bootloader should boot. When using OTA, an application should have at least two OTA application slots (``ota_0`` & ``ota_1``). Refer to the :doc:`OTA documentation ` for more details.
  - ``test`` (0x20)"
" is a reserved subtype for factory test procedures. It will be used as the fallback boot partition if no other valid app partition is found. It is also possible to configure the bootloader to read a GPIO input during each boot, and boot this partition if the GPIO is held low, see :ref:`bootloader_boot_from_test_firmware`.

  - ``ota`` (0) is the :ref:`OTA data partition ` which stores information about the currently selected OTA app slot. This partition should be 0x2000 bytes in size. Refer to t"
"he :ref:`OTA documentation ` for more details.
  - ``phy`` (1) is for storing PHY initialisation data. This allows PHY to be configured per-device, instead of in firmware.

    - In the default configuration, the phy partition is not used and PHY initialisation data is compiled into the app itself. As such, this partition can be removed from the partition table to save space.
    - To load PHY data from this partition, open the project configuration menu (``idf.py menuconfig``) and enable {IDF_T"
"ARGET_ESP_PHY_REF} option. You will also need to flash your devices with phy init data as the esp-idf build system does not do this automatically.
  - ``nvs`` (2) is for the :doc:`Non-Volatile Storage (NVS) API `.

    - NVS is used to store per-device PHY calibration data (different to initialisation data).

    .. only:: SOC_WIFI_SUPPORTED

        - NVS is used to store Wi-Fi data if the :doc:`esp_wifi_set_storage(WIFI_STORAGE_FLASH) ` initialization function is used.

    - The NVS API can a"
"lso be used for other application data.
    - It is strongly recommended that you include an NVS partition of at least 0x3000 bytes in your project.
    - If using NVS API to store a lot of data, increase the NVS partition size from the default 0x6000 bytes.
  - ``nvs_keys`` (4) is for the NVS key partition. See :doc:`Non-Volatile Storage (NVS) API ` for more details.

    - It is used to store NVS encryption keys when `NVS Encryption` feature is enabled.
    - The size of this partition should "
"be 4096 bytes (minimum partition size).

  - There are other predefined data subtypes for data storage supported by ESP-IDF. These include:

    - ``coredump`` (0x03) is for storing core dumps while using a custom partition table CSV file. See :doc:`/api-guides/core_dump` for more details.
    - ``efuse`` (0x05) is for emulating eFuse bits using :ref:`virtual-efuses`.
    - ``undefined`` (0x06) is implicitly used for data partitions with unspecified (empty) subtype, but it is possible to explici"
"tly mark them as undefined as well.
    - ``fat`` (0x81) is for :doc:`/api-reference/storage/fatfs`.
    - ``spiffs`` (0x82) is for :doc:`/api-reference/storage/spiffs`.
    - ``littlefs`` (0x83) is for `LittleFS filesystem `_. See :example:`storage/littlefs` example for more details.

.. Comment: ``esphttpd`` (0x80) was not added to the list because there is no docs section for it and it is not clear whether user should use it explicitly.

  Other subtypes of ``data`` type are reserved for futu"
"re ESP-IDF uses.

  Note that when writing in C++, an application-defined subtype value requires casting to type :cpp:type:`esp_partition_subtype_t` in order to use it with the :ref:`partition API `.

Extra Partition SubTypes
~~~~~~~~~~~~~~~~~~~~~~~~

A component can define a new partition subtype by setting the ``EXTRA_PARTITION_SUBTYPES`` property. This property is a CMake list, each entry of which is a comma separated string with ``, , `` format. The build system uses this property to add ext"
"ra subtypes and creates fields named ``ESP_PARTITION_SUBTYPE__`` in :cpp:type:`esp_partition_subtype_t`. The project can use this subtype to define partitions in the partitions table CSV file and use the new fields in :cpp:type:`esp_partition_subtype_t`.

.. _partition-offset-and-size:

Offset & Size
~~~~~~~~~~~~~

.. list::

    - The offset represents the partition address in the SPI flash, which sector size is 0x1000 (4 KB). Thus, the offset must be a multiple of 4 KB.
    - Partitions with b"
"lank offsets in the CSV file will start after the previous partition, or after the partition table in the case of the first partition.
    - Partitions of type ``app`` have to be placed at offsets aligned to 0x10000 (64 KB). If you leave the offset field blank, ``gen_esp32part.py`` will automatically align the partition. If you specify an unaligned offset for an ``app`` partition, the tool will return an error.
    - Partitions of type ``app`` should have the size aligned to the flash sector siz"
"e (4 KB). If you specify an unaligned size for an ``app`` partition, the tool will return an error.
    :SOC_SECURE_BOOT_V1: - If Secure Boot V1 is enabled, then the partition of type ``app`` needs to have size aligned to 0x10000 (64 KB) boundary.
    - Sizes and offsets can be specified as decimal numbers, hex numbers with the prefix 0x, or size multipliers K or M (1024 and 1024*1024 bytes).

If you want the partitions in the partition table to work relative to any placement (:ref:`CONFIG_PARTI"
"TION_TABLE_OFFSET`) of the table itself, leave the offset field (in CSV file) for all partitions blank. Similarly, if changing the partition table offset then be aware that all blank partition offsets may change to match, and that any fixed offsets may now collide with the partition table (causing an error).

Flags
~~~~~

Two flags are currently supported, ``encrypted`` and ``readonly``:

  - If ``encrypted`` flag is set, the partition will be encrypted if :doc:`/security/flash-encryption` is en"
"abled.

  .. note::

      ``app`` type partitions will always be encrypted, regardless of whether this flag is set or not.

  - If ``readonly`` flag is set, the partition will be read-only. This flag is only supported for ``data`` type partitions except ``ota subtypes. This flag can help to protect against accidental writes to a partition that contains critical device-specific configuration data, e.g., factory data partition.

  .. note::

      Using C file I/O API to open a file (``fopen```) "
"in any write mode (``w``, ``w+``, ``a``, ``a+``, ``r+``) will fail and return ``NULL``. Using ``open`` with any other flag than ``O_RDONLY`` will fail and return ``-1`` while ``errno`` global variable will be set to ``EROFS``. This is also true for any other POSIX syscall function performing write or erase operations. Opening a handle in read-write mode for NVS on a read-only partition will fail and return :c:macro:`ESP_ERR_NOT_ALLOWED` error code. Using a lower level API like ``esp_partition``,"
" ``spi_flash``, etc. to write to a read-only partition will result in :c:macro:`ESP_ERR_NOT_ALLOWED` error code.

You can specify multiple flags by separating them with a colon. For example, ``encrypted:readonly``.

Generating Binary Partition Table


The partition table which is flashed to the {IDF_TARGET_NAME} is in a binary format, not CSV. The tool :component_file:`partition_table/gen_esp32part.py` is used to convert between CSV and binary formats.

If you configure the partition table CSV n"
"ame in the project configuration (``idf.py menuconfig``) and then build the project or run ``idf.py partition-table``, this conversion is done as part of the build process.

To convert CSV to Binary manually::

  python gen_esp32part.py input_partitions.csv binary_partitions.bin

To convert binary format back to CSV manually::

  python gen_esp32part.py binary_partitions.bin input_partitions.csv

To display the contents of a binary partition table on stdout (this is how the summaries displayed w"
"hen running ``idf.py partition-table`` are generated::

  python gen_esp32part.py binary_partitions.bin

Partition Size Checks


The ESP-IDF build system will automatically check if generated binaries fit in the available partition space, and will fail with an error if a binary is too large.

Currently these checks are performed for the following binaries:

.. note::

   Although the build process will fail if the size check returns an error, the binary files are still generated and can be flash"
"ed (although they may not work if they are too large for the available space.)

MD5 Checksum
~~~~~~~~~~~~

The binary format of the partition table contains an MD5 checksum computed based on the partition table. This checksum is used for checking the integrity of the partition table during the boot.

.. only:: esp32

    The MD5 checksum generation can be disabled by the ``--disable-md5sum`` option of ``gen_esp32part.py`` or by the :ref:`CONFIG_PARTITION_TABLE_MD5` option. This is useful for exa"
"mple when one :ref:`uses a bootloader from ESP-IDF before v3.1 ` which cannot process MD5 checksums and the boot fails with the error message ``invalid magic number 0xebeb``.

.. only:: not esp32

    The MD5 checksum generation can be disabled by the ``--disable-md5sum`` option of ``gen_esp32part.py`` or by the :ref:`CONFIG_PARTITION_TABLE_MD5` option.


Flashing the Partition Table


A manual flashing command is also printed as part of ``idf.py partition-table`` output.

.. note::

  Note that"
" updating the partition table does not erase data that may have been stored according to the old partition table. You can use ``idf.py erase-flash`` (or ``esptool.py erase_flash``) to erase the entire flash contents.


Partition Tool (``parttool.py``)


The component `partition_table` provides a tool :component_file:`parttool.py ` for performing partition-related operations on a target device. The following operations can be performed using the tool:

  - reading a partition and saving the conte"
"nts to a file (read_partition)
  - writing the contents of a file to a partition (write_partition)
  - erasing a partition (erase_partition)
  - retrieving info such as name, offset, size and flag (""encrypted"") of a given partition (get_partition_info)

The tool can either be imported and used from another Python script or invoked from shell script for users wanting to perform operation programmatically. This is facilitated by the tool's Python API and command-line interface, respectively.

Pyth"
"on API
~~~~~~~~~~~

Before anything else, make sure that the `parttool` module is imported.

.. code-block:: python

  import sys
  import os

  idf_path = os.environ[""IDF_PATH""]  # get value of IDF_PATH from environment
  parttool_dir = os.path.join(idf_path, ""components"", ""partition_table"")  # parttool.py lives in $IDF_PATH/components/partition_table

  sys.path.append(parttool_dir)  # this enables Python to find parttool module
  from parttool import *  # import all names inside parttool modu"
"le

The starting point for using the tool's Python API to do is create a `ParttoolTarget` object:

.. code-block:: python

  # Create a parttool.py target device connected on serial port /dev/ttyUSB1
  target = ParttoolTarget(""/dev/ttyUSB1"")

The created object can now be used to perform operations on the target device:

.. code-block:: python

  # Erase partition with name 'storage'
  target.erase_partition(PartitionName(""storage""))

  # Read partition with type 'data' and subtype 'spiffs' and "
"save to file 'spiffs.bin'
  target.read_partition(PartitionType(""data"", ""spiffs""), ""spiffs.bin"")

  # Write to partition 'factory' the contents of a file named 'factory.bin'
  target.write_partition(PartitionName(""factory""), ""factory.bin"")

  # Print the size of default boot partition
  storage = target.get_partition_info(PARTITION_BOOT_DEFAULT)
  print(storage.size)

The partition to operate on is specified using `PartitionName` or `PartitionType` or PARTITION_BOOT_DEFAULT. As the name implies,"
" these can be used to refer to partitions of a particular name, type-subtype combination, or the default boot partition.

More information on the Python API is available in the docstrings for the tool.

Command-line Interface
~~~~~~~~~~~~~~~~~~~~~~

The command-line interface of `parttool.py` has the following structure:

.. code-block:: bash

  parttool.py [command-args] [subcommand] [subcommand-args]

  - command-args - These are arguments that are needed for executing the main command (partto"
"ol.py), mostly pertaining to the target device
  - subcommand - This is the operation to be performed
  - subcommand-args - These are arguments that are specific to the chosen operation

.. code-block:: bash

  # Erase partition with name 'storage'
  parttool.py --port ""/dev/ttyUSB1"" erase_partition --partition-name=storage

  # Read partition with type 'data' and subtype 'spiffs' and save to file 'spiffs.bin'
  parttool.py --port ""/dev/ttyUSB1"" read_partition --partition-type=data --partition-s"
"ubtype=spiffs --output ""spiffs.bin""

  # Write to partition 'factory' the contents of a file named 'factory.bin'
  parttool.py --port ""/dev/ttyUSB1"" write_partition --partition-name=factory --input ""factory.bin""

  # Print the size of default boot partition
  parttool.py --port ""/dev/ttyUSB1"" get_partition_info --partition-boot-default --info size

More information can be obtained by specifying `--help` as argument:

.. code-block:: bash

  # Display possible subcommands and show main command ar"
"gument descriptions
  parttool.py --help

  # Show descriptions for specific subcommand arguments
  parttool.py [subcommand] --help

.. _secure boot: security/secure-boot-v1.rst
"
"Low Power Mode User Guide





The document has not been translated into English yet. In the meantime, please refer to the Chinese version.
"
"High Priority Interrupts




.. toctree::
   :maxdepth: 1

The Xtensa architecture supports 32 interrupts, divided over 7 priority levels from level 1 to 7, with level 7 being an non-maskable interrupt (NMI), plus an assortment of exceptions. On the {IDF_TARGET_NAME}, the :doc:`../api-reference/system/intr_alloc` can route most interrupt sources to these interrupts via the interrupt mux. Normally, interrupts are written in C, but ESP-IDF allows high-priority interrupts to be written in assembly "
"as well, resulting in very low interrupt latencies.

Interrupt Priorities


.. only:: esp32

  .. list-table::
      :header-rows: 1
      :widths: 20 30 50
      :align: center
        - Symbol
        - Remark
        - N/A
        - Exception and low priority interrupts, handled by ESP-IDF.
        - N/A
        - Medium priority interrupts, handled by ESP-IDF.
        - xt_highint4
        - High priority interrupt, free to use. [1]_
        - xt_highint5
        - Normally used by ESP-IDF d"
"ebug logic. [1]_
        - xt_nmi
        - Non-maskable interrupt, free to use.
        - xt_debugexception
        - Debug exception. Called on e.g., a BREAK instruction. [2]_

  .. [1] ESP-IDF debug logic can be configured to run on ``xt_highint4`` or ``xt_highint5`` in :ref:`CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL`. Bluetooth's interrupt can be configured to run on priority level 4 by enabling :ref:`CONFIG_BTDM_CTRL_HLI`. If :ref:`CONFIG_BTDM_CTRL_HLI` is enabled, ESP-IDF debug logic must be runni"
"ng on priority level 5 interrupt.
  .. [2] If :ref:`CONFIG_BTDM_CTRL_HLI` is enabled, ``xt_debugexception`` is used to fix the `live lock issue `_ in ESP32 ECO3.

.. only:: not esp32

  .. list-table::
      :header-rows: 1
      :widths: 20 30 50
      :align: center
        - Symbol
        - Remark
        - N/A
        - Exception and low priority interrupts, handled by ESP-IDF.
        - N/A
        - Medium priority interrupts, handled by ESP-IDF.
        - xt_highint4
        - Normally u"
"sed by ESP-IDF debug logic.
        - xt_highint5
        - High priority interrupts, free to use.
        - xt_nmi
        - Non-maskable interrupt, free to use.
        - xt_debugexception
        - Debug exception. Called on e.g., a BREAK instruction.

Using these symbols is done by creating an assembly file with suffix ``.S`` and defining the named symbols, like this:

.. code-block:: none

        .section .iram1,""ax""
        .global     xt_highint5
        .type       xt_highint5,@function"
"
        .align      4
    xt_highint5:
        ... your code here
        rsr     a0, EXCSAVE_5
        rfi     5

For a real-life example, see the :component_file:`esp_system/port/soc/{IDF_TARGET_PATH_NAME}/highint_hdl.S` file; the panic handler interrupt is implemented there.


Notes


- Do not call C code from a high-priority interrupt; as these interrupts are run from a critical section, this can cause the target to crash. Note that although the panic handler interrupt does call normal C co"
"de, this exception is allowed due to the fact that this handler never returns (i.e., the application does not continue to run after the panic handler), so breaking C code execution flow is not a problem.

.. only:: esp32

  When :ref:`CONFIG_BTDM_CTRL_HLI` is enabled, C code is also called from a high-priority interrupt, this is possible thanks to some additional protection added to it.

- Make sure your assembly code gets linked in. Indeed, as the free-to-use symbols are declared as weak, the l"
"inker may discard the file containing the symbol. This happens if the only symbol defined, or used from the user file is the ``xt_*`` free-to-use symbol. To avoid this, in the assembly file containing the ``xt_*`` symbol, define another symbol, like:

.. code-block:: none

  .global ld_include_my_isr_file
  ld_include_my_isr_file:

Here it is called ``ld_include_my_isr_file`` but can have any name, as long as it is not defined anywhere else in the project.

Then, in the component ``CMakeLists.tx"
"t``, add this name as an unresolved symbol to the ld command line arguments:

.. code-block:: none

  target_link_libraries(${COMPONENT_TARGET} ""-u ld_include_my_isr_file"")

This will ensure the linker to always includes the file defining ``ld_include_my_isr_file``, so that the ISR is always linked.

- High-priority interrupts can be routed and handled using :cpp:func:`esp_intr_alloc` and associated functions. The handler and handler arguments to :cpp:func:`esp_intr_alloc` must be NULL, however."
"

- In theory, medium priority interrupts could also be handled in this way. ESP-IDF does not support this yet.

- To check Xtensa instruction set architecture (ISA), please refer to `Xtensa ISA Summary `_.
"
"lwIP




ESP-IDF uses the open source `lwIP lightweight TCP/IP stack`_. The ESP-IDF version of lwIP (`esp-lwip`_) has some modifications and additions compared to the upstream project.

Supported APIs


ESP-IDF supports the following lwIP TCP/IP stack functions:

- `BSD Sockets API`_
- `Netconn API`_ is enabled but not officially supported for ESP-IDF applications

.. _lwip-dns-limitation:

Adapted APIs


    .. warning::

        When using any lwIP API other than the `BSD Sockets API`_, please"
" make sure that the API is thread-safe. To check if a given API call is thread-safe, enable the :ref:`CONFIG_LWIP_CHECK_THREAD_SAFETY` configuration option and run the application. This enables lwIP to assert the correct access of the TCP/IP core functionality. If the API is not accessed or locked properly from the appropriate `lwIP FreeRTOS Task`_, the execution will be aborted. The general recommendation is to use the :doc:`/api-reference/network/esp_netif` component to interact with lwIP.

So"
"me common lwIP app APIs are supported indirectly by ESP-IDF:

- Dynamic Host Configuration Protocol (DHCP) Server & Client are supported indirectly via the :doc:`/api-reference/network/esp_netif` functionality.
- Domain Name System (DNS) is supported in lwIP; DNS servers could be assigned automatically when acquiring a DHCP address, or manually configured using the :doc:`/api-reference/network/esp_netif` API.

.. note::

    DNS server configuration in lwIP is global, not interface-specific. If "
"you are using multiple network interfaces with distinct DNS servers, exercise caution to prevent inadvertent overwrites of one interface's DNS settings when acquiring a DHCP lease from another interface.

- Simple Network Time Protocol (SNTP) is also supported via the :doc:`/api-reference/network/esp_netif`, or directly via the :component_file:`lwip/include/apps/esp_sntp.h` functions, which also provide thread-safe API to :component_file:`lwip/lwip/src/include/lwip/apps/sntp.h` functions, see al"
"so :ref:`system-time-sntp-sync`.
- ICMP Ping is supported using a variation on the lwIP ping API, see :doc:`/api-reference/protocols/icmp_echo`.
- ICMPv6 Ping, supported by lwIP's ICMPv6 Echo API, is used to test IPv6 network connectivity. For more information, see :example:`protocols/sockets/icmpv6_ping`.
- NetBIOS lookup is available using the standard lwIP API. :example:`protocols/http_server/restful_server` has the option to demonstrate using NetBIOS to look up a host on the LAN.
- mDNS uses"
" a different implementation to the lwIP default mDNS, see :doc:`/api-reference/protocols/mdns`. But lwIP can look up mDNS hosts using standard APIs such as ``gethostbyname()`` and the convention ``hostname.local``, provided the :ref:`CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES` setting is enabled.
- The PPP implementation in lwIP can be used to create PPPoS (PPP over serial) interface in ESP-IDF. Please refer to the documentation of the :doc:`/api-reference/network/esp_netif` component to create and co"
"nfigure a PPP network interface, by means of the ``ESP_NETIF_DEFAULT_PPP()`` macro defined in :component_file:`esp_netif/include/esp_netif_defaults.h`. Additional runtime settings are provided via :component_file:`esp_netif/include/esp_netif_ppp.h`. PPPoS interfaces are typically used to interact with NBIoT/GSM/LTE modems. More application-level friendly API is supported by the `esp_modem `_ library, which uses this PPP lwIP module behind the scenes.

BSD Sockets API


The BSD Sockets API is a c"
"ommon cross-platform TCP/IP sockets API that originated in the Berkeley Standard Distribution of UNIX but is now standardized in a section of the POSIX specification. BSD Sockets are sometimes called POSIX Sockets or Berkeley Sockets.

As implemented in ESP-IDF, lwIP supports all of the common usages of the BSD Sockets API.

References


A wide range of BSD Sockets reference materials are available, including:

- `Single UNIX Specification - BSD Sockets page `_
- `Berkeley Sockets - Wikipedia pa"
"ge `_

Examples


A number of ESP-IDF examples show how to use the BSD Sockets APIs:

- :example:`protocols/sockets/tcp_server`
- :example:`protocols/sockets/tcp_client`
- :example:`protocols/sockets/udp_server`
- :example:`protocols/sockets/udp_client`
- :example:`protocols/sockets/udp_multicast`
- :example:`protocols/http_request`: this simplified example uses a TCP socket to send an HTTP request, but :doc:`/api-reference/protocols/esp_http_client` is a much better option for sending HTTP requ"
"ests

Supported Functions


The following BSD socket API functions are supported. For full details, see :component_file:`lwip/lwip/src/include/lwip/sockets.h`.

- ``socket()``
- ``bind()``
- ``accept()``
- ``shutdown()``
- ``getpeername()``
- ``getsockopt()`` & ``setsockopt()``: see `Socket Options`_
- ``close()``: via :doc:`/api-reference/storage/vfs`
- ``read()``, ``readv()``, ``write()``, ``writev()``: via :doc:`/api-reference/storage/vfs`
- ``recv()``, ``recvmsg()``, ``recvfrom()``
- ``send("
")``, ``sendmsg()``, ``sendto()``
- ``select()``: via :doc:`/api-reference/storage/vfs`
- ``poll()`` : on ESP-IDF, ``poll()`` is implemented by calling ``select()`` internally, so using ``select()`` directly is recommended, if a choice of methods is available
- ``fcntl()``: see `fcntl()`_

Non-standard functions:

- ``ioctl()``: see `ioctl()`_

.. note::

  Some lwIP application sample code uses prefixed versions of BSD APIs, e.g., ``lwip_socket()``, instead of the standard ``socket()``. Both for"
"ms can be used with ESP-IDF, but using standard names is recommended.

Socket Error Handling


BSD Socket error handling code is very important for robust socket applications. Normally, socket error handling involves the following aspects:

- Detecting the error
- Getting the error reason code
- Handling the error according to the reason code

In lwIP, we have two different scenarios for handling socket errors:

- Socket API returns an error. For more information, see `Socket API Errors`_.
- ``s"
"elect(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout)`` has an exception descriptor indicating that the socket has an error. For more information, see `select() Errors`_.

Socket API Errors
+++++++++++++++++

**Error detection**

  - We can know that the socket API fails according to its return value.

**Get the error reason code**

  - When socket API fails, the return value does not contain the failure reason and the application can get the error rea"
"son code by accessing ``errno``. Different values indicate different meanings. For more information, see `Socket Error Reason Code`_.

Example:

.. code-block::

        int err;
        int sockfd;

        if (sockfd = socket(AF_INET,SOCK_STREAM,0) `_ and the platform-specific extensions :component_file:`newlib/platform_include/errno.h`.

.. list-table::
    :header-rows: 1
    :widths: 50 50
    :align: center
      - Description
      - Connection refused
      - Address already in use
     "
" - Software caused connection abort
      - Network is unreachable
      - Network interface is not configured
      - Connection timed out
      - Host is down
      - Host is unreachable
      - Connection already in progress
      - Socket already connected
      - Destination address required
      - Unknown protocol

Socket Options


The ``getsockopt()`` and ``setsockopt()`` functions allow getting and setting per-socket options respectively.

Not all standard socket options are supported b"
"y lwIP in ESP-IDF. The following socket options are supported:

Common Options
++++++++++++++

Used with level argument ``SOL_SOCKET``.

- ``SO_REUSEADDR``: available if :ref:`CONFIG_LWIP_SO_REUSE` is set, whose behavior can be customized by setting :ref:`CONFIG_LWIP_SO_REUSE_RXTOALL`
- ``SO_KEEPALIVE``
- ``SO_BROADCAST``
- ``SO_ACCEPTCONN``
- ``SO_RCVBUF``: available if :ref:`CONFIG_LWIP_SO_RCVBUF` is set
- ``SO_SNDTIMEO`` / ``SO_RCVTIMEO``
- ``SO_ERROR``: only used with ``select()``, see `Sock"
"et Error Handling`_
- ``SO_TYPE``
- ``SO_NO_CHECK``: for UDP sockets only

IP Options
++++++++++

Used with level argument ``IPPROTO_IP``.

- ``IP_TOS``
- ``IP_TTL``
- ``IP_PKTINFO``: available if :ref:`CONFIG_LWIP_NETBUF_RECVINFO` is set

For multicast UDP sockets:

- ``IP_MULTICAST_IF``
- ``IP_MULTICAST_LOOP``
- ``IP_MULTICAST_TTL``
- ``IP_ADD_MEMBERSHIP``
- ``IP_DROP_MEMBERSHIP``

TCP Options
+++++++++++

TCP sockets only. Used with level argument ``IPPROTO_TCP``.

- ``TCP_NODELAY``

Options "
"relating to TCP keepalive probes:

- ``TCP_KEEPALIVE``: int value, TCP keepalive period in milliseconds
- ``TCP_KEEPIDLE``: same as ``TCP_KEEPALIVE``, but the value is in seconds
- ``TCP_KEEPINTVL``: int value, the interval between keepalive probes in seconds
- ``TCP_KEEPCNT``: int value, number of keepalive probes before timing out

IPv6 Options
++++++++++++

IPv6 sockets only. Used with level argument ``IPPROTO_IPV6``.

- ``IPV6_CHECKSUM``
- ``IPV6_V6ONLY``

For multicast IPv6 UDP sockets:

- "
"``IPV6_JOIN_GROUP`` / ``IPV6_ADD_MEMBERSHIP``
- ``IPV6_LEAVE_GROUP`` / ``IPV6_DROP_MEMBERSHIP``
- ``IPV6_MULTICAST_IF``
- ``IPV6_MULTICAST_HOPS``
- ``IPV6_MULTICAST_LOOP``

``fcntl()``


The ``fcntl()`` function is a standard API for manipulating options related to a file descriptor. In ESP-IDF, the :doc:`/api-reference/storage/vfs` layer is used to implement this function.

When the file descriptor is a socket, only the following ``fcntl()`` values are supported:

- ``O_NONBLOCK`` to set or cle"
"ar non-blocking I/O mode. Also supports ``O_NDELAY``, which is identical to ``O_NONBLOCK``.
- ``O_RDONLY``, ``O_WRONLY``, ``O_RDWR`` flags for different read or write modes. These flags can only be read using ``F_GETFL``, and cannot be set using ``F_SETFL``. A TCP socket returns a different mode depending on whether the connection has been closed at either end or is still open at both ends. UDP sockets always return ``O_RDWR``.

``ioctl()``


The ``ioctl()`` function provides a semi-standard way"
" to access some internal features of the TCP/IP stack. In ESP-IDF, the :doc:`/api-reference/storage/vfs` layer is used to implement this function.

When the file descriptor is a socket, only the following ``ioctl()`` values are supported:

- ``FIONREAD`` returns the number of bytes of the pending data already received in the socket's network buffer.
- ``FIONBIO`` is an alternative way to set/clear non-blocking I/O status for a socket, equivalent to ``fcntl(fd, F_SETFL, O_NONBLOCK, ...)``.

Netco"
"nn API


lwIP supports two lower-level APIs as well as the BSD Sockets API: the Netconn API and the Raw API.

The lwIP Raw API is designed for single-threaded devices and is not supported in ESP-IDF.

The Netconn API is used to implement the BSD Sockets API inside lwIP, and it can also be called directly from ESP-IDF apps. This API has lower resource usage than the BSD Sockets API. In particular, it can send and receive data without firstly copying it into internal lwIP buffers.

.. important::
"
"
  Espressif does not test the Netconn API in ESP-IDF. As such, this functionality is **enabled but not supported**. Some functionality may only work correctly when used from the BSD Sockets API.

For more information about the Netconn API, consult `lwip/lwip/src/include/lwip/api.h `_ and `part of the **unofficial** lwIP Application Developers Manual `_.

lwIP FreeRTOS Task


lwIP creates a dedicated TCP/IP FreeRTOS task to handle socket API requests from other tasks.

A number of configuration "
"items are available to modify the task and the queues (mailboxes) used to send data to/from the TCP/IP task:

- :ref:`CONFIG_LWIP_TCPIP_RECVMBOX_SIZE`
- :ref:`CONFIG_LWIP_TCPIP_TASK_STACK_SIZE`
- :ref:`CONFIG_LWIP_TCPIP_TASK_AFFINITY`

IPv6 Support


Both IPv4 and IPv6 are supported in a dual-stack configuration and are enabled by default. Both IPv6 and IPv4 may be disabled separately if they are not needed, see :ref:`lwip-ram-usage`.

IPv6 support is limited to **Stateless Autoconfiguration** o"
"nly. **Stateful configuration** is not supported in ESP-IDF, nor in upstream lwIP.

IPv6 Address configuration is defined by means of these protocols or services:

- **SLAAC** IPv6 Stateless Address Autoconfiguration (RFC-2462)
- **DHCPv6** Dynamic Host Configuration Protocol for IPv6 (RFC-8415)

None of these two types of address configuration is enabled by default, so the device uses only Link Local addresses or statically-defined addresses.

.. _lwip-ivp6-autoconfig:

Stateless Autoconfigurat"
"ion Process


To enable address autoconfiguration using the Router Advertisement protocol, please enable:

- :ref:`CONFIG_LWIP_IPV6_AUTOCONFIG`

This configuration option enables IPv6 autoconfiguration for all network interfaces, which differs from the upstream lwIP behavior, where the autoconfiguration needs to be explicitly enabled for each ``netif`` with ``netif->ip6_autoconfig_enabled=1``.

.. _lwip-ivp6-dhcp6:

DHCPv6


DHCPv6 in lwIP is very simple and supports only stateless configuration"
". It could be enabled using:

- :ref:`CONFIG_LWIP_IPV6_DHCP6`

Since the DHCPv6 works only in its stateless configuration, the :ref:`lwip-ivp6-autoconfig` has to be enabled as well via :ref:`CONFIG_LWIP_IPV6_AUTOCONFIG`.

Moreover, the DHCPv6 needs to be explicitly enabled from the application code using:

.. code-block::

    dhcp6_enable_stateless(netif);

DNS Servers in IPv6 Autoconfiguration


In order to autoconfigure DNS server(s), especially in IPv6-only networks, we have these two option"
"s:

- Recursive Domain Name System (DNS): this belongs to the Neighbor Discovery Protocol (NDP) and uses :ref:`lwip-ivp6-autoconfig`.

  The number of servers must be set :ref:`CONFIG_LWIP_IPV6_RDNSS_MAX_DNS_SERVERS`, this option is disabled by default, i.e., set to 0.

- DHCPv6 stateless configuration, uses :ref:`lwip-ivp6-dhcp6` to configure DNS servers. Note that this configuration assumes IPv6 Router Advertisement Flags (RFC-5175) to be set to

    - Managed Address Configuration Flag = 0
  "
"  - Other Configuration Flag = 1

ESP-lwIP Custom Modifications


Additions


The following code is added, which is not present in the upstream lwIP release:

Thread-Safe Sockets
+++++++++++++++++++

It is possible to ``close()`` a socket from a different thread than the one that created it. The ``close()`` call blocks, until any function calls currently using that socket from other tasks have returned.

It is, however, not possible to delete a task while it is actively waiting on ``select()`` o"
"r ``poll()`` APIs. It is always necessary that these APIs exit before destroying the task, as this might corrupt internal structures and cause subsequent crashes of the lwIP. These APIs allocate globally referenced callback pointers on the stack so that when the task gets destroyed before unrolling the stack, the lwIP could still hold pointers to the deleted stack.

On-Demand Timers
++++++++++++++++

lwIP IGMP and MLD6 feature both initialize a timer in order to trigger timeout events at certain"
" times.

The default lwIP implementation is to have these timers enabled all the time, even if no timeout events are active. This increases CPU usage and power consumption when using automatic Light-sleep mode. ``ESP-lwIP`` default behavior is to set each timer ``on demand``, so it is only enabled when an event is pending.

To return to the default lwIP behavior, which is always-on timers, disable :ref:`CONFIG_LWIP_TIMERS_ONDEMAND`.

lwIP Timers API
+++++++++++++++

When not using Wi-Fi, the lwI"
"P timer can be turned off via the API to reduce power consumption.

The following API functions are supported. For full details, see :component_file:`lwip/lwip/src/include/lwip/timeouts.h`.

- ``sys_timeouts_init()``
- ``sys_timeouts_deinit()``

Additional Socket Options
+++++++++++++++++++++++++

- Some standard IPV4 and IPV6 multicast socket options are implemented, see `Socket Options`_.

- Possible to set IPV6-only UDP and TCP sockets with ``IPV6_V6ONLY`` socket option, while normal lwIP is "
"TCP-only.

IP Layer Features
+++++++++++++++++

- IPV4-source-based routing implementation is different

- IPV4-mapped IPV6 addresses are supported

NAPT and Port Forwarding
++++++++++++++++++++++++

IPV4 network address port translation (NAPT) and port forwarding are supported. However, the enabling of NAPT is limited to a single interface.

- To use NAPT for forwarding packets between two interfaces, it needs to be enabled on the interface connecting to the target network. For example, to enab"
"le internet access for Ethernet traffic through the Wi-Fi interface, NAPT must be enabled on the Ethernet interface.
- Usage of NAPT is demonstrated in :example:`network/vlan_support`.

.. _lwip-custom-hooks:

Customized lwIP Hooks
+++++++++++++++++++++

The original lwIP supports implementing custom compile-time modifications via ``LWIP_HOOK_FILENAME``. This file is already used by the ESP-IDF port layer, but ESP-IDF users could still include and implement any custom additions via a header file"
" defined by the macro ``ESP_IDF_LWIP_HOOK_FILENAME``. Here is an example of adding a custom hook file to the build process, and the hook is called ``my_hook.h``, located in the project's ``main`` folder:

.. code-block:: cmake

   idf_component_get_property(lwip lwip COMPONENT_LIB)
   target_compile_options(${lwip} PRIVATE ""-I${PROJECT_DIR}/main"")
   target_compile_definitions(${lwip} PRIVATE ""-DESP_IDF_LWIP_HOOK_FILENAME=\""my_hook.h\"""")

Customized lwIP Options From ESP-IDF Build System
+++++++"
"+++++++++++++++++++++++++++++++++++++++++++

The most common lwIP options are configurable through the component configuration menu. However, certain definitions need to be injected from the command line. The CMake function ``target_compile_definitions()`` can be employed to define macros, as illustrated below:

.. code-block:: cmake

   idf_component_get_property(lwip lwip COMPONENT_LIB)
   target_compile_definitions(${lwip} PRIVATE ""-DETHARP_SUPPORT_VLAN=1"")

This approach may not work for fun"
"ction-like macros, as there is no guarantee that the definition will be accepted by all compilers, although it is supported in GCC. To address this limitation, the ``add_definitions()`` function can be utilized to define the macro for the entire project, for example: ``add_definitions(""-DFALLBACK_DNS_SERVER_ADDRESS(addr)=\""IP_ADDR4((addr), 8,8,8,8)\"""")``.

Alternatively, you can define your function-like macro in a header file which will be pre-included as an lwIP hook file, see :ref:`lwip-custo"
"m-hooks`.

Limitations


ESP-IDF additions to lwIP still suffer from the global DNS limitation, described in :ref:`lwip-dns-limitation`. To address this limitation from application code, the ``FALLBACK_DNS_SERVER_ADDRESS()`` macro can be utilized to define a global DNS fallback server accessible from all interfaces. Alternatively, you have the option to maintain per-interface DNS servers and reconfigure them whenever the default interface changes.

Calling ``send()`` or ``sendto()`` repeatedly o"
"n a UDP socket may eventually fail with ``errno`` equal to ``ENOMEM``. This failure occurs due to the limitations of buffer sizes in the lower-layer network interface drivers. If all driver transmit buffers are full, the UDP transmission will fail. For applications that transmit a high volume of UDP datagrams and aim to avoid any dropped datagrams by the sender, it is advisable to implement error code checking and employ a retransmission mechanism with a short delay.

.. only:: esp32

    Increa"
"sing the number of TX buffers in the :ref:`Wi-Fi ` or :ref:`Ethernet ` project configuration as applicable may also help.

.. only:: not esp32 and SOC_WIFI_SUPPORTED

    Increasing the number of TX buffers in the :ref:`Wi-Fi ` project configuration may also help.

.. _lwip-performance:

Performance Optimization


TCP/IP performance is a complex subject, and performance can be optimized toward multiple goals. The default settings of ESP-IDF are tuned for a compromise between throughput, latency,"
" and moderate memory usage.

Maximum Throughput


Espressif tests ESP-IDF TCP/IP throughput using the iperf test application: https://iperf.fr/, please refer to :ref:`improve-network-speed` for more details about the actual testing and using the optimized configuration.

.. important::

  Suggest applying changes a few at a time and checking the performance each time with a particular application workload.

- If a lot of tasks are competing for CPU time on the system, consider that the lwIP task"
" has configurable CPU affinity (:ref:`CONFIG_LWIP_TCPIP_TASK_AFFINITY`) and runs at fixed priority (18, ``ESP_TASK_TCPIP_PRIO``). To optimize CPU utilization, consider assigning competing tasks to different cores or adjusting their priorities to lower values. For additional details on built-in task priorities, please refer to :ref:`built-in-task-priorities`.

- If using ``select()`` function with socket arguments only, disabling :ref:`CONFIG_VFS_SUPPORT_SELECT` will make ``select()`` calls faste"
"r.

- If there is enough free IRAM, select :ref:`CONFIG_LWIP_IRAM_OPTIMIZATION` and :ref:`CONFIG_LWIP_EXTRA_IRAM_OPTIMIZATION` to improve TX/RX throughput.

.. only:: SOC_WIFI_SUPPORTED

    If using a Wi-Fi network interface, please also refer to :ref:`wifi-buffer-usage`.

Minimum Latency


Except for increasing buffer sizes, most changes that increase throughput also decrease latency by reducing the amount of CPU time spent in lwIP functions.

- For TCP sockets, lwIP supports setting the stand"
"ard ``TCP_NODELAY`` flag to disable Nagle's algorithm.

.. _lwip-ram-usage:

Minimum RAM Usage


Most lwIP RAM usage is on-demand, as RAM is allocated from the heap as needed. Therefore, changing lwIP settings to reduce RAM usage may not change RAM usage at idle, but can change it at peak.

- Reducing :ref:`CONFIG_LWIP_MAX_SOCKETS` reduces the maximum number of sockets in the system. This also causes TCP sockets in the ``WAIT_CLOSE`` state to be closed and recycled more rapidly when needed to op"
"en a new socket, further reducing peak RAM usage.
- Reducing :ref:`CONFIG_LWIP_TCPIP_RECVMBOX_SIZE`, :ref:`CONFIG_LWIP_TCP_RECVMBOX_SIZE` and :ref:`CONFIG_LWIP_UDP_RECVMBOX_SIZE` reduce RAM usage at the expense of throughput, depending on usage.
- Reducing :ref:`CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE` reduce RAM usage by limiting concurrent accepted connections.
- Reducing :ref:`CONFIG_LWIP_TCP_MSL` and :ref:`CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT` reduces the maximum segment lifetime in the system. This als"
"o causes TCP sockets in the ``TIME_WAIT`` and ``FIN_WAIT_2`` states to be closed and recycled more rapidly.
- Disabling :ref:`CONFIG_LWIP_IPV6` can save about 39 KB for firmware size and 2 KB RAM when the system is powered up and 7 KB RAM when the TCP/IP stack is running. If there is no requirement for supporting IPV6, it can be disabled to save flash and RAM footprint.
- Disabling :ref:`CONFIG_LWIP_IPV4` can save about 26 KB of firmware size and 600 B RAM on power up and 6 KB RAM when the TCP/I"
"P stack is running. If the local network supports IPv6-only configuration, IPv4 can be disabled to save flash and RAM footprint.

.. only:: SOC_WIFI_SUPPORTED

    If using Wi-Fi, please also refer to :ref:`wifi-buffer-usage`.


Peak Buffer Usage
+++++++++++++++++

The peak heap memory that lwIP consumes is the **theoretically-maximum memory** that the lwIP driver consumes. Generally, the peak heap memory that lwIP consumes depends on:

 - the memory required to create a UDP connection: ``lwip_u"
"dp_conn``
 - the memory required to create a TCP connection: ``lwip_tcp_conn``
 - the number of UDP connections that the application has: ``lwip_udp_con_num``
 - the number of TCP connections that the application has: ``lwip_tcp_con_num``
 - the TCP TX window size: ``lwip_tcp_tx_win_size``
 - the TCP RX window size: ``lwip_tcp_rx_win_size``

**So, the peak heap memory that the lwIP consumes can be calculated with the following formula:**
  lwip_dynamic_peek_memory =  (lwip_udp_con_num * lwip_udp"
"_conn)  + (lwip_tcp_con_num * (lwip_tcp_tx_win_size + lwip_tcp_rx_win_size + lwip_tcp_conn))

Some TCP-based applications need only one TCP connection. However, they may choose to close this TCP connection and create a new one when an error occurs (e.g., a sending failure). This may result in multiple TCP connections existing in the system simultaneously, because it may take a long time for a TCP connection to close, according to the TCP state machine, refer to RFC793.


.. _lwIP lightweight TCP"
"/IP stack: https://savannah.nongnu.org/projects/lwip/
.. _esp-lwip: https://github.com/espressif/esp-lwip
"
"C Support




.. highlight:: cpp

ESP-IDF is primarily written in C and provides C APIs. `Newlib `_ is used as standard C library (the Newlib version can be found in :component_file:`newlib/sbom.yml`). In general, all C features supported by the compiler, currently GCC, should be available in ESP-IDF, unless specified in :ref:`unsupported_c_features` below.

.. _c_version:

C Version


**GNU dialect of ISO C17** (``--std=gnu17``) is the current default C version in ESP-IDF.

To compile the sourc"
"e code of a certain component using a different language standard, set the desired compiler flag in the component's ``CMakeLists.txt`` file:

.. code-block:: cmake

    idf_component_register( ... )
    target_compile_options(${COMPONENT_LIB} PRIVATE -std=gnu11)

If the public header files of the component also need to be compiled with the same language standard, replace the flag ``PRIVATE`` with ``PUBLIC``.

.. _unsupported_c_features:

Unsupported C Features


The following features are not su"
"pported in ESP-IDF.

Nested Function Pointers


The **GNU dialect of ISO C17** supports `nested functions `_. However, they do not work in ESP-IDF when referenced as function pointer because the compiler generates a trampoline on the stack, while the stack is not executable in ESP-IDF. Hence, do not use function pointers to nested functions.
"
"Core Dump




Overview


A core dump is a set of software state information that is automatically saved by the panic handler when a fatal error occurs. Core dumps are useful for conducting post-mortem analysis of the software's state at the moment of failure. ESP-IDF provides support for generating core dumps.

A core dump contains snapshots of all tasks in the system at the moment of failure, where each snapshot includes a task's control block (TCB) and stack. By analyzing the task snapshots, i"
"t is possible to find out what task, at what instruction (line of code), and what call stack of that task lead to the crash. It is also possible to dump the contents of variables on demand, provided those variables are assigned special core dump attributes.

Core dump data is saved to a core dump file according to a particular format, see :doc:`Core dump internals ` for more details. However, ESP-IDF's ``idf.py`` command provides special subcommands to decode and analyze the core dump file.


Co"
"nfigurations


Destination


The :ref:`CONFIG_ESP_COREDUMP_TO_FLASH_OR_UART` option enables or disables core dump, and selects the core dump destination if enabled. When a crash occurs, the generated core dump file can either be saved to flash, or output to a connected host over UART.


Format & Size


The :ref:`CONFIG_ESP_COREDUMP_DATA_FORMAT` option controls the format of the core dump file, namely ELF format or Binary format.

The ELF format contains extended features and allows more informat"
"ion regarding erroneous tasks and crashed software to be saved. However, using the ELF format causes the core dump file to be larger. This format is recommended for new software designs and is flexible enough to be extended in future revisions to save more information.

The Binary format is kept for compatibility reasons. Binary format core dump files are smaller while provide better performance.

The :ref:`CONFIG_ESP_COREDUMP_MAX_TASKS_NUM` option configures the number of task snapshots saved b"
"y the core dump.

Core dump data integrity checking is supported via the ``Components`` > ``Core dump`` > ``Core dump data integrity check`` option.

.. only:: esp32

    Data Integrity Check
    

    Core dump files include a checksum, which can be used to verify the integrity of the core dump file, i.e., the file has not been corrupted. The :ref:`CONFIG_ESP_COREDUMP_CHECKSUM` option controls the type of checksum, namely CRC32 or SHA256 (only supported in the ELF format).

    The CRC32 option"
" provides better calculation performance and consumes less memory for storage.

    The SHA256 hash algorithm provides a greater probability of detecting corruption than a CRC32 with multiple-bit errors.


Reserved Stack Size


Core dump routines run from a separate stack due to core dump itself needing to parse and save all other task stacks. The :ref:`CONFIG_ESP_COREDUMP_STACK_SIZE` option controls the size of the core dump's stack in number of bytes.

Setting this option to 0 bytes will cause"
" the core dump routines to run from the ISR stack, thus saving a bit of memory. Setting the option greater than zero will cause a separate stack to be instantiated.

.. note::

   If a separate stack is used, the recommended stack size should be larger than 800 bytes to ensure that the core dump routines themselves do not cause a stack overflow.


Core Dump to Flash


When the core dump file is saved to flash, the file is saved to a special core dump partition in flash. Specifying the core dump "
"partition will reserve space on the flash chip to store the core dump file.

The core dump partition is automatically declared when using the default partition table provided by ESP-IDF. However, when using a custom partition table, you need to declare the core dump partition, as illustrated below:

.. code-block:: none

    # Name,   Type, SubType, Offset,  Size
    # Note: if you have increased the bootloader size, make sure to update the offsets to avoid overlap
    nvs,      data, nvs,     0"
"x9000,  0x6000
    phy_init, data, phy,     0xf000,  0x1000
    factory,  app,  factory, 0x10000, 1M
    coredump, data, coredump,,        64K

.. important::

    If :doc:`../security/flash-encryption` is enabled on the device, please add an ``encrypted`` flag to the core dump partition declaration.

    .. code-block:: none

        coredump, data, coredump,,       64K, encrypted

There are no special requirements for the partition name. It can be chosen according to the application's needs, b"
"ut the partition type should be ``data`` and the sub-type should be ``coredump``. Also, when choosing partition size, note that the core dump file introduces a constant overhead of 20 bytes and a per-task overhead of 12 bytes. This overhead does not include the size of TCB and stack for every task. So the partition size should be at least ``20 + max tasks number x (12 + TCB size + max task stack size)`` bytes.

An example of the generic command to analyze core dump from flash is:

.. code-block:"
": bash

    idf.py coredump-info

or

.. code-block:: bash

    idf.py coredump-debug


Core Dump to UART


When the core dump file is output to UART, the output file is Base64-encoded. The :ref:`CONFIG_ESP_COREDUMP_DECODE` option allows for selecting whether the output file is automatically decoded by the ESP-IDF monitor or kept encoded for manual decoding.


Automatic Decoding


If :ref:`CONFIG_ESP_COREDUMP_DECODE` is set to automatically decode the UART core dump, ESP-IDF monitor will automat"
"ically decode the data, translate any function addresses to source code lines, and display it in the monitor. The output to ESP-IDF monitor would resemble the following output:

The :ref:`CONFIG_ESP_COREDUMP_UART_DELAY` allows for an optional delay to be added before the core dump file is output to UART.

.. code-block:: none

    
     ESP32 CORE DUMP START 

    Crashed task handle: 0x3ffafba0, name: 'main', GDB name: 'process 1073413024'
    Crashed task is not in the interrupt context
    Pa"
"nic reason: abort() was called at PC 0x400d66b9 on core 0

     CURRENT THREAD REGISTERS 
    exccause       0x1d (StoreProhibitedCause)
    excvaddr       0x0
    epc1           0x40084013
    epc2           0x0
    ...
     CURRENT THREAD STACK 
    #0  0x4008110d in panic_abort (details=0x3ffb4f0b ""abort() was called at PC 0x400d66b9 on core 0"") at /builds/espressif/esp-idf/components/esp_system/panic.c:472
    #1  0x4008510c in esp_system_abort (details=0x3ffb4f0b ""abort() was called at PC 0"
"x400d66b9 on core 0"") at /builds/espressif/esp-idf/components/esp_system/port/esp_system_chip.c:93
    ...
     THREADS INFO 
      Id   Target Id          Frame
      2    process 1073413368 vPortTaskWrapper (pxCode=0x0, pvParameters=0x0) at /builds/espressif/esp-idf/components/freertos/FreeRTOS-Kernel/portable/xtensa/port.c:133
    ...
           TCB             NAME PRIO C/B  STACK USED/FREE
       
    0x3ffafba0             main      1/1         368/3724
    0x3ffafcf8            IDLE0     "
" 0/0         288/1240
    0x3ffafe50            IDLE1      0/0         416/1108
    ...
     THREAD 1 (TCB: 0x3ffafba0, name: 'main') 
    #0  0x4008110d in panic_abort (details=0x3ffb4f0b ""abort() was called at PC 0x400d66b9 on core 0"") at /builds/espressif/esp-idf/components/esp_system/panic.c:472
    #1  0x4008510c in esp_system_abort (details=0x3ffb4f0b ""abort() was called at PC 0x400d66b9 on core 0"") at /builds/espressif/esp-idf/components/esp_system/port/esp_system_chip.c:93
    ...
     T"
"HREAD 2 (TCB: 0x3ffafcf8, name: 'IDLE0') 
    #0  vPortTaskWrapper (pxCode=0x0, pvParameters=0x0) at /builds/espressif/esp-idf/components/freertos/FreeRTOS-Kernel/portable/xtensa/port.c:133
    #1  0x40000000 in ?? ()
    ...
     ALL MEMORY REGIONS 
    Name   Address   Size   Attrs
    ...
    .iram0.vectors 0x40080000 0x403 R XA
    .iram0.text 0x40080404 0xb8ab R XA
    .dram0.data 0x3ffb0000 0x2114 RW A
    ...
     ESP32 CORE DUMP END 
    


Manual Decoding


If you set :ref:`CONFIG_ESP_C"
"OREDUMP_DECODE` to no decoding, then the raw  Base64-encoded body of core dump is output to UART between the following header and footer of the UART output:

.. code-block:: none

     CORE DUMP START 
    
     CORE DUMP END 

It is advised to manually save the core dump text body to a file. The ``CORE DUMP START`` and ``CORE DUMP END`` lines must not be included in a core dump text file. The saved text can the be decoded using the following command:

.. code-block:: bash

    idf.py coredump-i"
"nfo -c 

or

.. code-block:: bash

    idf.py coredump-debug -c 


Core Dump Commands


ESP-IDF provides special commands to help to retrieve and analyze core dumps:


ROM Functions in Backtraces


It is a possible that at the moment of a crash, some tasks and/or the crashed task itself have one or more ROM functions in their call stacks. Since ROM is not part of the program ELF, it is impossible for GDB to parse such call stacks due to GDB analyzing functions' prologues to decode backtraces. Th"
"us, call stack parsing will break with an error message upon the first ROM function that is encountered.

To overcome this issue, the `ROM ELF `_ provided by Espressif is loaded automatically by ESP-IDF monitor based on the target and its revision. More details about ROM ELFs can be found in `esp-rom-elfs `_.


Dumping Variables on Demand


Sometimes you want to read the last value of a variable to understand the root cause of a crash. Core dump supports retrieving variable data over GDB by appl"
"ying special attributes to declared variables.


Supported Notations and RAM Regions


.. list::
   :SOC_RTC_FAST_MEM_SUPPORTED or SOC_RTC_SLOW_MEM_SUPPORTED: * ``COREDUMP_RTC_ATTR`` places the variable into the RTC area, which is included in the dump.
   :SOC_RTC_FAST_MEM_SUPPORTED: * ``COREDUMP_RTC_FAST_ATTR`` places the variable into the RTC_FAST area, which is included in the dump.


Example


.. code-block:: bash

   // uint8_t global_var;
   COREDUMP_DRAM_ATTR uint8_t global_var;

.. code-"
"block:: bash

   global_var = 25;
   assert(0);

.. code-block:: bash

   idf.py coredump-debug

.. code-block:: bash

   (gdb) p global_var
   $1 = 25 '\031'


Running ``idf.py coredump-info`` and ``idf.py coredump-debug``


``idf.py coredump-info --help`` and ``idf.py coredump-debug --help`` commands can be used to get more details on usage.


Related Documents


.. toctree::
    :maxdepth: 1

    core_dump_internals
"
".. _memory-layout:

Memory Types




{IDF_TARGET_NAME} chip has multiple memory types and flexible memory mapping features. This section describes how ESP-IDF uses these features by default.

ESP-IDF distinguishes between instruction memory bus (IRAM, IROM, RTC FAST memory) and data memory bus (DRAM, DROM). Instruction memory is executable, and can only be read or written via 4-byte aligned words. Data memory is not executable and can be accessed via individual byte operations. For more informat"
"ion about the different memory buses consult the *{IDF_TARGET_NAME} Technical Reference Manual* > *System and Memory*  [`PDF `__].

.. _dram:

DRAM (Data RAM)


Non-constant static data (.data) and zero-initialized data (.bss) is placed by the linker into Internal SRAM as data memory. The remaining space in this region is used for the runtime heap.

.. only:: SOC_SPIRAM_SUPPORTED

   By applying the ``EXT_RAM_BSS_ATTR`` macro, zero-initialized data can also be placed into external RAM. To use th"
"is macro, the :ref:`CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY` needs to be enabled. See :ref:`external_ram_config_bss`.

.. only:: esp32

   The available size of the internal DRAM region is reduced by 64 KB (by shifting start address to ``0x3FFC0000``) if Bluetooth stack is used. Length of this region is also reduced by 16 KB or 32 KB if trace memory is used. Due to some memory fragmentation issues caused by ROM, it is also not possible to use all available DRAM for static allocations - howev"
"er the remaining DRAM is still available as heap at runtime.

   .. note::

    There is 520 KB of available SRAM (320 KB of DRAM and 200 KB of IRAM) on the ESP32. However, due to a technical limitation, the maximum statically allocated DRAM usage is 160 KB. The remaining 160 KB (for a total of 320 KB of DRAM) can only be allocated at runtime as heap.

.. only:: not esp32

   .. note::

    The maximum statically allocated DRAM size is reduced by the :ref:`iram` size of the compiled application."
" The available heap memory at runtime is reduced by the total static IRAM and DRAM usage of the application.

Constant data may also be placed into DRAM, for example if it is used in an non-flash-safe ISR (see explanation under :ref:`how-to-place-code-in-iram`).


""noinit"" DRAM


The macro ``__NOINIT_ATTR`` can be used as attribute to place data into ``.noinit`` section. The values placed into this section will not be initialized at startup and should keep its value after software restart.

.. o"
"nly:: esp32

    By applying the ``EXT_RAM_NOINIT_ATTR`` macro, non-initialized value could also be placed in external RAM. To do this, the :ref:`CONFIG_SPIRAM_ALLOW_NOINIT_SEG_EXTERNAL_MEMORY` needs to be enabled. See :ref:`external_ram_config_noinit`. If the :ref:`CONFIG_SPIRAM_ALLOW_NOINIT_SEG_EXTERNAL_MEMORY` is not enabled, ``EXT_RAM_NOINIT_ATTR`` will behave just as ``__NOINIT_ATTR``, it will make data to be placed into ``.noinit`` segment in internal RAM.

Example::

    __NOINIT_ATTR uin"
"t32_t noinit_data;


.. _iram:

IRAM (Instruction RAM)


.. only:: esp32

    ESP-IDF allocates part of the Internal SRAM0 region for instruction RAM. The region is defined in *{IDF_TARGET_NAME} Technical Reference Manual* > *System and Memory* > *Embedded Memory* [`PDF `__]. Except for the first 64 KB block which is used for PRO and APP MMU caches, the rest of this memory range (i.e., from ``0x40080000`` to ``0x400A0000``) is used to store parts of the application which need to run from RAM.

."
". only:: esp32s2

    ESP-IDF allocates part of the Internal SRAM region for instruction RAM. The region is defined in *{IDF_TARGET_NAME} Technical Reference Manual* > *System and Memory* > *Internal Memory* [`PDF `__]. Except for the first block (up to 32 KB) which is used for MMU cache, the rest of this memory range is used to store parts of application which need to run from RAM.

.. only:: not esp32

    .. note::

        Any internal SRAM which is not used for Instruction RAM will be made "
"available as :ref:`dram` for static data and dynamic allocation (heap).


When to Place Code in IRAM


Cases when parts of the application should be placed into IRAM:

- Interrupt handlers must be placed into IRAM if ``ESP_INTR_FLAG_IRAM`` is used when registering the interrupt handler. For more information, see :ref:`iram-safe-interrupt-handlers`.

- Some timing critical code may be placed into IRAM to reduce the penalty associated with loading the code from flash. {IDF_TARGET_NAME} reads code "
"and data from flash via the MMU cache. In some cases, placing a function into IRAM may reduce delays caused by a cache miss and significantly improve that function's performance.


.. _how-to-place-code-in-iram:

How to Place Code in IRAM


Some code is automatically placed into the IRAM region using the linker script.

If some specific application code needs to be placed into IRAM, it can be done by using the :doc:`linker-script-generation` feature and adding a linker script fragment file to yo"
"ur component that targets at the entire source files or functions with the ``noflash`` placement. See the :doc:`linker-script-generation` docs for more information.

Alternatively, it is possible to specify IRAM placement in the source code using the ``IRAM_ATTR`` macro::

    #include ""esp_attr.h""

    void IRAM_ATTR gpio_isr_handler(void* arg)
    {
        // ...
    }

There are some possible issues with placement in IRAM, that may cause problems with IRAM-safe interrupt handlers:

  .. code"
"-block:: c

    void IRAM_ATTR gpio_isr_handler(void* arg)
    {
       const static DRAM_ATTR uint8_t INDEX_DATA[] = { 45, 33, 12, 0 };
       const static char *MSG = DRAM_STR(""I am a string stored in RAM"");
    }

Note that knowing which data should be marked with ``DRAM_ATTR`` can be hard, the compiler will sometimes recognize that a variable or expression is constant (even if it is not marked ``const``) and optimize it into flash, unless it is marked with ``DRAM_ATTR``.

Jump table optimiza"
"tions can be re-enabled for individual source files that do not need to be placed in IRAM. For instructions on how to add the ``-fno-jump-tables -fno-tree-switch-conversion`` options when compiling individual source files, see :ref:`component_build_control`.


.. _irom:

IROM (Code Executed from flash)


If a function is not explicitly placed into :ref:`iram` or RTC memory, it is placed into flash. As IRAM is limited, most of an application's binary code must be placed into IROM instead.

.. onl"
"y:: esp32

    The mechanism by which Flash MMU is used to allow code execution from flash is described in *{IDF_TARGET_NAME} Technical Reference Manual* > *Memory Management and Protection Units (MMU, MPU)* [`PDF `__].

During :doc:`startup`, the bootloader (which runs from IRAM) configures the MMU flash cache to map the app's instruction code region to the instruction space. Flash accessed via the MMU is cached using some internal SRAM and accessing cached flash data is as fast as accessing ot"
"her types of internal memory.


.. _drom:

DROM (Data Stored in flash)


.. highlight:: c

By default, constant data is placed by the linker into a region mapped to the MMU flash cache. This is the same as the :ref:`irom` section, but is for read-only data not executable code.

The only constant data not placed into this memory type by default are literal constants which are embedded by the compiler into application code. These are placed as the surrounding function's executable instructions.

T"
"he ``DRAM_ATTR`` attribute can be used to force constants from DROM into the :ref:`dram` section (see above).

.. only:: SOC_RTC_SLOW_MEM_SUPPORTED

    RTC Slow Memory
    

    Global and static variables used by code which runs from RTC memory must be placed into RTC Slow memory. For example :doc:`deep sleep ` variables can be placed here instead of RTC FAST memory, or code and variables accessed by the :doc:`/api-reference/system/ulp`.

    The attribute macro named ``RTC_NOINIT_ATTR`` can b"
"e used to place data into this type of memory. The values placed into this section keep their value after waking from deep sleep.

    Example::

        RTC_NOINIT_ATTR uint32_t rtc_noinit_data;


.. only:: SOC_RTC_FAST_MEM_SUPPORTED

    RTC FAST Memory
    

    .. only:: esp32c6 or esp32h2

        .. note::

            On {IDF_TARGET_NAME} what was previously referred to as RTC memory has been renamed LP (low power) memory. You might see both terms being used interchangeably in IDF code, d"
"ocs and the technical reference manual.


    The same region of RTC FAST memory can be accessed as both instruction and data memory. Code which has to run after wake-up from deep sleep mode has to be placed into RTC memory. Please check detailed description in :doc:`deep sleep ` documentation.

    .. only:: esp32

        In single core mode (:ref:`CONFIG_FREERTOS_UNICORE`), remaining RTC FAST memory is added to the heap, unless the option :ref:`CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP` is"
" disabled. This memory can be used interchangeably with :ref:`DRAM`, but is slightly slower to access and not DMA-capable.

        This option is not available in dual core mode, because on {IDF_TARGET_NAME}, RTC FAST memory can only be accessed by the PRO CPU.

    .. only:: not esp32

        Remaining RTC FAST memory is added to the heap unless the option :ref:`CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP` is disabled. This memory can be used interchangeably with :ref:`DRAM`, but is slightly"
" slower to access.


.. only:: SOC_MEM_TCM_SUPPORTED

    TCM (Tightly-Coupled Memory)
    

    TCM is memory placed near the CPU, accessible at CPU frequency without passing through a cache. Even though on average, it may not surpass the efficiency or speed of cached memory, it does provide predictable and consistent access times. TCM can be useful for time-critical routines where having a deterministic access speed is important.


DMA-Capable Requirement


.. highlight:: c

Most peripheral DM"
"A controllers (e.g., SPI, sdmmc, etc.) have requirements that sending/receiving buffers should be placed in DRAM and word-aligned. We suggest to place DMA buffers in static variables rather than in the stack. Use macro ``DMA_ATTR`` to declare global/local static variables like::

    DMA_ATTR uint8_t buffer[]=""I want to send something"";

    void app_main()
    {
        // initialization code...
        spi_transaction_t temp = {
            .tx_buffer = buffer,
            .length = 8 * sizeof"
"(buffer),
        };
        spi_device_transmit(spi, &temp);
        // other stuff
    }

Or::

    void app_main()
    {
        DMA_ATTR static uint8_t buffer[] = ""I want to send something"";
        // initialization code...
        spi_transaction_t temp = {
            .tx_buffer = buffer,
            .length = 8 * sizeof(buffer),
        };
        spi_device_transmit(spi, &temp);
        // other stuff
    }

It is also possible to allocate DMA-capable memory buffers dynamically by using"
" the :ref:`MALLOC_CAP_DMA ` capabilities flag.

DMA Buffer in the Stack


Placing DMA buffers in the stack is possible but discouraged. If doing so, pay attention to the following:

.. list::

    :SOC_SPIRAM_SUPPORTED: - Placing DRAM buffers on the stack is not recommended if the stack may be in PSRAM. If the stack of a task is placed in the PSRAM, several steps have to be taken as described in :doc:`external-ram`.
    - Use macro ``WORD_ALIGNED_ATTR`` in functions before variables to place the"
"m in proper positions like::

        void app_main()
        {
            uint8_t stuff;
            WORD_ALIGNED_ATTR uint8_t buffer[] = ""I want to send something"";   //or the buffer will be placed right after stuff.
            // initialization code...
            spi_transaction_t temp = {
                .tx_buffer = buffer,
                .length = 8 * sizeof(buffer),
            };
            spi_device_transmit(spi, &temp);
            // other stuff
        }
"
"- Installed ESP-IDF including all ESP-IDF requirements
- System package requirements (``libbsd``, ``libbsd-dev``)
- A recent enough Linux or macOS version and GCC compiler
- All components the application depends on must be either supported on the Linux target (Linux/POSIX simulator) or mock-able

An application that runs on the Linux target has to set the ``COMPONENTS`` variable to ``main`` in the CMakeLists.txt of the application's root directory:

.. code-block:: cmake

  set(COMPONENTS main)"
"


This prevents the automatic inclusion of all components from ESP-IDF to the build process which is otherwise done for convenience.
"
"

Chip Revisions


There are some issues with certain revisions of ESP32 that have repercussions for use with external RAM. The issues are documented in the `ESP32 Series SoC Errata`_ document. In particular, ESP-IDF handles the bugs mentioned in the following ways:


ESP32 Rev v0.0

ESP-IDF has no workaround for the bugs in this revision of silicon, and it cannot be used to map external PSRAM into ESP32's main memory map.


ESP32 Rev v1.0

The bugs in this revision of silicon cause issues if ce"
"rtain sequences of machine instructions operate on external memory. (`ESP32 Series SoC Errata`_ 3.2). As a workaround, the ``-mfix-esp32-psram-cache-issue`` flag has been added to the ESP32 GCC compiler such that these sequences are filtered out. As a result, the compiler only outputs code that can safely be executed. The :ref:`CONFIG_SPIRAM_CACHE_WORKAROUND` option can be used to enable this workaround.

Aside from linking to a recompiled version of Newlib with the additional flag, ESP-IDF also"
" does the following:

- Avoids using some ROM functions
- Allocates static memory for the Wi-Fi stack

ESP32 Rev v3.0


ESP32 rev v3.0 fixes the PSRAM cache issue found in rev v1.0. When :ref:`CONFIG_ESP32_REV_MIN` option is set to ``rev v3.0``, compiler workarounds related to PSRAM will be disabled. For more information about ESP32 v3.0, see `ESP32 Chip Revision v3.0 User Guide`_.
"
"Tools


.. toctree::
   :maxdepth: 1

   idf-py
   idf-monitor
   idf-docker-image
   idf-windows-installer
   idf-component-manager
   idf-clang-tidy
   idf-tools
   :esp32 or esp32c3: qemu
"
"
IDF Monitor




IDF Monitor uses the esp-idf-monitor_ package as a serial terminal program which relays serial data to and from the target device's serial port. It also provides some ESP-IDF-specific features.

IDF Monitor can be launched from an ESP-IDF project by running ``idf.py monitor``.

Keyboard Shortcuts


For easy interaction with IDF Monitor, use the keyboard shortcuts given in the table. These keyboard shortcuts can be customized, for more details see `Configuration File`_ section.

"
".. list-table::
   :header-rows: 1
   :widths: 15 25 55
     - Action
     - Description
     - Exit the program
     -
     - Menu escape key
     - Press and follow it by one of the keys given below.
     - Send the menu character itself to remote
     -
     - Send the exit character itself to remote
     -
     - Reset target into bootloader to pause app via RTS and DTR lines
     - Resets the target into the bootloader using the RTS and DTR lines (if connected). This stops the board from ex"
"ecuting the application, making it useful when waiting for another device to start. For additional details, refer to :ref:`target-reset-into-bootloader`.
     - Reset target board via RTS
     - Resets the target board and re-starts the application via the RTS line (if connected).
     - Build and flash the project
     - Pauses idf_monitor to run the project ``flash`` target, then resumes idf_monitor. Any changed source files are recompiled and then re-flashed. Target ``encrypted-flash`` is run"
" if idf_monitor was started with argument ``-E``.
     - Build and flash the app only
     - Pauses idf_monitor to run the ``app-flash`` target, then resumes idf_monitor. Similar to the ``flash`` target, but only the main app is built and re-flashed. Target ``encrypted-app-flash`` is run if idf_monitor was started with argument ``-E``.
     - Stop/resume log output printing on screen
     - Discards all incoming serial data while activated. Allows to quickly pause and examine log output without "
"quitting the monitor.
     - Stop/resume log output saved to file
     - Creates a file in the project directory and the output is written to that file until this is disabled with the same keyboard shortcut (or IDF Monitor exits).
     - Stop/resume printing timestamps
     - IDF Monitor can print a timestamp in the beginning of each line. The timestamp format can be changed by the ``--timestamp-format`` command line argument.
     - Display all keyboard shortcuts
     -
     - Exit the program
"
"     -
     - Interrupt running application
     - Pauses IDF Monitor and runs GDB_ project debugger to debug the application at runtime. This requires :ref:`CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME` option to be enabled.

Any keys pressed, other than ``Ctrl-]`` and ``Ctrl-T``, will be sent through the serial port.


ESP-IDF-specific Features


Automatic Address Decoding
~~~~~~~~~~~~~~~~~~~~~~~~~~

Whenever the chip outputs a hexadecimal address that points to executable code, IDF monitor looks up the "
"location in the source code (file name and line number) and prints the location on the next line in yellow.

.. highlight:: none

.. only:: CONFIG_IDF_TARGET_ARCH_XTENSA

  If an ESP-IDF app crashes and panics, a register dump and backtrace are produced, such as the following::

      Guru Meditation Error of type StoreProhibited occurred on core  0. Exception was unhandled.
      Register dump:
      PC      : 0x400f360d  PS      : 0x00060330  A0      : 0x800dbf56  A1      : 0x3ffb7e00
      A2"
"      : 0x3ffb136c  A3      : 0x00000005  A4      : 0x00000000  A5      : 0x00000000
      A6      : 0x00000000  A7      : 0x00000080  A8      : 0x00000000  A9      : 0x3ffb7dd0
      A10     : 0x00000003  A11     : 0x00060f23  A12     : 0x00060f20  A13     : 0x3ffba6d0
      A14     : 0x00000047  A15     : 0x0000000f  SAR     : 0x00000019  EXCCAUSE: 0x0000001d
      EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0x00000000

      Backtrace: 0x400f360d:0x3ffb7e00 0x4"
"00dbf56:0x3ffb7e20 0x400dbf5e:0x3ffb7e40 0x400dbf82:0x3ffb7e60 0x400d071d:0x3ffb7e90

  IDF Monitor adds more details to the dump::

      Guru Meditation Error of type StoreProhibited occurred on core  0. Exception was unhandled.
      Register dump:
      PC      : 0x400f360d  PS      : 0x00060330  A0      : 0x800dbf56  A1      : 0x3ffb7e00
      0x400f360d: do_something_to_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:57
      (inlined by) inner_dont"
"_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:52
      A2      : 0x3ffb136c  A3      : 0x00000005  A4      : 0x00000000  A5      : 0x00000000
      A6      : 0x00000000  A7      : 0x00000080  A8      : 0x00000000  A9      : 0x3ffb7dd0
      A10     : 0x00000003  A11     : 0x00060f23  A12     : 0x00060f20  A13     : 0x3ffba6d0
      A14     : 0x00000047  A15     : 0x0000000f  SAR     : 0x00000019  EXCCAUSE: 0x0000001d
      EXCVADDR: 0x00000000  LBEG   "
" : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0x00000000

      Backtrace: 0x400f360d:0x3ffb7e00 0x400dbf56:0x3ffb7e20 0x400dbf5e:0x3ffb7e40 0x400dbf82:0x3ffb7e60 0x400d071d:0x3ffb7e90
      0x400f360d: do_something_to_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:57
      (inlined by) inner_dont_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:52
      0x400dbf56: still_dont_crash at /home/gus/esp/32/idf/example"
"s/get-started/hello_world/main/./hello_world_main.c:47
      0x400dbf5e: dont_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:42
      0x400dbf82: app_main at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:33
      0x400d071d: main_task at /home/gus/esp/32/idf/components/{IDF_TARGET_PATH_NAME}/./cpu_start.c:254

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

  If an ESP-IDF app crashes and panics, a register dump and backtrace ar"
"e produced, such as the following::

      abort() was called at PC 0x42067cd5 on core 0

      Stack dump detected
      Core  0 register dump:
      MEPC    : 0x40386488  RA      : 0x40386b02  SP      : 0x3fc9a350  GP      : 0x3fc923c0
      TP      : 0xa5a5a5a5  T0      : 0x37363534  T1      : 0x7271706f  T2      : 0x33323130
      S0/FP   : 0x00000004  S1      : 0x3fc9a3b4  A0      : 0x3fc9a37c  A1      : 0x3fc9a3b2
      A2      : 0x00000000  A3      : 0x3fc9a3a9  A4      : 0x00000001  A5  "
"    : 0x3fc99000
      A6      : 0x7a797877  A7      : 0x76757473  S2      : 0xa5a5a5a5  S3      : 0xa5a5a5a5
      S4      : 0xa5a5a5a5  S5      : 0xa5a5a5a5  S6      : 0xa5a5a5a5  S7      : 0xa5a5a5a5
      S8      : 0xa5a5a5a5  S9      : 0xa5a5a5a5  S10     : 0xa5a5a5a5  S11     : 0xa5a5a5a5
      T3      : 0x6e6d6c6b  T4      : 0x6a696867  T5      : 0x66656463  T6      : 0x62613938
      MSTATUS : 0x00001881  MTVEC   : 0x40380001  MCAUSE  : 0x00000007  MTVAL   : 0x00000000

      MHARTID : 0"
"x00000000

      Stack memory:
      3fc9a350: 0xa5a5a5a5 0xa5a5a5a5 0x3fc9a3b0 0x403906cc 0xa5a5a5a5 0xa5a5a5a5 0xa5a5a5a50
      3fc9a370: 0x3fc9a3b4 0x3fc9423c 0x3fc9a3b0 0x726f6261 0x20292874 0x20736177 0x6c6c61635
      3fc9a390: 0x43502074 0x34783020 0x37363032 0x20356463 0x63206e6f 0x2065726f 0x000000300
      3fc9a3b0: 0x00000030 0x36303234 0x35646337 0x3c093700 0x0000002a 0xa5a5a5a5 0x3c0937f48
      3fc9a3d0: 0x00000001 0x3c0917f8 0x3c0937d4 0x0000002a 0xa5a5a5a5 0xa5a5a5a5 0xa5a5a5a5e"
"
      3fc9a3f0: 0x0001f24c 0x000006c8 0x00000000 0x0001c200 0xffffffff 0xffffffff 0x000000200
      3fc9a410: 0x00001000 0x00000002 0x3c093818 0x3fccb470 0xa5a5a5a5 0xa5a5a5a5 0xa5a5a5a56
      .....

  IDF Monitor adds more details to the dump by analyzing the stack dump::

    abort() was called at PC 0x42067cd5 on core 0
    0x42067cd5: __assert_func at /builds/idf/crosstool-NG/.build/riscv32-esp-elf/src/newlib/newlib/libc/stdlib/assert.c:62 (discriminator 8)

    Stack dump detected
    Cor"
"e  0 register dump:
    MEPC    : 0x40386488  RA      : 0x40386b02  SP      : 0x3fc9a350  GP      : 0x3fc923c0
    0x40386488: panic_abort at /home/marius/esp-idf_2/components/esp_system/panic.c:367

    0x40386b02: rtos_int_enter at /home/marius/esp-idf_2/components/freertos/port/riscv/portasm.S:35

    TP      : 0xa5a5a5a5  T0      : 0x37363534  T1      : 0x7271706f  T2      : 0x33323130
    S0/FP   : 0x00000004  S1      : 0x3fc9a3b4  A0      : 0x3fc9a37c  A1      : 0x3fc9a3b2
    A2      : 0x"
"00000000  A3      : 0x3fc9a3a9  A4      : 0x00000001  A5      : 0x3fc99000
    A6      : 0x7a797877  A7      : 0x76757473  S2      : 0xa5a5a5a5  S3      : 0xa5a5a5a5
    S4      : 0xa5a5a5a5  S5      : 0xa5a5a5a5  S6      : 0xa5a5a5a5  S7      : 0xa5a5a5a5
    S8      : 0xa5a5a5a5  S9      : 0xa5a5a5a5  S10     : 0xa5a5a5a5  S11     : 0xa5a5a5a5
    T3      : 0x6e6d6c6b  T4      : 0x6a696867  T5      : 0x66656463  T6      : 0x62613938
    MSTATUS : 0x00001881  MTVEC   : 0x40380001  MCAUSE  : 0x0"
"0000007  MTVAL   : 0x00000000

    MHARTID : 0x00000000

    Backtrace:
    panic_abort (details=details@entry=0x3fc9a37c ""abort() was called at PC 0x42067cd5 on core 0"") at /home/marius/esp-idf_2/components/esp_system/panic.c:367
    367     *((int *) 0) = 0; // NOLINT(clang-analyzer-core.NullDereference) should be an invalid operation on targets
    #0  panic_abort (details=details@entry=0x3fc9a37c ""abort() was called at PC 0x42067cd5 on core 0"") at /home/marius/esp-idf_2/components/esp_system"
"/panic.c:367
    #1  0x40386b02 in esp_system_abort (details=details@entry=0x3fc9a37c ""abort() was called at PC 0x42067cd5 on core 0"") at /home/marius/esp-idf_2/components/esp_system/system_api.c:108
    #2  0x403906cc in abort () at /home/marius/esp-idf_2/components/newlib/abort.c:46
    #3  0x42067cd8 in __assert_func (file=file@entry=0x3c0937f4 """", line=line@entry=42, func=func@entry=0x3c0937d4  """", failedexpr=failedexpr@entry=0x3c0917f8 """") at /builds/idf/crosstool-NG/.build/riscv32-esp-elf/"
"src/newlib/newlib/libc/stdlib/assert.c:62
    #4  0x4200729e in app_main () at ../main/iperf_example_main.c:42
    #5  0x42086cd6 in main_task (args=) at /home/marius/esp-idf_2/components/freertos/port/port_common.c:133
    #6  0x40389f3a in vPortEnterCritical () at /home/marius/esp-idf_2/components/freertos/port/riscv/port.c:129

To decode each address, IDF Monitor runs the following command in the background::

  {IDF_TARGET_TOOLCHAIN_PREFIX}-addr2line -pfiaC -e build/PROJECT.elf ADDRESS

.. o"
"nly:: CONFIG_IDF_TARGET_ARCH_XTENSA

  If an address is not matched in the app source code, IDF monitor also checks the ROM code. Instead of printing the source file name and line number, only the function name followed by ``in ROM`` is displayed::

    abort() was called at PC 0x40007c69 on core 0
    0x40007c69: ets_write_char in ROM

    Backtrace: 0x40081656:0x3ffb4ac0 0x40085729:0x3ffb4ae0 0x4008a7ce:0x3ffb4b00 0x40007c69:0x3ffb4b70 0x40008148:0x3ffb4b90 0x400d51d7:0x3ffb4c20 0x400e31bc:0x3"
"ffb4c50 0x40087bc5:0x3ffb4c80
    0x40081656: panic_abort at /Users/espressif/esp-idf/components/esp_system/panic.c:452
    0x40085729: esp_system_abort at /Users/espressif/esp-idf/components/esp_system/port/esp_system_chip.c:90
    0x4008a7ce: abort at /Users/espressif/esp-idf/components/newlib/abort.c:38
    0x40007c69: ets_write_char in ROM
    0x40008148: ets_printf in ROM
    0x400d51d7: app_main at /Users/espressif/esp-idf/examples/get-started/hello_world/main/hello_world_main.c:49
    0x4"
"00e31bc: main_task at /Users/espressif/esp-idf/components/freertos/app_startup.c:208 (discriminator 13)
    0x40087bc5: vPortTaskWrapper at /Users/espressif/esp-idf/components/freertos/FreeRTOS-Kernel/portable/xtensa/port.c:162
    .....

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

  If an address is not matched in the app source code, IDF monitor also checks the ROM code. Instead of printing the source file name and line number, only the function name followed by ``in ROM`` is displayed::

    abor"
"t() was called at PC 0x400481c1 on core 0
    0x400481c1: ets_rsa_pss_verify in ROM

    Stack dump detected
    Core  0 register dump:
    MEPC    : 0x4038051c  RA      : 0x40383840  SP      : 0x3fc8f6b0  GP      : 0x3fc8b000
    0x4038051c: panic_abort at /Users/espressif/esp-idf/components/esp_system/panic.c:452
    0x40383840: __ubsan_include at /Users/espressif/esp-idf/components/esp_system/ubsan.c:313

    TP      : 0x3fc8721c  T0      : 0x37363534  T1      : 0x7271706f  T2      : 0x333231"
"30
    S0/FP   : 0x00000004  S1      : 0x3fc8f714  A0      : 0x3fc8f6dc  A1      : 0x3fc8f712
    A2      : 0x00000000  A3      : 0x3fc8f709  A4      : 0x00000001  A5      : 0x3fc8c000
    A6      : 0x7a797877  A7      : 0x76757473  S2      : 0x00000000  S3      : 0x3fc8f750
    S4      : 0x3fc8f7e4  S5      : 0x00000000  S6      : 0x400481b0  S7      : 0x3c025841
    0x400481b0: ets_rsa_pss_verify in ROM
    .....

The ROM ELF file is automatically loaded from a location based on the ``IDF_PATH"
"`` and ``ESP_ROM_ELF_DIR`` environment variables. This can be overridden by calling ``esp_idf_monitor`` and providing a path to a specific ROM ELF file: ``python -m esp_idf_monitor --rom-elf-file [path to ROM ELF file]``.

.. note::

    Set environment variable ``ESP_MONITOR_DECODE`` to ``0`` or call esp_idf_monitor with specific command line option: ``python -m esp_idf_monitor --disable-address-decoding`` to disable address decoding.

Target Reset on Connection
~~~~~~~~~~~~~~~~~~~~~~~~~~

By d"
"efault, IDF Monitor will reset the target when connecting to it. The reset of the target chip is performed using the DTR and RTS serial lines. To prevent IDF Monitor from automatically resetting the target on connection, call IDF Monitor with the ``--no-reset`` option (e.g., ``idf.py monitor --no-reset``). You can also set the environment variable ``ESP_IDF_MONITOR_NO_RESET`` to ``1`` to achieve the same behavior.

.. note::

    The ``--no-reset`` option applies the same behavior even when conn"
"ecting IDF Monitor to a particular port (e.g., ``idf.py monitor --no-reset -p [PORT]``).


.. _target-reset-into-bootloader:

Target Reset into Bootloader
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IDF Monitor provides the capability to reset a chip into the bootloader using a pre-defined reset sequence that has been tuned to work in most environments. Additionally, users have the flexibility to set a custom reset sequence, allowing for fine-tuning and adaptability to diverse scenarios.

Using Pre-defined Re"
"set Sequence


IDF Monitor's default reset sequence is designed to work seamlessly across a wide range of environments. To trigger a reset into the bootloader using the default sequence, no additional configuration is required.

Custom Reset Sequence


For more advanced users or specific use cases, IDF Monitor supports the configuration of a custom reset sequence using :ref:`configuration-file`. This is particularly useful in extreme edge cases where the default sequence may not suffice.

The se"
"quence is defined with a string in the following format:

- Consists of individual commands divided by ``|`` (e.g. ``R0|D1|W0.5``).
- Commands (e.g. ``R0``) are defined by a code (``R``) and an argument (``0``).

.. list-table::
    :header-rows: 1
    :widths: 15 50 35
    :align: center
      - Action
      - Argument
      - Set DTR control line
      - ``1``/``0``
      - Set RTS control line
      - ``1``/``0``
      - Set DTR and RTS control lines at the same time (Unix-like systems only)
"
"      - ``0,0``/``0,1``/``1,0``/``1,1``
      - Wait for ``N`` seconds (where ``N`` is a float)
      - N

Example:

.. code-block:: ini

    [esp-idf-monitor]
    custom_reset_sequence = U0,1|W0.1|D1|R0|W0.5|D0

Refer to `custom reset sequence`_ from Esptool documentation for further details. Please note that ``custom_reset_sequence`` is the only used value from the Esptool configuration, and others will be ignored in IDF Monitor.

Share Configuration Across Tools


The configuration for the cu"
"stom reset sequence can be specified in a shared configuration file between IDF Monitor and Esptool. In this case, your configuration file name should be either ``setup.cfg`` or ``tox.ini`` so it would be recognized by both tools.

Example of a shared configuration file:

.. code-block:: ini

    [esp-idf-monitor]
    menu_key = T
    skip_menu_key = True

    [esptool]
    custom_reset_sequence = U0,1|W0.1|D1|R0|W0.5|D0

.. note::

    When using the ``custom_reset_sequence`` parameter in both "
"the ``[esp-idf-monitor]`` section and the ``[esptool]`` section, the configuration from the ``[esp-idf-monitor]`` section will take precedence in IDF Monitor. Any conflicting configuration in the ``[esptool]`` section will be ignored.

    This precedence rule also applies when the configuration is spread across multiple files. The global esp-idf-monitor configuration will take precedence over the local esptool configuration.


Launching GDB with GDBStub
~~~~~~~~~~~~~~~~~~~~~~~~~~

GDBStub is a "
"useful runtime debugging feature that runs on the target and connects to the host over the serial port to receive debugging commands. GDBStub supports commands such as reading memory and variables, examining call stack frames etc. Although GDBStub is less versatile than JTAG debugging, it does not require any special hardware (such as a JTAG to USB bridge) as communication is done entirely over the serial port.

A target can be configured to run GDBStub in the background by setting the :ref:`CON"
"FIG_ESP_SYSTEM_GDBSTUB_RUNTIME`. GDBStub will run in the background until a ``Ctrl+C`` message is sent over the serial port and causes the GDBStub to break (i.e., stop the execution of) the program, thus allowing GDBStub to handle debugging commands.

Furthermore, the panic handler can be configured to run GDBStub on a crash by setting the :ref:`CONFIG_ESP_SYSTEM_PANIC` to ``GDBStub on panic``. When a crash occurs, GDBStub will output a special string pattern over the serial port to indicate tha"
"t it is running.

In both cases (i.e., sending the ``Ctrl+C`` message, or receiving the special string pattern), IDF Monitor will automatically launch GDB in order to allow the user to send debugging commands. After GDB exits, the target is reset via the RTS serial line. If this line is not connected, users can reset their target (by pressing the board's Reset button).

.. note::

    In the background, IDF Monitor runs the following command to launch GDB::

        {IDF_TARGET_TOOLCHAIN_PREFIX}"
"-gdb -ex ""set serial baud BAUD"" -ex ""target remote PORT"" -ex interrupt build/PROJECT.elf :idf_target:`Hello NAME chip`


Output Filtering
~~~~~~~~~~~~~~~~

IDF monitor can be invoked as ``idf.py monitor --print-filter=""xyz""``, where ``--print-filter`` is the parameter for output filtering. The default value is an empty string, which means that everything is printed. Filtering can also be configured using the ``ESP_IDF_MONITOR_PRINT_FILTER`` environment variable.

.. note::

   When using both th"
"e environment variable ``ESP_IDF_MONITOR_PRINT_FILTER`` and the argument ``--print-filter``, the setting from the CLI argument will take precedence.

Restrictions on what to print can be specified as a series of ``:`` items where ```` is the tag string and ```` is a character from the set ``{N, E, W, I, D, V, *}`` referring to a level for :doc:`logging `.

For example, ``--print_filter=""tag1:W""`` matches and prints only the outputs written with ``ESP_LOGW(""tag1"", ...)`` or at lower verbosity lev"
"el, i.e., ``ESP_LOGE(""tag1"", ...)``. Not specifying a ```` or using ``*`` defaults to a Verbose level.

.. note::

   Use primary logging to disable at compilation the outputs you do not need through the :doc:`logging library `. Output filtering with the IDF monitor is a secondary solution that can be useful for adjusting the filtering options without recompiling the application.

Your app tags must not contain spaces, asterisks ``*``, or colons ``:`` to be compatible with the output filtering f"
"eature.

If the last line of the output in your app is not followed by a carriage return, the output filtering might get confused, i.e., the monitor starts to print the line and later finds out that the line should not have been written. This is a known issue and can be avoided by always adding a carriage return (especially when no output follows immediately afterwards).

Examples of Filtering Rules:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- ``*`` can be used to match any tags. However, the string ``--pri"
"nt_filter=""*:I tag1:E""`` with regards to ``tag1`` prints errors only, because the rule for ``tag1`` has a higher priority over the rule for ``*``.
- The default (empty) rule is equivalent to ``*:V`` because matching every tag at the Verbose level or lower means matching everything.
- ``""*:N""`` suppresses not only the outputs from logging functions, but also the prints made by ``printf``, etc. To avoid this, use ``*:E`` or a higher verbosity level.
- Rules ``""tag1:V""``, ``""tag1:v""``, ``""tag1:""``,"
" ``""tag1:*""``, and ``""tag1""`` are equivalent.
- Rule ``""tag1:W tag1:E""`` is equivalent to ``""tag1:E""`` because any consequent occurrence of the same tag name overwrites the previous one.
- Rule ``""tag1:I tag2:W""`` only prints ``tag1`` at the Info verbosity level or lower and ``tag2`` at the Warning verbosity level or lower.
- Rule ``""tag1:I tag2:W tag3:N""`` is essentially equivalent to the previous one because ``tag3:N`` specifies that ``tag3`` should not be printed.
- ``tag3:N`` in the rule ``"""
"tag1:I tag2:W tag3:N *:V""`` is more meaningful because without ``tag3:N`` the ``tag3`` messages could have been printed; the errors for ``tag1`` and ``tag2`` will be printed at the specified (or lower) verbosity level and everything else will be printed by default.


A More Complex Filtering Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following log snippet was acquired without any filtering options::

    load:0x40078000,len:13564
    entry 0x40078d4c
    E (31) esp_image: image at 0x30000 has"
" invalid magic byte
    W (31) esp_image: image at 0x30000 has invalid SPI mode 255
    E (39) boot: Factory app partition is not bootable
    I (568) cpu_start: Pro cpu up.
    I (569) heap_init: Initializing. RAM available for dynamic allocation:
    I (603) cpu_start: Pro cpu start user code
    D (309) light_driver: [light_init, 74]:status: 1, mode: 2
    D (318) vfs: esp_vfs_register_fd_range is successful for range /.config/esp-idf-monitor/``
 - MacOS ``/Users//.config/esp-idf-monitor/``
 "
"- Windows: ``c:\Users\\AppData\Local\esp-idf-monitor\``

If a configuration file is still not found, the last inspected location is the home directory:

 - Linux: ``/home//``
 - MacOS ``/Users//``
 - Windows: ``c:\Users\\``

On Windows, the home directory can be set with the ``HOME`` or ``USERPROFILE`` environment variables. Therefore, the Windows configuration directory location also depends on these.

A different location for the configuration file can be specified with the ``ESP_IDF_MONITOR_C"
"FGFILE`` environment variable, e.g., ``ESP_IDF_MONITOR_CFGFILE = ~/custom_config.cfg``. This overrides the search priorities described above.

``esp-idf-monitor`` will read settings from other usual configuration files if no other configuration file is used. It automatically reads from ``setup.cfg`` or ``tox.ini`` if they exist.

Configuration Options
~~~~~~~~~~~~~~~~~~~~~

Below is a table listing the available configuration options:

.. list-table::
    :header-rows: 1
    :widths: 30 50 20
  "
"  :align: center
      - Description
      - Default Value
      - Key to access the main menu.
      - ``T``
      - Key to exit the monitor.
      - ``]``
      - Key to initiate a chip reset.
      - ``R``
      - Key to recompile and upload.
      - ``F``
      - Key to recompile and upload just the application.
      - ``A``
      - Key to toggle the output display.
      - ``Y``
      - Key to toggle the logging feature.
      - ``L``
      - Key to toggle timestamp display.
      - ``I``
"
"      - Key to reset the chip to bootloader mode.
      - ``P``
      - Key to exit the monitor from the menu.
      - ``X``
      - Pressing the menu key can be skipped for menu commands.
      - ``False``
      - Custom reset sequence for resetting into the bootloader.
      - N/A


Syntax
~~~~~~

The configuration file is in .ini file format: it must be introduced by an ``[esp-idf-monitor]`` header to be recognized as valid. This section then contains name = value entries. Lines beginning wit"
"h ``#`` or ``;`` are ignored as comments.

.. code-block:: ini

    # esp-idf-monitor.cfg file to configure internal settings of esp-idf-monitor
    [esp-idf-monitor]
    menu_key = T
    exit_key = ]
    chip_reset_key = R
    recompile_upload_key = F
    recompile_upload_app_key = A
    toggle_output_key = Y
    toggle_log_key = L
    toggle_timestamp_key = I
    chip_reset_bootloader_key = P
    exit_menu_key = X
    skip_menu_key = False


Known Issues with IDF Monitor


If you encounter any"
" issues while using IDF Monitor, check our `GitHub repository `_ for a list of known issues and their current status. If you come across a problem that hasn't been documented yet, we encourage you to create a new issue report.

.. _addr2line: https://sourceware.org/binutils/docs/binutils/addr2line.html
.. _esp-idf-monitor: https://github.com/espressif/esp-idf-monitor
.. _gdb: https://sourceware.org/gdb/download/onlinedocs/
.. _pySerial: https://github.com/pyserial/pyserial
.. _miniterm: https://"
"pyserial.readthedocs.org/en/latest/tools.html#module-serial.tools.miniterm
.. _C0 control codes: https://en.wikipedia.org/wiki/C0_and_C1_control_codes#C0_controls
.. _custom reset sequence: https://docs.espressif.com/projects/esptool/en/latest/{IDF_TARGET_PATH_NAME}/esptool/configuration-file.html#custom-reset-sequence
"
"
IDF Docker Image




..
    When changing this page, please keep tools/docker/README.md in sync.

.. highlight:: bash

IDF Docker image (``espressif/idf``) is intended for building applications and libraries with specific versions of ESP-IDF when doing automated builds.

The image contains:

- Common utilities such as ``git``, ``wget``, ``curl``, and ``zip``.
- Python 3.8 or newer.
- A copy of a specific version of ESP-IDF. See below for information about versions. ``IDF_PATH`` environment vari"
"able is set and points to the ESP-IDF location in the container.
- All the build tools required for the specific version of ESP-IDF: CMake, Ninja, cross-compiler toolchains, etc.
- All Python packages required by ESP-IDF are installed in a virtual environment.

The image ``ENTRYPOINT`` sets up the ``PATH`` environment variable to point to the correct version of tools, and activates the Python virtual environment. As a result, the environment is ready to use the ESP-IDF build system.

The image c"
"an also be used as a base for custom images, if additional utilities are required.

Tags


Multiple tags of this image are maintained:

- ``latest``: tracks ``master`` branch of ESP-IDF
- ``vX.Y``: corresponds to ESP-IDF release ``vX.Y``
- ``release-vX.Y``: tracks ``release/vX.Y`` branch of ESP-IDF

.. note::

    Versions of ESP-IDF released before this feature was introduced do not have corresponding Docker image versions. You can check the up-to-date list of available tags at https://hub.dock"
"er.com/r/espressif/idf/tags.

Usage


Setting up Docker
~~~~~~~~~~~~~~~~~

Before using the ``espressif/idf`` Docker image locally, make sure you have Docker installed. Follow the instructions at https://docs.docker.com/install/, if it is not installed yet.

If using the image in a CI environment, consult the documentation of your CI service on how to specify the image used for the build process.

Building a Project with CMake
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the project directory, run:

.. cod"
"e-block:: bash

    docker run --rm -v $PWD:/project -w /project -u $UID -e HOME=/tmp espressif/idf idf.py build

The above command explained:

- ``docker run``: runs a Docker image. It is a shorter form of the command ``docker container run``.
- ``--rm``: removes the container when the build is finished.
- ``-v $PWD:/project``: mounts the current directory on the host (``$PWD``) as ``/project`` directory in the container.
- ``-w /project``: makes ``/project`` the working directory for the comma"
"nd.
- ``-u $UID``: makes the command run with your user ID so that files are created as you (instead of root).
- ``-e HOME=/tmp``: gives the user a home directory for storing temporary files created by ``idf.py`` in ``~/.cache``.
- ``espressif/idf``: uses Docker image ``espressif/idf`` with tag ``latest``. The ``latest`` tag is implicitly added by Docker when no tag is specified.
- ``idf.py build``: runs this command inside the container.

.. note::

   When the mounted directory, ``/project``, "
"contains a git repository owned by a different user (``UID``) than the one running the Docker container, git commands executed within ``/project`` might fail, displaying an error message ``fatal: detected dubious ownership in repository at '/project'``. To resolve this issue, you can designate the ``/project`` directory as safe by setting the IDF_GIT_SAFE_DIR environment variable during the Docker container startup. For instance, you can achieve this by including ``-e IDF_GIT_SAFE_DIR='/project'"
"`` as a parameter. Additionally, multiple directories can be specified by using a ``:`` separator. To entirely disable this git security check, ``*`` can be used.

To build with a specific Docker image tag, specify it as ``espressif/idf:TAG``, for example:

.. code-block:: bash

    docker run --rm -v $PWD:/project -w /project -u $UID -e HOME=/tmp espressif/idf:release-v4.4 idf.py build

You can check the up-to-date list of available tags at https://hub.docker.com/r/espressif/idf/tags.

Using th"
"e Image Interactively
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is also possible to do builds interactively, to debug build issues or test the automated build scripts. Start the container with ``-i -t`` flags:

.. code-block:: bash

    docker run --rm -v $PWD:/project -w /project -u $UID -e HOME=/tmp -it espressif/idf

Then inside the container, use ``idf.py`` as usual:

.. code-block:: bash

    idf.py menuconfig
    idf.py build

.. note::

    Commands which communicate with the development board, s"
"uch as ``idf.py flash`` and ``idf.py monitor`` does not work in the container, unless the serial port is passed through into the container. This can be done with Docker for Linux with the `device option`_. However, currently, this is not possible with Docker for Windows (https://github.com/docker/for-win/issues/1018) and Docker for Mac (https://github.com/docker/for-mac/issues/900). This limitation may be overcome by using `remote serial ports`_. An example of how to do this can be found in the "
"following `using remote serial port`_ section.


.. _using remote serial port:

Using Remote Serial Port
~~~~~~~~~~~~~~~~~~~~~~~~

The `RFC2217`_ (Telnet) protocol can be used to remotely connect to a serial port. For more information please see the `remote serial ports`_ documentation in the ESP tool project. This method can also be used to access the serial port inside a Docker container if it cannot be accessed directly. Following is an example of how to use the Flash command from within a Do"
"cker container.

On host install and start ``esp_rfc2217_server``:

.. code-block:: bash

    esp_rfc2217_server -v -p 4000 COM3

.. code-block:: bash

    pip install esptool

And then starting the server by executing

.. code-block:: bash

    esp_rfc2217_server.py -v -p 4000 /dev/ttyUSB0

Now the device attached to the host can be flashed from inside a Docker container by using:

.. code-block:: bash

    docker run --rm -v :/ -w / espressif/idf idf.py --port 'rfc2217://host.docker.internal:4"
"000?ign_set_control' flash

Please make sure that ```` is properly set to your project path on the host, and ```` is set as a working directory inside the container with the ``-w`` option. The ``host.docker.internal`` is a special Docker DNS name to access the host. This can be replaced with a host IP if necessary.


Building Custom Images


The Docker file in ESP-IDF repository provides several build arguments which can be used to customize the Docker image:

- ``IDF_CLONE_URL``: URL of the rep"
"ository to clone ESP-IDF from. Can be set to a custom URL when working with a fork of ESP-IDF. The default is ``https://github.com/espressif/esp-idf.git``.
- ``IDF_CLONE_BRANCH_OR_TAG``: Name of a git branch or tag used when cloning ESP-IDF. This value is passed to the ``git clone`` command using the ``--branch`` argument. The default is ``master``.
- ``IDF_CHECKOUT_REF``: If this argument is set to a non-empty value, ``git checkout $IDF_CHECKOUT_REF`` command performs after cloning. This argume"
"nt can be set to the SHA of the specific commit to check out, for example, if some specific commit on a release branch is desired.
- ``IDF_CLONE_SHALLOW``: If this argument is set to a non-empty value, ``--depth=1 --shallow-submodules`` arguments are used when performing ``git clone``. Depth can be customized using ``IDF_CLONE_SHALLOW_DEPTH``. Doing a shallow clone significantly reduces the amount of data downloaded and the size of the resulting Docker image. However, if switching to a different"
" branch in such a ""shallow"" repository is necessary, an additional ``git fetch origin `` command must be executed first.
- ``IDF_CLONE_SHALLOW_DEPTH``: This argument specifies the depth value to use when doing a shallow clone. If not set, ``--depth=1`` will be used. This argument has effect only if ``IDF_CLONE_SHALLOW`` is used. Use this argument if you are building a Docker image for a branch, and the image has to contain the latest tag on that branch. To determine the required depth, run ``git"
" describe`` for the given branch and note the offset number. Increment it by 1, then use it as the value of this argument. The resulting image will contain the latest tag on the branch, and consequently ``git describe`` command inside the Docker image will work as expected.
- ``IDF_INSTALL_TARGETS``: Comma-separated list of ESP-IDF targets to install toolchains for, or ``all`` to install toolchains for all targets. Selecting specific targets reduces the amount of data downloaded and the size of "
"the resulting Docker image. The default is ``all``.

To use these arguments, pass them via the ``--build-arg`` command line option. For example, the following command builds a Docker image with a shallow clone of ESP-IDF v4.4.1 and tools for ESP32-C3 only:

.. code-block:: bash

    docker build -t idf-custom:v4.4.1-esp32c3 \
        --build-arg IDF_CLONE_BRANCH_OR_TAG=v4.4.1 \
        --build-arg IDF_CLONE_SHALLOW=1 \
        --build-arg IDF_INSTALL_TARGETS=esp32c3 \
        tools/docker

.. _r"
"emote serial ports: https://docs.espressif.com/projects/esptool/en/latest/esptool/remote-serial-ports.html
.. _RFC2217: http://www.ietf.org/rfc/rfc2217.txt
.. _esptool releases: https://github.com/espressif/esptool/releases
.. _device option: https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities
"
"
IDF Component Manager




The IDF Component Manager is a tool that downloads dependencies for any ESP-IDF CMake project. The download happens automatically during a run of CMake. It can source components either from the `component registry `__ or from a Git repository.

A list of components can be found on ``__.

For detailed information about the IDF Component Manager, see the `IDF Component Manager and ESP Component Registry Documentation `__.

Using with a Project


Dependencies for each com"
"ponent in the project are defined in a separate manifest file named ``idf_component.yml`` placed in the root of the component. The manifest file template can be created by running ``idf.py create-manifest``. By default, a manifest file is created for the main component. You can explicitly either specify the directory where the manifest should be created using the ``--path`` option or specify the component in your ``components`` folder using ``--component=my_component``. The ``create-manifest`` c"
"ommand can be run in the following ways:

- ``idf.py create-manifest`` creates a manifest file for the main component
- ``idf.py create-manifest --component=my_component`` creates a manifest file for the component **my_component** in the ``components`` directory
- ``idf.py create-manifest --path=""../../my_component""`` creates a manifest file for the component **my_component** in the ``my_component`` directory

When a new manifest is added to one of the components in the project, it is necessary "
"to reconfigure the project manually by running ``idf.py reconfigure``. The build will then track changes in ``idf_component.yml`` manifests and automatically trigger CMake when necessary.

To add a dependency to a component (e.g., ``my_component``) in your ESP-IDF project, you can run the command ``idf.py add-dependency DEPENDENCY``. The ``DEPENDENCY`` argument represents an additional component managed by the IDF Component Manager that ``my_component`` depends on. It is defined in the format ``"
"namespace/name=1.0.0``, where `namespace/name` is the name of the component and `=1.0.0` is a version range of the component, see the `Versioning Documentation `__. By default, dependencies are added to the main component. You can either explicitly specify a directory where the manifest is located using the ``--path`` option, or specify the component in your ``components`` folder using ``--component=my_component``. The ``add-dependency`` command can be run in the following ways:

- ``idf.py add-"
"dependency example/cmp`` adds a dependency on the most recent version of ``example/cmp`` to the main component
- ``idf.py add-dependency --component=my_component example/cmp`__.

To update dependencies of the ESP-IDF project, you can run the command ``idf.py update-dependencies``. You can also specify the path to the project directory using ``--project-dir PATH``.

There is an example application :example:`build_system/cmake/component_manager` that uses components installed by the component mana"
"ger.

It is not necessary to have a manifest for components that do not need any managed dependencies.

When CMake configures the project (e.g., ``idf.py reconfigure``) component manager does a few things:

- Processes ``idf_component.yml`` manifests for every component in the project and recursively solves dependencies.
- Creates a ``dependencies.lock`` file in the root of the project with a full list of dependencies.
- Downloads all dependencies to the ``managed_components`` directory.

The lo"
"ck file ``dependencies.lock`` and the content of the ``managed_components`` directory are not supposed to be modified by a user. When the component manager runs, it always makes sure they are up to date. If these files were accidentally modified, it is possible to re-run the component manager by triggering CMake with ``idf.py reconfigure``.

You may set the build property ``DEPENDENCIES_LOCK`` to specify the lock-file path in the top-level CMakeLists.txt. For example, adding ``idf_build_set_prop"
"erty(DEPENDENCIES_LOCK dependencies.lock.${IDF_TARGET})`` before ``project(PROJECT_NAME)`` could help generate different lock files for different targets.

Creating a Project From an Example


Some components on the registry contain example projects. To create a new project from an example you can run the command ``idf.py create-project-from-example EXAMPLE``. The ``EXAMPLE`` argument should be in the format ``namespace/name=1.0.0:example`` where `namespace/name` is the name of the component, `="
"1.0.0` is a version range of the component (see the `Versioning Documentation `__) and `example` is the example's name. You can find the list of examples for every component and the command to start a project for it in the `Espressif Component Registry `__.

Defining Dependencies in the Manifest


You can easily define dependencies in the manifest file ``idf_component.yml`` by editing it directly in the text editor. Below are some basic examples that demonstrate how to define dependencies.

You "
"can define a dependency from the registry by specifying the component name and the version range:

.. code-block:: yaml

    dependencies:
      # Define a dependency from the registry (https://components.espressif.com/component/example/cmp)
      example/cmp: "">=1.0.0""

To define a dependency from a Git repository, provide the path to the component within the repository and the repository's URL:

.. code-block:: yaml

    dependencies:
      # Define a dependency from a Git repository
      tes"
"t_component:
        path: test_component
        git: ssh://git@gitlab.com/user/components.git

During the development of components, you can use components from a local directory by specifying either a relative or an absolute path:

.. code-block:: yaml

      dependencies:
        # Define local dependency with relative path
        some_local_component:
          path: ../../projects/component

For detailed information about the manifest file format, see `Manifest File Format Documentation `"
"__.

Disabling the Component Manager


The component manager can be explicitly disabled by setting the ``IDF_COMPONENT_MANAGER`` environment variable to ``0``.
"
"QEMU Emulator


Espressif maintains a `fork `_ of the QEMU emulator with support for {IDF_TARGET_NAME}. This fork implements emulation of the CPU, memory, and several peripherals of {IDF_TARGET_NAME}. For more information about QEMU for {IDF_TARGET_NAME}, see the `documentation `_.

:doc:`idf.py` allows for running and debugging applications in QEMU. This is a convenient way to test applications without having to flash them to real hardware.

Prerequisites


To use QEMU with ``idf.py`` you first"
" need to install the above-mentioned fork of QEMU. ESP-IDF provides pre-built binaries for x86_64 and arm64 Linux and macOS, as well as x86_64 Windows. Before you use the pre-built binaries on Linux and macOS platroms please install system dependencies:

- Ubuntu and Debian:

.. code-block:: console

    sudo apt-get install -y libgcrypt20 libglib2.0-0 libpixman-1-0 libsdl2-2.0-0 libslirp0

- CentOS:

.. code-block:: console

    sudo yum install -y --enablerepo=powertools libgcrypt glib2 pixman"
" SDL2 libslirp

- Arch:

.. code-block:: console

    sudo pacman -S --needed libgcrypt glib2 pixman sdl2 libslirp

- macOS:

.. code-block:: console

    brew install libgcrypt glib pixman sdl2 libslirp

Then install the pre-built binaries with the following command:

.. code-block:: console

    python $IDF_PATH/tools/idf_tools.py install qemu-xtensa qemu-riscv32

After installing QEMU, make sure it is added to PATH by running ``. ./export.sh`` in the IDF directory.

If you are using a differe"
"nt platform, you need to build QEMU from source. Refer to official QEMU documentation for instructions.

Usage


Running an Application
~~~~~~~~~~~~~~~~~~~~~~

To run an IDF application in QEMU, use the following command:

.. code-block:: console

    idf.py qemu monitor

This command builds the application, starts QEMU and opens :doc:`IDF monitor `, connecting it to the emulated UART port. You can see the console output of the application and interact with it. IDF Monitor also provides automati"
"c decoding of panic backtraces and UART core dumps.

Debugging
~~~~~~~~~

To debug an application in QEMU, use the following command:

.. code-block:: console

    idf.py qemu gdb

This command builds the application, starts QEMU with the GDB server enabled, and opens an interactive GDB session. You can use GDB to debug the application as if it was running on real hardware.

To see console output while debugging in QEMU, use two terminals.

  .. code-block:: console

    idf.py qemu --gdb monito"
"r

  This command starts QEMU and IDF Monitor, and tells QEMU to wait for a GDB connection.

  .. code-block:: console

    idf.py gdb

  This command starts an interactive GDB sessions and connects it to QEMU. You can now debug the application, and the console output will be visible in the first terminal.

It is also possible to run QEMU without the IDF Monitor:

.. code-block:: console

    idf.py qemu

In this case, the IDF Monitor is not used, and you can interact with QEMU process directly."
" To switch between the emulated UART console and QEMU console (""QEMU monitor""), use Ctrl-A shortcut. For example, to exit QEMU, press Ctrl-A, then type ``q`` and press Enter. You can use the QEMU console to enter commands, such as for inspecting registers and memory.

Graphics Support
~~~~~~~~~~~~~~~~

QEMU supports a virtual framebuffer device. This device doesn't exist in the real {IDF_TARGET_NAME} hardware, but it can be used to test graphics applications in QEMU.

To launch QEMU with a virtu"
"al framebuffer device enabled, use the following command:

.. code-block:: console

    idf.py qemu --graphics monitor

When the ``--graphics`` option is used, QEMU opens an additional window where the framebuffer contents are displayed.

To use the virtual framebuffer device in your application, you can add the `espressif/esp_lcd_qemu_rgb `_ component to your project. This component provides an esp_lcd compatible driver for the virtual framebuffer device.
"
"IDF Windows Installer




Command-Line Parameters


Windows Installer ``esp-idf-tools-setup`` provides the following command-line parameters:

Unattended Installation


The unattended installation of ESP-IDF can be achieved by following command-line parameters:

.. code-block:: batch

    esp-idf-tools-setup-x.x.exe /VERYSILENT /SUPPRESSMSGBOXES /SP- /NOCANCEL

When running the installer from the command line, it detaches its process from the command line and starts a separate process in the bac"
"kground to perform the installation without blocking the use of the command line. The following PowerShell script allows you to wait for the installer to complete:

.. code-block:: powershell

    esp-idf-tools-setup-x.x.exe /VERYSILENT /SUPPRESSMSGBOXES /SP- /NOCANCEL
    $InstallerProcess = Get-Process esp-idf-tools-setup
    Wait-Process -Id $InstallerProcess.id

Custom Python and Custom Location of Python Wheels


The IDF installer is using by default embedded Python with reference to the Py"
"thon Wheel mirror.

The following parameters allow to select custom Python and custom location of Python wheels:

.. code-block:: batch

    esp-idf-tools-setup-x.x.exe /USEEMBEDDEDPYTHON=no /PYTHONWHEELSURL=https://pypi.org/simple/
"
"IDF Frontend - ``idf.py``




The ``idf.py`` command-line tool provides a front-end for easily managing your project builds, deployment and debugging, and more. It manages several tools, for example:

- CMake_, which configures the project to be built.
- Ninja_, which builds the project.
- `esptool.py`_, which flashes the target.

The :ref:`Step 5. First Steps on ESP-IDF ` contains a brief introduction on how to set up ``idf.py`` to configure, build, and flash projects.

.. important::

  ``idf."
"py`` should be run in an ESP-IDF project directory, i.e., a directory containing a ``CMakeLists.txt`` file. Older style projects that contain a ``Makefile`` will not work with ``idf.py``.

Commands


Start a New Project: ``create-project``


.. code-block:: bash

    idf.py create-project 

This command creates a new ESP-IDF project. Additionally, the folder where the project will be created in can be specified by the ``--path`` option.

Create a New Component: ``create-component``


.. code-blo"
"ck:: bash

    idf.py create-component 

This command creates a new component, which will have a minimum set of files necessary for building. The ``-C`` option can be used to specify the directory the component will be created in. For more information about components see the :ref:`Component CMakeLists Files `.

.. _selecting-idf-target:

Select the Target Chip: ``set-target``


ESP-IDF supports multiple targets (chips). A full list of supported targets in your version of ESP-IDF can be seen by "
"running ``idf.py --list-targets``.

.. code-block:: bash

    idf.py set-target 

This command sets the current project target.

.. important::

    ``idf.py set-target`` will clear the build directory and re-generate the ``sdkconfig`` file from scratch. The old ``sdkconfig`` file will be saved as ``sdkconfig.old``.

.. note::

    The behavior of the ``idf.py set-target`` command is equivalent to:

It is also possible to pass the desired ``IDF_TARGET`` as an environment variable (e.g., ``export"
" IDF_TARGET=esp32s2``) or as a CMake variable (e.g., ``-DIDF_TARGET=esp32s2`` argument to CMake or  ``idf.py`` ). Setting the environment variable is a convenient method if you mostly work with one type of the chip.

To specify the default value of ``IDF_TARGET`` for a given project, please add the ``CONFIG_IDF_TARGET`` option to the project's ``sdkconfig.defaults`` file, e.g., ``CONFIG_IDF_TARGET=""esp32s2""``. This value of the option will be used if ``IDF_TARGET`` is not specified by other meth"
"ods, such as using an environment variable, a CMake variable, or the ``idf.py set-target`` command.

If the target has not been set by any of these methods, the build system will default to ``esp32`` target.

Start the Graphical Configuration Tool: ``menuconfig``


.. code-block:: bash

  idf.py menuconfig

Build the Project: ``build``


.. code-block:: bash

  idf.py build

This command builds the project found in the current directory. This can involve multiple steps:

  - Create the build dir"
"ectory if needed. The sub-directory ``build`` is used to hold build output, although this can be changed with the ``-B`` option.
  - Run CMake_ as necessary to configure the project and generate build files for the main build tool.
  - Run the main build tool (Ninja_ or `GNU Make`). By default, the build tool is automatically detected but it can be explicitly set by passing the ``-G`` option to ``idf.py``.

Building is incremental, so if no source files or configuration has changed since the las"
"t build, nothing will be done.

Additionally, the command can be run with ``app``, ``bootloader`` and ``partition-table`` arguments to build only the app, bootloader or partition table as applicable.

Remove the Build Output: ``clean``


.. code-block:: bash

  idf.py clean

This command removes the project build output files from the build directory, and the project will be fully rebuilt on next build. Using this command does not remove the CMake configuration output inside the build folder.

D"
"elete the Entire Build Contents: ``fullclean``


.. code-block:: bash

  idf.py fullclean

This command deletes the entire ""build"" directory contents, which includes all CMake configuration output. The next time the project is built, CMake will configure it from scratch. Note that this option recursively deletes **all** files in the build directory, so use with care. Project configuration is not deleted.

Flash the Project: ``flash``


.. code-block:: bash

  idf.py flash

This command automatic"
"ally builds the project if necessary, and then flash it to the target. You can use ``-p`` and ``-b`` options to set serial port name and flasher baud rate, respectively.

.. note:: The environment variables ``ESPPORT`` and ``ESPBAUD`` can be used to set default values for the ``-p`` and ``-b`` options, respectively. Providing these options on the command line overrides the default.

Similarly to the ``build`` command, the command can be run with ``app``, ``bootloader`` and ``partition-table`` ar"
"guments to flash only the app, bootloader or partition table as applicable.

Hints on How to Resolve Errors


``idf.py`` will try to suggest hints on how to resolve errors. It works with a database of hints stored in :idf_file:`tools/idf_py_actions/hints.yml` and the hints will be printed if a match is found for the given error. The menuconfig target is not supported at the moment by automatic hints on resolving errors.

The ``--no-hints`` argument of ``idf.py`` can be used to turn the hints off"
" in case they are not desired.

Important Notes


Multiple ``idf.py`` commands can be combined into one. For example, ``idf.py -p COM4 clean flash monitor`` will clean the source tree, then build the project and flash it to the target before running the serial monitor.

The order of multiple ``idf.py`` commands on the same invocation is not important, as they will automatically be executed in the correct order for everything to take effect (e.g., building before flashing, erasing before flashing"
").

For commands that are not known to ``idf.py``, an attempt to execute them as a build system target will be made.

The command ``idf.py`` supports `shell autocompletion `_ for bash, zsh and fish shells.

To enable autocompletion for ``idf.py``, use the ``export`` command (:ref:`Step 4. Set up the environment variables `). Autocompletion is initiated by pressing the TAB key. Type ``idf.py -`` and press the TAB key to autocomplete options.

The autocomplete support for PowerShell is planned in "
"the future.

Advanced Commands


Open the Documentation: ``docs``


.. code-block:: bash

  idf.py docs

This command opens the documentation for the projects target and ESP-IDF version in the browser.

Show Size: ``size``


.. code-block:: bash

  idf.py size

This command prints app size information including the occupied RAM and flash and section (i.e., .bss) sizes.

.. code-block:: bash

  idf.py size-components

Similarly, this command prints the same information for each component used in "
"the project.

.. code-block:: bash

  idf.py size-files

This command prints size information per source file in the project.

Options


- ``--format`` specifies the output format with available options: ``text``, ``csv``, ``json``, default being ``text``.
- ``--output-file`` optionally specifies the name of the file to print the command output to instead of the standard output.

Reconfigure the Project: ``reconfigure``


.. code-block:: bash

  idf.py reconfigure

This command forces CMake_ to "
"be rerun regardless of whether it is necessary. It is unnecessary during normal usage, but can be useful after adding/removing files from the source tree, or when modifying CMake cache variables. For example, ``idf.py -DNAME='VALUE' reconfigure`` can be used to set variable ``NAME`` in CMake cache to value ``VALUE``.

Clean the Python Byte Code: ``python-clean``


.. code-block:: bash

  idf.py python-clean

This command deletes generated python byte code from the ESP-IDF directory. The byte cod"
"e may cause issues when switching between ESP-IDF and Python versions. It is advised to run this target after switching versions of Python.

Generate a UF2 Binary: ``uf2``


.. code-block:: bash

  idf.py uf2

This command generates a UF2 (`USB Flashing Format `_) binary ``uf2.bin`` in the build directory. This file includes all the necessary binaries (bootloader, app, and partition table) for flashing the target.

This UF2 file can be copied to a USB mass storage device exposed by another ESP r"
"unning the `ESP USB Bridge `_ project. The bridge MCU will use it to flash the target MCU. This is as simple as copying (or ""drag-and-dropping"") the file to the exposed disk accessed by a file explorer in your machine.

To generate a UF2 binary for the application only (not including the bootloader and partition table), use the ``uf2-app`` command.

.. code-block:: bash

  idf.py uf2-app

Read Otadata Partition: ``read-otadata``


.. code-block:: bash

  idf.py read-otadata

This command prints "
"the contents of the ``otadata`` partition which stores the information about the currently selected OTA app slot. Refer to :doc:`/api-reference/system/ota` for more about the ``otadata`` partition.

Global Options


To list all available root level options, run ``idf.py --help``. To list options that are specific for a subcommand, run ``idf.py  --help``, e.g., ``idf.py monitor --help``. Here is a list of some useful options:

- ``-C `` allows overriding the project directory from the default cur"
"rent working directory.
- ``-B `` allows overriding the build directory from the default ``build`` subdirectory of the project directory.
- ``--ccache`` enables CCache_ when compiling source files if the CCache_ tool is installed. This can dramatically reduce the build time.

.. important::

    Note that some older versions of CCache_ may exhibit bugs on some platforms, so if files are not rebuilt as expected, try disabling CCache_ and rebuiling the project. To enable CCache_ by default, set th"
"e ``IDF_CCACHE_ENABLE`` environment variable to a non-zero value.

- ``-v`` flag causes both ``idf.py`` and the build system to produce verbose build output. This can be useful for debugging build problems.
- ``--cmake-warn-uninitialized`` (or ``-w``)  causes CMake to print uninitialized variable warnings found in the project directory only. This only controls CMake variable warnings inside CMake itself, not other types of build warnings. This option can also be set permanently by setting the ``"
"IDF_CMAKE_WARN_UNINITIALIZED`` environment variable to a non-zero value.
- ``--no-hints`` flag disables hints on resolving errors and disable capturing output.

Passing arguments via a ``@file``


It is possible to pass multiple arguments to ``idf.py`` via a file. The file or path to the file must be annotated with ``@`` at the beginning. Arguments in the file can be separated by newlines or spaces and are expanded exactly as if they had appeared in that order on the idf.py command line.

For ex"
"ample, let's have a file `custom_flash.txt`:

.. code-block:: bash

  flash --baud 115200

Then the command can be executed as: ``idf.py @custom_flash.txt monitor``

Arguments from a file can be combined with additional command line arguments, and multiple files annotated with ``@`` can be used simultaneously. For instance, if there is a second file ``another_config.txt``, both can be utilized by specifying ``idf.py @custom_flash.txt @another_config.txt monitor``.

A further example of how this "
"argument file can be used, e.g., creating configuration profile files via @filename, is in the :example_file:`Multiple Build Configurations Example `.

.. _cmake: https://cmake.org
.. _ninja: https://ninja-build.org
.. _esptool.py: https://github.com/espressif/esptool/#readme
.. _CCache: https://ccache.dev/
"
"Downloadable IDF Tools




The ESP-IDF build process relies on a number of tools: cross-compiler toolchains, CMake build system, and others.

Installing the tools using an OS-specific package manager (e.g., apt, yum, brew, etc.) is the preferred method, when the required version of the tool is available. This recommendation is reflected in the :doc:`Get Started `. For example, on Linux and macOS, it is recommended to install CMake using an OS package manager.

However, some of the tools are spec"
"ific to ESP-IDF and are not available in OS package repositories. Furthermore, different ESP-IDF versions require different tool versions for proper operation. To solve these two problems, ESP-IDF provides a set of scripts that can download and install the correct tool versions and set up the environment accordingly.

The rest of the document refers to these downloadable tools simply as ""tools"". Other kinds of tools used in ESP-IDF are:

The following sections explain the installation method and"
" provide the list of tools installed on each platform.

.. note::

    This document is provided for advanced users who need to customize their installation, users who wish to understand the installation process, and ESP-IDF developers.

    If you are looking for instructions on how to install the tools, see :doc:`Get Started `.


Tools Metadata File


The list of tools and tool versions required for each platform is located in :idf_file:`tools/tools.json`. The schema of this file is defined by"
" :idf_file:`tools/tools_schema.json`.

This file is used by the :idf_file:`tools/idf_tools.py` script when installing the tools or setting up the environment variables.

.. _idf-tools-path:

Tools Installation Directory


The ``IDF_TOOLS_PATH`` environment variable specifies the location where the tools are to be downloaded and installed. If not set, the default location will be ``HOME/.espressif`` on Linux and macOS, and ``%USER_PROFILE%\.espressif`` on Windows.

Inside the ``IDF_TOOLS_PATH`` d"
"irectory, the tools installation scripts create the following directories and files:

- ``dist`` — where the archives of the tools are downloaded.
- ``tools`` — where the tools are extracted. The tools are extracted into subdirectories: ``tools/TOOL_NAME/VERSION/``. This arrangement allows different versions of tools to be installed side by side.
- ``idf-env.json`` — user install options, such as targets and features, are stored in this file. Targets are selected chip targets for which tools are"
" installed and kept up-to-date. Features determine the Python package set which should be installed. These options will be discussed later.
- ``python_env`` —  not related to the tools; virtual Python environments are installed in the sub-directories. Note that the Python environment directory can be placed elsewhere by setting the ``IDF_PYTHON_ENV_PATH`` environment variable.
- ``espidf.constraints.*.txt`` — one constraint file for each ESP-IDF release containing Python package version requirem"
"ents.

GitHub Assets Mirror


Most of the tools downloaded by the tools installer are GitHub Release Assets, which are files attached to a software release on GitHub.

If GitHub downloads are inaccessible or slow to access, a GitHub assets mirror can be configured.

To use Espressif's download server, set the environment variable ``IDF_GITHUB_ASSETS`` to ``dl.espressif.com/github_assets``, or ``dl.espressif.cn/github_assets`` for faster download in China. When the install process is downloading "
"a tool from ``github.com``, the URL will be rewritten to use this server instead.

Any mirror server can be used provided the URL matches the ``github.com`` download URL format. For any GitHub asset URL that the install process downloads, it will replace ``https://github.com`` with ``https://${IDF_GITHUB_ASSETS}``.

.. note:: The Espressif download server currently does not mirror everything from GitHub, but only files attached as Assets to some releases, as well as source archives for some rele"
"ases.


``idf_tools.py`` Script


The :idf_file:`tools/idf_tools.py` script bundled with ESP-IDF performs several functions:

  The ``install`` command accepts the list of tools to install in the ``TOOL_NAME`` or ``TOOL_NAME@VERSION`` format. If ``all`` is given, all the tools, including required and optional ones, are installed. If no argument or ``required`` is given, only the required tools are installed.

  The environment variables can be listed in either ``shell`` or ``key-value`` formats,"
" which can be set using the ``--format`` parameter:

  - ``export`` optional parameters:

    - ``--unset``: Creates a statement that unsets specific global variables and restores the environment to its state before calling ``export.{sh/fish}``.
    - ``--add_paths_extras``: Adds extra ESP-IDF-related paths of ``$PATH`` to ``${IDF_TOOLS_PATH}/esp-idf.json``, which is used to remove global variables when the active ESP-IDF environment is deactivated. For example, while processing the ``export.{sh"
"/fish}`` script, if new paths are added to the global variable ``$PATH``, this option saves these new paths to the ``${IDF_TOOLS_PATH}/esp-idf.json`` file.

  - ``shell``: Produces output suitable for evaluation in the shell. For example, produce the following output on Linux and macOS:

    .. code-block:: none

        export PATH=""/home/user/.espressif/tools/tool/v1.0.0/bin:$PATH""

    Produce the following output on Windows:

    .. code-block:: none

        set ""PATH=C:\Users\user\.espress"
"if\tools\v1.0.0\bin;%PATH%""

    .. note::

        Exporting environment variables in Powershell format is not supported at the moment. ``key-value`` format may be used instead.

    The output of this command may be used to update the environment variables if the shell supports it. For example

    .. code-block:: none

        eval $($IDF_PATH/tools/idf_tools.py export)

  - ``key-value``: Produces output in the ``VARIABLE=VALUE`` format that is suitable for parsing by other scripts

    .. c"
"ode-block:: none

        PATH=/home/user/.espressif/tools/tool/v1.0.0:$PATH

    Note that the script consuming this output has to perform expansion of ``$VAR`` or ``%VAR%`` patterns found in the output.

  The following option is available to customize the output.

  - ``--outdated``: Lists only outdated versions of tools installed in ``IDF_TOOLS_PATH``.

    #. A feature that begins with ``-`` will be removed, and features with ``+`` or without any sign will be added. Example syntax for remov"
"ing feature ``XY`` is ``--features=-XY``, and for adding feature ``XY`` is ``--features=+XY`` or ``--features=XY``. If both removing and adding options are provided with the same feature, no operation is performed.

    #. For each feature, a requirements file must exist. For example, feature ``XY`` is a valid feature if ``${IDF_PATH}/tools/requirements/requirements.XY.txt`` is an existing file with a list of Python packages to be installed.

    #. There is one mandatory ``core`` feature ensuri"
"ng the core functionality of ESP-IDF, e.g., build, flash, monitor, debug in console. There can be an arbitrary number of optional features.

    #. The selected list of features is stored in ``idf-env.json``.

    #. The requirement files contain a list of the desired Python packages to be installed and the ``espidf.constraints.*.txt`` file downloaded from https://dl.espressif.com and stored in ``${IDF_TOOLS_PATH}``, which contains the package version requirements for a given ESP-IDF version.

 "
" .. note::

    Although **it is not recommended**, the download and use of constraint files can be disabled with the ``--no-constraints`` argument or setting the ``IDF_PYTHON_CHECK_CONSTRAINTS`` environment variable to ``no``.

  .. note::

    The constraint file is downloaded with the ``install-python-env`` command. Similar to the ``install-python-env`` command, the use of constraint files can be disabled with the ``--no-constraints`` argument or setting the ``IDF_PYTHON_CHECK_CONSTRAINTS`` e"
"nvironment variable to ``no``.

  - ``--dry-run``: Prints installed unused tools.
  - ``--remove-archives``: Additionally removes all older versions of previously downloaded installation packages.

.. _idf-tools-install:

Install Scripts


Shell-specific user-facing installation scripts are provided in the root directory of ESP-IDF repository to facilitate tools installation. These are:

Apart from downloading and installing the tools in ``IDF_TOOLS_PATH``, these scripts prepare a Python virtual"
" environment, and install the required packages into that environment.

These scripts accept optionally a comma-separated list of chip targets and ``--enable-*`` arguments for enabling features. These arguments are passed to the ``idf_tools.py`` script which stores them in ``idf-env.json``. Therefore, chip targets and features can be enabled incrementally.

To install tools for all chip targets, run the scripts without any optional arguments using ``idf_tools.py install --targets=all``. Similarl"
"y, to install Python packages for core ESP-IDF functionality, run ``idf_tools.py install-python-env --features=core``.

It is also possible to install tools for specific chip targets. For example, ``install.sh esp32`` installs tools only for ESP32. See :ref:`Step 3. Set up the Tools ` for more examples.

``install.sh --enable-XY`` enables feature ``XY`` (by running ``idf_tools.py install-python-env --features=core,XY``).

.. _idf-tools-export:

Export Scripts


Since the installed tools are not "
"permanently added to the user or system ``PATH`` environment variable, an extra step is required to use them in the command line. The following scripts modify the environment variables in the current shell to make the correct versions of the tools available:

.. note::

    To modify the shell environment in Bash, ``export.sh`` must be ""sourced"" by using the ``. ./export.sh`` command. Please ensure to include the leading dot and space.

    ``export.sh`` may be used with shells other than Bash ("
"such as zsh). However, in this case, it is required to set the ``IDF_PATH`` environment variable before running the script. When used in Bash, the script guesses the ``IDF_PATH`` value from its own location.

In addition to calling ``idf_tools.py``, these scripts list the directories that have been added to the ``PATH``.

Other Installation Methods


Depending on the environment, more user-friendly wrappers for ``idf_tools.py`` are provided:

Custom Installation


Although the methods above are "
"recommended for ESP-IDF users, they are not a must for building ESP-IDF applications. ESP-IDF build system expects that all the necessary tools are installed somewhere, and made available in the ``PATH``.

.. _idf-tools-uninstall:

Uninstall ESP-IDF


Uninstalling ESP-IDF requires removing both the tools and the environment variables that have been configured during the installation.

.. note::

  Uninstalling the ESP-IDF tools does not remove any project files or your code. Be mindful of what y"
"ou are deleting to avoid losing any work. If you are unsure about a step, refer back to the installation instructions.

  These instructions assume that the tools were installed following the procedures in this provided document. If you've used a custom installation method, you might need to adapt these instructions accordingly.

.. _idf-tools-list:

List of ESP-IDF Tools


.. include-build-file:: idf-tools-inc.rst
"
"
IDF Clang-Tidy




The IDF Clang Tidy is a tool that uses `clang-tidy `__ to run static analysis on your current app.

.. warning::

   This functionality and the toolchain it relies on are still under development. There may be breaking changes before a final release.

   Only clang based toolchain is currently supported. It has to be activated by setting ``IDF_TOOLCHAIN=clang`` in the environment or in CMake cache before configuring the project.

.. only:: CONFIG_IDF_TARGET_ARCH_RISCV

   .. w"
"arning::

      This tool does not support RISC-V based chips yet. For now, we do not provide clang based toolchain for RISC-V.

Prerequisites


If you have never run this tool before, take the following steps to get this tool prepared.

#. Run ``idf_tools.py install esp-clang`` to install the clang-tidy required binaries

   .. note::

      This toolchain is still under development. After the final release, you do not have to install them manually.

#. Run the export scripts (``export.sh`` / `"
"`export.bat`` / ... ) again to refresh the environment variables.

Extra Commands


``clang-check``


Run ``idf.py clang-check`` to re-generate the compilation database and run ``clang-tidy`` under your current project folder. The output would be written to ``/warnings.txt``.

Run ``idf.py clang-check --help`` to see the full documentation.

``clang-html-report``


#. Run ``pip install codereport`` to install the additional dependency.
#. Run ``idf.py clang-html-report`` to generate an HTML repo"
"rt in folder ``/html_report`` according to the ``warnings.txt``. Please open the ``/html_report/index.html`` in your browser to check the report.

Bug Report


This tool is hosted in `espressif/clang-tidy-runner `__. If you were to face any bugs or have any feature request, please report them via `Github issues `__
"
"
ESP-BLE-MESH




Bluetooth® mesh networking enables many-to-many (m:m) device communications and is optimized for creating large-scale device networks.

Devices may relay data to other devices not in direct radio range of the originating device. In this way, mesh networks can span very large physical areas and contain large numbers of devices. It is ideally suited for building automation, sensor networks, and other IoT solutions where tens, hundreds, or thousands of devices need to reliably and"
" securely communicate with one another.

Bluetooth mesh is not a wireless communications technology, but a networking technology. This technology is dependent upon Bluetooth Low Energy (BLE) - a wireless communications protocol stack.

Built on top of Zephyr Bluetooth Mesh stack, the ESP-BLE-MESH implementation supports device provisioning and node control. It also supports such node features as Proxy, Relay, Low power and Friend.

Please see the :doc:`ble-mesh-architecture` for information abou"
"t the implementation of ESP-BLE-MESH architecture and :doc:`ESP-BLE-MESH API Reference ` for information about respective API.

ESP-BLE-MESH is implemented and certified based on the latest Mesh Profile v1.0.1, users can refer `here `_ for the certification details of ESP-BLE-MESH.

.. only:: SOC_WIFI_MESH_SUPPORT

    .. note::

      If you are looking for Wi-Fi based implementation of mesh for {IDF_TARGET_NAME}, please check another product by Espressif called ESP-WIFI-MESH. For more informat"
"ion and documentation see :doc:`ESP-WIFI-MESH `.


.. _getting-started-with-ble-mesh:

Getting Started with ESP-BLE-MESH


This section is intended to help you get started with ESP-BLE-MESH for the hardware based on the {IDF_TARGET_NAME} chip by Espressif.

We are going to demonstrate process of setting and operation of a small ESP-BLE-MESH network of three nodes. This process will cover device provisioning and node configuration, and then sending on/off commands to Generic OnOff Server Models o"
"n specific nodes.

If you are new to ESP-IDF, please first set up development environment, compile , flash and run example application following top level ESP-IDF :doc:`../../get-started/index` documentation.


What You Need


Hardware:

Software:

    - `EspBleMesh `_ Android App
    - Silicon Labs Android or iOS App

Installation Step by Step


This is a detailed roadmap to walk you through the installation process.


.. _get-started-ble-mesh-check-hardware:

Step 1. Check Hardware
"""""""""""""""""""""""
"""""""""""""""""""""""

Both `ESP32-DevKitC`_ and `ESP-WROVER-KIT`_ development boards are supported for ESP-BLE-MESH implementation. You can choose particular board through menuconfig: :code:`idf.py menuconfig` > ``Example Configuration`` > ``Board selection for ESP-BLE-MESH``

.. note::

  If you plan to use `ESP32-DevKitC`_, connect a RGB LED to GPIO pins 25, 26 and 27.


Step 2. Configure Software
""""""""""""""""""""""""""""""""""""""""""""""""""""

Enter the :example:`bluetooth/esp_ble_mesh/onoff_models/onoff_server` example "
"directory, run :code:`idf.py menuconfig` to select your board and then run :code:`idf.py build` to compile the example.

Step 3. Upload Application to Nodes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

After the :example:`bluetooth/esp_ble_mesh/onoff_models/onoff_server` example is compiled successfully, users can run :code:`idf.py flash` to upload the same generated binary files into each of the three development boards.

Once boards are powered on, the RGB LED on each board should turn **GREEN**.

.. "
"figure:: ../../../_static/ble-mesh-device-power-on.png
    :align: center

    ESP-BLE-MESH Devices Power On

Step 4. Provision Nodes
""""""""""""""""""""""""""""""""""""""""""""""

In this section, we will use the **nRF Mesh Android** App to demonstrate how to provision an unprovisioned device. Users can also get its iOS version from the App Store.

4.1 Scanner


The Scanner is App's functionality to search for unprovisioned devices in range. Open the App, press **Scanner** at the bottom and the search will start. Af"
"ter a short while we should see three unprovisioned devices displayed.

.. figure:: ../../../_static/ble-mesh-scanner.png
    :align: center
    :height: 370

    nRF Mesh - Scanner

4.2 Identify


Users can select any unprovisioned device, then the App will try to set up a connection with the selected device. After the Bluetooth LE connection is established successfully (sometimes users need to try multiple times to get connected), and proper ESP-BLE-MESH GATT Service is discovered, users can s"
"ee the **IDENTIFY** interface button on the screen. The IDENTIFY operation can be used to tell users which device is going to be provisioned.

.. note::
    The IDENTIFY operation also needs some cooperation on the device side, then users can see which device is in the provisioning process. Currently when pressing the **IDENTIFY** interface button, no signs can been seen from the device except from the log on the serial monitor.

After the **IDENTIFY** interface button is pressed, users can see "
"the **PROVISION** interface button.

.. figure:: ../../../_static/ble-mesh-identify-provision.png
    :align: center
    :height: 370

    nRF Mesh - IDENTIFY - PROVISION

4.3 Provision


Then, the App will try to provision the unprovisioned device. When the device is provisioned successfully, the RGB LED on the board will turn off, and the App will implement the following procedures:

#. Disconnect with the node
#. Try to reconnect with the node
#. Connect successfully and discover ESP-BLE-MESH"
" GATT Service
#. Get Composition Data of the node and add AppKey to it

When all the procedures are finished, the node is configured properly. And after pressing **OK**, users can see that unicast address is assigned, and Composition Data of the node is decoded successfully.

.. figure:: ../../../_static/ble-mesh-config-complete.png
    :align: center
    :height: 370

    nRF Mesh - Configuration Complete

Sometimes in procedure 2, the App may fail to reconnect with the node. In this case, afte"
"r pressing **OK**, users can see that only unicast address of the node has been assigned, but no Composition Data has been got. Then users need to press **CONNECT** on the top right, and the previously provisioned node will be displayed on the screen, and users need to choose it and try to connect with the node.

.. figure:: ../../../_static/ble-mesh-initial-config-fail.png
    :align: center
    :height: 370

    nRF Mesh - Initial Configuration Failed

After connecting successfully, the App wi"
"ll show the interface buttons which can be used to get Composition Data and add AppKey.

.. figure:: ../../../_static/ble-mesh-reconnect-initial-config.png
    :align: center
    :height: 370

    nRF Mesh - Reconnect - Initial Configuration

If the device is the second or the third one which has been provisioned by the App, and after pressing **CONNECT**, users can see two or three nodes on the screen. In this situation, users can choose any device to connect with, once succeed then go back to "
"the main screen to choose the node which needs to be configured.

Here an example of three devices listed.

.. figure:: ../../../_static/ble-mesh-reconnect-three.png
    :align: center
    :height: 370

    nRF Mesh - Reconnect - Three Nodes

4.4 Configuration


When provisioning and initial configuration are finished, users can start to configure the node, such as binding AppKey with each model with the elements, setting publication information to it, etc.

Example below shows how to bind AppKe"
"y with Generic OnOff Server Model within the Primary Element.

.. figure:: ../../../_static/ble-mesh-model-bind-appkey.png
    :align: center
    :height: 370

    nRF Mesh - Model Bind AppKey

.. note::

    No need to bind AppKey with the Configuration Server Model, since it only uses the DevKey to encrypt messages in the Upper Transport Layer.

Step 5. Operate Network
""""""""""""""""""""""""""""""""""""""""""""""

After all the Generic OnOff Server Models within the three elements are bound with proper AppKey, use"
"rs can use the App to turn on/off the RGB LED.

In the :example:`bluetooth/esp_ble_mesh/onoff_models/onoff_server` example, the first Generic OnOff Server Model is used to control the **RED** color, the second one is used to control the **GREEN** color and the third one is used to control the **BLUE** color.

.. figure:: ../../../_static/ble-mesh-generic-onoff.png
    :align: center
    :height: 370

    nRF Mesh - Generic OnOff Control

The following screenshot shows different board with differ"
"ent color on.

.. figure:: ../../../_static/ble-mesh-three-nodes-on.png
    :align: center

    Three ESP-BLE-MESH Nodes On

.. note::
  For **nRF Mesh** iOS App [version 1.0.4], when the node contains more than one element, the App is not behaving correctly. If users try to turn on/off the second or the third Generic OnOff Server Model, the message sent by the App is destinated to the first Generic OnOff Server Model within the Primary Element.


.. _esp-ble-mesh-examples:

ESP-BLE-MESH Example"
"s



.. _esp-ble-mesh-demo-videos:

ESP-BLE-MESH Demo Videos



ESP-BLE-MESH FAQ



Related Documents


.. toctree::
    :maxdepth: 1

    ble-mesh-feature-list
    ble-mesh-architecture
    ble-mesh-faq
    ble-mesh-terminology



Bluetooth SIG Documentation


- `BLE Mesh Core Specification `_
- `BLE Mesh Protocol v1.1 Specification(draft) `_
- `BLE Mesh Model Specification `_
- `BLE Mesh Model v1.1 Specification(draft) `_
- `An Intro to Bluetooth Mesh Part 1 `_ / `Part 2 `__
- `The Fundamental"
" Concepts of Bluetooth Mesh Networking, Part 1 `_ / `Part 2 `__
- `Bluetooth Mesh Networking: Friendship `_
- `Management of Devices in a Bluetooth Mesh Network `_
- `Bluetooth Mesh Security Overview `_
- `Provisioning a Bluetooth Mesh Network Part 1 `_ / `Part 2 `__


.. _ESP32-DevKitC: https://www.espressif.com/en/products/devkits/esp32-devkitc/overview
.. _ESP-WROVER-KIT: https://www.espressif.com/en/products/hardware/esp-wrover-kit/overview
"
"ESP-BLE-MESH FAQ




This document provides a summary of frequently asked questions about developing with ESP-BLE-MESH, and is divided into seven sections:

Users could refer to the sections for quick answer to their questions. This document will be updated based on the feedback collected via various channels.


.. _ble-mesh-faq-provisioner-development:


Generally, a Provisioner is used to provision unprovisioned devices and form a mesh network. And after provisioning, roles of the unprovisione"
"d devices will be changed to those of a node.

1.1 What Is the Flow for an Unprovisioned Device to Join ESP-BLE-MESH Network?


    There are two phases for a device to join ESP-BLE-MESH network via a Provisioner, namely, provisioning and configuration.

    - The phase of provisioning is to assign unicast address, add NetKey and etc. to a device. By provisioning, the device joins the ESP-BLE-MESH network and its role is changed from an unprovisioned device to a node.

    - The phase of configu"
"ration is to add AppKeys to the node and bind AppKeys to corresponding models. And some items are optional during configuration, including adding subscription addresses to the node, set publication information, etc. By configuration, the node can actually transmit messages to a Provisioner and receive messages from it.

1.2 If a Provisioner Wants to Change States of a Node, What Requirements Should Be Met for a Provisioner?


    - Client model that corresponds to server model of the node is req"
"uired.
    - NetKey and AppKey used to encrypt messages shall be owned by both the node and the Provisioner.
    - The address owned by the node shall be known, which could be its unicast address or subscription address.

1.3 How Can NetKey and AppKey Be Used?


    - NetKey is used for encryption of messages in Network Layer. Nodes with the same NetKey are assumed to be in the same subnet while those with different NetKeys cannot communicate with each other.
    - AppKey is used for encryption "
"of messages in Upper Transport Layer. If client model and server model are bound to different AppKeys, the communication cannot be achieved.

1.4 How to Generate a NetKey or AppKey for Provisioner? Can We Use a Fixed NetKey or AppKey?


    - The API :cpp:func:`esp_ble_mesh_provisioner_add_local_net_key` can be used to add a NetKey with a fixed or random value.
    - The API :cpp:func:`esp_ble_mesh_provisioner_add_local_app_key` can be used to add an AppKey with a fixed or random value.

1.5 Is "
"the Unicast Address of Provisioner Fixed?


    The value of :code:`prov_unicast_addr` in :cpp:type:`esp_ble_mesh_prov_t` is used to set the unicast address of Provisioner, it can be set only once during initialization and cannot be changed afterwards.

1.6 Can the Address of Provisioner Serve as Destination Address of the Node-reporting-status Message?


    The unicast address of Provisioner can be set only once during initialization and cannot be changed afterwards. In theory, it can serve as"
" the destination address of the node-reporting-status message, provided that the unicast address of the Provisioner is known by nodes. Nodes can know the unicast address of Provisioner during configuration since Provisioner sends messages to them with its unicast address used as the source address.

    Subscription address can also be used. Provisioner subscribes to a group address or virtual address, and nodes send messages to the subscription address.

1.7 Is the Unicast Address of the Node T"
"hat Is Firstly Provisioned by ProvIsioner to ESP-BLE-MESH Network Fixed?


    The value of :code:`prov_start_address` in :cpp:type:`esp_ble_mesh_prov_t` is used to set the starting address when the Provisioner provisions unprovisioned devices, i.e., the unicast address of the node it firstly provisioned. It can be set only once during initialization and cannot be changed afterwards.

1.8 Is the Unicast Address of the Node That Mobile App Firstly Provisioned Fixed?


    The App will decide the "
"unicast address, and currently most of them are fixed.

1.9 How to Know Which Unprovisioned Device Is the ProvIsioner That Is Provisioning Currently?


    The value of :code:`prov_attention` in :cpp:type:`esp_ble_mesh_prov_t` is used by Provisioner set to unprovisioned device during provisioning. It can be set only once during initialization and cannot be changed afterwards. When the unprovisioned device is joining the mesh network, it can display in a specific way like flashing light to notify"
" Provisioner that it is being provisioned.

1.10 How Many Ways to Authenticate the Devices During Provisioning? Which Way Was Used in the :example:`provided examples `?


    There are four authentication methods, i.e., No OOB, Static OOB, Output OOB and Input OOB. In the provided examples, No OOB is used.

1.11 What Information Can Be Carried by the Advertising Packets of the Unprovisioned Device Before Provisioning into the Network?


    - Device UUID
    - OOB Info
    - URL Hash (optional)
"
"
1.12 Can Such Information Be Used for Device Identification?


    For example, each unprovisioned device contains a unique Device UUID, which can be used for device identification.

1.13 How Is the Unicast Address Assigned When the Node Provisioned by ProvIsioner Contains Multiple Elements?


    - Provisioner will assign an unicast address for the primary element of the node, and unicast address of the remaining elements are incremented one by one.
    - For example: If an unprovisioned devic"
"e has three elements, i.e., the primary element, the second element and the third element. After provisioning, the primary element address of the node is 0x0002 while the second element address is 0x0003, and the third element address is 0x0004.

1.14 How Can Provisioner Get and Parse the :ref:`Composition Data ` of Nodes Through Configuration Client Model?


    - Provisioner can get the Composition Data of nodes using the :ref:`Configuration Client Model ` API :cpp:func:`esp_ble_mesh_config_cl"
"ient_set_state` with :code:`comp_data_get` in the parameter :cpp:type:`esp_ble_mesh_cfg_client_get_state_t` set properly.
    - Users can refer to the following code to parse the Composition Data:

    .. code:: c

        #include 
        #include 
        #include 

        //test date: 0C001A0001000800030000010501000000800100001003103F002A00
        //0C00 1A00 0100 0800 0300 0001 05 01 0000 0080 0100 0010 0310 3F002A00

        // CID is 0x000C
        // PID is 0x001A
        // VID is 0x0"
"001
        // CRPL is 0x0008
        // Features is 0x0003 – Relay and Friend features.
        // Loc is “front” – 0x0100
        // NumS is 5
        // NumV is 1
        // The Bluetooth SIG Models supported are: 0x0000, 0x8000, 0x0001, 0x1000, 0x1003
        // The Vendor Models supported are: Company Identifier 0x003F and Model Identifier 0x002A

        typedef struct {
            int16_t cid;
            int16_t pid;
            int16_t vid;
            int16_t crpl;
            int16_t"
" features;
            int16_t all_models;
            uint8_t sig_models;
            uint8_t vnd_models;
        } esp_ble_mesh_composition_head;

        typedef struct {
            uint16_t model_id;
            uint16_t vendor_id;
        } tsModel;

        typedef struct {
            // reserve space for up to 20 SIG models
            uint16_t SIG_models[20];
            uint8_t numSIGModels;

            // reserve space for up to 4 vendor models
            tsModel Vendor_models[4];
"
"            uint8_t numVendorModels;
        } esp_ble_mesh_composition_decode;

        int decode_comp_data(esp_ble_mesh_composition_head *head, esp_ble_mesh_composition_decode *data, uint8_t *mystr, int size)
        {
            int pos_sig_base;
            int pos_vnd_base;
            int i;

            memcpy(head, mystr, sizeof(*head));

            if(size sig_models * 2 + head->vnd_models * 4) {
                return -1;
            }

            pos_sig_base = sizeof(*head) - 1;
"
"
            for(i = 1; i sig_models * 2; i = i + 2) {
                data->SIG_models[i/2] = mystr[i + pos_sig_base] | (mystr[i + pos_sig_base + 1] SIG_models[i/2]);
            }

            pos_vnd_base = head->sig_models * 2 + pos_sig_base;

            for(i = 1; i vnd_models * 2; i = i + 2) {
                data->Vendor_models[i/2].model_id = mystr[i + pos_vnd_base] | (mystr[i + pos_vnd_base + 1] Vendor_models[i/2].model_id);

                data->Vendor_models[i/2].vendor_id = mystr[i"
" + pos_vnd_base + 2] | (mystr[i + pos_vnd_base + 3] Vendor_models[i/2].vendor_id);
            }

            return 0;
        }

        void app_main(void)
        {
            esp_ble_mesh_composition_head head = {0};
            esp_ble_mesh_composition_decode data = {0};
            uint8_t mystr[] = { 0x0C, 0x00, 0x1A, 0x00,
                                0x01, 0x00, 0x08, 0x00,
                                0x03, 0x00, 0x00, 0x01,
                                0x05, 0x01, 0x00, 0x0"
"0,
                                0x00, 0x80, 0x01, 0x00,
                                0x00, 0x10, 0x03, 0x10,
                                0x3F, 0x00, 0x2A, 0x00};
            int ret;

            ret = decode_comp_data(&head, &data, mystr, sizeof(mystr));
            if (ret == -1) {
                printf(""decode_comp_data error"");
            }
        }

1.15 How Can Provisioner Further Configure Nodes Through Obtained Composition Data?


    Provisioner do the following configurati"
"on by calling the :ref:`Configuration Client Model ` API :cpp:func:`esp_ble_mesh_config_client_set_state`.

    - Add AppKey to nodes with :code:`app_key_add` in the parameter :cpp:type:`esp_ble_mesh_cfg_client_set_state_t` set properly.
    - Add subscription address to the models of nodes with :code:`model_sub_add` in the parameter :cpp:type:`esp_ble_mesh_cfg_client_set_state_t` set properly.
    - Set publication information to the models of nodes with :code:`model_pub_set` in the parameter :"
"cpp:type:`esp_ble_mesh_cfg_client_set_state_t` set properly.

1.16 Can Nodes Add Corresponding Configurations for Themselves?


    This method can be used in special cases like testing period.

    - Here is an example to show nodes add new group addresses for their models.

    .. code:: c

        esp_err_t example_add_fast_prov_group_address(uint16_t model_id, uint16_t group_addr)
        {
            const esp_ble_mesh_comp_t *comp = NULL;
            esp_ble_mesh_elem_t *element = NULL;
 "
"           esp_ble_mesh_model_t *model = NULL;
            int i, j;

            if (!ESP_BLE_MESH_ADDR_IS_GROUP(group_addr)) {
                return ESP_ERR_INVALID_ARG;
            }

            comp = esp_ble_mesh_get_composition_data();
            if (!comp) {
                return ESP_FAIL;
            }

            for (i = 0; i element_count; i++) {
                element = &comp->elements[i];
                model = esp_ble_mesh_find_sig_model(element, model_id);
                i"
"f (!model) {
                    continue;
                }
                for (j = 0; j groups); j++) {
                    if (model->groups[j] == group_addr) {
                        break;
                    }
                }
                if (j != ARRAY_SIZE(model->groups)) {
                    ESP_LOGW(TAG, ""%s: Group address already exists, element index: %d"", __func__, i);
                    continue;
                }
                for (j = 0; j groups); j++) {
             "
"       if (model->groups[j] == ESP_BLE_MESH_ADDR_UNASSIGNED) {
                        model->groups[j] = group_addr;
                        break;
                    }
                }
                if (j == ARRAY_SIZE(model->groups)) {
                    ESP_LOGE(TAG, ""%s: Model is full of group addresses, element index: %d"", __func__, i);
                }
            }

            return ESP_OK;
        }

.. note::

    When the NVS storage of the node is enabled, group address added"
" and AppKey bound by this method will not be saved in the NVS when the device is powered off currently. These configuration information can only be saved if they are configured by Configuration Client Model.

1.17 How Does Provisioner Control Nodes by Grouping?


    Generally there are two approaches to implement group control in ESP-BLE-MESH network, group address approach and virtual address approach. And supposing there are 10 devices, i.e., five devices with blue lights and five devices wit"
"h red lights.

    - Method 1: 5 blue lights can subscribe to a group address, 5 red lights subscribe to another one. By sending messages to different group addresses, Provisioner can realize group control.

    - Method 2: 5 blue lights can subscribe to a virtual address, 5 red lights subscribe to another one. By sending messages to different virtual addresses, Provisioner can realize group control.

1.18 How Does Provisioner Add Nodes to Multiple Subnets?


    Provisioner can add multiple Net"
"Keys to nodes during configuration, and nodes sharing the same NetKey belong to the same subnet. Provisioner can communicate with nodes on different subnets by using different NetKeys.

1.19 How Does ProvIsioner Know If a Node in the Mesh Network Is Offline?


    Node offline is usually defined as: the condition that the node cannot be properly communicated with other nodes in the mesh network due to power failure or some other reasons.

    There is no connection between nodes and nodes in the"
" ESP-BLE-MESH network. They communicate with each other through advertising channels.

    An example is given here to show how to detect a node is offline by Provisioner.

    - The node can periodically send heartbeat messages to Provisioner. And if Provisioner failed to receive heartbeat messages in a certain period, the node is considered to be offline.

.. note::

    The heartbeat message should be designed into a single package (less than 11 bytes), so the transmission and reception of it"
" can be more efficient.

1.20 What Operations Should Be Performed When Provisioner Removes Nodes from the Network?


    Usually when Provisioner tries to remove node from the mesh network, the procedure includes three main steps:

    - Firstly, Provisioner adds the node that need to be removed to the ""blacklist"".

    - Secondly, Provisioner performs the :ref:`Key Refresh procedure `.

    - Lastly, the node performs node reset procedure, and switches itself to an unprovisioned device.

1.21 I"
"n the Key Refresh Procedure, How Does Provisioner Update the Netkey Owned by Nodes?


    - Provisioner updates the NetKey of nodes using the :ref:`Configuration Client Model ` API :cpp:func:`esp_ble_mesh_config_client_set_state` with :code:`net_key_update` in the parameter :cpp:type:`esp_ble_mesh_cfg_client_set_state_t` set properly.

    - Provisioner updates the AppKey of nodes using the :ref:`Configuration Client Model ` API :cpp:func:`esp_ble_mesh_config_client_set_state` with :code:`app_ke"
"y_update` in the parameter :cpp:type:`esp_ble_mesh_cfg_client_set_state_t` set properly.

1.22 How Does Provisioner Manage Nodes in the Mesh Network?


    ESP-BLE-MESH implements several functions related to basic node management in the example, such as :cpp:func:`esp_ble_mesh_store_node_info`. And ESP-BLE-MESH also provides the API :cpp:func:`esp_ble_mesh_provisioner_set_node_name` which can be used to set the node's local name and the API :cpp:func:`esp_ble_mesh_provisioner_get_node_name` whi"
"ch can be used to get the node's local name.

1.23 What Does Provisioner Need When Trying to Control the Server Model of Nodes?


    Provisioner must include corresponding client model before controlling the server model of nodes.

    Provisioner shall add its local NetKey and AppKey.

    - Provisioner add NetKey by calling the API :cpp:func:`esp_ble_mesh_provisioner_add_local_net_key`.

    - Provisioner add AppKey by calling the API :cpp:func:`esp_ble_mesh_provisioner_add_local_app_key`.

 "
"   Provisioner shall configure its own client model.

    - Provisioner bind AppKey to its own client model by calling the API :cpp:func:`esp_ble_mesh_provisioner_bind_app_key_to_local_model`.

1.24 How Does Provisioner Control the Server Model of Nodes?


    ESP-BLE-MESH supports all SIG-defined client models. Provisioner can use these client models to control the server models of nodes. And the client models are divided into 6 categories with each category has the corresponding functions.

  "
"  - Configuration Client Model

        - The API :cpp:func:`esp_ble_mesh_config_client_get_state` can be used to get the :cpp:type:`esp_ble_mesh_cfg_client_get_state_t` values of Configuration Server Model.
        - The API :cpp:func:`esp_ble_mesh_config_client_set_state` can be used to set the :cpp:type:`esp_ble_mesh_cfg_client_set_state_t` values of Configuration Server Model.

    - Health Client Model

        - The API :cpp:func:`esp_ble_mesh_health_client_get_state` can be used to get th"
"e :cpp:type:`esp_ble_mesh_health_client_get_state_t` values of Health Server Model.
        - The API :cpp:func:`esp_ble_mesh_health_client_set_state` can be used to set the :cpp:type:`esp_ble_mesh_health_client_set_state_t` values of Health Server Model.

    - Generic Client Models

        - The API :cpp:func:`esp_ble_mesh_generic_client_get_state` can be used to get the :cpp:type:`esp_ble_mesh_generic_client_get_state_t` values of Generic Server Models.
        - The API :cpp:func:`esp_ble_m"
"esh_generic_client_set_state` can be used to set the :cpp:type:`esp_ble_mesh_generic_client_set_state_t` values of Generic Server Models.

    - Lighting Client Models

        - The API :cpp:func:`esp_ble_mesh_light_client_get_state` can be used to get the :cpp:type:`esp_ble_mesh_light_client_get_state_t` values of Lighting Server Models.
        - The API :cpp:func:`esp_ble_mesh_light_client_set_state` can be used to set the :cpp:type:`esp_ble_mesh_light_client_set_state_t` values of Lighting "
"Server Models.

    - Sensor Client Models

        - The API :cpp:func:`esp_ble_mesh_sensor_client_get_state` can be used to get the :cpp:type:`esp_ble_mesh_sensor_client_get_state_t` values of Sensor Server Model.
        - The API :cpp:func:`esp_ble_mesh_sensor_client_set_state` can be used to set the :cpp:type:`esp_ble_mesh_sensor_client_set_state_t` values of Sensor Server Model.

    - Time and Scenes Client Models
        - The API :cpp:func:`esp_ble_mesh_time_scene_client_get_state` can "
"be used to get the :cpp:type:`esp_ble_mesh_time_scene_client_get_state_t` values of Time and Scenes Server Models.
        - The API :cpp:func:`esp_ble_mesh_time_scene_client_set_state` can be used to set the :cpp:type:`esp_ble_mesh_time_scene_client_set_state_t` values of Time and Scenes Server Models.


.. _ble-mesh-faq-node-development:


2.1 What Kind of Models Are Included by Nodes?


    - In ESP-BLE-MESH, nodes are all composed of a series of models with each model implements some functio"
"ns of the node.

    - Model has two types, client model and server model. Client model can get and set the states of server model.

    - Model can also be divided into SIG model and vendor model. All behaviors of SIG models are officially defined while behaviors of vendor models are defined by users.

2.2 Is the Format of Messages Corresponding to Each Model Fixed?


    - Messages, which consist of opcode and payload, are divided by opcode.

    - The type and the format of the messages corre"
"sponding to models are both fixed, which means the messages transmitted between models are fixed.

2.3 Which Functions Can Be Used to Send Messages with the Models of Nodes?


    - For client models, users can use the API :cpp:func:`esp_ble_mesh_client_model_send_msg` to send messages.

    - For server models, users can use the API :cpp:func:`esp_ble_mesh_server_model_send_msg` to send messages.

    - For publication, users call the API :cpp:func:`esp_ble_mesh_model_publish` to publish messag"
"es.

2.4 How to Achieve the Transmission of Messages Without Packet Loss?


    Acknowledged message is needed if users want to transmit messages without packet loss. The default time to wait for corresponding response is set in :ref:`CONFIG_BLE_MESH_CLIENT_MSG_TIMEOUT`. If the sender waits for the response until the timer expires, the corresponding timeout event would be triggered.

.. note::

    Response timeout can be set in the API :cpp:func:`esp_ble_mesh_client_model_send_msg`. The default"
" value (4 seconds) would be applied if the parameter :code:`msg_timeout` is set to **0**.

2.5 How to Send Unacknowledged Messages?


    For client models, users can use the API :cpp:func:`esp_ble_mesh_client_model_send_msg` with the parameter :code:`need_rsp` set to :code:`false` to send unacknowledged messages.

    For server models, the messages sent by using the API :cpp:func:`esp_ble_mesh_server_model_send_msg` are always unacknowledged messages.

2.6 How to Add Subscription Address to Mo"
"dels?


    Subscription address can be added through Configuration Client Model.

2.7 What Is the Difference Between Messages Sent and Published by Models?


    Messages sent by calling the API :cpp:func:`esp_ble_mesh_client_model_send_msg` or :cpp:func:`esp_ble_mesh_server_model_send_msg` will be sent in the duration determined by the Network Transmit state.

    Messages published by calling the API :cpp:func:`esp_ble_mesh_model_publish` will be published determined by the Model Publication "
"state. And the publication of messages is generally periodic or with a fixed number of counts. The publication period and publication count are controlled by the Model Publication state, and can be configured through Configuration Client Model.

2.8 How Many Bytes Can Be Carried When Sending Unsegmented Messages?


    The total payload length (which can be set by users) of unsegmented message is 11 octets, so if the opcode of the message is 2 octets, then the message can carry 9-octets of valid"
" information. For vendor messages, due to the 3-octets opcode, the remaining payload length is 8 octets.

2.9 When Should the :ref:`Relay ` Feature of Nodes Be Enabled?


    Users can enable the Relay feature of all nodes when nodes detected in the mesh network are sparse.

    For dense mesh network, users can choose to just enable the Relay feature of several nodes.

    And users can enable the Relay feature by default if the mesh network size is unknown.

2.10 When Should the :ref:`Proxy ` "
"Feature of Node Be Enabled?


    If the unprovisioned device is expected to be provisioned by a phone, then it should enable the Proxy feature since almost all the phones do not support sending ESP-BLE-MESH packets through advertising bearer currently. And after the unprovisioned device is provisioned successfully and becoming a Proxy node, it will communicate with the phone using GATT bearer and using advertising bearer to communicate with other nodes in the mesh network.

2.11 How to Use the "
"Proxy Filter?


    The Proxy filter is used to reduce the number of Network PDUs exchanged between a Proxy Client (e.g., the phone) and a Proxy Server (e.g., the node). And with the Proxy filter, Proxy Client can explicitly request to receive only mesh messages with certain destination addresses from Proxy Server.

2.12 When a Message Can Be Relayed by a Relay Node?


    If a message need to be relayed, the following conditions should be met.

    - The message is in the mesh network.

    - T"
"he message is not sent to the unicast address of the node.

    - The value of TTL in the message is greater than 1.

2.13 If a Message Is Segmented into Several Segments, Should the Other Relay Nodes Just Relay When One of These Segments Is Received or Wait Until the Message Is Received Completely?


    Relay nodes will forward segments when one of them are received rather than keeping waiting until all the segments are received.

2.14 What Is the Principle of Reducing Power Consumption Using "
":ref:`Low Power ` Feature?


    - When the radio is turned on for listening, the device is consuming energy. When low power feature of the node is enabled, it will turn off its radio in the most of the time.

    - And cooperation is needed between low power node and friend node, thus low power node can receive messages at an appropriate or lower frequency without the need to keep listening.

    - When there are some new messages for low power node, its friend node will store the messages for "
"it. And low power node can poll friend nodes to see if there are new messages at a fixed interval.

2.15 How to Continue the Communication on the Network After Powering-down and Powering-up Again?


    Enable the configuration :code:`Store ESP-BLE-MESH Node configuration persistently` in `menuconfig`.

2.16 How to Send out the Self-test Results of Nodes?


    It is recommended that nodes can publish its self-test results periodically through Health Server Model.

2.17 How to Transmit Informati"
"on Between Nodes?


    One possible application scenario for transmitting information between nodes is that spray nodes would be triggered once smoke alarm detected high smoke concentration. There are two approaches in implementation.

    - Approach 1 is that spray node subscribes to a group address. When smoke alarm detects high smoke concentration, it will publish a message whose destination address is the group address which has been subscribed by spray node.

    - Approach 2 is that Provi"
"sioner can configure the unicast address of spray node to the smoke alarm. When high smoke concentration is detected, smoke alarm can use send messages to the spray node with the spray node's unicast address as the destination address.

2.18 Is Gateway a Must for Nodes Communication?


    - Situation 1: nodes only communicate within the mesh network. In this situation, no gateway is need. ESP-BLE-MESH network is a flooded network, messages in the network have no fixed paths, and nodes can commu"
"nicate with each other freely.

    - Situation 2: if users want to control the nodes remotely, for example turn on some nodes before getting home, then a gateway is needed.

2.19 When Will the IV Update Procedure Be Performed?


    IV Update procedure would be performed once sequence number of messages sent detected by the bottom layer of node reached a critical value.

2.20 How to Perform IV Update Procedure?


    Nodes can perform IV Update procedure with Secure Network Beacon.


.. _ble-me"
"sh-faq-ble-mesh-and-wi-fi-coexistence:


3.1 Which Modes Does Wi-Fi Support When it Coexists with ESP-BLE-MESH?


    Currently only Wi-Fi station mode supports the coexistence.

3.2 Why Is the Wi-Fi Throughput So Low When Wi-Fi and ESP-BLE-MESH Coexist?


    .. only:: esp32

        The :doc:`ESP32-DevKitC ` board without PSRAM can run properly but the throughput of it is low since it has no PSRAM. When Bluetooth and Wi-Fi coexist, the throughput of ESP32-DevKitC with PSRAM can be stabilized t"
"o more than 1 Mbps.

    Some configurations in menuconfig shall be enabled to support PSRAM.

        - ``{IDF_TARGET_NAME}-specific`` > ``Support for external,SPI-connected RAM`` > ``Try to allocate memories of Wi-Fi and LWIP...``
        - ``Bluetooth`` > ``Bluedroid Enable`` > ``BT/BLE will first malloc the memory from the PSRAM``
        - ``Bluetooth`` > ``Bluedroid Enable`` > ``Use dynamic memory allocation in BT/BLE stack``
        - ``Bluetooth`` > ``Bluetooth controller`` > ``BLE full "
"scan feature supported``
        - ``Wi-Fi`` > ``Software controls Wi-Fi/Bluetooth coexistence`` > ``Wi-Fi``


.. _ble-mesh-faq-fast-provisioning:


4.1 Why Is Fast Provisioning Needed?


    Normally when they are several unprovisioned devices, users can provision them one by one. But when it comes to a large number of unprovisioned devices (e.g., 100), provisioning them one by one will take huge amount of time. With fast provisioning, users can provision 100 unprovisioned devices in about 50 s"
"econds.

4.2 Why EspBleMesh App Would Wait for a Long Time During Fast Provisioning?


    After the App provisioned one Proxy node, it will disconnect from the App during fast provisioning, and reconnect with the App when all the nodes are provisioned.

4.3 Why Is the Number of Node Addresses Displayed in the App Is More than That of Existing Node Addresses?


    Each time after a fast provisioning process, and before starting a new one, the node addresses in the App should be cleared, otherwi"
"se the number of the node address will be incorrect.

4.4 What Is the Usage of the **count** Value Which Was Input in EspBleMesh App?


    The **count** value is provided to the Proxy node which is provisioned by the App so as to determine when to start Proxy advertising in advance.

4.5 When will Configuration Client Model of the node running :example:`fast_prov_server ` example start to work?


    Configuration Client Model will start to work after the Temporary Provisioner functionality is "
"enabled.

4.6 Will the Temporary Provisioner Functionality Be Enabled All the Time?


    After the nodes receive messages used to turn on/off lights, all the nodes will disable its Temporary Provisioner functionality and become nodes.


.. _ble-mesh-faq-log-help:


You can find meaning of errors or warnings when they appear at the bottom of ESP-BLE-MESH stack.

5.1 What Is the Meaning of Warning ``ran out of retransmit attempts``?


    When the node transmits a segmented message, and due to so"
"me reasons, the receiver does not receive the complete message. Then the node will retransmit the message. When the retransmission count reaches the maximum number, which is 4 currently, then this warning will appear.

5.2 What Is the Meaning of Warning  ``Duplicate found in Network Message Cache``?


    When the node receives a message, it will compare the message with the ones stored in the network cache. If the same has been found in the cache, which means it has been received before, then t"
"he message will be dropped.

5.3 What Is the Meaning of Warning  ``Incomplete timer expired``?


    When the node does not receive all the segments of a segmented message during a certain period (e.g., 10 seconds), then the Incomplete timer will expire and this warning will appear.

5.4 What Is the Meaning of Warning  ``No matching TX context for ack``?


    When the node receives a segment ack and it does not find any self-send segmented message related with this ack, then this warning will a"
"ppear.

5.5 What Is the Meaning of Warning  ``No free slots for new incoming segmented messages``?


    When the node has no space for receiving new segmented message, this warning will appear. Users can make the space larger through the configuration :ref:`CONFIG_BLE_MESH_RX_SEG_MSG_COUNT`.

5.6 What Is the Meaning of Error ``Model not bound to Appkey 0x0000``?


    When the node sends messages with a model and the model has not been bound to the AppKey with AppKey Index 0x000, then this erro"
"r will appear.

5.7 What Is the Meaning of Error ``Busy sending message to DST xxxx``?


   This error means client model of the node has transmitted a message to the target node and now is waiting for a response, users can not send messages to the same node with the same unicast address. After the corresponding response is received or timer is expired, then another message can be sent.


.. _ble-mesh-faq-example-help:


6.1 How Are the ESP-BLE-MESH Callback Functions Classified?


    - The API"
" :cpp:func:`esp_ble_mesh_register_prov_callback` is used to register callback function used to handle provisioning and networking related events.
    - The API :cpp:func:`esp_ble_mesh_register_config_client_callback` is used to register callback function used to handle Configuration Client Model related events.
    - The API :cpp:func:`esp_ble_mesh_register_config_server_callback` is used to register callback function used to handle Configuration Server Model related events.
    - The API :cpp:f"
"unc:`esp_ble_mesh_register_health_client_callback` is used to register callback function used to handle Health Client Model related events.
    - The API :cpp:func:`esp_ble_mesh_register_health_server_callback` is used to register callback function used to handle Health Server Model related events.
    - The API :cpp:func:`esp_ble_mesh_register_generic_client_callback` is used to register callback function used to handle Generic Client Models related events.
    - The API :cpp:func:`esp_ble_mesh"
"_register_light_client_callback` is used to register callback function used to handle Lighting Client Models related events.
    - The API :cpp:func:`esp_ble_mesh_register_sensor_client_callback` is used to register callback function used to handle Sensor Client Model related events.
    - The API :cpp:func:`esp_ble_mesh_register_time_scene_client_callback` is used to register callback function used to handle Time and Scenes Client Models related events.
    - The API :cpp:func:`esp_ble_mesh_reg"
"ister_custom_model_callback` is used to register callback function used to handle vendor model and unrealized server models related events.


.. _ble-mesh-faq-others:


7.1 How to Print the Message Context?


    The examples use :cpp:func:`ESP_LOG_BUFFER_HEX` to print the message context while the ESP-BLE-MESH protocol stack uses :cpp:func:`bt_hex`.

7.2 Which API Can Be Used to Restart {IDF_TARGET_NAME}?


    The API :cpp:func:`esp_restart`.

7.3 How to Monitor the Remaining Space of the Stac"
"k of a Task?


    The API :cpp:func:`vTaskList` can be used to print the remaining space of the task stack periodically.

7.4 How to Change the Level of Log Without Changing the Menuconfig Output Level?


    The API :cpp:func:`esp_log_level_set` can be used to change the log output level rather than using menuconfig to change it.
"
"ESP-BLE-MESH Terminology




.. _ble-mesh-terminology-role:

.. list-table:: Table 1 ESP-BLE-MESH Terminology - Role
  :widths: 10 40 60
  :header-rows: 1
    - Official Definition
    - Detailed Explanation
    - A device that is not a member of a mesh network is known as an unprovisioned device.
    - Examples: lighting devices, temperature control devices, manufacturing equipments and electric doors, etc.
    - A node is a provisioned device.
    - The role of unprovisioned device will change"
" to node after being provisioned to ESP-BLE-MESH network. Nodes (such as lighting devices, temperature control devices, manufacturing equipments, and electric doors) are devices that can send, receive, or relay messages in ESP-BLE-MESH network, and they can optionally support one or more subnets.
    - A node that supports the Relay feature and has the Relay feature enabled is known as a Relay node.
    - Relay nodes can receive and resend ESP-BLE-MESH messages, so the messages can be transferre"
"d further. Users can decide whether or not to enable forwarding function of nodes according to nodes' status. Messages can be relayed for multiple times, and each relay is considered as a ""hop"". Messages can hop up to 126 times, which is enough for message transmission in a wide area.
    - A node that supports the Proxy feature and has the Proxy feature enabled is known as a Proxy node.
    - Proxy nodes receive messages from one bearer (it generally includes advertising bearer and GATT bearer)"
" and resend it from another one. The purpose is to connect communication equipments that only support GATT bearer to ESP-BLE-MESH network. Generally, mobile apps need a Proxy node to access Mesh network. Without Proxy nodes, mobile apps cannot communicate with members in Mesh network.
    - A node that supports the Friend feature, has the Friend feature enabled, and has a friendship with a node that supports the Low Power feature is known as a Friend node.
    - Friend node, like the backup of L"
"ow Power node (LPN), can store messages that are sent to Low Power node and security updates; the stored information will be transferred to Low Power node when Low Power node needs it. Low Power node must establish ""friendship"" with another node that supports the Friend Feature to reduce duty cycle of its receiver, thus power consumption of Low Power node can be reduced. Low Power node needs to find a Friend node to establish a friendship with it. The process involved is called ""friendship estab"
"lishment"". Cooperation between Low Power node and Friend nodes enables Low Power node to schedule the use of the radio, thus Low Power node can receive messages at an appropriate or lower frequency without the need of keeping listening. Low Power node will poll Friend node to see if there is new message.
    - A node that supports the Low Power feature and has a friendship with a node that supports the Friend feature is known as a Low Power node.
    - By polling, Low Power node gets information"
" from Friend node, such as messages, security updates, and etc.
    - A node that is capable of adding a device to a mesh network.
    - The device that can provision unprovisioned devices is called a Provisioner. This process usually needs to be implemented through an app that is typically provided by the product manufacturer and can be used on a gateway, a smartphone, tablet or other carriers.


.. _ble-mesh-terminology-composition:

.. list-table:: Table 2 ESP-BLE-MESH Terminology - Compositi"
"on
  :widths: 10 40 60
  :header-rows: 1
    - Official Definition
    - Detailed Explanation
    - A value representing a condition of an element that is exposed by an element of a node.
    - Each node in a ESP-BLE-MESH network has an independent set of state values that indicate certain states of the device, like brightness, and color of lighting device. Change of state value will lead to change of the physical state of devices. For example, changing the on/off state of a device is actually t"
"urning on/off the device.
    - A model defines the basic functionality of a node.
    - A node may contain multiple models, and each model defines basic functionalities of nodes, like the states needed by the nodes, the messages controlling the states, and actions resulted from messages handling. The function implementation of the nodes is based on models, which can be divided into SIG Model and Vendor Model, with the former defined by SIG and latter defined by users.
    - An addressable entit"
"y within a device.
    - A node can contain one or more elements, with each having a unicast address and one or more models, and the models contained by the same element must not be the same.
    - The Composition Data state contains information about a node, the elements it includes, and the supported models.
    - By reading the value of the Composition Data state, users can know basic information of the node, such as the number of elements, and the models in each element. Provisioner gets thi"
"s message to further provision the device, such as configuring subscription address and publishing address of nodes.


.. _ble-mesh-terminology-features:

.. list-table:: Table 3 ESP-BLE-MESH Terminology - Features
  :widths: 10 40 60
  :header-rows: 1
    - Official Definition
    - Detailed Explanation
    - The ability to operate within a mesh network at significantly reduced receiver duty cycles only in conjunction with a node supporting the Friend feature.
    - Low Power feature reduces po"
"wer consumption of nodes. When a Low Power node is searching for a Friend node, and there are multiple Friend nodes nearby, it selects the most suitable Friend node through algorithm.
    - The ability to help a node supporting the Low Power feature to operate by storing messages destined for those nodes.
    - By enabling friend feature, the node can help to store information for Low Power node. The nodes enabled with friend feature may cause more power and memory consumption.
    - The ability"
" to receive and retransmit mesh messages over the advertising bearer to enable larger networks.
    - The relay feature enables ESP-BLE-MESH messages to hop among nodes for multiple times, and the transmission distance can exceed the range of direct radio transmission between two nodes, thereby covering the entire network. When a node is enabled with the relay feature to relay messages, it only relays the messages of its own subnet, and does not relay the messages of other subnets. The data inte"
"grity will not be considered when the node enabled with relay feature relays segmented messages. The node would relay every segmented message once it receives one rather than waiting for the complete message.
    - The ability to receive and retransmit mesh messages between GATT and advertising bearers.
    - The purpose of the proxy feature is to allow nodes without an advertising bearer to access the ESP-BLE-MESH network. The proxy feature is typically used in nodes that need to connect to mob"
"ile apps.


.. _ble-mesh-terminology-provisioning:

.. list-table:: Table 4 ESP-BLE-MESH Terminology - Provisioning
  :widths: 10 40 60
  :header-rows: 1
    - Official Definition
    - Detailed Explanation
    - PB-ADV is a provisioning bearer used to provision a device using Generic Provisioning PDUs over the advertising channels.
    - PB-ADV transfers packets generated during the provisioning process over the advertising channels. This way can only be used for provisioning when provisioner a"
"nd unprovisioned device both support PB-ADV.
    - PB-GATT is a provisioning bearer used to provision a device using Proxy PDUs to encapsulate Provisioning PDUs within the Mesh Provisioning Service.
    - PB-GATT uses connection channels to transfer packets generated during the provisioning process. If an unprovisioned device wants to be provisioned through this method, it needs to implement the related Mesh Provisioning Service. Unprovisioned devices which don't implement such service cannot be"
" provisioned into mesh network through PB-GATT bearer.
    - The PB-Remote provisioning bearer uses the existing mesh network to provision an unprovisioned device that is not within immediate radio range of the Provisioner.
    - PB-Remote uses the PB-ADV bearer or the PB-GATT bearer for the last hop to the unprovisioned device.
    - Provisioning is a process of adding an unprovisioned device to a mesh network, managed by a Provisioner.
    - The process of provisioning turns the ""unprovisioned"
" device"" into a ""node"", making it a member of the ESP-BLE-MESH network.
    - Authentication is a step during the provisioning of nodes.
    - There are four authentication methods for unprovisioned devices: Output OOB, Input OOB, Static OOB, and No OOB.
    - Input Out-of-Band
    - For example, a Provisioner generates and displays a random number, and then prompts users to take appropriate actions to input the random number into the unprovisioned device. Taking lighting switch as an example, u"
"sers can press the button for several times in a certain period of time to input the random number displayed on the Provisioner. Authentication method of the Input OOB is similar to that of Output OOB, but the role of the device is reversed.
    - Output Out-of-Band
    - For example, an unprovisioned device will choose a random number and output the number in a way that is compatible with its functionality. If the unprovisioned device is a bulb, it can flash a specified number of times. If the "
"unprovisioned device has an LCD screen, the random number can display as a multi-digit value. Users who start provisioning should input the observed number to authenticate the unprovisioned device.
    - Static Out-of-Band
    - Authentication method of Static OOB: use Static OOB information. Use 0 as Static OOB information if No OOB information is needed. Use Static OOB information to authenticate devices which are going through provisioning if OOB information is needed.
    - No Out-of-Band
  "
"  - Authentication method of No OOB: Set the value of the Static OOB field to 0. Using this way is like not authenticating the unprovisioned devices.
    - Certificate-based Out-of-Band
    - The certificate-based provisioning feature makes use of Public Key Infrastructure to authenticate unprovisioned device's public key and UUID information.


.. _ble-mesh-terminology-address:

.. list-table:: Table 5 ESP-BLE-MESH Terminology - Address
  :widths: 10 40 60
  :header-rows: 1
    - Official Defin"
"ition
    - Detailed Explanation
    - This is a special address type, with a value of 0x0000. Its use indicates that an Element has not yet been configured or had a Unicast Address assigned to it.
    - The addresses owned by elements which has not been configured yet or no address has been allocated are unassigned addresses. These elements will not be used for messages transfer because they have no fixed address. Unassigned address is recommended to set as the value of the address before setti"
"ng the address of user code.
    - A unicast address is a unique address allocated to each element.
    - During provisioning, the Provisioner will assign a unicast address to each element of node within the life cycle of the nodes in the network. A unicast address may appear in the source/destination address field of a message. Messages sent to a unicast address can only be processed by the element that owns the unicast address.
    - A virtual address represents a set of destination addresses."
" Each virtual address logically represents a Label UUID, which is a 128-bit value that does not have to be managed centrally.
    - Associated with specific UUID labels, a virtual address may serve as the publishing or subscription address of the model. A UUID label is a 128-bit value associated with elements of one or more nodes. For virtual addresses, the 15th and 14th bits are set to 1 and 0 respectively; bits from 13th to 0 are set to hash values (providing 16384 hash values). The hash is a "
"derivation of the Label UUID. To use subscribing elements to check the full 128-bit UUID is very inefficient while hash values provide a more efficient way to determine which elements that which messages are finally sent to.
    - A group address is an address that is programmed into zero or more elements
    - Group address is another kind of multicast address in the ESP-BLE-MESH network, which is usually used to group nodes. A message sent to the all-proxies address shall be processed by the p"
"rimary element of all nodes that have the proxy functionality enabled. A message sent to the all-friends address shall be processed by the primary element of all nodes that have the friend functionality enabled. A message sent to the all-relays address shall be processed by the primary element of all nodes that have the relay functionality enabled. A message sent to the all-nodes address shall be processed by the primary element of all nodes.


.. _ble-mesh-terminology-security:

.. list-table::"
" Table 6 ESP-BLE-MESH Terminology - Security
  :widths: 10 40 60
  :header-rows: 1
    - Official Definition
    - Detailed Explanation
    - There is also a device key, which is a special application key that is unique to each node, is known only to the node and a Configuration Client, and is used to secure communications between the node and a Configuration Client.
    - The device key enables you to provision the devices, configure the nodes. The device key is used to encrypt Configuration Me"
"ssages, i.e., the message transferred between the Provisioner and the node when the device is configured.
    - Application keys are used to secure communications at the upper transport layer.
    - Application key is used for decryption of application data before delivering application data to application layer and encryption of them during the delivery of application layer. Some nodes in the network have a specific purpose and can restrict access to potentially sensitive data based on the need"
"s of the application. With specific application keys, these nodes are associated with specific applications. Generally speaking, the fields using different application keys include security (access control of buildings, machine rooms and CEO offices), lighting (plant, exterior building and sidewalks) and HVAC systems. Application keys are bound to Network keys. This means application keys are only used in a context of a Network key they are bound to. An application key shall only be bound to a s"
"ingle Network key.
    - The flooding security material is derived from the network key (NetKey) and can be used by other nodes in the same network. Messages encrypted with flooding security material can be decoded by any node in the same network.
    - The corresponding friendship messages encrypted with the friendship security material: 1. Friend Poll, 2. Friend Update, 3. Friend Subscription List, add/delete/confirm, 4. The Stored Messages"" sent by friend nodes to Low Power node. The correspo"
"nding friendship messages encrypted with the flooding security material: 1. Friend Clear, 2. Friend Clear Confirm. Based on the setup of the applications, the messages sent from the Low Power node to the friend nodes will be encrypted with the friendship security material or flooding security material, with the former being used by the messages transmitted between Low Power node and friend nodes and the latter being used by other network messages.
    - The directed security material is derived "
"from the network key (NetKey) and can be used by other nodes in the directed forwarding path.
    - The messages that need to be forwarded through the directed forwarding path need to be encrypted with the directed security material. Messages encrypted with directed security material can be decoded by any node in the same directed forwarding path.

.. _ble-mesh-terminology-message:

.. list-table:: Table 7 ESP-BLE-MESH Terminology - Message
  :widths: 10 40 60
  :header-rows: 1
    - Official De"
"finition
    - Detailed Explanation
    - Segmentation and reassembly (SAR) is a method of communication network, which is divided into small units before transmitting packets and reassembled in a proper order at the communication receiving end.
    - The lower transport layer will automatically segment the message whose size is too big. The receiving end will return a response message, and the transmitting end will send the data packet again that the receiving end does not receive according to "
"the response message. This is automatically completed by the lower transport layer. Unsegmented messages have at most 15 bytes, of which 4 bytes are transMIC, so the remaining is 11 bytes; in the case of segmentation, there are 12 valid bytes in the first several packets, and 8 in the last one. Special case: A shorter packet requires mandatory segmentation from lower transport layer, in which case the valid byte is 8 bytes.
    - There are two types of messages: Unacknowledged or Acknowledged
  "
"  - Based on the whether or not the receiving end needs to send the response message, the messages sent are divided into two kinds. The sending end should set the maximum number of retransmission.


.. _ble-mesh-terminology-foundation-models:

.. list-table:: Table 8 ESP-BLE-MESH Terminology - Foundation Models
  :widths: 10 40 60
  :header-rows: 1
    - Official Definition
    - Detailed Explanation
    - This model is used to represent a mesh network configuration of a device.
    - The node m"
"ust contain the Configuration Server Model, which is responsible for maintaining configuration-related states. The states that Configuration Server Model maintains include: NetKey List, AppKey List, Model to AppKey List, Node Identity, Key Refresh Phase, Heartbeat Publish, Heartbeat Subscription, Network Transmit, Relay Retransmit etc.
    - The model is used to represent an element that can control and monitor the configuration of a node.
    - The Configuration Client Model uses messages to co"
"ntrol the state maintained by the Configuration Server Model. The Provisioner must contain the Configuration Client Model, with which the configuration messages, like Configuration Composition Data Get can be sent.
    - This model is used to represent a mesh network diagnostics of a device.
    - The Health Server Model is primarily used by devices to check their states and see if there is an error. The states maintained by Health Server model include: Current Fault, Registered Fault, Health Pe"
"riod, and Attention Timer.
    - The model is used to represent an element that can control and monitor the health of a node.
    - The Health Client Model uses messages to control the state maintained by the Health Server Model. The model can get the self-test information of other nodes through the message ""Health Fault Get"".
    - The model is used to support the functionality of provisioning a remote device over the mesh network and to perform the Node Provisioning Protocol Interface procedur"
"es.
    - The Remote Provisioning Server model is a root model and a main model that does not extend any other models.
    - The model is used to support the functionality of provisioning devices into a mesh network by interacting with a mesh node that supports the Remote Provisioning Server model.
    - The Remote Provisioning Client is a root model and a main model that does not extend any other models. The Remote Provisioning Client may operate on states defined by the Remote Provisioning Ser"
"ver model using Remote Provisioning messages.
    - The model is used to support the configuration of the directed forwarding functionality of a node.
    - The Directed Forwarding Configuration Server model is a main model that extends the Configuration Server model.
    - The model is used to support the functionality of a node that can configure the directed forwarding functionality of another node.
    - The Directed Forwarding Configuration Client model is a root model and a main model that"
" does not extend any other models. The Directed Forwarding Configuration Client model may operate on states defined by the Directed Forwarding Configuration Server model using Directed Forwarding Configuration messages.
    - The model is used to support the configuration of the subnet bridge functionality of a node.
    - The Bridge Configuration Server model is a main model that extends the Configuration Server model.
    - The model is used to support the functionality of a node that can conf"
"igure the subnet bridge functionality of another node.
    - The Bridge Configuration Client model is a root model and a main model that does not extend any other models. The Bridge Configuration Client model may operate on states defined by the Bridge Configuration Server model using Bridge messages.
    - The model is used to support the configuration of the Mesh Private beacons functionality of a node.
    - The Mesh Private Beacon Server model is a main model that extends the Configuration S"
"erver model.
    - The model is used to support the functionality of a node that can configure the Mesh Private beacons functionality of another node.
    - The Mesh Private Beacon Client model is a root model and a main model that does not extend any other models. The Mesh Private Beacon Client model may operate on states defined by the Mesh Private Beacon Server model using Mesh Private Beacon messages.
    - The model is used to support the configuration of the advertising with Private Networ"
"k Identity type functionality of a node.
    - The On-Demand Private Proxy Server model is a main model that extends the Mesh Private Beacon Server model and corresponds with the Solicitation PDU RPL Configuration Server model.
    - The model is used to support the functionality of a node that can configure the advertising with Private Network Identity type functionality of another node.
    - The On-Demand Private Proxy Client model is a root model and a main model that does not extend any oth"
"er models. The On-Demand Private Proxy Client model may operate on states defined by the On-Demand Private Proxy Server model using On-Demand Private Proxy messages.
    - The model is used to support the configuration of the segmentation and reassembly behavior of a node.
    - The SAR Configuration Server model is a root model and a main model that does not extend any other models.
    - The SAR Configuration Client model is used to support the functionality of configuring the behavior of the "
"lower transport layer of a node that supports the SAR Configuration Server model.
    - The SAR Configuration Client model is a root model and a main model that does not extend any other models. The SAR Configuration Client model may operate on states defined by the SAR Configuration Server model using SAR Configuration messages.
    - The Solicitation PDU RPL Configuration Server model is used to support the functionality of removing items from the solicitation replay protection list of a node."
"
    - The Solicitation PDU RPL Configuration Server model corresponds with the On-Demand Private Proxy Server model.
    - The model is used to support the functionality of removing addresses from the solicitation replay protection list of a node that supports the Solicitation PDU RPL Configuration Server model.
    - The Solicitation PDU RPL Configuration Client model is a root model and a main model that does not extend any other models. The Solicitation PDU RPL Configuration Client model may"
" be used to remove items from a solicitation replay protection list of a peer node by using Solicitation PDU RPL Configuration messages.
    - The model is used to support the functionality of processing a sequence of access layer messages.
    - The Opcodes Aggregator Server model is a root model that does not extend any other models.
    - The model is used to support the functionality of dispatching a sequence of access layer messages to nodes supporting the Opcodes Aggregator Server model.
 "
"   - The Opcodes Aggregator Client model is a root model and a main model that does not extend any other models.
    - The model is used to support the functionality of exposing pages of Composition Data that do not fit in a Config Composition Data Status message and to expose metadata of the model instances.
    - The Large Composition Data Server is a main model that extends the Configuration Server model.
    - The model is used to support the functionality of reading pages of Composition Dat"
"a that do not fit in a Config Composition Data Status message and reading the metadata of the model instances.
    - The Large Composition Data Client model is a root model that does not extend any other models. The Large Composition Data Client model may operate on states defined by the Large Composition Data Server model using Large Composition Data messages.


.. _ble-mesh-terminology-network-management:

.. list-table:: Table 9 ESP-BLE-MESH Terminology - Network Management
  :widths: 10 40 6"
"0
  :header-rows: 1
    - Official Definition
    - Detailed Explanation
    - This procedure is used when the security of one or more network keys and/or one or more of the application keys has been compromised or could be compromised.
    - Key Refresh Procedure is used to update network key and application key of ESP-BLE-MESH network. Key Refresh Procedure is used when the security of one or more network keys and/or one or more application keys is threatened or potentially threatened. Keys ar"
"e usually updated after some nodes in the network are removed.
    - A node can also use an IV Update procedure to signal to peer nodes that it is updating the IV Index.
    - The IV Update procedure is used to update the value of ESP-BLE-MESH network's IV Index. This value is related to the random number required for message encryption. To ensure that the value of the random number is not repeated, this value is periodically incremented. IV Index is a 32-bit value and a shared network resource."
" For example, all nodes in a mesh network share the same IV Index value. Starting from 0x00000000, the IV Index increments during the IV Update procedure and maintained by a specific process, ensuring the IV Index shared in the mesh network is the same. This can be done when the node believes that it has the risk of exhausting its sequence number, or when it determines that another node is nearly exhausting its sequence number. Note: The update time must not be less than 96 hours. It can be trig"
"gered when a secure network beacon is received, or when the node determines that its sequence number is greater than a certain value.

For more terms, please see: `ESP-BLE-MESH Glossary of Terms `_.
"
"ESP-BLE-MESH Feature List


Supported Features


Mesh Core
""""""""""""""""""

Mesh Models
""""""""""""""""""""""

Mesh Applications
""""""""""""""""""""""""""""""""""


Future Release Features


Mesh Core
""""""""""""""""""

Mesh Applications
""""""""""""""""""""""""""""""""""
"
"ESP-BLE-MESH Architecture




This document introduces ESP-BLE-MESH architecture overview, ESP-BLE-MESH architecture implementation as well as ESP-BLE-MESH auxiliary routines.

- ESP-BLE-MESH Architecture Overview

  - Describes the five major parts of ESP-BLE-MESH architecture and the functionality of each part.

- ESP-BLE-MESH Architecture Implementation

  - Describes the basic functions of ESP-BLE-MESH files, the correspondence between files and ESP-BLE-MESH architecture, and the interface f"
"or calling among files.

- ESP-BLE-MESH Auxiliary Routines

  - Describe the auxiliary routines of ESP-BLE-MESH, such as Mesh network management, Mesh features, etc.


Currently ESP-BLE-MESH has implemented most functions of Mesh Profile and all the Client Models defined in Mesh Model specification. Those missing functions/models are under development and will be provided soon. ESP-BLE-MESH architecture has been granted the official Bluetooth `certification `__.

.. figure:: ../../../_static/esp"
"-ble-mesh-architecture.png
  :align: center

  Figure 1.1 ESP-BLE-MESH Architecture Diagram

ESP-BLE-MESH architecture includes five key parts:

- ``Mesh Protocol Stack``

  - ``Mesh Networking`` is responsible for processing of messages of ESP-BLE-MESH nodes.
  - ``Mesh Provisioning`` is responsible for provisioning flow of ESP-BLE-MESH devices.
  - ``Mesh Models`` is responsible for the implementation of SIG-defined models.

- ``Network Management``

  - Implements several network management p"
"rocedures, including node removal procedure, IV Index recovery procedure, etc.

- ``Features``

  - Include several ESP-BLE-MESH features, e.g., Low Power feature, Friend feature, Relay feature, etc.

- ``Mesh Bearer Layer``

  - Includes ``Advertising Bearer`` and ``GATT Bearer``. The bearer layer is crucial to ESP-BLE-MESH protocol stack which is built on Bluetooth Low-Energy technology, because the protocol stack must make use of the bearer layer to transmit data via the BLE advertising chann"
"el and connection channel.

- ``Applications``

  - Based on ESP-BLE-MESH protocol stack and ``Mesh Models``.
  - By calling API and handling Event, ``Applications`` interact with ``Mesh Networking`` and ``Mesh Provisioning`` in ESP-BLE-MESH protocol stack, as well as a series of Models provided by ``Mesh Models``.


1.1 Mesh Protocol Stack


1.1.1 Mesh Networking


``Mesh Networking`` in the protocol stack architecture implements the following functions:

- The communication between nodes in th"
"e Mesh network.
- Encryption and decryption of messages in the Mesh network.
- Management of Mesh network resources (Network Key, IV Index, etc.).
- Segmentation and reassembly of Mesh network messages.
- Model mapping of messages between different models.
- For more features, please see :doc:`ble-mesh-feature-list`.

The implementation of ``Mesh Networking`` functions is based on hierarchy structure. Functions of each layer are shown in Table 1.1:

.. list-table:: Table 1.1  Mesh Networking Arc"
"hitecture Description
  :widths: 40 150
  :header-rows: 1
    - Function
    - Access Layer not only defines the format of application data, but also defines and controls the encryption and decryption of the data packets conducted by Upper Transport Layer.
    - Upper Transport Layer encrypts, decrypts, and authenticates application data to and from the access layer; it also handles special messages called ""transport control messages"", including messages related to ""friendship"" and heartbeat mes"
"sages.
    - Lower Transport Layer handles segmentation and reassembly of PDU.
    - Network Layer defines the address type and format of the network messages, and implements the relay function of the device.

1.1.2 Mesh Provisioning


``Mesh Provisioning`` in the protocol stack architecture implements the following functions:

- Provisioning of unprovisioned devices.
- Allocation of Mesh network resources (unicast address, IV Index, NetKey, etc.).
- Four authentication methods support during pr"
"ovisioning.
- For more features, please see :doc:`ble-mesh-feature-list`.

The implementation of ``Mesh Provisioning`` functions is based on hierarchy structure. Functions of each layer are shown in Table 1.2:

.. list-table:: Table 1.2  Mesh Provisioning Architecture Description
  :widths: 40 150
  :header-rows: 1
    - Function
    - Provisioning PDUs from different layers are handled using provisioning protocol.
    - The Provisioning PDUs are transmitted to an unprovisioned device using a Ge"
"neric Provisioning layer or Proxy protocol layer.
    - These layers define how the Provisioning PDUs are transmitted as transactions that can be segmented and reassembled.
    - The provisioning bearers define how sessions are established such that the transactions from the generic provisioning layer can be delivered to a single device.

1.1.3 Mesh Models


``Mesh Models`` in the protocol stack architecture implements the following functions:

- Configuration Client/Server Models
- Health Clien"
"t/Server Models
- Generic Client/Server Models
- Sensor Client/Server Models
- Time and Scenes Client/Server Models
- Lighting Client/Server Models

Functions of each layer are shown in Table 1.3:

.. list-table:: Table 1.3  Mesh Models Architecture Description
  :widths: 40 150
  :header-rows: 1
    - Function
    - Model Layer implements models used to standardize the operation of typical user scenarios, including Generic Client/Server Models, Sensor Client/Server Models, Time and Scenes Clien"
"t/Server Models, Lighting Client/Server Models and several vendor models.
    - Foundation Model Layer implements models related to ESP-BLE-MESH configuration, management, self diagnosis, etc.

1.2 Mesh Network Management


``Network Management`` implements the following functions:

- Node removal procedure is used to remove a node from the network.
- IV Index recovery procedure is used to recover a node's IV Index.
- IV update procedure is used to update the nodes' IV Index.
- Key refresh proce"
"dure is used to update the nodes' NetKey, AppKey, etc.
- Network creation procedure is used to create a mesh network.
- NVS storage is used to store node's networking information.

1.3 Mesh Features


``Features`` includes the following options:

- Low Power feature is used to reduce node's power consumption.
- Friend feature is used to store messages for Low Power nodes.
- Relay feature is used to relay/forward Network PDUs received by a node over the advertising bearer.
- Proxy Server/Client a"
"re two node roles in proxy protocol, which enable nodes to send and receive Network PDUs, mesh beacons, proxy configuration messages and Provisioning PDUs over a connection-oriented bearer.

1.4 Mesh Bearer Layer


``Bearers`` in the protocol stack architecture are responsible for passing of data between ESP-BLE-MESH protocol stack and Bluetooth Low Energy Core.

``Bearers`` can be taken as a carrier layer based on Bluetooth Low Energy Core, which implements the function of receiving and transmi"
"tting data for the ESP-BLE-MESH protocol stack.

.. list-table:: Table 1.3  Mesh Bearers Description
  :widths: 40 150
  :header-rows: 1
    - Function
    - The GATT Bearer uses the Proxy protocol to transmit and receive ``Proxy PDUs`` between two devices over a GATT connection.
    - When using the Advertising Bearer, a mesh packet shall be sent in the Advertising Data of a ``Bluetooth Low Energy advertising PDU`` using the Mesh Message AD Type.

1.5 Mesh Applications


The ``Applications`` in"
" the protocol stack architecture implement the corresponding functions by calling the API provided by the ESP-BLE-MESH protocol stack and processing the Event reported by the protocol stack. There are some common applications, such as gateway, lighting and etc.

Interaction between application layer (``Applications``) and ``API/Event``

- Application layer calls API

  - Call the provisioning-related API for provisioning.
  - Call the model-related API to send messages.
  - Call the device-attri"
"butes-related API to get local information about the device.

- Application layer processes Event

  The application layer is designed based on events, which take parameters to the application layer. Events are mainly divided into two categories.

    - The events completed by calling API.
        - Such as nodes sending messages.
    - The events that the protocol stack actively reports to the application layer.
        - The Event that the protocol stack actively reports.
        - The Event t"
"hat Model actively reports.

- The event is reported by the callback function registered by the application layer, and the callback function also contains the corresponding processing of the event.

Interaction between ``API / Event`` and ESP-BLE-MESH protocol stack

- API used by user mainly calls functions provided by ``Mesh Networking``, ``Mesh Provisioning`` and ``Mesh Models``.

- The interaction between ``API / Event`` and the protocol stack does not operate across the hierarchy of the pro"
"tocol stack. For example, API does not call functions related to ``Network Layer``.


The design and implementation of ESP-BLE-MESH architecture is based on layers and modules. In details, Section 2.1 (Mesh Networking Implementation), Section 2.2 (Mesh Provisioning Implementation) and Section 2.3 (Mesh Bearers Implementation) are based on layers, and Section 2.4 (Mesh Models Implementation) is on modules.

- **Layer-based Approach**: With Layer-based approach, the architecture is designed accord"
"ing to the layers specified in the Mesh Profile Specification. Each layer has its unique files which include APIs of this layer and etc. The specific design is shown in Figure 2.1.

- **Module-based Approach**: Every file implements an independent function that can be called by other programs.

.. figure:: ../../../_static/esp-ble-mesh-interface.png
  :align: center

  Figure 2.1 ESP-BLE-MESH Architecture Implementation Diagram

The design of ESP-BLE-MESH architecture uses layer-based approach. "
"The sequence of layers which data packets are processed through is fixed, i.e., the processing of packets will form a ``message flow``. Thus, we could see flows of messages from the Protocol Stack Interface Diagram in Figure 2.1.

2.1 Mesh Protocol Stack Implementation


2.1.1 Mesh Networking Implementation


The list of files and the functions implemented in each file in ``Mesh Networking`` are shown in Table 2.1:

.. list-table:: Table 2.1  Mesh Networking File Description
   :widths: 40 150
 "
"  :header-rows: 1
    - Functionality
    - ESP-BLE-MESH Access Layer
    - ESP-BLE-MESH Lower/Upper Transport Layer
    - ESP-BLE-MESH Network Layer
    - A task used to send ESP-BLE-MESH advertising packets, a callback used to handle received advertising packets and APIs used to allocate adv buffers

2.1.2 Mesh Provisioning Implementation


The implementation of Mesh Provisioning is divided into two chunks due to the Node/Provisioner coexistence.

Specific files that provide implementation of "
"provisioning of Node are shown in Table 2.2:

.. list-table:: Table 2.2  Mesh Provisioning (Node) File Description
  :widths: 40 150
  :header-rows: 1
    - Functionality
    - ESP-BLE-MESH Node provisioning (PB-ADV & PB-GATT)
    - ESP-BLE-MESH Proxy Server related functionalities
    - APIs used to handle ESP-BLE-MESH Beacons

Specific files that implement functions of Provisioner are shown in Table 2.3:

.. list-table:: Table 2.3  Mesh Provisioning (Provisioner) File Description
  :widths: 40"
" 150
  :header-rows: 1
    - Functionality
    - ESP-BLE-MESH Provisioner provisioning (PB-ADV & PB-GATT)
    - ESP-BLE-MESH Proxy Client related functionalities
    - ESP-BLE-MESH Provisioner networking related functionalities

2.1.3 Mesh Models Implementation


Mesh Models are used to implement the specific functions of model in nodes. Server model is used to maintain node status. Client model is used to obtain and modify node state.

.. list-table:: Table 2.4  Mesh Models File Description
  :"
"widths: 40 150
  :header-rows: 1
    - Functionality
    - Send Configuration Client messages and receive corresponding response messages
    - Receive Configuration Client messages and send proper response messages
    - Send Health Client messages and receive corresponding response messages
    - Receive Health Client messages and send proper response messages
    - ESP-BLE-MESH model related operations
    - Send ESP-BLE-MESH Generic Client messages and receive corresponding response messages"
"
    - Send ESP-BLE-MESH Lighting Client messages and receive corresponding response messages
    - Send ESP-BLE-MESH Sensor Client messages and receive corresponding response messages
    - Send ESP-BLE-MESH Time Scene Client messages and receive corresponding response messages
    - Receive ESP-BLE-MESH Generic Client messages and send corresponding response messages
    - Receive ESP-BLE-MESH Lighting Client messages and send corresponding response messages
    - Receive ESP-BLE-MESH Sensor C"
"lient messages and send corresponding response messages
    - Receive ESP-BLE-MESH Time Scene Client messages and send corresponding response messages

2.2 Mesh Bearers Implementation


Portability is fully considered in the implementation of Mesh Bearers. When the ESP-BLE-MESH protocol stack is being ported to other platforms, users only need to modify :component_file:`adapter.c ` (example of :component_file:`NimBLE version `).

.. list-table:: Table 2.5  Mesh Bearers File Description
  :widths"
": 40 150
  :header-rows: 1
    - Functionality
    - ESP-BLE-MESH Bearer Layer adapter，This file provides the interfaces used to receive and send ESP-BLE-MESH ADV & GATT related packets.

.. note::

  :component_file:`adapter.c ` is the implementation of ``Advertising Bearer`` and ``GATT Bearer`` in Mesh Networking framework.

2.3 Mesh Applications Implementation


We have provided a series of application examples for customer development, and users can develop products based on :ref:`esp-ble-me"
"sh-examples`.


Auxiliary routine refers to optional functions in the ESP-BLE-MESH protocol stack. The design of the auxiliary routine generally implement the truncation of code through :ref:`CONFIG_BLE_MESH`.

3.1 Features


- Low Power
- Friend
- Relay
- Proxy Client/Server

3.2 Network Management


- Node Removal procedure
- IV Index Recovery procedure
- IV Update procedure
- Key Refresh procedure
- Network Creation procedure
- NVS Storage

3.3 Auxiliary Routine Implementation


When adopting"
" the design of independent module, the two main factors should be considered:

- The module can not be implemented hierarchically, and it can be completely independent, which means it does not rely on the implementation of other modules.
- The functions in the module will be used repeatedly, so it is reasonable to design it into a module. Independent module is shown in Table 3.1:

.. list-table:: Table 3.1 Module File Description
  :widths: 40 150
  :header-rows: 1
    - Functionality
    - ESP-"
"BLE-MESH Low Power functionality
    - ESP-BLE-MESH Friend functionality
    - ESP-BLE-MESH Relay feature, network creation, IV Update procedure, IV Index recovery procedure, Key Refresh procedure related functionalities
    - ESP-BLE-MESH Proxy Server related functionalities
    - ESP-BLE-MESH Proxy Client related functionalities
    - ESP-BLE-MESH NVS storage functionality
    - ESP-BLE-MESH stack initialize, stack enable, node removal related functionalities
"
"Using Debugger




This section covers the steps to configure and run a debugger using various methods, including:

For how to run a debugger from VS Code, see `Configuration for Visual Studio Code Debug `__.


.. _jtag-debugging-using-debugger-eclipse:

Eclipse


.. note::

    It is recommended to first check if debugger works using :ref:`jtag-debugging-with-idf-py` or from :ref:`jtag-debugging-using-debugger-command-line` and then move to using Eclipse.

Eclipse is an integrated development e"
"nvironment (IDE) that provides a powerful set of tools for developing and debugging software applications. For ESP-IDF applications, `IDF Eclipse plugin `_ provides two ways of debugging:

By default, Eclipse supports OpenOCD Debugging via the GDB Hardware Debugging plugin, which requires starting the OpenOCD server from the command line and configuring the GDB client from Eclipse to start with the debugging. This approach can be time-consuming and error-prone.

To make the debugging process eas"
"ier, the IDF Eclipse plugin has a customized ESP-IDF GDB OpenOCD Debugging functionality. This functionality supports configuring the OpenOCD server and GDB client from within Eclipse. All the required configuration parameters will be pre-filled by the plugin, and you can start debugging with just a click of a button.

Therefore, it is recommended to use the `ESP-IDF GDB OpenOCD Debugging `_ via the IDF Eclipse plugin.

**GDB Hardware Debugging**

.. note::
    This approach is recommended only "
"if you are unable to debug using `ESP-IDF GDB OpenOCD Debugging `_ for some reason.

To install the ``GDB Hardware Debugging`` plugin, open Eclipse and select ``Help`` > ``Install`` New Software.

After installation is complete, follow these steps to configure the debugging session. Please note that some configuration parameters are generic, while others are project-specific. This will be shown below by configuring debugging for ""blink"" example project. If not done already, add this project to E"
"clipse workspace following `Eclipse Plugin `_.  The source of :example:`get-started/blink` application is available in :idf:`examples` directory of ESP-IDF repository.

    A sample window with settings entered in points 1 - 5 is shown below.

    .. figure:: ../../../_static/hw-debugging-main-tab.jpg
        :align: center
        :alt: Configuration of GDB Hardware Debugging - Main tab
        :figclass: align-center

        Configuration of GDB Hardware Debugging - Main tab

    Configuratio"
"n entered in points 6 and 7 is shown on the following picture.

    .. figure:: ../../../_static/hw-debugging-debugger-tab.jpg
        :align: center
        :alt: Configuration of GDB Hardware Debugging - Debugger tab
        :figclass: align-center

        Configuration of GDB Hardware Debugging - Debugger tab

    ::

        mon reset halt
        maintenance flush register-cache
        set remote hardware-watchpoint-limit 2

    .. note::
        To automatically update the image in the f"
"lash before starting a new debug session, add the following command lines to the beginning of the ``Initialization Commands`` textbox::

            mon reset halt
            mon program_esp ${workspace_loc:blink/build/blink.bin} 0x10000 verify

    For description of ``program_esp`` command, see :ref:`jtag-upload-app-debug`.

    Configuration described in points 8 - 11 is shown below.

    .. figure:: ../../../_static/hw-debugging-startup-tab.jpg
        :align: center
        :alt: Configura"
"tion of GDB Hardware Debugging - Startup tab
        :figclass: align-center

        Configuration of GDB Hardware Debugging - Startup tab

    If the ``Startup`` sequence looks convoluted and respective ``Initialization Commands`` are unclear, check :ref:`jtag-debugging-tip-debugger-startup-commands` for additional explanation.

Once all configuration steps 1-12 are satisfied, the new Eclipse perspective called ""Debug"" will open, as shown in the example picture below.

.. figure:: ../../../_st"
"atic/debug-perspective.jpg
    :align: center
    :alt: Debug Perspective in Eclipse
    :figclass: align-center

    Debug Perspective in Eclipse

If you are not quite sure how to use GDB, check :ref:`jtag-debugging-examples-eclipse` example debugging session in section :ref:`jtag-debugging-examples`.


.. _jtag-debugging-using-debugger-command-line:

Command Line


.. highlight:: bash

    ::

        cd ~/esp/blink

.. highlight:: none

    ::

        target remote :3333
        set remote h"
"ardware-watchpoint-limit 2
        mon reset halt
        maintenance flush register-cache
        thb app_main
        c

    Save this file in the current directory.

    For more details on what is inside ``gdbinit`` file, see :ref:`jtag-debugging-tip-debugger-startup-commands`

.. highlight:: bash

    ::

        {IDF_TARGET_TOOLCHAIN_PREFIX}-gdb -x gdbinit build/blink.elf

.. highlight:: none

    ::

        user-name@computer-name:~/esp/blink$ {IDF_TARGET_TOOLCHAIN_PREFIX}-gdb -x gdbinit"
" build/blink.elf
        GNU gdb (crosstool-NG crosstool-ng-1.22.0-61-gab8375a) 7.10
        Copyright (C) 2015 Free Software Foundation, Inc.
        License GPLv3+: GNU GPL version 3 or later 
        This is free software: you are free to change and redistribute it.
        There is NO WARRANTY, to the extent permitted by law.  Type ""show copying""
        and ""show warranty"" for details.
        This GDB was configured as ""--host=x86_64-build_pc-linux-gnu --target={IDF_TARGET_TOOLCHAIN_PREFIX"
"}"".
        Type ""show configuration"" for configuration details.
        For bug reporting instructions, please see:
        .
        Find the GDB manual and other documentation resources online at:
        .
        For help, type ""help"".
        Type ""apropos word"" to search for commands related to ""word""...
        Reading symbols from build/blink.elf...done.
        0x400d10d8 in esp_vApplicationIdleHook () at /home/user-name/esp/esp-idf/components/{IDF_TARGET_PATH_NAME}/./freertos_hooks.c:"
"52
        52          asm(""waiti 0"");
        JTAG tap: {IDF_TARGET_PATH_NAME}.cpu0 tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)
        JTAG tap: {IDF_TARGET_PATH_NAME}.slave tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)
        {IDF_TARGET_PATH_NAME}: Debug controller was reset (pwrstat=0x5F, after clear 0x0F).
        {IDF_TARGET_PATH_NAME}: Core was reset (pwrstat=0x5F, after clear 0x0F).
        Target halted. PRO_CPU: PC=0x5"
"000004B (active)    APP_CPU: PC=0x00000000
        {IDF_TARGET_PATH_NAME}: target state: halted
        {IDF_TARGET_PATH_NAME}: Core was reset (pwrstat=0x1F, after clear 0x0F).
        Target halted. PRO_CPU: PC=0x40000400 (active)    APP_CPU: PC=0x40000400
        {IDF_TARGET_PATH_NAME}: target state: halted
        Hardware assisted breakpoint 1 at 0x400db717: file /home/user-name/esp/blink/main/./blink.c, line 43.
        0x0:    0x00000000
        Target halted. PRO_CPU: PC=0x400DB717 (activ"
"e)    APP_CPU: PC=0x400D10D8
        [New Thread 1073428656]
        [New Thread 1073413708]
        [New Thread 1073431316]
        [New Thread 1073410672]
        [New Thread 1073408876]
        [New Thread 1073432196]
        [New Thread 1073411552]
        [Switching to Thread 1073411996]

        Temporary breakpoint 1, app_main () at /home/user-name/esp/blink/main/./blink.c:43
        43      xTaskCreate(&blink_task, ""blink_task"", 512, NULL, 5, NULL);
        (gdb)


Note the third-to-last"
" line, which shows debugger halting at breakpoint established in ``gdbinit`` file at function ``app_main()``. Since the processor is halted, the LED should not be blinking. If this is what you see as well, you are ready to start debugging.

If you are not sure how to use GDB, check :ref:`jtag-debugging-examples-command-line` example debugging session in section :ref:`jtag-debugging-examples`.


.. _jtag-debugging-with-idf-py:

Idf.py Debug Targets


It is also possible to execute the described d"
"ebugging tools conveniently from ``idf.py``. These commands are supported:

    Runs OpenOCD in a console with configuration defined in the environment or via command line. It uses default script directory defined as ``OPENOCD_SCRIPTS`` environmental variable, which is automatically added from an Export script (``export.sh`` or ``export.bat``).
    It is possible to override the script location using command line argument ``--openocd-scripts``.

    .. include:: {IDF_TARGET_PATH_NAME}.inc
      "
"  :start-after: idf-py-openocd-default-cfg
        :end-before: ---

    To configure the JTAG configuration for the current board, please use the environmental variable ``OPENOCD_COMMANDS`` or ``--openocd-commands`` command line argument. If none of the above is defined, OpenOCD is started with |idf-py-def-cfg| board definition.

    Starts the GDB the same way as the :ref:`jtag-debugging-using-debugger-command-line`, but generates the initial GDB scripts referring to the current project elf fi"
"le.

    The same as `2`, but starts the gdb with ``tui`` argument, allowing for a simple source code view.

    Starts `gdbgui `_ debugger frontend enabling out-of-the-box debugging in a browser window. To enable this option, run the install script with the ""--enable-gdbgui"" argument, e.g., ``install.sh --enable-gdbgui``.


    You can combine these debugging actions on a single command line, allowing for convenient setup of blocking and non-blocking actions in one step. ``idf.py`` implements a"
" simple logic to move the background actions (such as openocd) to the beginning and the interactive ones (such as gdb, monitor) to the end of the action list.

    An example of a very useful combination is::

        idf.py openocd gdbgui monitor


    The above command runs OpenOCD in the background, starts `gdbgui `_ to open a browser window with active debugger frontend and opens a serial monitor in the active console.
"
"JTAG Debugging




This document provides a guide to installing OpenOCD for {IDF_TARGET_NAME} and debugging using GDB.

.. note::

    You can also debug your {IDF_TARGET_NAME} without needing to setup JTAG or OpenOCD by using ``idf.py monitor``. See: :doc:`../../api-guides/tools/idf-monitor` and :ref:`CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME`.

.. highlight:: none

The document is structured as follows:

:ref:`jtag-debugging-introduction`
    Introduction to the purpose of this guide.
:ref:`jtag-debug"
"ging-how-it-works`
    Description how {IDF_TARGET_NAME}, JTAG interface, OpenOCD and GDB are interconnected and working together to enable debugging of {IDF_TARGET_NAME}.
:ref:`jtag-debugging-selecting-jtag-adapter`
    What are the criteria and options to select JTAG adapter hardware.
:ref:`jtag-debugging-setup-openocd`
    Procedure to install OpenOCD and verify that it is installed.
:ref:`jtag-debugging-configuring-target`
    Configuration of OpenOCD software and setting up of JTAG adapter "
"hardware, which together make up the debugging target.
:ref:`jtag-debugging-launching-debugger`
    Steps to start up a debug session with GDB from :ref:`jtag-debugging-using-debugger-eclipse` and from :ref:`jtag-debugging-using-debugger-command-line`.
:ref:`jtag-debugging-examples`
    If you are not familiar with GDB, check this section for debugging examples provided from :ref:`jtag-debugging-examples-eclipse` as well as from :ref:`jtag-debugging-examples-command-line`.
:ref:`jtag-debugging-b"
"uilding-openocd`
    Procedure to build OpenOCD from sources for :doc:`Windows `, :doc:`Linux ` and :doc:`macOS ` operating systems.
:ref:`jtag-debugging-tips-and-quirks`
    This section provides collection of tips and quirks related to JTAG debugging of {IDF_TARGET_NAME} with OpenOCD and GDB.


.. include:: {IDF_TARGET_PATH_NAME}.inc
   :start-after: devkit-defs
   :end-before: ---


.. _jtag-debugging-introduction:

Introduction


.. only:: esp32

    The ESP32 has two powerful Xtensa cores, "
"allowing for a great deal of variety of program architectures. The FreeRTOS OS that comes with ESP-IDF is capable of multi-core preemptive scheduling, allowing for an intuitive way of writing software.

    The downside of the ease of programming is that debugging without the right tools is harder: figuring out a bug that is caused by two threads, running even simultaneously on two different CPU cores, can take a long time when all you have are ``printf()`` statements. A better (and in many case"
"s quicker) way to debug such problems is by using a debugger, connected to the processors over a debug port.

Espressif has ported OpenOCD to support the {IDF_TARGET_NAME} processor and the multi-core FreeRTOS  (which is the foundation of most {IDF_TARGET_NAME} apps). Additionally, some extra tools have been written to provide extra features that OpenOCD does not support natively.

This document provides a guide to installing OpenOCD for {IDF_TARGET_NAME} and debugging using GDB under Linux, Win"
"dows and macOS. Except for OS specific installation procedures, the s/w user interface and use procedures are the same across all supported operating systems.

.. note::

    Screenshots presented in this document have been made for Eclipse Neon 3 running on Ubuntu 16.04 LTS. There may be some small differences in what a particular user interface looks like, depending on whether you are using Windows, macOS or Linux and/or a different release of Eclipse.

.. _jtag-debugging-how-it-works:

How it"
" Works?


The key software and hardware components that perform debugging of {IDF_TARGET_NAME} with OpenOCD over JTAG (Joint Test Action Group) interface is presented in the diagram below under the ""Debugging With JTAG"" label. These components include {IDF_TARGET_TOOLCHAIN_PREFIX}-gdb debugger, OpenOCD on chip debugger, and the JTAG adapter connected to {IDF_TARGET_NAME} target.

.. figure:: ../../../_static/jtag-debugging-overview.jpg
    :align: center
    :alt: JTAG debugging - overview diagr"
"am
    :figclass: align-center

    JTAG debugging - overview diagram

Likewise, the ""Application Loading and Monitoring"" label indicates the key software and hardware components that allow an application to be compiled, built, and flashed to {IDF_TARGET_NAME}, as well as to provide means to monitor diagnostic messages from {IDF_TARGET_NAME}.

""Debugging With JTAG"" and ""Application Loading and Monitoring"" is integrated under the `Eclipse `_ IDE in order to provide a quick and easy transition bet"
"ween writing/compiling/loading/debugging code. The Eclipse IDE (and the integrated debugging software) is available for Windows, Linux and macOS platforms. Depending on user preferences, both the debugger and ``idf.py build`` can also be used directly from terminal/command line, instead of Eclipse.

.. only:: esp32 or esp32s2

    If the |devkit-name-with-link| is used, then connection from PC to {IDF_TARGET_NAME} is done effectively with a single USB cable. This is made possible by the FT2232H "
"chip, which provides two USB channels, one for JTAG and the other for UART connection.

.. only:: SOC_USB_SERIAL_JTAG_SUPPORTED

    The connection from PC to {IDF_TARGET_NAME} is done effectively with a single USB cable. This is made possible by the {IDF_TARGET_NAME} chip itself, which provides two USB channels, one for JTAG and the other for the USB terminal connection. The USB cable should be connected to the D+/D- USB pins of {IDF_TARGET_NAME} and not to the serial RxD/TxD through a USB-to-U"
"ART chip. The proper connection is explained later in subsection :ref:`jtag-debugging-configuring-target`.

.. only:: esp32c3

    .. note::

        Debugging through the USB interface implemented in {IDF_TARGET_NAME} requires to have a chip with revision 0.3 or newer. Please use other debugging options (e.g., with ESP-Prog) for chip revisions 0.1 and 0.2. The easiest way to determine the chip revision is to look for the ``boot: chip revision: v0.3`` message at the beginning of the boot log. Se"
"e `SoC errata `_ for more details.

.. _jtag-debugging-selecting-jtag-adapter:

Selecting JTAG Adapter


.. only:: esp32 or esp32s2

    The quickest and most convenient way to start with JTAG debugging is by using |devkit-name-with-link|. Each version of this development board has JTAG interface already built in. No need for an external JTAG adapter and extra wiring/cable to connect JTAG to {IDF_TARGET_NAME}. |devkit-name| is using FT2232H JTAG interface operating at 20 MHz clock speed, which i"
"s difficult to achieve with an external adapter.

.. only:: SOC_USB_SERIAL_JTAG_SUPPORTED

    The quickest and most convenient way to start with JTAG debugging is through a USB cable connected to the D+/D- USB pins of {IDF_TARGET_NAME}. No need for an external JTAG adapter and extra wiring/cable to connect JTAG to {IDF_TARGET_NAME}.

If you decide to use separate JTAG adapter, look for one that is compatible with both the voltage levels on the {IDF_TARGET_NAME} as well as with the OpenOCD softw"
"are. The JTAG port on the {IDF_TARGET_NAME} is an industry-standard JTAG port which lacks (and does not need) the TRST pin. The JTAG I/O pins all are powered from the VDD_3P3_RTC pin (which normally would be powered by a 3.3 V rail) so the JTAG adapter needs to be able to work with JTAG pins in that voltage range.

On the software side, OpenOCD supports a fair amount of JTAG adapters. See https://openocd.org/doc/html/Debug-Adapter-Hardware.html for an (unfortunately slightly incomplete) list of "
"the adapters OpenOCD works with. This page lists SWD-compatible adapters as well; take note that the {IDF_TARGET_NAME} does not support SWD. JTAG adapters that are hardcoded to a specific product line, e.g., ST-LINK debugging adapters for STM32 families, will not work.

The minimal signalling to get a working JTAG connection are TDI, TDO, TCK, TMS and GND. Some JTAG debuggers also need a connection from the {IDF_TARGET_NAME} power line to a line called e.g., Vtar to set the working voltage. SRST"
" can optionally be connected to the CH_PD of the {IDF_TARGET_NAME}, although for now, support in OpenOCD for that line is pretty minimal.

`ESP-Prog `_ is an example for using an external board for debugging by connecting it to the JTAG pins of {IDF_TARGET_NAME}.

.. _jtag-debugging-setup-openocd:

Setup of OpenOCD


.. highlight:: bash

If you have already set up ESP-IDF with CMake build system according to the :doc:`Getting Started Guide `, then OpenOCD is already installed. After :ref:`settin"
"g up the environment ` in your terminal, you should be able to run OpenOCD. Check this by executing the following command::

    openocd --version

.. highlight:: none

The output should be as follows (although the version may be more recent than listed here)::

    Open On-Chip Debugger  v0.10.0-esp32-20190708 (2019-07-08-11:04)
    Licensed under GNU GPL v2
    For bug reports, read
        https://openocd.org/doc/doxygen/bugs.html

You may also verify that OpenOCD knows where its configuratio"
"n scripts are located by printing the value of ``OPENOCD_SCRIPTS`` environment variable, by typing ``echo $OPENOCD_SCRIPTS`` (for Linux and macOS) or ``echo %OPENOCD_SCRIPTS%`` (for Windows). If a valid path is printed, then OpenOCD is set up correctly.

If any of these steps do not work, please go back to the :ref:`setting up the tools ` section (for Linux and macOS) or :ref:`ESP-IDF Tools Installer ` (for Windows) section of the Getting Started Guide.

.. note::

    It is also possible to bui"
"ld OpenOCD from source. Please refer to :ref:`jtag-debugging-building-openocd` section for details.

.. _jtag-debugging-configuring-target:

Configuring {IDF_TARGET_NAME} Target


Once OpenOCD is installed, you can proceed to configuring the {IDF_TARGET_NAME} target (i.e {IDF_TARGET_NAME} board with JTAG interface). Configuring the target is split into the following three steps:

.. _jtag-debugging-configure-and-connect-JTAG-interface:

Configure and Connect JTAG Interface


This step depends on"
" the JTAG and {IDF_TARGET_NAME} board you are using (see the two cases described below).

.. toctree::
    :maxdepth: 1

    :esp32: configure-ft2232h-jtag
    :esp32s2: configure-ft2232h-jtag
    :SOC_USB_SERIAL_JTAG_SUPPORTED: configure-builtin-jtag
    configure-other-jtag


.. _jtag-debugging-run-openocd:

Run OpenOCD


Once target is configured and connected to computer, you are ready to launch OpenOCD.

.. highlight:: bash

Open a terminal and set it up for using the ESP-IDF as described i"
"n the :ref:`setting up the environment ` section of the Getting Started Guide. Then run OpenOCD (this command works on Windows, Linux, and macOS):

.. include:: {IDF_TARGET_PATH_NAME}.inc
   :start-after: run-openocd
   :end-before: ---

{IDF_TARGET_FTDI_CONFIG:default=""Not Updated!"", esp32s3=""board/esp32s3-ftdi.cfg"", esp32c3=""board/esp32c3-ftdi.cfg"", esp32c6=""board/esp32c6-ftdi.cfg"", esp32h2=""board/esp32h2-ftdi.cfg""}

.. note::

    The files provided after ``-f`` above are specific for |run-op"
"enocd-device-name|. You may need to provide different files depending on the hardware that is used. For guidance see :ref:`jtag-debugging-tip-openocd-configure-target`.

    .. only:: SOC_USB_SERIAL_JTAG_SUPPORTED

        For example, ``{IDF_TARGET_FTDI_CONFIG}`` can be used for a custom board with an FT2232H or FT232H chip used for JTAG connection, or with ESP-Prog.

.. highlight:: none

You should now see similar output (this log is for |run-openocd-device-name|):

.. include:: {IDF_TARGET_PA"
"TH_NAME}.inc
   :start-after: run-openocd-output
   :end-before: ---

.. _jtag-upload-app-debug:

Upload Application for Debugging


Build and upload your application to {IDF_TARGET_NAME} as usual, see :ref:`get-started-build`.

Another option is to write application image to flash using OpenOCD via JTAG with commands like this:

.. include:: {IDF_TARGET_PATH_NAME}.inc
   :start-after: run-openocd-upload
   :end-before: ---

OpenOCD flashing command ``program_esp`` has the following format:

``p"
"rogram_esp   [verify] [reset] [exit] [compress] [encrypt]``

 - ``image_file`` - Path to program image file.
 - ``offset`` - Offset in flash bank to write image.
 - ``verify`` - Optional. Verify flash contents after writing.
 - ``reset`` - Optional. Reset target after programing.
 - ``exit`` - Optional. Finally exit OpenOCD.
 - ``compress`` - Optional. Compress image file before programming.
 - ``encrypt`` - Optional. Encrypt binary before writing to flash. Same functionality with ``idf.py encry"
"pted-flash``

You are now ready to start application debugging. Follow the steps described in the section below.


.. _jtag-debugging-launching-debugger:

Launching Debugger


The toolchain for {IDF_TARGET_NAME} features GNU Debugger, in short GDB. It is available with other toolchain programs under filename: {IDF_TARGET_TOOLCHAIN_PREFIX}-gdb. GDB can be called and operated directly from command line in a terminal. Another option is to call it from within IDE (like Eclipse, Visual Studio Code, e"
"tc.) and operate indirectly with help of GUI instead of typing commands in a terminal.

The options of using debugger are discussed under links below.

It is recommended to first check if debugger works from :ref:`jtag-debugging-using-debugger-command-line` and then move to using :ref:`jtag-debugging-using-debugger-eclipse`.


.. _jtag-debugging-examples:

Debugging Examples


This section is intended for users not familiar with GDB. It presents example debugging session from :ref:`jtag-debuggin"
"g-examples-eclipse` using simple application available under :example:`get-started/blink` and covers the following debugging actions:

Similar debugging actions are provided using GDB from :ref:`jtag-debugging-examples-command-line`.

.. note::

    :ref:`jtag-debugging-examples-command-line-08` is currently only available for command line debugging.


Before proceeding to examples, set up your {IDF_TARGET_NAME} target and load it with :example:`get-started/blink`.


.. _jtag-debugging-building-"
"openocd:

Building OpenOCD from Sources


Please refer to separate documents listed below, that describe build process.

.. toctree::
    :maxdepth: 1

    Windows 
    Linux 
    macOS 

The examples of invoking OpenOCD in this document assume using pre-built binary distribution described in section :ref:`jtag-debugging-setup-openocd`.

To use binaries build locally from sources, change the path to OpenOCD executable to ``src/openocd`` and set the ``OPENOCD_SCRIPTS`` environment variable so tha"
"t OpenOCD can find the configuration files. For Linux and macOS:

.. code-block:: bash

    cd ~/esp/openocd-esp32
    export OPENOCD_SCRIPTS=$PWD/tcl

For Windows:

.. code-block:: batch

    cd %USERPROFILE%\esp\openocd-esp32
    set ""OPENOCD_SCRIPTS=%CD%\tcl""

Example of invoking OpenOCD build locally from sources, for Linux and macOS:

.. include:: {IDF_TARGET_PATH_NAME}.inc
   :start-after: run-openocd-src-linux
   :end-before: ---

and Windows:

.. include:: {IDF_TARGET_PATH_NAME}.inc
   :"
"start-after: run-openocd-src-win
   :end-before: ---

.. _jtag-debugging-tips-and-quirks:

Tips and Quirks


This section provides collection of links to all tips and quirks referred to from various parts of this guide.

.. toctree::
    :maxdepth: 2

    tips-and-quirks


Related Documents


.. toctree::
    :hidden:

    :maxdepth: 1

    using-debugger
    debugging-examples
    tips-and-quirks
    ../app_trace

- :doc:`using-debugger`
- :doc:`debugging-examples`
- :doc:`tips-and-quirks`
- :d"
"oc:`../app_trace`
- `Introduction to ESP-Prog Board `__
"
"Debugging Examples




This section describes debugging with GDB from :ref:`jtag-debugging-examples-eclipse` as well as from :ref:`jtag-debugging-examples-command-line`.

.. highlight:: none


.. _jtag-debugging-examples-eclipse:

Eclipse


Verify if your target is ready and loaded with :example:`get-started/blink` example. Configure and start debugger following steps in section :ref:`jtag-debugging-using-debugger-eclipse`. Pick up where target was left by debugger, i.e., having the application "
"halted at breakpoint established at ``app_main()``.

.. figure:: ../../../_static/debug-perspective.jpg
    :align: center
    :alt: Debug Perspective in Eclipse
    :figclass: align-center

    Debug Perspective in Eclipse


Examples in This Section



.. _jtag-debugging-examples-eclipse-01:

Navigating Through the Code, Call Stack and Threads


When the target is halted, debugger shows the list of threads in ""Debug"" window. The line of code where program halted is highlighted in another window"
" below, as shown on the following picture. The LED stops blinking.

.. figure:: ../../../_static/debugging-target-halted.jpg
    :align: center
    :alt: Target halted during debugging
    :figclass: align-center

    Target halted during debugging

Specific thread where the program halted is expanded showing the call stack. It represents function calls that lead up to the highlighted line of code, where the target halted. The first line of call stack under Thread #1 contains the last called fun"
"ction ``app_main()``, that in turn was called from function ``main_task()`` shown in a line below. Each line of the stack also contains the file name and line number where the function was called. By clicking/highlighting the stack entries, in window below, you will see contents of this file.

By expanding threads you can navigate throughout the application. Expand Thread #5 that contains much longer call stack. You will see there, besides function calls, numbers like ``0x4000000c``. They repres"
"ent addresses of binary code not provided in source form.

.. figure:: ../../../_static/debugging-navigate-through-the-stack.jpg
    :align: center
    :alt: Navigate through the call stack
    :figclass: align-center

    Navigate through the call stack

In another window on right, you can see the disassembled machine code no matter if your project provides it in source or only the binary form.

Go back to the ``app_main()`` in Thread #1 to familiar code of ``blink.c`` file that will be examine"
"d in more details in the following examples. Debugger makes it easy to navigate through the code of entire application. This comes handy when stepping through the code and working with breakpoints and will be discussed below.


.. _jtag-debugging-examples-eclipse-02:

Setting and Clearing Breakpoints


When debugging, we would like to be able to stop the application at critical lines of code and then examine the state of specific variables, memory and registers/peripherals. To do so we are using"
" breakpoints. They provide a convenient way to quickly get to and halt the application at specific line.

Let's establish two breakpoints when the state of LED changes. Basing on code listing above, this happens at lines 33 and 36. To do so, hold the ""Control"" on the keyboard and double clink on number ``33`` in file ``blink.c`` file. A dialog will open where you can confirm your selection by pressing ""OK"" button. If you do not like to see the dialog just double click the line number. Set anothe"
"r breakpoint in line 36.

.. figure:: ../../../_static/debugging-setting-breakpoint.jpg
    :align: center
    :alt: Setting a breakpoint
    :figclass: align-center

    Setting a breakpoint

Information how many breakpoints are set and where is shown in window ""Breakpoints"" on top right. Click ""Show Breakpoints Supported by Selected Target"" to refresh this list. Besides the two just set breakpoints the list may contain temporary breakpoint at function ``app_main()`` established at debugger sta"
"rt. As maximum two breakpoints are allowed (see :ref:`jtag-debugging-tip-breakpoints`), you need to delete it, or debugging will fail.

.. figure:: ../../../_static/debugging-three-breakpoints-set.jpg
    :align: center
    :alt: Three breakpoints are set / maximum two are allowed
    :figclass: align-center

    Three breakpoints are set / maximum two are allowed

If you now click ""Resume"" (click ``blink_task()`` under ""Tread #8"", if ""Resume"" button is grayed out), the processor will run and ha"
"lt at a breakpoint. Clicking ""Resume"" another time will make it run again, halt on second breakpoint, and so on.

You will be also able to see that LED is changing the state after each click to ""Resume"" program execution.

Read more about breakpoints under :ref:`jtag-debugging-tip-breakpoints` and :ref:`jtag-debugging-tip-where-breakpoints`


.. _jtag-debugging-examples-eclipse-03:

Halting the Target Manually


When debugging, you may resume application and enter code waiting for some event or "
"staying in infinite loop without any break points defined. In such case, to go back to debugging mode, you can break program execution manually by pressing ""Suspend"" button.

To check it, delete all breakpoints and click ""Resume"". Then click ""Suspend"". Application will be halted at some random point and LED will stop blinking. Debugger will expand tread and highlight the line of code where application halted.

.. figure:: ../../../_static/debugging-target-halted-manually.jpg
    :align: center
 "
"   :alt: Target halted manually
    :figclass: align-center

    Target halted manually

In particular case above, the application has been halted in line 52 of code in file ``freertos_hooks.c`` Now you can resume it again by pressing ""Resume"" button or do some debugging as discussed below.


.. _jtag-debugging-examples-eclipse-04:

Stepping Through the Code


It is also possible to step through the code using ""Step Into (F5)"" and ""Step Over (F6)"" commands. The difference is that ""Step Into (F5)"
""" is entering inside subroutines calls, while ""Step Over (F6)"" steps over the call, treating it as a single source line.

Before being able to demonstrate this functionality, using information discussed in previous paragraph, make sure that you have only one breakpoint defined at line ``36`` of ``blink.c``.

Resume program by entering pressing F8 and let it halt. Now press ""Step Over (F6)"", one by one couple of times, to see how debugger is stepping one program line at a time.

.. figure:: ../.."
"/../_static/debugging-step-over.jpg
    :align: center
    :alt: Stepping through the code with ""Step Over (F6)""
    :figclass: align-center

    Stepping through the code with ""Step Over (F6)""

If you press ""Step Into (F5)"" instead, then debugger will step inside subroutine calls.

.. figure:: ../../../_static/debugging-step-into.jpg
    :align: center
    :alt: Stepping through the code with ""Step Into (F5)""
    :figclass: align-center

    Stepping through the code with ""Step Into (F5)""

In t"
"his particular case debugger stepped inside ``gpio_set_level(BLINK_GPIO, 0)`` and effectively moved to ``gpio.c`` driver code.

See :ref:`jtag-debugging-tip-why-next-works-as-step` for potential limitation of using ``next`` command.


.. _jtag-debugging-examples-eclipse-05:

Checking and Setting Memory


To display or set contents of memory use ""Memory"" tab at the bottom of ""Debug"" perspective.

With the ""Memory"" tab, we will read from and write to the memory location ``0x3FF44004`` labeled as `"
"`GPIO_OUT_REG`` used to set and clear individual GPIO's.

For more information, see *{IDF_TARGET_NAME} Technical Reference Manual* > *IO MUX and GPIO Matrix (GPIO, IO_MUX)* [`PDF `__].

Being in the same ``blink.c`` project as before, set two breakpoints right after ``gpio_set_level`` instruction. Click ""Memory"" tab and then ""Add Memory Monitor"" button. Enter ``0x3FF44004`` in provided dialog.

Now resume program by pressing F8 and observe ""Monitor"" tab.

.. figure:: ../../../_static/debugging-m"
"emory-location-on.jpg
    :align: center
    :alt: Observing memory location 0x3FF44004 changing one bit to ON""
    :figclass: align-center

    Observing memory location 0x3FF44004 changing one bit to ""ON""

You should see one bit being flipped over at memory location ``0x3FF44004`` (and LED changing the state) each time F8 is pressed.

.. figure:: ../../../_static/debugging-memory-location-off.jpg
    :align: center
    :alt: Observing memory location 0x3FF44004 changing one bit to ON""
    :fig"
"class: align-center

    Observing memory location 0x3FF44004 changing one bit to ""OFF""

To set memory use the same ""Monitor"" tab and the same memory location. Type in alternate bit pattern as previously observed. Immediately after pressing enter you will see LED changing the state.


.. _jtag-debugging-examples-eclipse-06:

Watching and Setting Program Variables


A common debugging tasks is checking the value of a program variable as the program runs. To be able to demonstrate this functionali"
"ty, update file ``blink.c`` by adding a declaration of a global variable ``int i`` above definition of function ``blink_task``. Then add ``i++`` inside ``while(1)`` of this function to get ``i`` incremented on each blink.

Exit debugger, so it is not confused with new code, build and flash the code to the ESP and restart debugger. There is no need to restart OpenOCD.

Once application is halted, enter a breakpoint in the line where you put ``i++``.

In next step, in the window with ""Breakpoints"""
", click the ""Expressions"" tab. If this tab is not visible, then add it by going to the top menu Window > Show View > Expressions. Then click ""Add new expression"" and enter ``i``.

Resume program execution by pressing F8. Each time the program is halted you will see ``i`` value being incremented.

.. figure:: ../../../_static/debugging-watch-variable.jpg
    :align: center
    :alt: Watching program variable ""i""
    :figclass: align-center

    Watching program variable ""i""


To modify ``i`` ente"
"r a new number in ""Value"" column. After pressing ""Resume (F8)"" the program will keep incrementing ``i`` starting from the new entered number.


.. _jtag-debugging-examples-eclipse-07:

Setting Conditional Breakpoints


Here comes more interesting part. You may set a breakpoint to halt the program execution, if certain condition is satisfied. Right click on the breakpoint to open a context menu and select ""Breakpoint Properties"". Change the selection under ""Type:"" to ""Hardware"" and enter a ""Condi"
"tion:"" like ``i == 2``.

.. figure:: ../../../_static/debugging-setting-conditional-breakpoint.jpg
    :align: center
    :alt: Setting a conditional breakpoint
    :figclass: align-center

    Setting a conditional breakpoint

If current value of ``i`` is less than ``2`` (change it if required) and program is resumed, it will blink LED in a loop until condition ``i == 2`` gets true and then finally halt.


.. _jtag-debugging-examples-command-line:

Command Line


Verify if your target is ready "
"and loaded with :example:`get-started/blink` example. Configure and start debugger following steps in section :ref:`jtag-debugging-using-debugger-command-line`. Pick up where target was left by debugger, i.e. having the application halted at breakpoint established at ``app_main()``::

    Temporary breakpoint 1, app_main () at /home/user-name/esp/blink/main/./blink.c:43
    43      xTaskCreate(&blink_task, ""blink_task"", configMINIMAL_STACK_SIZE, NULL, 5, NULL);
    (gdb)


Examples in This Secti"
"on



.. _jtag-debugging-examples-command-line-01:

Navigating Through the Code, Call Stack and Threads


When you see the ``(gdb)`` prompt, the application is halted. LED should not be blinking.

To find out where exactly the code is halted, enter ``l`` or ``list``, and debugger will show couple of lines of code around the halt point (line 43 of code in file ``blink.c``) ::

    (gdb) l
    38      }
    39  }
    40
    41  void app_main()
    42  {
    43      xTaskCreate(&blink_task, ""blink_"
"task"", configMINIMAL_STACK_SIZE, NULL, 5, NULL);
    44  }
    (gdb)


Check how code listing works by entering, e.g., ``l 30, 40`` to see particular range of lines of code.

You can use ``bt`` or ``backtrace`` to see what function calls lead up to this code::

    (gdb) bt
    #0  app_main () at /home/user-name/esp/blink/main/./blink.c:43
    #1  0x400d057e in main_task (args=0x0) at /home/user-name/esp/esp-idf/components/{IDF_TARGET_PATH_NAME}/./cpu_start.c:339
    (gdb)

Line #0 of output pro"
"vides the last function call before the application halted, i.e., ``app_main ()`` we have listed previously. The ``app_main ()`` was in turn called by function ``main_task`` from line 339 of code located in file ``cpu_start.c``.

To get to the context of ``main_task`` in file ``cpu_start.c``, enter ``frame  N``, where N = 1, because the ``main_task`` is listed under #1)::

    (gdb) frame 1
    #1  0x400d057e in main_task (args=0x0) at /home/user-name/esp/esp-idf/components/{IDF_TARGET_PATH_NAME"
"}/./cpu_start.c:339
    339     app_main();
    (gdb)

Enter ``l`` and this will reveal the piece of code that called ``app_main()`` (in line 339)::

    (gdb) l
    334         ;
    335     }
    336 #endif
    337     //Enable allocation in region where the startup stacks were located.
    338     heap_caps_enable_nonos_stack_heaps();
    339     app_main();
    340     vTaskDelete(NULL);
    341 }
    342
    (gdb)

By listing some lines before, you will see the function name ``main_task`` w"
"e have been looking for::

    (gdb) l 326, 341
    326 static void main_task(void* args)
    327 {
    328     // Now that the application is about to start, disable boot watchdogs
    329     REG_CLR_BIT(TIMG_WDTCONFIG0_REG(0), TIMG_WDT_FLASHBOOT_MOD_EN_S);
    330     REG_CLR_BIT(RTC_CNTL_WDTCONFIG0_REG, RTC_CNTL_WDT_FLASHBOOT_MOD_EN);
    331 #if !CONFIG_FREERTOS_UNICORE
    332     // Wait for FreeRTOS initialization to finish on APP CPU, before replacing its startup stack
    333     while"
" (port_xSchedulerRunning[1] == 0) {
    334         ;
    335     }
    336 #endif
    337     //Enable allocation in region where the startup stacks were located.
    338     heap_caps_enable_nonos_stack_heaps();
    339     app_main();
    340     vTaskDelete(NULL);
    341 }
    (gdb)

To see the other code, enter ``i threads``. This will show the list of threads running on target::

    (gdb) i threads
      Id   Target Id         Frame
      8    Thread 1073411336 (dport) 0x400d0848 in dpor"
"t_access_init_core (arg=)
        at /home/user-name/esp/esp-idf/components/{IDF_TARGET_PATH_NAME}/./dport_access.c:170
      7    Thread 1073408744 (ipc0) xQueueGenericReceive (xQueue=0x3ffae694, pvBuffer=0x0, xTicksToWait=1644638200,
        xJustPeeking=0) at /home/user-name/esp/esp-idf/components/freertos/./queue.c:1452
      6    Thread 1073431096 (Tmr Svc) prvTimerTask (pvParameters=0x0)
        at /home/user-name/esp/esp-idf/components/freertos/./timers.c:445
      5    Thread 1073410208 "
"(ipc1 : Running) 0x4000bfea in ?? ()
      4    Thread 1073432224 (dport) dport_access_init_core (arg=0x0)
        at /home/user-name/esp/esp-idf/components/{IDF_TARGET_PATH_NAME}/./dport_access.c:150
      3    Thread 1073413156 (IDLE) prvIdleTask (pvParameters=0x0)
        at /home/user-name/esp/esp-idf/components/freertos/./tasks.c:3282
      2    Thread 1073413512 (IDLE) prvIdleTask (pvParameters=0x0)
        at /home/user-name/esp/esp-idf/components/freertos/./tasks.c:3282
    (gdb)

The th"
"read list shows the last function calls per each thread together with the name of C source file if available.

You can navigate to specific thread by entering  ``thread N``, where ``N`` is the thread Id. To see how it works go to thread thread 5::

    (gdb) thread 5
    [Switching to thread 5 (Thread 1073410208)]
    #0  0x4000bfea in ?? ()
    (gdb)

Then check the backtrace::

    (gdb) bt
    #0  0x4000bfea in ?? ()
    #1  0x40083a85 in vPortCPUReleaseMutex (mux=) at /home/user-name/esp/esp"
"-idf/components/freertos/./port.c:415
    #2  0x40083fc8 in vTaskSwitchContext () at /home/user-name/esp/esp-idf/components/freertos/./tasks.c:2846
    #3  0x4008532b in _frxt_dispatch ()
    #4  0x4008395c in xPortStartScheduler () at /home/user-name/esp/esp-idf/components/freertos/./port.c:222
    #5  0x4000000c in ?? ()
    #6  0x4000000c in ?? ()
    #7  0x4000000c in ?? ()
    #8  0x4000000c in ?? ()
    (gdb)

As you see, the backtrace  may contain several entries. This will let you check "
"what exact sequence of function calls lead to the code where the target halted. Question marks ``??`` instead of a function name indicate that application is available only in binary format, without any source file in C language. The value like ``0x4000bfea`` is the memory address of the function call.

Using ``bt``, ``i threads``, ``thread N`` and ``list`` commands we are now able to navigate through the code of entire application. This comes handy when stepping through the code and working wit"
"h breakpoints and will be discussed below.


.. _jtag-debugging-examples-command-line-02:

Setting and Clearing Breakpoints


When debugging, we would like to be able to stop the application at critical lines of code and then examine the state of specific variables, memory and registers/peripherals. To do so we are using breakpoints. They provide a convenient way to quickly get to and halt the application at specific line.

Let's establish two breakpoints when the state of LED changes. Basing on"
" code listing above this happens at lines 33 and 36. Breakpoints may be established using command ``break M`` where M is the code line number::

    (gdb) break 33
    Breakpoint 2 at 0x400db6f6: file /home/user-name/esp/blink/main/./blink.c, line 33.
    (gdb) break 36
    Breakpoint 3 at 0x400db704: file /home/user-name/esp/blink/main/./blink.c, line 36.

If you new enter ``c``, the processor will run and halt at a breakpoint. Entering ``c`` another time will make it run again, halt on second "
"breakpoint, and so on::

    (gdb) c
    Continuing.
    Target halted. PRO_CPU: PC=0x400DB6F6 (active)    APP_CPU: PC=0x400D10D8

    Breakpoint 2, blink_task (pvParameter=0x0) at /home/user-name/esp/blink/main/./blink.c:33
    33          gpio_set_level(BLINK_GPIO, 0);
    (gdb) c
    Continuing.
    Target halted. PRO_CPU: PC=0x400DB6F8 (active)    APP_CPU: PC=0x400D10D8
    Target halted. PRO_CPU: PC=0x400DB704 (active)    APP_CPU: PC=0x400D10D8

    Breakpoint 3, blink_task (pvParameter=0x0"
") at /home/user-name/esp/blink/main/./blink.c:36
    36          gpio_set_level(BLINK_GPIO, 1);
    (gdb)

You will be also able to see that LED is changing the state only if you resume program execution by entering ``c``.

To examine how many breakpoints are set and where, use command ``info break``::

    (gdb) info break
    Num     Type           Disp Enb Address    What
    2       breakpoint     keep y   0x400db6f6 in blink_task at /home/user-name/esp/blink/main/./blink.c:33
        breakp"
"oint already hit 1 time
    3       breakpoint     keep y   0x400db704 in blink_task at /home/user-name/esp/blink/main/./blink.c:36
        breakpoint already hit 1 time
    (gdb)

Please note that breakpoint numbers (listed under ``Num``) start with ``2``. This is because first breakpoint has been already established at function ``app_main()`` by running command ``thb app_main`` on debugger launch. As it was a temporary breakpoint, it has been automatically deleted and now is not listed anymore"
".

To remove breakpoints enter ``delete N`` command (in short ``d N``), where ``N`` is the breakpoint number::

    (gdb) delete 1
    No breakpoint number 1.
    (gdb) delete 2
    (gdb)

Read more about breakpoints under :ref:`jtag-debugging-tip-breakpoints` and :ref:`jtag-debugging-tip-where-breakpoints`


.. _jtag-debugging-examples-command-line-03:

Halting and Resuming the Application


When debugging, you may resume application and enter code waiting for some event or staying in infinite "
"loop without any break points defined. In such case, to go back to debugging mode, you can break program execution manually by entering Ctrl+C.

To check it delete all breakpoints and enter ``c`` to resume application. Then enter Ctrl+C. Application will be halted at some random point and LED will stop blinking. Debugger will print the following::

    (gdb) c
    Continuing.
    ^CTarget halted. PRO_CPU: PC=0x400D0C00             APP_CPU: PC=0x400D0C00 (active)
    [New Thread 1073433352]

    "
"Program received signal SIGINT, Interrupt.
    [Switching to Thread 1073413512]
    0x400d0c00 in esp_vApplicationIdleHook () at /home/user-name/esp/esp-idf/components/{IDF_TARGET_PATH_NAME}/./freertos_hooks.c:52
    52          asm(""waiti 0"");
    (gdb)

In particular case above, the application has been halted in line 52 of code in file ``freertos_hooks.c``. Now you can resume it again by enter ``c`` or do some debugging as discussed below.


.. _jtag-debugging-examples-command-line-04:

Stepp"
"ing Through the Code


It is also possible to step through the code using ``step`` and ``next`` commands (in short ``s`` and ``n``). The difference is that ``step`` is entering inside subroutines calls, while ``next`` steps over the call, treating it as a single source line.

To demonstrate this functionality, using command ``break`` and ``delete`` discussed in previous paragraph, make sure that you have only one breakpoint defined at line ``36`` of ``blink.c``::

    (gdb) info break
    Num   "
"  Type           Disp Enb Address    What
    3       breakpoint     keep y   0x400db704 in blink_task at /home/user-name/esp/blink/main/./blink.c:36
        breakpoint already hit 1 time
    (gdb)

Resume program by entering ``c`` and let it halt::

    (gdb) c
    Continuing.
    Target halted. PRO_CPU: PC=0x400DB754 (active)    APP_CPU: PC=0x400D1128

    Breakpoint 3, blink_task (pvParameter=0x0) at /home/user-name/esp/blink/main/./blink.c:36
    36          gpio_set_level(BLINK_GPIO, 1);
  "
"  (gdb)

Then enter ``n`` couple of times to see how debugger is stepping one program line at a time::

    (gdb) n
    Target halted. PRO_CPU: PC=0x400DB756 (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DB758 (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DC04C (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DB75B (active)    APP_CPU: PC=0x400D1128
    37          vTaskDelay(1000 / portTICK_PERIOD_MS);
    (gdb) n
    Targe"
"t halted. PRO_CPU: PC=0x400DB75E (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400846FC (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DB761 (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DB746 (active)    APP_CPU: PC=0x400D1128
    33          gpio_set_level(BLINK_GPIO, 0);
    (gdb)

If you enter ``s`` instead, then debugger will step inside subroutine calls::

    (gdb) s
    Target halted. PRO_CPU: PC=0x400DB748 (active)  "
"  APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DB74B (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DC04C (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DC04F (active)    APP_CPU: PC=0x400D1128
    gpio_set_level (gpio_num=GPIO_NUM_4, level=0) at /home/user-name/esp/esp-idf/components/esp_driver_gpio/src/gpio.c:183
    183     GPIO_CHECK(GPIO_IS_VALID_OUTPUT_GPIO(gpio_num), ""GPIO output gpio_num error"", ESP_ERR_INVALID_ARG);
    (gdb)"
"

In this particular case debugger stepped inside ``gpio_set_level(BLINK_GPIO, 0)`` and effectively moved to ``gpio.c`` driver code.

See :ref:`jtag-debugging-tip-why-next-works-as-step` for potential limitation of using ``next`` command.


.. _jtag-debugging-examples-command-line-05:

Checking and Setting Memory


Displaying the contents of memory is done with command ``x``. With additional parameters you may vary the format and count of memory locations displayed. Run ``help x`` to see more de"
"tails. Companion command to ``x`` is ``set`` that let you write values to the memory.

We will demonstrate how ``x`` and ``set`` work by reading from and writing to the memory location ``0x3FF44004`` labeled as ``GPIO_OUT_REG`` used to set and clear individual GPIO's.

For more information, see *{IDF_TARGET_NAME} Technical Reference Manual* > *IO MUX and GPIO Matrix (GPIO, IO_MUX)* [`PDF `__].

Being in the same ``blink.c`` project as before, set two breakpoints right after ``gpio_set_level`` in"
"struction. Enter two times ``c`` to get to the break point followed by ``x /1wx 0x3FF44004`` to display contents of ``GPIO_OUT_REG`` memory location::

    (gdb) c
    Continuing.
    Target halted. PRO_CPU: PC=0x400DB75E (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DB74E (active)    APP_CPU: PC=0x400D1128

    Breakpoint 2, blink_task (pvParameter=0x0) at /home/user-name/esp/blink/main/./blink.c:34
    34          vTaskDelay(1000 / portTICK_PERIOD_MS);
    (gdb) x /1wx"
" 0x3FF44004
    0x3ff44004: 0x00000000
    (gdb) c
    Continuing.
    Target halted. PRO_CPU: PC=0x400DB751 (active)    APP_CPU: PC=0x400D1128
    Target halted. PRO_CPU: PC=0x400DB75B (active)    APP_CPU: PC=0x400D1128

    Breakpoint 3, blink_task (pvParameter=0x0) at /home/user-name/esp/blink/main/./blink.c:37
    37          vTaskDelay(1000 / portTICK_PERIOD_MS);
    (gdb) x /1wx 0x3FF44004
    0x3ff44004: 0x00000010
    (gdb)

If your are blinking LED connected to GPIO4, then you should se"
"e fourth bit being flipped each time the LED changes the state::

    0x3ff44004: 0x00000000
    ...
    0x3ff44004: 0x00000010

Now, when the LED is off, that corresponds to ``0x3ff44004: 0x00000000`` being displayed, try using ``set`` command to set this bit by writting ``0x00000010`` to the same memory location::

    (gdb) x /1wx 0x3FF44004
    0x3ff44004: 0x00000000
    (gdb) set {unsigned int}0x3FF44004=0x000010

You should see the LED to turn on immediately after entering ``set {unsigned "
"int}0x3FF44004=0x000010`` command.


.. _jtag-debugging-examples-command-line-06:

Watching and Setting Program Variables


A common debugging tasks is checking the value of a program variable as the program runs. To be able to demonstrate this functionality, update file ``blink.c`` by adding a declaration of a global variable ``int i`` above definition of function ``blink_task``. Then add ``i++`` inside ``while(1)`` of this function to get ``i`` incremented on each blink.

Exit debugger, so it "
"is not confused with new code, build and flash the code to the ESP and restart debugger. There is no need to restart OpenOCD.

Once application is halted, enter the command ``watch i``::

    (gdb) watch i
    Hardware watchpoint 2: i
    (gdb)

This will insert so called ""watchpoint"" in each place of code where variable ``i`` is being modified. Now enter ``continue`` to resume the application and observe it being halted::

    (gdb) c
    Continuing.
    Target halted. PRO_CPU: PC=0x400DB751 (a"
"ctive)    APP_CPU: PC=0x400D0811
    [New Thread 1073432196]

    Program received signal SIGTRAP, Trace/breakpoint trap.
    [Switching to Thread 1073432196]
    0x400db751 in blink_task (pvParameter=0x0) at /home/user-name/esp/blink/main/./blink.c:33
    33          i++;
    (gdb)

Resume application couple more times so ``i`` gets incremented. Now you can enter ``print i`` (in short ``p i``) to check the current value of ``i``::

    (gdb) p i
    $1 = 3
    (gdb)

To modify the value of ``i`"
"` use ``set`` command as below (you can then print it out to check if it has been indeed changed)::

    (gdb) set var i = 0
    (gdb) p i
    $3 = 0
    (gdb)

You may have up to two watchpoints, see :ref:`jtag-debugging-tip-breakpoints`.


.. _jtag-debugging-examples-command-line-07:

Setting Conditional Breakpoints


Here comes more interesting part. You may set a breakpoint to halt the program execution, if certain condition is satisfied. Delete existing breakpoints and try this::

    (gdb)"
" break blink.c:34 if (i == 2)
    Breakpoint 3 at 0x400db753: file /home/user-name/esp/blink/main/./blink.c, line 34.
    (gdb)

Above command sets conditional breakpoint to halt program execution in line ``34`` of ``blink.c`` if ``i == 2``.

If current value of ``i`` is less than ``2`` and program is resumed, it will blink LED in a loop until condition ``i == 2`` gets true and then finally halt::

    (gdb) set var i = 0
    (gdb) c
    Continuing.
    Target halted. PRO_CPU: PC=0x400DB755 (act"
"ive)    APP_CPU: PC=0x400D112C
    Target halted. PRO_CPU: PC=0x400DB753 (active)    APP_CPU: PC=0x400D112C
    Target halted. PRO_CPU: PC=0x400DB755 (active)    APP_CPU: PC=0x400D112C
    Target halted. PRO_CPU: PC=0x400DB753 (active)    APP_CPU: PC=0x400D112C

    Breakpoint 3, blink_task (pvParameter=0x0) at /home/user-name/esp/blink/main/./blink.c:34
    34          gpio_set_level(BLINK_GPIO, 0);
    (gdb)


.. _jtag-debugging-examples-command-line-08:

Debugging FreeRTOS Objects


This part"
" might be interesting when you are debugging FreeRTOS tasks interactions.

Users that need to use the FreeRTOS task interactions can use the GDB ``freertos`` command. The ``freertos`` command is not native to GDB and comes from the `freertos-gdb `_ Python extension module. The ``freertos`` command contains a series of sub-commands as demonstrated in the code snippet::

    (gdb) freertos
    ""freertos"" must be followed by the name of a subcommand.
    List of freertos subcommands:

    freertos "
"queue --  Generate a print out of the current queues info.
    freertos semaphore --  Generate a print out of the current semaphores info.
    freertos task --  Generate a print out of the current tasks and their states.
    freertos timer --  Generate a print out of the current timers info.

For a more detailed description of this extension, please refer to https://pypi.org/project/freertos-gdb.

.. note::

    The freertos-gdb Python module is included as a Python package requirement by ESP-ID"
"F, thus should be automatically installed (see :ref:`get-started-set-up-tools` for more details).

    The FreeRTOS extension automatically loads in case GDB is executed with command via ``idf.py gdb``. Otherwise, the module could be enabled via the ``python import freertos_gdb`` command inside GDB.

    Users only need to have Python 3.6 (or above) that contains a Python shared library.


Obtaining Help on Commands


Commands presented so for should provide are very basis and intended to let yo"
"u quickly get started with JTAG debugging. Check help what are the other commands at you disposal. To obtain help on syntax and functionality of particular command, being at ``(gdb)`` prompt type ``help`` and command name::

    (gdb) help next
    Step program, proceeding through subroutine calls.
    Usage: next [N]
    Unlike ""step"", if the current source line calls a subroutine,
    this command does not enter the subroutine, but instead steps over
    the call, in effect treating it as a si"
"ngle source line.
    (gdb)

By typing just ``help``, you will get top level list of command classes, to aid you drilling down to more details. Optionally refer to available GDB cheat sheets, for instance https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf. Good to have as a reference (even if not all commands are applicable in an embedded environment).


Ending Debugger Session


To quit debugger enter ``q``::

    (gdb) q
    A debugging session is active.

        Inferior 1 [Remote target] wi"
"ll be detached.

    Quit anyway? (y or n) y
    Detaching from program: /home/user-name/esp/blink/build/blink.elf, Remote target
    Ending remote debugging.
    user-name@computer-name:~/esp/blink$
"
"Tips and Quirks




This section provides collection of all tips and quirks referred to from various parts of this guide.

.. _jtag-debugging-tip-breakpoints:

Breakpoints and Watchpoints Available


{IDF_TARGET_NAME} debugger supports {IDF_TARGET_SOC_CPU_BREAKPOINTS_NUM} hardware implemented breakpoints and 64 software ones. Hardware breakpoints are implemented by {IDF_TARGET_NAME} chip's logic and can be set anywhere in the code: either in flash or IRAM program's regions. Additionally there ar"
"e 2 types of software breakpoints implemented by OpenOCD: flash (up to 32) and IRAM (up to 32) breakpoints. Currently GDB can not set software breakpoints in flash. So until this limitation is removed those breakpoints have to be emulated by OpenOCD as hardware ones (see :ref:`below ` for details). {IDF_TARGET_NAME} also supports {IDF_TARGET_SOC_CPU_WATCHPOINTS_NUM} watchpoints, so {IDF_TARGET_SOC_CPU_WATCHPOINTS_NUM} variables can be watched for change or read by the GDB command ``watch myVaria"
"ble``. Note that menuconfig option :ref:`CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK` uses the last watchpoint and will not provide expected results, if you also try to use it within OpenOCD/GDB. See menuconfig's help for detailed description.


.. _jtag-debugging-tip-where-breakpoints:

What Else Should I Know About Breakpoints?


Emulating part of hardware breakpoints using software flash ones means that the GDB command ``hb myFunction`` which is invoked for function in flash will use pure hardwar"
"e breakpoint if it is avalable otherwise one of the 32 software flash breakpoints is used. The same rule applies to ``b myFunction``-like commands. In this case GDB will decide what type of breakpoint to set itself. If ``myFunction`` is resided in writable region (IRAM) software IRAM breakpoint will be used otherwise hardware or software flash breakpoint is used as it is done for ``hb`` command.


.. _jtag-debugging-tip-flash-mappings:

Flash Mappings vs SW Flash Breakpoints


In order to set/cl"
"ear software breakpoints in flash, OpenOCD needs to know their flash addresses. To accomplish conversion from the {IDF_TARGET_NAME} address space to the flash one, OpenOCD uses mappings of program's code regions resided in flash. Those mappings are kept in the image header which is prepended to program binary data (code and data segments) and is specific to every application image written to the flash. So to support software flash breakpoints OpenOCD should know where application image under deb"
"ugging is resided in the flash. By default OpenOCD reads partition table at 0x8000 and uses mappings from the first found application image, but there can be the cases when it will not work, e.g., partition table is not at standard flash location or even there can be multiple images: one factory and two OTA and you may want to debbug any of them. To cover all possible debugging scenarios OpenOCD supports special command which can be used to set arbitrary location of application image to debug. T"
"he command has the following format:

``esp appimage_offset ``

Offset should be in hex format. To reset to the default behaviour you can specify ``-1`` as offset.

.. note::

    Since GDB requests memory map from OpenOCD only once when connecting to it, this command should be specified in one of the TCL configuration files, or passed to OpenOCD via its command line. In the latter case command line should look like below:

    .. highlight:: bash

    .. include:: {IDF_TARGET_PATH_NAME}.inc
   "
"     :start-after: run-openocd-appimage-offset
        :end-before: ---

    Another option is to execute that command via OpenOCD telnet session and then connect GDB, but it seems to be less handy.

.. _jtag-debugging-tip-why-next-works-as-step:

Why Stepping with ""next"" Does Not Bypass Subroutine Calls?


When stepping through the code with ``next`` command, GDB is internally setting a breakpoint ahead in the code to bypass the subroutine calls. If all {IDF_TARGET_SOC_CPU_BREAKPOINTS_NUM} brea"
"kpoints are already set, this functionality will not work. If this is the case, delete breakpoints to have one ""spare"". With all breakpoints already used, stepping through the code with ``next`` command will work as like with ``step`` command and debugger will step inside subroutine calls.


.. _jtag-debugging-tip-code-options:

Support Options for OpenOCD at Compile Time


ESP-IDF has some support options for OpenOCD debugging which can be set at compile time:

Please see the :ref:`project conf"
"iguration menu ` menu for more details on setting compile-time options.

.. _jtag-debugging-tip-freertos-support:

FreeRTOS Support


OpenOCD has explicit support for the ESP-IDF FreeRTOS. GDB can see FreeRTOS tasks as threads. Viewing them all can be done using the GDB ``i threads`` command, changing to a certain task is done with ``thread n``, with ``n`` being the number of the thread. FreeRTOS detection can be disabled in target's configuration. For more details see :ref:`jtag-debugging-tip-o"
"penocd-configure-target`.

GDB has a Python extension for FreeRTOS support. ESP-IDF automatically loads this module into GDB with the ``idf.py gdb`` command when the system requirements are met. See more details in :ref:`jtag-debugging-examples-command-line-08`.

.. only:: esp32

    .. _jtag-debugging-tip-code-flash-voltage:

    Why to Set SPI Flash Voltage in OpenOCD Configuration?
    

    The MTDI pin of ESP32, being among four pins used for JTAG communication, is also one of ESP32's boots"
"trapping pins. On power up ESP32 is sampling binary level on MTDI to set it's internal voltage regulator used to supply power to external SPI flash chip. If binary level on MDTI pin on power up is low, the voltage regulator is set to deliver 3.3 V, if it is high, then the voltage is set to 1.8 V. The MTDI pin should have a pull-up or may rely on internal weak pull down resistor (see `ESP32 Series Datasheet `_ for details), depending on the type of SPI chip used. Once JTAG is connected, it overri"
"des the pull-up or pull-down resistor that is supposed to do the bootstrapping.

    To handle this issue OpenOCD's board configuration file (e.g. ``board\esp32-wrover-kit-3.3v.cfg`` for ESP-WROVER-KIT board) provides ``ESP32_FLASH_VOLTAGE`` parameter to set the idle state of the ``TDO`` line to a specified binary level, therefore reducing the chance of a bad bootup of application due to incorrect flash voltage.

    Check specification of ESP32 module connected to JTAG, what is the power supply"
" voltage of SPI flash chip. Then set ``ESP32_FLASH_VOLTAGE`` accordingly. Most WROOM modules use 3.3 V flash. WROVER earlier than ESP32-WROVER-B use 1.8 V flash, while ESP32-WROVER-B and -E modules use 3.3 V flash.

    .. _jtag-debugging-tip-optimize-jtag-speed:

.. only:: not esp32

    .. _jtag-debugging-tip-optimize-jtag-speed:

Optimize JTAG Speed


In order to achieve higher data rates and minimize number of dropped packets it is recommended to optimize setting of JTAG clock frequency, so "
"it is at maximum and still provides stable operation of JTAG. To do so use the following tips.


.. _jtag-debugging-tip-debugger-startup-commands:

What Is the Meaning of Debugger's Startup Commands?


On startup, debugger is issuing sequence of commands to reset the chip and halt it at specific line of code. This sequence (shown below) is user defined to pick up at most convenient/appropriate line and start debugging.


.. _jtag-debugging-tip-openocd-configure-target:

Configuration of OpenOCD "
"for Specific Target


There are several kinds of OpenOCD configuration files (``*.cfg``). All configuration files are located in subdirectories of ``share/openocd/scripts`` directory of OpenOCD distribution (or ``tcl/scripts`` directory of the source repository). For the purposes of this guide, the most important ones are ``board``, ``interface`` and ``target``.

The following configuration files are available for {IDF_TARGET_NAME}:

.. include:: {IDF_TARGET_PATH_NAME}.inc
    :start-after: open"
"ocd-cfg-files
    :end-before: ---


If you are using one of the boards which have a pre-defined configuration file, you only need to pass one ``-f`` argument to OpenOCD, specifying that file.

If you are using a board not listed here, you need to specify both the interface configuration file and target configuration file.

Custom Configuration Files
""""""""""""""""""""""""""""""""""""""""""""""""""""

OpenOCD configuration files are written in TCL, and include a variety of choices for customization and scripting. This "
"can be useful for non-standard debugging situations. Please refer to `OpenOCD Manual`_ for the TCL scripting reference.

.. _jtag-debugging-tip-openocd-config-vars:

OpenOCD Configuration Variables
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The following variables can be optionally set before including the ESP-specific target configuration file. This can be done either in a custom configuration file, or from the command line.

The syntax for setting a variable in TCL is:

.. code-block:: tcl

    set VARI"
"ABLE_NAME value

To set a variable from the command line (replace the name of .cfg file with the correct file for your board):

.. code-block:: bash

    openocd -c 'set VARIABLE_NAME value' -f board/esp-xxxxx-kit.cfg

It is important to set the variable before including the ESP-specific configuration file, otherwise the variable will not have effect. You can set multiple variables by repeating the ``-c`` option.

.. list-table:: Common ESP-related OpenOCD variables
    :widths: 25 75
    :heade"
"r-rows: 1
      - Description
      - Set to ``none`` to disable RTOS support. In this case, thread list will not be available in GDB. Can be useful when debugging FreeRTOS itself, and stepping through the scheduler code.
      - Set to ``0`` to disable Flash breakpoints support.
      - Set to the path (on the host) which will be the default directory for semihosting functions.

.. include:: {IDF_TARGET_PATH_NAME}.inc
    :start-after: openocd-target-specific-config-vars
    :end-before: ---

."
". _jtag-debugging-tip-reset-by-debugger:

How Debugger Resets {IDF_TARGET_NAME}?


The board can be reset by entering ``mon reset`` or ``mon reset halt`` into GDB.


.. _jtag-debugging-tip-jtag-pins-reconfigured:

Can JTAG Pins Be Used for Other Purposes?


.. only:: SOC_USB_SERIAL_JTAG_SUPPORTED

    {IDF_TARGET_NAME} contains a USB Serial/JTAG Controller which can be used for debugging. By default, {IDF_TARGET_NAME} JTAG interface is connected to the built-in USB SERIAL/JTAG peripheral. For de"
"tails, please refer to :doc:`Configure {IDF_TARGET_NAME} built-in JTAG Interface `.

    When you use USB Serial/JTAG Controller for debugging, |jtag-gpio-list| can be used for other purposes.

    However, if you switch the USB JTAG interface to the GPIOs by burning eFuses, |jtag-gpio-list| can be used for JTAG debugging. When they perform this function, they cannot be used for other purposes.

Operation of JTAG may be disturbed, if some other hardware is connected to JTAG pins besides {IDF_TAR"
"GET_NAME} module and JTAG adapter. {IDF_TARGET_NAME} JTAG is using the following pins:

.. include:: {IDF_TARGET_PATH_NAME}.inc
    :start-after: jtag-pins
    :end-before: ---

JTAG communication will likely fail, if configuration of JTAG pins is changed by a user application. If OpenOCD initializes correctly (detects all the CPU cores in the SOC), but loses sync and spews out a lot of DTR/DIR errors when the program is running, it is likely that the application reconfigures the JTAG pins to so"
"mething else, or the user forgot to connect Vtar to a JTAG adapter that requires it.

.. only:: esp32

    .. highlight:: none

    Below is an excerpt from series of errors on the dual-core {IDF_TARGET_NAME} reported by GDB after the application stepped into the code that reconfigured MTDO pin to be an input::

        cpu0: xtensa_resume (line 431): DSR (FFFFFFFF) indicates target still busy!
        cpu0: xtensa_resume (line 431): DSR (FFFFFFFF) indicates DIR instruction generated an exceptio"
"n!
        cpu0: xtensa_resume (line 431): DSR (FFFFFFFF) indicates DIR instruction generated an overrun!
        cpu1: xtensa_resume (line 431): DSR (FFFFFFFF) indicates target still busy!
        cpu1: xtensa_resume (line 431): DSR (FFFFFFFF) indicates DIR instruction generated an exception!
        cpu1: xtensa_resume (line 431): DSR (FFFFFFFF) indicates DIR instruction generated an overrun!

.. _jtag-debugging-security-features:

JTAG with Flash Encryption or Secure Boot


By default, enabli"
"ng Flash Encryption and/or Secure Boot will disable JTAG debugging. On first boot, the bootloader will burn an eFuse bit to permanently disable JTAG at the same time it enables the other features.

.. only:: SOC_HMAC_SUPPORTED

    Please note that once JTAG is permanently disabled, it cannot be re-enabled for JTAG access. However, we do have the option of disabling JTAG softly. For more details on soft disabling and re-enabling soft-disabled JTAG, please refer to the :ref:`hmac_for_enabling_jta"
"g`.

The project configuration option :ref:`CONFIG_SECURE_BOOT_ALLOW_JTAG` will keep JTAG enabled at this time, removing all physical security but allowing debugging. (Although the name suggests Secure Boot, this option can be applied even when only Flash Encryption is enabled).

However, OpenOCD may attempt to automatically read and write the flash in order to set :ref:`software breakpoints `. This has two problems:

- Software breakpoints are incompatible with Flash Encryption, OpenOCD current"
"ly has no support for encrypting or decrypting flash contents.
- If Secure Boot is enabled, setting a software breakpoint will change the digest of a signed app and make the signature invalid. This means if a software breakpoint is set and then a reset occurs, the signature verification will fail on boot.

To disable software breakpoints while using JTAG, add an extra argument ``-c 'set ESP_FLASH_SIZE 0'`` to the start of the OpenOCD command line, see :ref:`jtag-debugging-tip-openocd-config-vars"
"`.

.. note::

   For the same reason, the ESP-IDF app may fail bootloader verification of app signatures, when this option is enabled and a software breakpoint is set.

.. only:: esp32

    JTAG and ESP32-WROOM-32 AT Firmware Compatibility Issue
    

    The ESP32-WROOM series of modules come pre-flashed with AT firmware. This firmware configures the pins GPIO12 to GPIO15 as SPI slave interface, which makes using JTAG impossible.

    To make JTAG available, build new firmware that is not usin"
"g pins GPIO12 to GPIO15 dedicated to JTAG communication. After that, flash the firmware onto your module. See also :ref:`jtag-debugging-tip-jtag-pins-reconfigured`.

.. _jtag-debugging-tip-reporting-issues:

Reporting Issues with OpenOCD/GDB


In case you encounter a problem with OpenOCD or GDB programs itself and do not find a solution searching available resources on the web, open an issue in the OpenOCD issue tracker under https://github.com/espressif/openocd-esp32/issues.

    a. JTAG adapte"
"r type, and the chip/module being debugged.
    b. Release of ESP-IDF used to compile and load application that is being debugged.
    c. Details of OS used for debugging.
    d. Is OS running natively on a PC or on a virtual machine?

.. highlight:: bash

    OpenOCD:

    .. include:: {IDF_TARGET_PATH_NAME}.inc
        :start-after: run-openocd-d3
        :end-before: ---

    Logging to a file this way will prevent information displayed on the terminal. This may be a good thing taken amount o"
"f information provided, when increased debug level ``-d3`` is set. If you still like to see the log on the screen, then use another command instead:

    .. include:: {IDF_TARGET_PATH_NAME}.inc
        :start-after: run-openocd-d3-tee
        :end-before: ---

    Debugger:

    .. include:: {IDF_TARGET_PATH_NAME}.inc
        :start-after: run-gdb-remotelog
        :end-before: ---

    Optionally add command ``remotelogfile gdb_log.txt`` to the ``gdbinit`` file.


.. _OpenOCD Manual: https://op"
"enocd.org/doc/html/index.html
"
"
Building OpenOCD from Sources for Windows




.. note::

    This document outlines how to build a binary of OpenOCD from its source files instead of downloading the pre-built binary. For a quick setup, users can download a pre-built binary of OpenOCD from `Espressif GitHub `_ instead of compiling it themselves (see :ref:`jtag-debugging-setup-openocd` for more details).

.. note::

    All code snippets in this document are assumed to be running in an MSYS2 shell with the MINGW32 subsystem.


I"
"nstall Dependencies


Install packages that are required to compile OpenOCD:

.. code-block:: bash

    pacman -S --noconfirm --needed autoconf automake git make \
    mingw-w64-i686-gcc \
    mingw-w64-i686-toolchain \
    mingw-w64-i686-libtool \
    mingw-w64-i686-pkg-config \
    mingw-w64-cross-winpthreads-git \
    p7zip


Download Sources of OpenOCD


The sources for the {IDF_TARGET_NAME}-enabled variant of OpenOCD are available from Espressif's GitHub under https://github.com/espressif/o"
"penocd-esp32. These source files can be pulled via Git using the following commands:

.. code-block:: bash

    cd ~/esp
    git clone --recursive https://github.com/espressif/openocd-esp32.git

The clone of sources should be now saved in ``~/esp/openocd-esp32`` directory.


Downloading libusb


The libusb library is also required when building OpenOCD. The following commands will download a particular release of libusb and uncompress it to the current directory.

.. code-block:: bash

    wget "
"https://github.com/libusb/libusb/releases/download/v1.0.22/libusb-1.0.22.7z
    7z x -olibusb ./libusb-1.0.22.7z

We now need to export the following variables such that the libusb library gets linked into the OpenOCD build.

.. code-block:: bash

    export CPPFLAGS=""$CPPFLAGS -I${PWD}/libusb/include/libusb-1.0""
    export LDFLAGS=""$LDFLAGS -L${PWD}/libusb/MinGW32/.libs/dll""


Build OpenOCD


The following commands will configure OpenOCD then build it.

.. code-block:: bash

    cd ~/esp/openoc"
"d-esp32
    export CPPFLAGS=""$CPPFLAGS -D__USE_MINGW_ANSI_STDIO=1 -Wno-error""; export CFLAGS=""$CFLAGS -Wno-error""
    ./bootstrap
    ./configure --disable-doxygen-pdf --enable-ftdi --enable-jlink --enable-ulink --build=i686-w64-mingw32 --host=i686-w64-mingw32
    make
    cp ../libusb/MinGW32/dll/libusb-1.0.dll ./src
    cp /opt/i686-w64-mingw32/bin/libwinpthread-1.dll ./src


Once the build is completed, the OpenOCD binary will be placed in ``~/esp/openocd-esp32/src/``.

You can then optionall"
"y call ``make install``. This will copy the OpenOCD binary to a user specified location.

- This location can be specified when OpenOCD is configured, or by setting ``export DESTDIR=""/custom/install/dir""`` before calling ``make install``.
- If you have an existing OpenOCD (from e.g., another development platform), you may want to skip this call as your existing OpenOCD may get overwritten.

.. note::

Once ``make`` process is successfully completed, the executable of OpenOCD will be saved in ``~"
"/esp/openocd-esp32/src`` directory.


Full Listing


For greater convenience, all of commands called throughout the OpenOCD build process have been listed in the code snippet below. Users can copy this code snippet into a shell script then execute it:

.. code-block:: bash

    pacman -S --noconfirm --needed autoconf automake git make mingw-w64-i686-gcc mingw-w64-i686-toolchain mingw-w64-i686-libtool mingw-w64-i686-pkg-config mingw-w64-cross-winpthreads-git p7zip
    cd ~/esp
    git clone --rec"
"ursive https://github.com/espressif/openocd-esp32.git

    wget https://github.com/libusb/libusb/releases/download/v1.0.22/libusb-1.0.22.7z
    7z x -olibusb ./libusb-1.0.22.7z
    export CPPFLAGS=""$CPPFLAGS -I${PWD}/libusb/include/libusb-1.0""; export LDFLAGS=""$LDFLAGS -L${PWD}/libusb/MinGW32/.libs/dll""

    export CPPFLAGS=""$CPPFLAGS -D__USE_MINGW_ANSI_STDIO=1 -Wno-error""; export CFLAGS=""$CFLAGS -Wno-error""
    cd ~/esp/openocd-esp32
    ./bootstrap
    ./configure --disable-doxygen-pdf --enabl"
"e-ftdi --enable-jlink --enable-ulink --build=i686-w64-mingw32 --host=i686-w64-mingw32
    make
    cp ../libusb/MinGW32/dll/libusb-1.0.dll ./src
    cp /opt/i686-w64-mingw32/bin/libwinpthread-1.dll ./src

    # # optional
    # export DESTDIR=""$PWD""
    # make install
    # cp ./src/libusb-1.0.dll $DESTDIR/mingw32/bin
    # cp ./src/libwinpthread-1.dll $DESTDIR/mingw32/bin


Next Steps


To carry on with debugging environment setup, proceed to section :ref:`jtag-debugging-configuring-target`.
"
".. include:: {IDF_TARGET_PATH_NAME}.inc
   :start-after: devkit-defs
   :end-before: ---


Configure {IDF_TARGET_NAME} Built-in JTAG Interface


{IDF_TARGET_JTAG_PIN_Dneg:default=""Not Updated!"", esp32c3=""GPIO18"", esp32c6=""GPIO12"", esp32s3=""GPIO19"", esp32h2=""GPIO26""}
{IDF_TARGET_JTAG_PIN_Dpos:default=""Not Updated!"", esp32c3=""GPIO19"", esp32c6=""GPIO13"", esp32s3=""GPIO20"", esp32h2=""GPIO27""}

{IDF_TARGET_NAME} has a built-in JTAG circuitry and can be debugged without any additional chip. Only an USB c"
"able connected to the D+/D- pins is necessary. The necessary connections are shown in the following section.

Configure Hardware


.. list-table:: {IDF_TARGET_NAME} pins and USB signals
    :widths: 25 75
    :header-rows: 1
      - USB Signal
      - D-
      - D+
      - V_BUS
      - Ground

Please verify that the {IDF_TARGET_NAME} pins used for USB communication are not connected to some other HW that may disturb the JTAG operation.

Configure USB Drivers


JTAG communication should work on "
"all supported platforms. Windows users might get `LIBUSB_ERROR_NOT_FOUND` errors. Please use version 2.8 (or newer) of the :ref:`get-started-windows-tools-installer` and select the driver ""Espressif - WinUSB support for JTAG (ESP32-C3/S3)"" in order to resolve this issue. If you do not want to re-run the installer then the same can be achieved with `idf-env `_ by running the following command from PowerShell::

    Invoke-WebRequest 'https://dl.espressif.com/dl/idf-env/idf-env.exe' -OutFile .\idf"
"-env.exe; .\idf-env.exe driver install --espressif

On Linux adding OpenOCD udev rules is required and is done by placing the following `udev rules file `_ in the ``/etc/udev/rules.d`` folder.
"
"
Building OpenOCD from Sources for MacOS




The following instructions are alternative to downloading binary OpenOCD from `Espressif GitHub `_. To quickly setup the binary OpenOCD, instead of compiling it yourself, backup and proceed to section :ref:`jtag-debugging-setup-openocd`.

.. highlight:: bash

Download Sources of OpenOCD


The sources for the {IDF_TARGET_NAME}-enabled variant of OpenOCD are available from Espressif GitHub under https://github.com/espressif/openocd-esp32. To download th"
"e sources, use the following commands::

    cd ~/esp
    git clone --recursive https://github.com/espressif/openocd-esp32.git

The clone of sources should be now saved in ``~/esp/openocd-esp32`` directory.


Install Dependencies


Install packages that are required to compile OpenOCD using Homebrew::

    brew install automake libtool libusb wget gcc@4.9 pkg-config


Build OpenOCD


Proceed with configuring and building OpenOCD::

    cd ~/esp/openocd-esp32
    ./bootstrap
    ./configure
    m"
"ake

Optionally you can add ``sudo make install`` step at the end. Skip it, if you have an existing OpenOCD (from e.g., another development platform), as it may get overwritten.

.. note::

        brew install texinfo
        export PATH=/usr/local/opt/texinfo/bin:$PATH

Once ``make`` process is successfully completed, the executable of OpenOCD will be saved in ``~/esp/openocd-esp32/src/openocd`` directory.


Next Steps


To carry on with debugging environment setup, proceed to section :ref:`jt"
"ag-debugging-configuring-target`.
"
"Configure Other JTAG Interfaces




{IDF_TARGET_JTAG_SEL_EFUSE:default=""Not Updated!"", esp32s3=""STRAP_JTAG_SEL"", esp32c6=""JTAG_SEL_ENABLE"", esp32h2=""JTAG_SEL_ENABLE""}

For guidance about which JTAG interface to select when using OpenOCD with {IDF_TARGET_NAME}, refer to the section :ref:`jtag-debugging-selecting-jtag-adapter`. Then follow the configuration steps below to get it working.

.. only:: SOC_USB_SERIAL_JTAG_SUPPORTED

    Configure eFuses
    

    By default, {IDF_TARGET_NAME} JTAG int"
"erface is connected to the :doc:`built-in USB_SERIAL_JTAG peripheral `. To use an external JTAG adapter instead, you need to switch the JTAG interface to the GPIO pins. This can be done by burning eFuses using ``espefuse.py`` tool.

    .. only:: esp32c3

        Burning ``DIS_USB_JTAG`` eFuse will permanently disable the connection between USB_SERIAL_JTAG and the JTAG port of the {IDF_TARGET_NAME}. JTAG interface can then be connected to |jtag-gpio-list|. Note that USB CDC functionality of USB_"
"SERIAL_JTAG will still be usable, i.e., flashing and monitoring over USB CDC will still work.

    .. only:: not esp32c3

        - Burning ``DIS_USB_JTAG`` eFuse will permanently disable the connection between USB_SERIAL_JTAG and the JTAG port of the {IDF_TARGET_NAME}. JTAG interface can then be connected to |jtag-gpio-list|. Note that USB CDC functionality of USB_SERIAL_JTAG will still be usable, i.e., flashing and monitoring over USB CDC will still work.
        - Burning ``{IDF_TARGET_JTAG_S"
"EL_EFUSE}`` eFuse will enable selection of JTAG interface by a strapping pin, |jtag-sel-gpio|. If the strapping pin is low when {IDF_TARGET_NAME} is reset, JTAG interface will use |jtag-gpio-list|. If the strapping pin is high, USB_SERIAL_JTAG will be used as the JTAG interface.

    .. warning::
        Burning eFuses is an irreversible operation, so please consider the above option before starting the process.

Configure Hardware


    .. include:: {IDF_TARGET_PATH_NAME}.inc
        :start-aft"
"er: jtag-pins
        :end-before: ---


Configure Drivers


You may need to install driver software to make JTAG work with computer. Refer to documentation of your JTAG adapter for related details.

On Linux, adding OpenOCD udev rules is required and is done by copying the `udev rules file `_ into the ``/etc/udev/rules.d`` directory.

Connect


Connect JTAG interface to the computer. Power on {IDF_TARGET_NAME} and JTAG interface boards. Check if the JTAG interface is visible on the computer.


"
"To carry on with debugging environment setup, proceed to section :ref:`jtag-debugging-run-openocd`.
"
"
Building OpenOCD from Sources for Linux




The following instructions are alternative to downloading binary OpenOCD from `Espressif GitHub `_. To quickly setup the binary OpenOCD, instead of compiling it yourself, backup and proceed to section :ref:`jtag-debugging-setup-openocd`.


.. highlight:: bash

Download Sources of OpenOCD


The sources for the {IDF_TARGET_NAME}-enabled variant of OpenOCD are available from Espressif GitHub under https://github.com/espressif/openocd-esp32. To download t"
"he sources, use the following commands::

    cd ~/esp
    git clone --recursive https://github.com/espressif/openocd-esp32.git

The clone of sources should be now saved in ``~/esp/openocd-esp32`` directory.


Install Dependencies


Install packages that are required to compile OpenOCD.

.. note::

    Install the following packages one by one, check if installation was successful and then proceed to the next package. Resolve reported problems before moving to the next step.

::

    sudo apt-ge"
"t install make
    sudo apt-get install libtool
    sudo apt-get install pkg-config
    sudo apt-get install autoconf
    sudo apt-get install automake
    sudo apt-get install texinfo
    sudo apt-get install libusb-1.0

.. note::


Build OpenOCD


Proceed with configuring and building OpenOCD::

    cd ~/esp/openocd-esp32
    ./bootstrap
    ./configure
    make

Optionally you can add ``sudo make install`` step at the end. Skip it, if you have an existing OpenOCD (from e.g., another developme"
"nt platform), as it may get overwritten.

.. note::

Once ``make`` process is successfully completed, the executable of OpenOCD will be saved in ``~/openocd-esp32/bin`` directory.


Next Steps


To carry on with debugging environment setup, proceed to section :ref:`jtag-debugging-configuring-target`.
"
".. include:: {IDF_TARGET_PATH_NAME}.inc
   :start-after: devkit-defs
   :end-before: ---

Configure |devkit-name| JTAG Interface




All versions of |devkit-name| boards have built-in JTAG functionality. Putting it to work requires setting jumpers or DIP switches to enable JTAG functionality, and configuring USB drivers. Please refer to step by step instructions below.

Configure Hardware


.. include:: {IDF_TARGET_PATH_NAME}.inc
    :start-after: devkit-hw-config
    :end-before: ---

    .. in"
"clude:: {IDF_TARGET_PATH_NAME}.inc
        :start-after: jtag-pins
        :end-before: ---

Configure USB Drivers


Install and configure USB drivers, so OpenOCD is able to communicate with JTAG interface on |devkit-name| board as well as with UART interface used to upload application for flash. Follow steps below specific to your operating system.

.. note:: |devkit-name| uses an FT2232 adapter. The following instructions can also be used for other FT2232 based JTAG adapters.


Windows
"""""""""""""""
"

    .. figure:: ../../../_static/jtag-usb-configuration-zadig.jpg
        :align: center
        :alt: Configuration of JTAG USB driver in Zadig tool
        :figclass: align-center

        Configuration of JTAG USB driver in Zadig tool

.. note::

    Do not change the second device ""Dual RS232-HS (Interface 1)"". It is routed to {IDF_TARGET_NAME}'s serial port (UART) used for upload of application to {IDF_TARGET_NAME}'s flash.

Now |devkit-name|'s JTAG interface should be available to the Op"
"enOCD. To carry on with debugging environment setup, proceed to section :ref:`jtag-debugging-run-openocd`.


Linux
""""""""""

.. highlight:: none

    ::

        user-name@computer-name:~/esp$ ls -l /dev/ttyUSB*
        crw-rw 1 root dialout 188, 0 Jul 10 19:04 /dev/ttyUSB0
        crw-rw 1 root dialout 188, 1 Jul 10 19:04 /dev/ttyUSB1

    ::

        user-name@computer-name:~/esp$ ls -l /dev/ttyUSB*
        crw-rw-r-- 1 root plugdev 188, 0 Jul 10 19:07 /dev/ttyUSB0
        crw-rw-r-- 1 root plugd"
"ev 188, 1 Jul 10 19:07 /dev/ttyUSB1

    If you see similar result and you are a member of ``plugdev`` group, then the set up is complete.

    The ``/dev/ttyUSBn`` interface with lower number is used for JTAG communication. The other interface is routed to {IDF_TARGET_NAME}'s serial port (UART) used for upload of application to {IDF_TARGET_NAME}'s flash.

Now |devkit-name|'s JTAG interface should be available to the OpenOCD. To carry on with debugging environment setup, proceed to section :ref:"
"`jtag-debugging-run-openocd`.


MacOS
""""""""""

On macOS, using FT2232 for JTAG and serial port at the same time needs some additional steps. When the OS loads FTDI serial port driver, it does so for both channels of FT2232 chip. However only one of these channels is used as a serial port, while the other is used as JTAG. If the OS has loaded FTDI serial port driver for the channel used for JTAG, OpenOCD will not be able to connect to the chip. There are two ways around this:

Manually unloading th"
"e driver
.............................

    sudo kextunload -b com.FTDI.driver.FTDIUSBSerialDriver

   In some cases you may need to unload Apple's FTDI driver as well:
        
            CFBundleIdentifier
            com.FTDI.driver.FTDIUSBSerialDriver
            IOClass
            FTDIUSBSerialDriver
            IOProviderClass
            IOUSBInterface
            bConfigurationValue
            1
            bInterfaceNumber
            1
            bcdDevice
            1792
        "
"    idProduct
            24592
            idVendor
            1027

       csrutil enable --without kext

After these steps, serial port and JTAG can be used at the same time.

To carry on with debugging environment setup, proceed to section :ref:`jtag-debugging-run-openocd`.
"
"Minimizing Binary Size




{IDF_TARGET_REDUCED_BY_IRAM: default=""DRAM"", esp32=""IRAM and/or DRAM (depending on sizes)""}

The ESP-IDF build system compiles all source files in the project and ESP-IDF, but only functions and variables that are actually referenced by the program are linked into the final binary. In some cases, it is necessary to reduce the total size of the firmware binary, e.g., in order to fit it into the available flash partition size.

The first step to reducing the total firmwa"
"re binary size is measuring what is causing the size to increase.

.. _idf.py-size:

Measuring Static Sizes


To optimize both the firmware binary size and the memory usage, it is necessary to measure statically-allocated RAM (``data``, ``bss``), code (``text``), and read-only data (``rodata``) in your project.

Using the :ref:`idf.py` sub-commands ``size``, ``size-components``, and ``size-files`` provides a summary of memory used by the project:

.. note::

    It is possible to add ``-DOUTPUT_"
"FORMAT=csv`` or ``-DOUTPUT_FORMAT=json`` to get the output in CSV or JSON format.

Size Summary ``idf.py size``


.. only:: esp32

    .. code-block:: bash

        $ idf.py size
        [...]
        Total sizes:
        Used static DRAM:   10608 bytes ( 170128 remain, 5.9% used)
              .data size:    8464 bytes
              .bss  size:    2144 bytes
        Used static IRAM:   48834 bytes (  82238 remain, 37.3% used)
              .text size:   47807 bytes
           .vectors size:    "
"1027 bytes
        Used Flash size :  117391 bytes
                   .text:   80103 bytes
                 .rodata:   37032 bytes
        Total image size:  174689 bytes (.bin may be padded larger)


.. only:: not esp32

    .. code-block:: bash

        $ idf.py size
        [...]
        Total sizes:
        Used stat D/IRAM:   53743 bytes ( 122385 remain, 30.5% used)
              .data size:    6504 bytes
              .bss  size:    1984 bytes
              .text size:   44228 bytes
      "
"     .vectors size:    1027 bytes
        Used Flash size :  118879 bytes
                   .text:   83467 bytes
                 .rodata:   35156 bytes
        Total image size:  170638 bytes (.bin may be padded larger)

This output breaks down the size of all static memory regions in the firmware binary:

.. only:: esp32

    .. code-block:: bash

        $ idf.py size
        [...]
        Total sizes:
        Used static DRAM:   10608 bytes ( 170128 remain, 5.9% used)
              .data si"
"ze:    8464 bytes
              .bss  size:    2144 bytes
        Used static IRAM:   48834 bytes (  82238 remain, 37.3% used)
              .text size:   47807 bytes
           .vectors size:    1027 bytes
        Used Flash size :  117391 bytes
                   .text:   80103 bytes
                 .rodata:   37032 bytes
        Total image size:  174689 bytes (.bin may be padded larger)

    - ``Used static DRAM``: Total amount of DRAM allocated at compile time. ``remain`` indicates the amo"
"unt of DRAM left to be used as heap memory at runtime. Note that due to meta data overhead, implementation constraints, and startup heap allocations, the actual size of the DRAM heap is smaller.

        - ``.data size``: Amount of DRAM allocated at compile time for the ``.data`` (i.e., all statically allocated variables that are initialized to non-zero values). ``.data`` also consumes space in the binary image to store the non-zero initialization values.
        - ``.bss  size``: Amount of DRAM"
" allocated at compile time for ``.bss``  (i.e., all statically allocated variables that are initialized to zero). ``.bss`` does not consume extra space in flash.

    - ``Used static IRAM``: Total amount of IRAM allocated at compile time. ``remain`` indicates the amount of IRAM left to be used as heap memory at runtime. Note that due to meta data overhead, implementation constraints, and startup heap allocations, the actual size of the IRAM heap is smaller.

        - ``.text size``: Amount of I"
"RAM used for ``.text`` (i.e., all code that is executed from :ref:`IRAM `). ``.text`` also consumes space in the binary image as the code is initially stored there and is then copied over to IRAM on startup.

    - ``Used Flash size``: Total amount of flash used (excluding usage by DRAM and IRAM)

        - ``.text``: Amount of flash used for ``.text`` (i.e., all code that is executed via the flash cache, see :ref:`IROM `).
        - ``.rodata``: Amount of flash used for ``.rodata`` (i.e., read-"
"only data that is loaded via the flash cache, see :ref:`DROM `).

    - ``Total image size`` is the estimated total size of the binary file.

.. only:: not esp32

    .. code-block:: bash

        $ idf.py size
        [...]
        Total sizes:
        Used stat D/IRAM:   53743 bytes ( 122385 remain, 30.5% used)
              .data size:    6504 bytes
              .bss  size:    1984 bytes
              .text size:   44228 bytes
           .vectors size:    1027 bytes
        Used Flash size :"
"  118879 bytes
                   .text:   83467 bytes
                 .rodata:   35156 bytes
        Total image size:  170638 bytes (.bin may be padded larger)

    - ``Used stat D/IRAM``: Total amount of D/IRAM used at compile time. ``remain`` indicates the amount of D/IRAM left to be used as heap memory at runtime. Note that due to meta data overhead, implementation constraints, and startup heap allocations, the actual size of the DRAM heap is smaller.

        - ``.data size``: Amount of D"
"/IRAM allocated at compile time for the ``.data`` (i.e., all statically allocated variables that are initialized to non-zero values). ``.data`` also consumes space in the binary image to store the non-zero initialization values.
        - ``.bss  size``: Amount of D/IRAM allocated at compile time for ``.bss``  (i.e., all statically allocated variables that are initialized to zero). ``.bss`` does not consume extra space in flash.
        - ``.text size``: Amount of D/IRAM used for ``.text`` (i.e."
", all code that is executed from internal RAM). ``.text`` also consumes space in the binary image as the code is initially stored there and is then copied over to D/IRAM on startup.

    - ``Used Flash size``: Total amount of flash used (excluding usage by D/IRAM)

        - ``.text``: Amount of flash used for ``.text`` (i.e., all code that is executed via the flash cache, see :ref:`IROM `).
        - ``.rodata``: Amount of flash used for ``.rodata`` (i.e., read-only data that is loaded via the "
"flash cache, see :ref:`DROM `).

    - ``Total image size`` is the estimated total size of the binary file.


Component Usage Summary ``idf.py size-components``


The summary output provided by ``idf.py size`` does not give enough details to find the main contributor to excessive binary size. To analyze in detail, use ``idf.py size-components``.

.. code-block:: bash

    $ idf.py size-components
    [...]
        Total sizes:
     DRAM .data size:   14956 bytes
     DRAM .bss  size:   15808 byt"
"es
    Used static DRAM:   30764 bytes ( 149972 available, 17.0% used)
    Used static IRAM:   83918 bytes (  47154 available, 64.0% used)
          Flash code:  559943 bytes
        Flash rodata:  176736 bytes
    Total image size:~ 835553 bytes (.bin may be padded larger)
    Per-archive contributions to ELF file:
                Archive File DRAM .data & .bss & other   IRAM   D/IRAM Flash code & rodata   Total
               libnet80211.a       1267   6044       0   5490        0     107445  "
"  18484  138730
                   liblwip.a         21   3838       0      0        0      97465    16116  117440
                libmbedtls.a         60    524       0      0        0      27655    69907   98146
             libmbedcrypto.a         64     81       0     30        0      76645    11661   88481
                     libpp.a       2427   1292       0  20851        0      37208     4708   66486
                      libc.a          4      0       0      0        0      57056     64"
"55   63515
                    libphy.a       1439    715       0   7798        0      33074        0   43026
         libwpa_supplicant.a         12    848       0      0        0      35505     1446   37811
               libfreertos.a       3104    740       0  15711        0        367     4228   24150
              libnvs_flash.a          0     24       0      0        0      14347     2924   17295
              libspi_flash.a       1562    294       0   8851        0       1840     1913   "
"14460
             libesp_system.a        245    206       0   3078        0       5990     3817   13336
                libesp-tls.a          0      4       0      0        0       5637     3524    9165
    [... removed some lines here ...]
                libesp_rom.a          0      0       0    112        0          0        0     112
                    libcxx.a          0      0       0      0        0         47        0      47
                       (exe)          0      0       0      "
"3        0          3       12      18
                 libesp_pm.a          0      0       0      0        0          8        0       8
                libesp_eth.a          0      0       0      0        0          0        0       0
                   libmesh.a          0      0       0      0        0          0        0       0

The first lines of the output from ``idf.py size-components`` are the same as that from ``idf.py size``. After this, a table is printed as ``Per-archive contributi"
"ons to ELF file``. This means how much each static library archive has contributed to the final binary size.

Generally, one static library archive is built per component, although some are binary libraries included by a particular component, for example, ``libnet80211.a`` is included by ``esp_wifi`` component. There are also toolchain libraries such as ``libc.a`` and ``libgcc.a`` listed here, these provide Standard C/C++ Library and toolchain built-in functionality.

If your project is simple a"
"nd only has a ``main`` component, then all of the project's code will be shown under ``libmain.a``. If your project includes its own components (see :doc:`/api-guides/build-system`), then they will each be shown on a separate line.

The table is sorted in descending order of the total contribution of the static archive to the binary size.

The columns are as follows:

.. list::

    - ``DRAM .data & .bss & other`` - ``.data`` and ``.bss`` are the same as for the totals shown above. Both are stat"
"ic variables and reduce the total available RAM at runtime, but ``.bss`` does not contribute to the binary file size. ``other`` is a column for any custom section types that also contribute to RAM size. Usually, the value is 0.
    :esp32: - ``IRAM`` - is the same as for the totals shown above. It refers to code linked to execute from IRAM, which uses space in the binary file and also reduces IRAM that can be dynamically allocated at runtime using ``HEAP_CAP_32BIT``.
    :esp32: - ``D/IRAM`` - s"
"hows IRAM space which, due to occupying D/IRAM space, is also reducing available DRAM available as heap at runtime.
    :not esp32: - ``IRAM`` - is the same as for the totals shown above. It refers to code linked to execute from IRAM, which uses space in the binary file and also reduces DRAM available as heap at runtime.
    - ``Flash code & rodata`` - these are the same as the totals above, IROM and DROM space accessed from the flash cache that contribute to the binary size.

Source File Usage "
"Summary ``idf.py size-files``


For even more details, run ``idf.py size-files`` to get a summary of the contribution each object file has made to the final binary size. Each object file corresponds to a single source file.

.. code-block:: bash

    $ idf.py size-files
    [...]
    Total sizes:
     DRAM .data size:   14956 bytes
     DRAM .bss  size:   15808 bytes
    Used static DRAM:   30764 bytes ( 149972 available, 17.0% used)
    Used static IRAM:   83918 bytes (  47154 available, 64.0% "
"used)
          Flash code:  559943 bytes
        Flash rodata:  176736 bytes
    Total image size:~ 835553 bytes (.bin may be padded larger)
    Per-file contributions to ELF file:
                 Object File DRAM .data & .bss & other   IRAM   D/IRAM Flash code & rodata   Total
         x509_crt_bundle.S.o          0      0       0      0        0          0    64212   64212
                    wl_cnx.o          2   3183       0    221        0      13119     3286   19811
               phy_ch"
"ip_v7.o        721    614       0   1642        0      16820        0   19797
           ieee80211_ioctl.o        740     96       0    437        0      15325     2627   19225
                        pp.o       1142     45       0   8871        0       5030      537   15625
          ieee80211_output.o          2     20       0   2118        0      11617      914   14671
             ieee80211_sta.o          1     41       0   1498        0      10858     2218   14616
            lib_a-vfprintf"
".o          0      0       0      0        0      13829      752   14581
           lib_a-svfprintf.o          0      0       0      0        0      13251      752   14003
                 ssl_tls.c.o         60      0       0      0        0      12769      463   13292
                 sockets.c.o          0    648       0      0        0      11096     1030   12774
                     nd6.c.o          8    932       0      0        0      11515      314   12769
           phy_chip_v7_cal.o   "
"     477     53       0   3499        0       8561        0   12590
                        pm.o         32    364       0   2673        0       7788      782   11639
            ieee80211_scan.o         18    288       0      0        0       8889     1921   11116
          lib_a-svfiprintf.o          0      0       0      0        0       9654     1206   10860
           lib_a-vfiprintf.o          0      0       0      0        0      10069      734   10803
              ieee80211_ht.o        "
"  0      4       0   1186        0       8628      898   10716
           phy_chip_v7_ana.o        241     48       0   2657        0       7677        0   10623
                  bignum.c.o          0      4       0      0        0       9652      752   10408
                  tcp_in.c.o          0     52       0      0        0       8750     1282   10084
                       trc.o        664     88       0   1726        0       6245     1108    9831
                   tasks.c.o          8  "
"  704       0   7594        0          0     1475    9781
              ecp_curves.c.o         28      0       0      0        0       7384     2325    9737
                     ecp.c.o          0     64       0      0        0       8864      286    9214
          ieee80211_hostap.o          1     41       0      0        0       8578      585    9205
                      wdev.o        121    125       0   4499        0       3684      580    9009
                 tcp_out.c.o          0      0"
"       0      0        0       5686     2161    7847
                     tcp.c.o          2     26       0      0        0       6161     1617    7806
           ieee80211_input.o          0      0       0      0        0       6797      973    7770
                     wpa.c.o          0    656       0      0        0       6828       55    7539
    [... additional lines removed ...]

After the summary of total sizes, a table of ``Per-file contributions to ELF file`` is printed.

The columns a"
"re the same as shown above for ``idy.py size-components``, but this time the granularity is the contribution of each individual object file to the binary size.

For example, we can see that the file ``x509_crt_bundle.S.o`` contributed 64,212 bytes to the total firmware size, all as ``.rodata`` in flash. Therefore we can guess that this application is using the :doc:`/api-reference/protocols/esp_crt_bundle` feature and not using this feature would save at last this many bytes from the firmware si"
"ze.

Some of the object files are linked from binary libraries and therefore you will not find a corresponding source file. To locate which component a source file belongs to, it is generally possible to search in the ESP-IDF source tree or look in the :ref:`linker-map-file`  for the full path.

Comparing Two Binaries


If making some changes that affect binary size, it is possible to use an ESP-IDF tool to break down the exact differences in size.

This operation is not part of ``idf.py``, it i"
"s necessary to run the `esp_idf_size `_ Python tool directly.

To do so, first, locate the linker map file with the name ``PROJECTNAME.map`` in the build directory. The ``esp_idf_size`` tool performs its analysis based on the output of the linker map file.

To compare with another binary, you also need its corresponding ``.map`` file saved from the build directory.

For example, to compare two builds, one of which with the default :ref:`CONFIG_COMPILER_OPTIMIZATION` setting ``Debug (-Og)`` confi"
"guration while another with ``Optimize for size (-Os)``:

.. code-block:: bash

    $ python -m esp_idf_size --diff build_Og/https_request.map build_Os/https_request.map
     MAP file: build_Os/https_request.map
     MAP file: build_Og/https_request.map
    Difference is counted as  - , i.e. a positive number means that  is larger.
    Total sizes of :                                                      Difference
     DRAM .data size:   14516 bytes                                              "
"   14956           -440
     DRAM .bss  size:   15792 bytes                                                 15808            -16
    Used static DRAM:   30308 bytes ( 150428 available, 16.8% used)                 30764           -456 (   +456 available,      +0 total)
    Used static IRAM:   78498 bytes (  52574 available, 59.9% used)                 83918          -5420 (  +5420 available,      +0 total)
          Flash code:  509183 bytes                                                559943  "
"       -50760
        Flash rodata:  170592 bytes                                                176736          -6144
    Total image size:~ 772789 bytes (.bin may be padded larger)                    835553         -62764

We can see from the ``Difference`` column that changing this one setting caused the whole binary to be over 60 KB smaller and over 5 KB more RAM is available.

It is also possible to use the ``diff`` mode to output a table of component-level (static library archive) differen"
"ces:

.. note::

    To get the output in JSON or CSV format using ``esp_idf_size``, it is possible to use the ``--format`` option.

.. code-block:: bash

    python -m esp_idf_size --archives --diff build_Og/https_request.map build_Oshttps_request.map

Also at the individual source file level:

.. code-block:: bash

    python -m esp_idf_size --files --diff build_Og/https_request.map build_Oshttps_request.map

Other options, like writing the output to a file, are available, pass ``--help`` to s"
"ee the full list.

.. _idf-size-linker-failed:

Showing Size When Linker Fails


If too much static memory is allocated, the linker will fail with an error such as ``DRAM segment data does not fit``, ``region `iram0_0_seg' overflowed by 44 bytes``, or similar.

In these cases, ``idf.py size`` will not succeed either. However, it is possible to run ``esp_idf_size`` manually to view the **partial static memory usage**. The memory usage will miss the variables that could not be linked, so there sti"
"ll appears to be some free space.

The map file argument is ``.map`` in the build directory.

.. code-block:: bash

    python -m esp_idf_size build/project_name.map

It is also possible to view the equivalent of ``size-components`` or ``size-files`` output:

.. code-block:: bash

    python -m esp_idf_size --archives build/project_name.map
    python -m esp_idf_size --files build/project_name.map

.. _linker-map-file:

Linker Map File


.. note::

    This is an advanced analysis method, but it"
" can be very useful. Feel free to skip ahead to :ref:`reducing-overall-size` and possibly come back to this later.

The ``idf.py size`` analysis tools all work by parsing the GNU binutils ``linker map file``, which is a summary of everything the linker did when it created (i.e., linked) the final firmware binary file.

Linker map files themselves are plain text files, so it is possible to read them and find out exactly what the linker did. However, they are also very complex and long, often exce"
"eding 100,000 lines.

The map file itself is broken into parts and each part has a heading. The parts are:

- ``Archive member included to satisfy reference by file (symbol)``

    - This shows you: for each object file included in the link, what symbol (function or variable) was the linker searching for when it included that object file.
    - If you are wondering why some object file in particular was included in the binary, this part may give a clue. This part can be used in conjunction with "
"the ``Cross Reference Table`` at the end of the file.

    .. note::

        Not every object file shown in this list ends up included in the final binary, some end up in the ``Discarded input sections`` list instead.

- ``Allocating common symbols``

    - This is a list of some global variables along with their sizes. Common symbols have a particular meaning in ELF binary files, but ESP-IDF does not make much use of them.

- ``Discarded input sections``

    - These sections were read by the "
"linker as part of an object file to be linked into the final binary, but then nothing else referred to them, so they were discarded from the final binary.
    - For ESP-IDF, this list can be very long, as we compile each function and static variable to a unique section in order to minimize the final binary size. Specifically, ESP-IDF uses compiler options ``-ffunction-sections -fdata-sections`` and linker option ``--gc-sections``.
    - Items mentioned in this list **do not** contribute to the f"
"inal binary.

- ``Memory Configuration``, ``Linker script and memory map``

    - These two parts go together. Some of the output comes directly from the linker command line and the Linker Script, both provided by :doc:`/api-guides/build-system`. The linker script is partially generated from the ESP-IDF project using the :doc:`/api-guides/linker-script-generation` feature.

    - As the output of the ``Linker script and memory map`` part of the map unfolds, you can see each symbol (function or s"
"tatic variable) linked into the final binary along with its address (as a 16 digit hex number), its length (also in hex), and the library and object file it was linked from (which can be used to determine the component and the source file).

    - Following all of the output sections that take up space in the final ``.bin`` file, the ``memory map`` also includes some sections in the ELF file that are only used for debugging, e.g., ELF sections ``.debug_*``, etc. These do not contribute to the fi"
"nal binary size. You can notice the address of these symbols is a very small number, starting from ``0x0000000000000000`` and counting up.

- ``Cross Reference Table``

    - This table shows the symbol (function or static variable) that the list of object file(s) refers to. If you are wondering why a particular thing is included in the binary, this will help determine what included it.

    .. note::

        Unfortunately, the ``Cross Reference Table`` does not only include symbols that made i"
"t into the final binary. It also includes symbols in discarded sections. Therefore, just because something is shown here does not mean that it was included in the final binary - this needs to be checked separately.


.. note::

   Linker map files are generated by the GNU binutils linker ``ld``, not ESP-IDF. You can find additional information online about the linker map file format. This quick summary is written from the perspective of ESP-IDF build system in particular.

.. _reducing-overall-s"
"ize:

Reducing Overall Size


The following configuration options reduces the final binary size of almost any ESP-IDF project:

.. list::

    - Set :ref:`CONFIG_COMPILER_OPTIMIZATION` to ``Optimize for size (-Os)``. In some cases, ``Optimize for performance (-O2)`` will also reduce the binary size compared to the default. Note that if your code contains C or C++ Undefined Behavior then increasing the compiler optimization level may expose bugs that otherwise do not happen.
    - Reduce the comp"
"iled-in log output by lowering the app :ref:`CONFIG_LOG_DEFAULT_LEVEL`. If the :ref:`CONFIG_LOG_MAXIMUM_LEVEL` is changed from the default then this setting controls the binary size instead. Reducing compiled-in logging reduces the number of strings in the binary, and also the code size of the calls to logging functions.
    - Set the :ref:`CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL` to ``Silent``. This avoids compiling in a dedicated assertion string and source file name for each assert that "
"may fail. It is still possible to find the failed assert in the code by looking at the memory address where the assertion failed.
    - Besides the :ref:`CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL`, you can disable or silent the assertion for the HAL component separately by setting :ref:`CONFIG_HAL_DEFAULT_ASSERTION_LEVEL`. It is to notice that ESP-IDF lowers the HAL assertion level in bootloader to be silent even if :ref:`CONFIG_HAL_DEFAULT_ASSERTION_LEVEL` is set to full-assertion level. Thi"
"s is to reduce the bootloader size.
    - Setting :ref:`CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT` removes specific error messages for particular internal ESP-IDF error check macros. This may make it harder to debug some error conditions by reading the log output.
    :esp32: - If the binary needs to run on only certain revision(s) of ESP32, increasing :ref:`CONFIG_ESP32_REV_MIN` to match can result in a reduced binary size. This will make a large difference if setting ESP32 minimum revision 3,"
" and PSRAM is enabled.
    :esp32c3: - If the binary needs to run on only certain revision(s) of ESP32-C3, increasing :ref:`CONFIG_ESP32C3_REV_MIN` to match can result in a reduced binary size. This is particularly true if setting ESP32-C3 minimum revision 3 and using Wi-Fi, as some functionality was moved to ROM code.
    - Do not enable :ref:`CONFIG_COMPILER_CXX_EXCEPTIONS`, :ref:`CONFIG_COMPILER_CXX_RTTI`, or set the :ref:`CONFIG_COMPILER_STACK_CHECK_MODE` to Overall. All of these options are"
" already disabled by default, but they have a large impact on binary size.
    - Disabling :ref:`CONFIG_ESP_ERR_TO_NAME_LOOKUP` removes the lookup table to translate user-friendly names for error values (see :doc:`/api-guides/error-handling`) in error logs, etc. This saves some binary size, but error values will be printed as integers only.
    - Setting :ref:`CONFIG_ESP_SYSTEM_PANIC` to ``Silent reboot`` saves a small amount of binary size, however this is **only** recommended if no one will us"
"e UART output to debug the device.
    :CONFIG_IDF_TARGET_ARCH_RISCV: - Seting :ref:`CONFIG_COMPILER_SAVE_RESTORE_LIBCALLS` reduces binary size by replacing inlined prologues/epilogues with library calls.
    - If the application binary uses only one of the security versions of the protocomm component, then the support for others can be disabled to save some code size. The support can be disabled through :ref:`CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0`, :ref:`CONFIG_ESP_PROTOCOMM_SUPPORT_S"
"ECURITY_VERSION_1` or :ref:`CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2` respectively.

.. note::

   In addition to the many configuration items shown here, there are a number of configuration options where changing the option from the default increases binary size. These are not noted here. Where the increase is significant is usually noted in the configuration item help text.

.. _size-targeted-optimizations:

Targeted Optimizations


The following binary size optimizations apply to a par"
"ticular component or a function:

.. only:: SOC_WIFI_SUPPORTED

    Wi-Fi
    @@@@@

    - Disabling :ref:`CONFIG_ESP_WIFI_ENABLE_WPA3_SAE` will save some Wi-Fi binary size if WPA3 support is not needed. Note that WPA3 is mandatory for new Wi-Fi device certifications.
    - Disabling :ref:`CONFIG_ESP_WIFI_SOFTAP_SUPPORT` will save some Wi-Fi binary size if soft-AP support is not needed.
    - Disabling :ref:`CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT` will save some Wi-Fi binary size if enterprise suppo"
"rt is not needed.

.. only:: esp32

    ADC
    @@@

    - Disabling ADC calibration features :ref:`CONFIG_ADC_CAL_EFUSE_TP_ENABLE`, :ref:`CONFIG_ADC_CAL_EFUSE_VREF_ENABLE`, :ref:`CONFIG_ADC_CAL_LUT_ENABLE` will save a small amount of binary size if ADC driver is used, at expense of accuracy.

.. only:: SOC_BT_SUPPORTED

    Bluetooth NimBLE
    @@@@@@@@@@@@@@@@

    If using :doc:`/api-reference/bluetooth/nimble/index` then the following modifications can reduce binary size:

    .. list::

   "
"     :esp32: - Set :ref:`CONFIG_BTDM_CTRL_BLE_MAX_CONN` to 1 if only one Bluetooth LE connection is needed.
        - Set :ref:`CONFIG_BT_NIMBLE_MAX_CONNECTIONS` to 1 if only one Bluetooth LE connection is needed.
        - Disable either :ref:`CONFIG_BT_NIMBLE_ROLE_CENTRAL` or :ref:`CONFIG_BT_NIMBLE_ROLE_OBSERVER` if these roles are not needed.
        - Reducing :ref:`CONFIG_BT_NIMBLE_LOG_LEVEL` can reduce binary size. Note that if the overall log level has been reduced as described above in :"
"ref:`reducing-overall-size` then this also reduces the NimBLE log level.

lwIP IPv6
@@@@@@@@@

- Setting :ref:`CONFIG_LWIP_IPV6` to ``false`` will reduce the size of the lwIP TCP/IP stack, at the cost of only supporting IPv4.

  .. note::

      IPv6 is required by some components such as :doc:`/api-reference/protocols/asio`. These components will not be available if IPV6 is disabled.

lwIP IPv4
@@@@@@@@@

- If IPv4 connectivity is not required, setting :ref:`CONFIG_LWIP_IPV4` to ``false`` will "
"reduce the size of the lwIP, supporting IPv6-only TCP/IP stack.

  .. note::

      Before disabling IPv4 support, please note that IPv6 only network environments are not ubiquitous and must be supported in the local network, e.g., by your internet service provider or using constrained local network settings.

.. _newlib-nano-formatting:

Newlib Nano Formatting
@@@@@@@@@@@@@@@@@@@@@@

By default, ESP-IDF uses Newlib ""full"" formatting for I/O functions (``printf()``, ``scanf()``, etc.)

.. only::"
" CONFIG_ESP_ROM_HAS_NEWLIB_NANO_FORMAT

    Enabling the config option :ref:`CONFIG_NEWLIB_NANO_FORMAT` will switch Newlib to the ""Nano"" formatting mode. This is smaller in code size, and a large part of the implementation is compiled into the {IDF_TARGET_NAME} ROM, so it does not need to be included in the binary at all.

    The exact difference in binary size depends on which features the firmware uses, but 25 KB ~ 50 KB is typical.

.. only:: CONFIG_ESP_ROM_HAS_NEWLIB_NORMAL_FORMAT

    Disa"
"bling the config option :ref:`CONFIG_NEWLIB_NANO_FORMAT` will switch Newlib to the ""full"" formatting mode. This will reduce the binary size, as {IDF_TARGET_NAME} has the full formatting version of the functions in ROM, so it does not need to be included in the binary at all.

Enabling ""Nano"" formatting reduces the stack usage of each function that calls ``printf()`` or another string formatting function, see :ref:`optimize-stack-sizes`.

""Nano"" formatting does not support 64-bit integers, or C99"
" formatting features. For a full list of restrictions, search for ``--enable-newlib-nano-formatted-io`` in the `Newlib README file`_.


.. only:: esp32c2

    .. note::

        :ref:`CONFIG_NEWLIB_NANO_FORMAT` is enabled by default on {IDF_TARGET_NAME}.


.. _Newlib README file: https://sourceware.org/newlib/README

.. _minimizing_binary_mbedtls:

MbedTLS Features
@@@@@@@@@@@@@@@@

Under **Component Config** > **mbedTLS**, there are multiple mbedTLS features enabled default, some of which can b"
"e disabled if not needed to save code size.

These include:

- :ref:`CONFIG_MBEDTLS_HAVE_TIME`
- :ref:`CONFIG_MBEDTLS_ECDSA_DETERMINISTIC`
- :ref:`CONFIG_MBEDTLS_SHA512_C`
- :ref:`CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS`
- :ref:`CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS`
- :ref:`CONFIG_MBEDTLS_SSL_CONTEXT_SERIALIZATION`
- :ref:`CONFIG_MBEDTLS_SSL_ALPN`
- :ref:`CONFIG_MBEDTLS_SSL_RENEGOTIATION`
- :ref:`CONFIG_MBEDTLS_CCM_C`
- :ref:`CONFIG_MBEDTLS_GCM_C`
- :ref:`CONFIG_MBEDTLS_ECP_C` (Alternativ"
"ely: Leave this option enabled but disable some of the elliptic curves listed in the sub-menu.)
- :ref:`CONFIG_MBEDTLS_ECP_NIST_OPTIM`
- :ref:`CONFIG_MBEDTLS_ECP_FIXED_POINT_OPTIM`
- Change :ref:`CONFIG_MBEDTLS_TLS_MODE` if both server & client functionalities are not needed
- Consider disabling some cipher suites listed in the ``TLS Key Exchange Methods`` sub-menu (i.e., :ref:`CONFIG_MBEDTLS_KEY_EXCHANGE_RSA`)

The help text for each option has some more information for reference.

.. important"
"::

   It is **strongly not recommended to disable all these mbedTLS options**. Only disable options of which you understand the functionality and are certain that it is not needed in the application. In particular:

   - Ensure that any TLS server(s) the device connects to can still be used. If the server is controlled by a third party or a cloud service, it is recommended to ensure that the firmware supports at least two of the supported cipher suites in case one is disabled in a future update"
".
   - Ensure that any TLS client(s) that connect to the device can still connect with supported/recommended cipher suites. Note that future versions of client operating systems may remove support for some features, so it is recommended to enable multiple supported cipher suites, or algorithms for redundancy.

   If depending on third party clients or servers, always pay attention to announcements about future changes to supported TLS features. If not, the {IDF_TARGET_NAME} device may become ina"
"ccessible if support changes.

.. only:: CONFIG_ESP_ROM_HAS_MBEDTLS_CRYPTO_LIB

   Enabling the config option :ref:`CONFIG_MBEDTLS_USE_CRYPTO_ROM_IMPL` will use the crypto algorithms from mbedTLS library inside the chip ROM.
   Disabling the config option :ref:`CONFIG_MBEDTLS_USE_CRYPTO_ROM_IMPL` will use the crypto algorithms from the ESP-IDF mbedtls component library. This will increase the binary size (flash footprint).

.. note::

   Not every combination of mbedTLS compile-time config is te"
"sted in ESP-IDF. If you find a combination that fails to compile or function as expected, please report the details on `GitHub `_.

VFS
@@@

:doc:`/api-reference/storage/vfs` feature in ESP-IDF allows multiple filesystem drivers and file-like peripheral drivers to be accessed using standard I/O functions (``open``, ``read``, ``write``, etc.) and C library functions (``fopen``, ``fread``, ``fwrite``, etc.). When filesystem or file-like peripheral driver functionality is not used in the applicatio"
"n, this feature can be fully or partially disabled. VFS component provides the following configuration options:

.. only:: CONFIG_ESP_ROM_HAS_HAL_SYSTIMER or CONFIG_ESP_ROM_HAS_HAL_WDT

    HAL
    @@@

    .. list::

        :CONFIG_ESP_ROM_HAS_HAL_SYSTIMER: * Enabling :ref:`CONFIG_HAL_SYSTIMER_USE_ROM_IMPL` can reduce the IRAM usage and binary size by linking in the systimer HAL driver of ROM implementation.
        :CONFIG_ESP_ROM_HAS_HAL_WDT: * Enabling :ref:`CONFIG_HAL_WDT_USE_ROM_IMPL` can"
" reduce the IRAM usage and binary size by linking in the watchdog HAL driver of ROM implementation.

    Heap
    @@@@

    .. list::
        :CONFIG_ESP_ROM_HAS_HEAP_TLSF: * Enabling :ref:`CONFIG_HEAP_TLSF_USE_ROM_IMPL` can reduce the IRAM usage and binary size by linking in the TLSF library of ROM implementation.

Bootloader Size


This document deals with the size of an ESP-IDF app binary only, and not the ESP-IDF :ref:`second-stage-bootloader`.

For a discussion of ESP-IDF bootloader binary "
"size, see :ref:`bootloader-size`.

IRAM Binary Size


If the IRAM section of a binary is too large, this issue can be resolved by reducing IRAM memory usage. See :ref:`optimize-iram-usage`.
"
"Performance




ESP-IDF ships with default settings that are designed for a trade-off between performance, resource usage, and available functionality.

These guides describe how to optimize a firmware application for a particular aspect of performance. Usually this involves some trade-off in terms of limiting available functions, or swapping one aspect of performance (such as execution speed) for another (such as RAM usage).

How to Optimize Performance


Guides


.. toctree::
   :maxdepth: 2

"
"   speed
   size
   ram-usage
"
"Speed Optimization




{IDF_TARGET_CONTROLLER_CORE_CONFIG:default=""CONFIG_BT_CTRL_PINNED_TO_CORE"", esp32=""CONFIG_BTDM_CTRL_PINNED_TO_CORE_CHOICE"", esp32s3=""CONFIG_BT_CTRL_PINNED_TO_CORE_CHOICE""}
{IDF_TARGET_RF_TYPE:default=""Wi-Fi/Bluetooth"", esp32s2=""Wi-Fi"", esp32c6=""Wi-Fi/Bluetooth/802.15.4"", esp32h2=""Bluetooth/802.15.4""}

Overview


Optimizing execution speed is a key element of software performance. Code that executes faster can also have other positive effects, e.g., reducing overall power c"
"onsumption. However, improving execution speed may have trade-offs with other aspects of performance such as :doc:`size`.

Choose What to Optimize


If a function in the application firmware is executed once per week in the background, it may not matter if that function takes 10 ms or 100 ms to execute. If a function is executed constantly at 10 Hz, it matters greatly if it takes 10 ms or 100 ms to execute.

Most kinds of application firmware only have a small set of functions that require optim"
"al performance. Perhaps those functions are executed very often, or have to meet some application requirements for latency or throughput. Optimization efforts should be targeted at these particular functions.

Measuring Performance


The first step to improving something is to measure it.

Basic Performance Measurements


You may be able to measure directly the performance relative to an external interaction with the world, e.g., see the examples :example:`wifi/iperf` and :example:`ethernet/iper"
"f` for measuring general network performance. Or you can use an oscilloscope or logic analyzer to measure the timing of an interaction with a device peripheral.

Otherwise, one way to measure performance is to augment the code to take timing measurements:

.. code-block:: c

    #include ""esp_timer.h""

    void measure_important_function(void) {
        const unsigned MEASUREMENTS = 5000;
        uint64_t start = esp_timer_get_time();

        for (int retries = 0; retries ` is an excellent tool"
" for visualizing task execution and looking for performance issues or improvements in the system as a whole.

Improving Overall Speed


The following optimizations improve the execution of nearly all code, including boot times, throughput, latency, etc:

.. list::

    :esp32: - Set :ref:`CONFIG_ESPTOOLPY_FLASHFREQ` to 80 MHz. This is double the 40 MHz default value and doubles the speed at which code is loaded or executed from flash. You should verify that the board or module that connects the "
"{IDF_TARGET_NAME} to the flash chip is rated for 80 MHz operation at the relevant temperature ranges before changing this setting. This information is contained in the hardware datasheet(s).
    - Set :ref:`CONFIG_ESPTOOLPY_FLASHMODE` to QIO or QOUT mode (Quad I/O). Both almost double the speed at which code is loaded or executed from flash compared to the default DIO mode. QIO is slightly faster than QOUT if both are supported. Note that both the flash chip model, and the electrical connections"
" between the {IDF_TARGET_NAME} and the flash chip must support quad I/O modes or the SoC will not work correctly.
    - Set :ref:`CONFIG_COMPILER_OPTIMIZATION` to ``Optimize for performance (-O2)`` . This may slightly increase binary size compared to the default setting, but almost certainly increases the performance of some code. Note that if your code contains C or C++ Undefined Behavior, then increasing the compiler optimization level may expose bugs that otherwise are not seen.
    :SOC_ASSI"
"ST_DEBUG_SUPPORTED: - Set :ref:`CONFIG_ESP_SYSTEM_HW_STACK_GUARD` to disabled. This may slightly increase the performance of some code, especially in cases where a lot of interrupts occur on the device.
    :esp32: - If the application uses PSRAM and is based on ESP32 rev. 3 (ECO3), setting :ref:`CONFIG_ESP32_REV_MIN` to ``3`` disables PSRAM bug workarounds, reducing the code size and improving overall performance.
    :SOC_CPU_HAS_FPU: - Avoid using floating point arithmetic ``float``. Even tho"
"ugh {IDF_TARGET_NAME} has a single precision hardware floating point unit, floating point calculations are always slower than integer calculations. If possible then use fixed point representations, a different method of integer representation, or convert part of the calculation to be integer only before switching to floating point.
    :not SOC_CPU_HAS_FPU: - Avoid using floating point arithmetic ``float``. On {IDF_TARGET_NAME} these calculations are emulated in software and are very slow. If po"
"ssible, use fixed point representations, a different method of integer representation, or convert part of the calculation to be integer only before switching to floating point.
    - Avoid using double precision floating point arithmetic ``double``. These calculations are emulated in software and are very slow. If possible then use an integer-based representation, or single-precision floating point.

Reduce Logging Overhead


Although standard output is buffered, it is possible for an applicatio"
"n to be limited by the rate at which it can print data to log output once buffers are full. This is particularly relevant for startup time if a lot of output is logged, but such problem can happen at other times as well. There are multiple ways to solve this problem:

.. list::

    - Reduce the volume of log output by lowering the app :ref:`CONFIG_LOG_DEFAULT_LEVEL` (the equivalent bootloader setting is :ref:`CONFIG_BOOTLOADER_LOG_LEVEL`). This also reduces the binary size, and saves some CPU t"
"ime spent on string formatting.
    :not SOC_USB_OTG_SUPPORTED: - Increase the speed of logging output by increasing the :ref:`CONFIG_ESP_CONSOLE_UART_BAUDRATE`.
    :SOC_USB_OTG_SUPPORTED: - Increase the speed of logging output by increasing the :ref:`CONFIG_ESP_CONSOLE_UART_BAUDRATE`. However, if you are using internal USB-CDC, the serial throughput is not dependent on the configured baud rate.

Not Recommended


The following options also increase execution speed, but are not recommended as t"
"hey also reduce the debuggability of the firmware application and may increase the severity of any bugs.

.. list::

   - Set :ref:`CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL` to disabled. This also reduces firmware binary size by a small amount. However, it may increase the severity of bugs in the firmware including security-related bugs. If it is necessary to do this to optimize a particular function, consider adding ``#define NDEBUG`` at the top of that single source file instead.

.. _spee"
"d-targeted-optimizations:

Targeted Optimizations


The following changes increase the speed of a chosen part of the firmware application:

.. list::

    - Move frequently executed code to IRAM. By default, all code in the app is executed from flash cache. This means that it is possible for the CPU to have to wait on a ""cache miss"" while the next instructions are loaded from flash. Functions which are copied into IRAM are loaded once at boot time, and then always execute at full speed.

      I"
"RAM is a limited resource, and using more IRAM may reduce available DRAM, so a strategic approach is needed when moving code to IRAM. See :ref:`iram` for more information.

    -  Jump table optimizations can be re-enabled for individual source files that do not need to be placed in IRAM. For hot paths in large ``switch cases``, this improves performance. For instructions on how to add the ``-fjump-tables`` and ``-ftree-switch-conversion`` options when compiling individual source files, see :ref"
":`component_build_control`

Improving Startup Time


In addition to the overall performance improvements shown above, the following options can be tweaked to specifically reduce startup time:

.. list::

   - Minimizing the :ref:`CONFIG_LOG_DEFAULT_LEVEL` and :ref:`CONFIG_BOOTLOADER_LOG_LEVEL` has a large impact on startup time. To enable more logging after the app starts up, set the :ref:`CONFIG_LOG_MAXIMUM_LEVEL` as well, and then call :cpp:func:`esp_log_level_set` to restore higher level logs"
". The :example:`system/startup_time` main function shows how to do this.
   :SOC_RTC_FAST_MEM_SUPPORTED: - If using Deep-sleep mode, setting :ref:`CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP` allows a faster wake from sleep. Note that if using Secure Boot, this represents a security compromise, as Secure Boot validation are not be performed on wake.
   - Setting :ref:`CONFIG_BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON` skips verifying the binary on every boot from the power-on reset. How much time th"
"is saves depends on the binary size and the flash settings. Note that this setting carries some risk if the flash becomes corrupt unexpectedly. Read the help text of the :ref:`config item ` for an explanation and recommendations if using this option.
   - It is possible to save a small amount of time during boot by disabling RTC slow clock calibration. To do so, set :ref:`CONFIG_RTC_CLK_CAL_CYCLES` to 0. Any part of the firmware that uses RTC slow clock as a timing source will be less accurate a"
"s a result.

The example project :example:`system/startup_time` is pre-configured to optimize startup time. The file :example_file:`system/startup_time/sdkconfig.defaults` contain all of these settings. You can append these to the end of your project's own ``sdkconfig`` file to merge the settings, but please read the documentation for each setting first.

Task Priorities


As ESP-IDF FreeRTOS is a real-time operating system, it is necessary to ensure that high-throughput or low-slatency tasks ar"
"e granted a high priority in order to run immediately. Priority is set when calling :cpp:func:`xTaskCreate` or :cpp:func:`xTaskCreatePinnedToCore` and can be changed at runtime by calling :cpp:func:`vTaskPrioritySet`.

It is also necessary to ensure that tasks yield CPU (by calling :cpp:func:`vTaskDelay`, ``sleep()``, or by blocking on semaphores, queues, task notifications, etc) in order to not starve lower-priority tasks and cause problems for the overall system. The :ref:`task-watchdog-timer`"
" provides a mechanism to automatically detect if task starvation happens. However, note that a TWDT timeout does not always indicate a problem, because sometimes the correct operation of the firmware requires some long-running computation. In these cases, tweaking the TWDT timeout or even disabling the TWDT may be necessary.

.. _built-in-task-priorities:

Built-in Task Priorities


ESP-IDF starts a number of system tasks at fixed priority levels. Some are automatically started during the boot p"
"rocess, while some are started only if the application firmware initializes a particular feature. To optimize performance, structure the task priorities of your application properly to ensure the tasks are not delayed by the system tasks, while also not starving system tasks and impacting other functions of the system.

This may require splitting up a particular task. For example, perform a time-critical operation in a high-priority task or an interrupt handler and do the non-time-critical part "
"in a lower-priority task.

Header :idf_file:`components/esp_system/include/esp_task.h` contains macros for the priority levels used for built-in ESP-IDF tasks system. See :ref:`freertos_system_tasks` for more details about the system tasks.

Common priorities are:

.. Note: the following two lists should be kept the same, but the second list also shows CPU affinities

.. only:: not SOC_HP_CPU_HAS_MULTIPLE_CORES

    .. list::

        - :ref:`app-main-task` that executes app_main function has mi"
"nimum priority (1).
        - :doc:`/api-reference/system/esp_timer` system task to manage timer events and execute callbacks has high priority (22, ``ESP_TASK_TIMER_PRIO``)
        - FreeRTOS Timer Task to handle FreeRTOS timer callbacks is created when the scheduler initializes and has minimum task priority (1, :ref:`configurable `).
        - :doc:`/api-reference/system/esp_event` system task to manage the default system event loop and execute callbacks has high priority (20, ``ESP_TASK_EVENT"
"_PRIO``). This configuration is only used if the application calls :cpp:func:`esp_event_loop_create_default`. It is possible to call :cpp:func:`esp_event_loop_create` with a custom task configuration instead.
        - :doc:`/api-guides/lwip` TCP/IP task has high priority (18, ``ESP_TASK_TCPIP_PRIO``).
        :SOC_WIFI_SUPPORTED: - :doc:`/api-guides/wifi` task has high priority (23).
        :SOC_WIFI_SUPPORTED: - Wi-Fi wpa_supplicant component may create dedicated tasks while the Wi-Fi Protect"
"ed Setup (WPS), WPA2 EAP-TLS, Device Provisioning Protocol (DPP) or BSS Transition Management (BTM) features are in use. These tasks all have low priority (2).
        :SOC_BT_SUPPORTED: - :doc:`/api-reference/bluetooth/controller_vhci` task has high priority (23, ``ESP_TASK_BT_CONTROLLER_PRIO``). The Bluetooth Controller needs to respond to requests with low latency, so it should always be among the highest priority task in the system.
        :SOC_BT_SUPPORTED: - :doc:`/api-reference/bluetooth"
"/nimble/index` task has high priority (21).
        - The Ethernet driver creates a task for the MAC to receive Ethernet frames. If using the default config ``ETH_MAC_DEFAULT_CONFIG`` then the priority is medium-high (15). This setting can be changed by passing a custom :cpp:class:`eth_mac_config_t` struct when initializing the Ethernet MAC.
        - If using the :doc:`/api-reference/protocols/mqtt` component, it creates a task with default priority 5 (:ref:`configurable`), depending on :ref:`C"
"ONFIG_MQTT_USE_CUSTOM_CONFIG`, and also configurable at runtime by ``task_prio`` field in the :cpp:class:`esp_mqtt_client_config_t`)
        - To see what is the task priority for ``mDNS`` service, please check `Performance Optimization `__.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    .. list::

        - :ref:`app-main-task` that executes app_main function has minimum priority (1). This task is pinned to Core 0 by default (:ref:`configurable`).
        - :doc:`/api-reference/system/esp_timer`"
" system task to manage high precision timer events and execute callbacks has high priority (22, ``ESP_TASK_TIMER_PRIO``). This task is pinned to Core 0.
        - FreeRTOS Timer Task to handle FreeRTOS timer callbacks is created when the scheduler initializes and has minimum task priority (1, :ref:`configurable `). This task is pinned to Core 0.
        - :doc:`/api-reference/system/esp_event` system task to manage the default system event loop and execute callbacks has high priority (20, ``ESP_"
"TASK_EVENT_PRIO``) and it is pinned to Core 0. This configuration is only used if the application calls :cpp:func:`esp_event_loop_create_default`, it is possible to call :cpp:func:`esp_event_loop_create` with a custom task configuration instead.
        - :doc:`/api-guides/lwip` TCP/IP task has high priority (18, ``ESP_TASK_TCPIP_PRIO``) and is not pinned to any core (:ref:`configurable`).
        :SOC_WIFI_SUPPORTED: - :doc:`/api-guides/wifi` task has high priority (23) and is pinned to Core 0 "
"by default (:ref:`configurable`).
        :SOC_WIFI_SUPPORTED: - Wi-Fi wpa_supplicant component may create dedicated tasks while the Wi-Fi Protected Setup (WPS), WPA2 EAP-TLS, Device Provisioning Protocol (DPP) or BSS Transition Management (BTM) features are in use. These tasks all have low priority (2) and are not pinned to any core.
        :SOC_BT_SUPPORTED: - :doc:`/api-reference/bluetooth/controller_vhci` task has high priority (23, ``ESP_TASK_BT_CONTROLLER_PRIO``) and is pinned to Core 0 b"
"y default (:ref:`configurable `). The Bluetooth Controller needs to respond to requests with low latency, so it should always be among the highest priority task assigned to a single CPU.
        :SOC_BT_SUPPORTED: - :doc:`/api-reference/bluetooth/nimble/index` task has high priority (21) and is pinned to Core 0 by default (:ref:`configurable `).
        :esp32: - :doc:`/api-reference/bluetooth/index` creates multiple tasks when used:
               - Stack event callback task (""BTC"") has high pr"
"iority (19).
               - Stack BTU layer task has high priority (20).
               - Host HCI host task has high priority (22).

               All Bluedroid Tasks are pinned to the same core, which is Core 0 by default (:ref:`configurable `).

        - The Ethernet driver creates a task for the MAC to receive Ethernet frames. If using the default config ``ETH_MAC_DEFAULT_CONFIG`` then the priority is medium-high (15) and the task is not pinned to any core. These settings can be changed "
"by passing a custom :cpp:class:`eth_mac_config_t` struct when initializing the Ethernet MAC.
        - If using the :doc:`/api-reference/protocols/mqtt` component, it creates a task with default priority 5 (:ref:`configurable `, depending on :ref:`CONFIG_MQTT_USE_CUSTOM_CONFIG`) and not pinned to any core (:ref:`configurable `).
        - To see what is the task priority for ``mDNS`` service, please check `Performance Optimization `__.


Choosing Task Priorities of the Application


.. only:: no"
"t SOC_HP_CPU_HAS_MULTIPLE_CORES

    In general, it is not recommended to set task priorities higher than the built-in {IDF_TARGET_RF_TYPE} operations as starving them of CPU may make the system unstable. For very short timing-critical operations that do not use the network, use an ISR or a very restricted task (with very short bursts of runtime only) at the highest priority (24). Choosing priority 19 allows lower-layer {IDF_TARGET_RF_TYPE} functionality to run without delays, but still preempts"
" the lwIP TCP/IP stack and other less time-critical internal functionality - this is the best option for time-critical tasks that do not perform network operations. Any task that does TCP/IP network operations should run at a lower priority than the lwIP TCP/IP task (18) to avoid priority-inversion issues.

.. only:: SOC_HP_CPU_HAS_MULTIPLE_CORES

    With a few exceptions, most importantly the lwIP TCP/IP task, in the default configuration most built-in tasks are pinned to Core 0. This makes it"
" quite easy for the application to place high priority tasks on Core 1. Using priority 19 or higher guarantees that an application task can run on Core 1 without being preempted by any built-in task. To further isolate the tasks running on each CPU, configure the :ref:`lwIP task ` to only run on Core 0 instead of either core, which may reduce total TCP/IP throughput depending on what other tasks are running.

    In general, it is not recommended to set task priorities on Core 0 higher than the "
"built-in {IDF_TARGET_RF_TYPE} operations as starving them of CPU may make the system unstable. Choosing priority 19 and Core 0 allows lower-layer {IDF_TARGET_RF_TYPE} functionality to run without delays, but still pre-empts the lwIP TCP/IP stack and other less time-critical internal functionality. This is an option for time-critical tasks that do not perform network operations. Any task that does TCP/IP network operations should run at lower priority than the lwIP TCP/IP task (18) to avoid prior"
"ity-inversion issues.

    .. note::

        Setting a task to always run in preference to built-in ESP-IDF tasks does not require pinning the task to Core 1. Instead, the task can be left unpinned and assigned a priority of 17 or lower. This allows the task to optionally run on Core 0 if there are no higher-priority built-in tasks running on that core. Using unpinned tasks can improve the overall CPU utilization, however it makes reasoning about task scheduling more complex.

.. note::

    Ta"
"sk execution is always completely suspended when writing to the built-in SPI flash chip. Only :ref:`iram-safe-interrupt-handlers` continues executing.

Improving Interrupt Performance


ESP-IDF supports dynamic :doc:`/api-reference/system/intr_alloc` with interrupt preemption. Each interrupt in the system has a priority, and higher-priority interrupts preempts lower priority ones.

Interrupt handlers execute in preference to any task, provided the task is not inside a critical section. For this "
"reason, it is important to minimize the amount of time spent in executing an interrupt handler.

To obtain the best performance for a particular interrupt handler:

.. list::

    - Assign more important interrupts a higher priority using a flag such as ``ESP_INTR_FLAG_LEVEL2`` or ``ESP_INTR_FLAG_LEVEL3`` when calling :cpp:func:`esp_intr_alloc`.
    :SOC_HP_CPU_HAS_MULTIPLE_CORES: - Assign the interrupt on a CPU where built-in {IDF_TARGET_RF_TYPE} tasks are not configured to run, which means ass"
"igning the interrupt on Core 1 by default, see :ref:`built-in-task-priorities`. Interrupts are assigned on the same CPU where the :cpp:func:`esp_intr_alloc` function call is made.
    - If you are sure the entire interrupt handler can run from IRAM (see :ref:`iram-safe-interrupt-handlers`) then set the ``ESP_INTR_FLAG_IRAM`` flag when calling :cpp:func:`esp_intr_alloc` to assign the interrupt. This prevents it being temporarily disabled if the application firmware writes to the internal SPI flas"
"h.
    - Even if the interrupt handler is not IRAM-safe, if it is going to be executed frequently then consider moving the handler function to IRAM anyhow. This minimizes the chance of a flash cache miss when the interrupt code is executed (see :ref:`speed-targeted-optimizations`). It is possible to do this without adding the ``ESP_INTR_FLAG_IRAM`` flag to mark the interrupt as IRAM-safe, if only part of the handler is guaranteed to be in IRAM.

.. _improve-network-speed:

Improving Network Spee"
"d


.. list::

    :SOC_WIFI_SUPPORTED: * For Wi-Fi, see :ref:`How-to-improve-Wi-Fi-performance` and :ref:`wifi-buffer-usage`
    :SOC_WIFI_SUPPORTED: * The :example:`wifi/iperf` example contains a configuration that is heavily optimized for Wi-Fi TCP/IP throughput, usually at the expense of higher RAM usage. Append the contents of the files :example_file:`wifi/iperf/sdkconfig.defaults`, :example_file:`wifi/iperf/sdkconfig.defaults.{IDF_TARGET_PATH_NAME}` and :example_file:`wifi/iperf/sdkconfig."
"ci.99` to the ``sdkconfig`` file in your project in order to add all of these options. Note that some of these options may have trade-offs in terms of reduced debuggability, increased firmware size, increased memory usage, or reduced performance of other features. To get the best result, read the documentation pages linked above and use related information to determine exactly which options are best suited for your app.
    :SOC_EMAC_SUPPORTED: * The :example:`ethernet/iperf` example contains a "
"configuration that is heavily optimized for Ethernet TCP/IP throughput, usually at the expense of higher RAM usage. Examine :example_file:`ethernet/iperf/sdkconfig.defaults` for more details. Note that some of these options may have trade-offs in terms of reduced debuggability, increased firmware size, increased memory usage, or reduced performance of other features. To get the best result, read the documentation pages linked above and use related information to determine exactly which options a"
"re best suited for your app.

Improving I/O Performance


Using standard C library functions like ``fread`` and ``fwrite`` instead of platform specific unbuffered syscalls such as ``read`` and ``write`` can be slow.These functions are designed to be portable, so they are not necessarily optimized for speed, have a certain overhead and are buffered.

:doc:`/api-reference/storage/fatfs` specific information and tips:

.. list::

    - Maximum size of the R/W request = FatFS cluster size (allocatio"
"n unit size).
    - Use ``read`` and ``write`` instead of ``fread`` and ``fwrite``.
    - To increase speed of buffered reading functions like ``fread`` and ``fgets``, you can increase a size of the file buffer (Newlib's default is 128 bytes) to a higher number like 4096, 8192 or 16384. This can be done locally via the ``setvbuf`` function used on a certain file pointer or globally applied to all files via modifying :ref:`CONFIG_FATFS_VFS_FSTAT_BLKSIZE`.

        .. note::
            Setting a "
"bigger buffer size also increases the heap memory usage.
"
"Minimizing RAM Usage




{IDF_TARGET_STATIC_MEANS_HEAP:default=""Wi-Fi library, Bluetooth controller"", esp32s2=""Wi-Fi library"", esp32c6=""Wi-Fi library, Bluetooth controller, IEEE 802.15.4 library"", esp32h2=""Bluetooth controller, IEEE 802.15.4 library""}

In some cases, a firmware application's available RAM may run low or run out entirely. In these cases, it is necessary to tune the memory usage of the firmware application.

In general, firmware should aim to leave some headroom of free internal R"
"AM to deal with extraordinary situations or changes in RAM usage in future updates.

Background


Before optimizing ESP-IDF RAM usage, it is necessary to understand the basics of {IDF_TARGET_NAME} memory types, the difference between static and dynamic memory usage in C, and the way ESP-IDF uses stack and heap. This information can all be found in :doc:`/api-reference/system/mem_alloc`.

Measuring Static Memory Usage


The :ref:`idf.py` tool can be used to generate reports about the static memor"
"y usage of an application, see :ref:`idf.py-size`.

Measuring Dynamic Memory Usage


ESP-IDF contains a range of heap APIs for measuring free heap at runtime, see :doc:`/api-reference/system/heap_debug`.

.. note::

   In embedded systems, heap fragmentation can be a significant issue alongside total RAM usage. The heap measurement APIs provide ways to measure the largest free block. Monitoring this value along with the total number of free bytes can give a quick indication of whether heap fragm"
"entation is becoming an issue.

Reducing Static Memory Usage


- Reducing the static memory usage of the application increases the amount of RAM available for heap at runtime, and vice versa.
- Generally speaking, minimizing static memory usage requires monitoring the ``.data`` and ``.bss`` sizes. For tools to do this, see :ref:`idf.py-size`.
- Internal ESP-IDF functions do not make heavy use of static RAM in C. In many instances (such as {IDF_TARGET_STATIC_MEANS_HEAP}), static buffers are still"
" allocated from the heap. However, the allocation is performed only once during feature initialization and will be freed if the feature is deinitialized. This approach is adopted to optimize the availability of free memory at various stages of the application's life cycle.

To minimize static memory use:

.. list::

   - Constant data can be stored in flash memory instead of RAM, thus it is recommended to declare structures, buffers, or other variables as ``const``. This approach may require mod"
"ifying firmware functions to accept ``const *`` arguments instead of mutable pointer arguments. These changes can also help reduce the stack usage of certain functions.
   :SOC_BT_SUPPORTED: - If using Bluedroid, setting the option :ref:`CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY` will cause Bluedroid to allocate memory on initialization and free it on deinitialization. This does not necessarily reduce the peak memory usage, but changes it from static memory usage to runtime memory usage.
   - If using Op"
"enThread, enabling the option :ref:`CONFIG_OPENTHREAD_PLATFORM_MSGPOOL_MANAGEMENT` will cause OpenThread to allocate message pool buffers from PSRAM, which will reduce static memory use.

.. _optimize-stack-sizes:

Reducing Stack Sizes


In FreeRTOS, task stacks are usually allocated from the heap. The stack size for each task is fixed and passed as an argument to :cpp:func:`xTaskCreate`. Each task can use up to its allocated stack size, but using more than this will cause an otherwise valid pro"
"gram to crash, with a stack overflow or heap corruption.

Therefore, determining the optimum sizes of each task stack, minimizing the required size of each task stack, and minimizing the number of task stacks as whole, can all substantially reduce RAM usage.

To determine the optimum size for a particular task stack, users can consider the following methods:

- At runtime, call the function :cpp:func:`uxTaskGetStackHighWaterMark` with the handle of any task where you think there is unused stack "
"memory. This function returns the minimum lifetime free stack memory in bytes.

  - The easiest time to call :cpp:func:`uxTaskGetStackHighWaterMark` is from the task itself: call ``uxTaskGetStackHighWaterMark(NULL)`` to get the current task's high water mark after the time that the task has achieved its peak stack usage, i.e., if there is a main loop, execute the main loop a number of times with all possible states, and then call :cpp:func:`uxTaskGetStackHighWaterMark`.
  - Often, it is possible"
" to subtract almost the entire value returned here from the total stack size of a task, but allow some safety margin to account for unexpected small increases in stack usage at runtime.

- Call :cpp:func:`uxTaskGetSystemState` at runtime to get a summary of all tasks in the system. This includes their individual stack high watermark values.
- When debugger watchpoints are not being used, users can set the :ref:`CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK` option. This will cause one of the watchpoin"
"ts to watch the last word of the task's stack. If that word is overwritten (such as in a stack overflow), a panic is triggered immediately. This is slightly more reliable than the default :ref:`CONFIG_FREERTOS_CHECK_STACKOVERFLOW` option of ``Check using canary bytes``, because the panic happens immediately, rather than on the next RTOS context switch. Neither option is perfect. In some cases, it is possible that the stack pointer skips the watchpoint or canary bytes and corrupts another region "
"of RAM instead.

To reduce the required size of a particular task stack, users can consider the following methods:

- Avoid stack heavy functions. String formatting functions (like ``printf()``) are particularly heavy users of the stack, so any task which does not ever call these can usually have its stack size reduced.

  - Enabling :ref:`newlib-nano-formatting` reduces the stack usage of any task that calls ``printf()`` or other C string formatting functions.

- Avoid allocating large variable"
"s on the stack. In C, any large structures or arrays allocated as an automatic variable (i.e., default scope of a C declaration) uses space on the stack. To minimize the sizes of these, allocate them statically and/or see if you can save memory by dynamically allocating them from the heap only when they are needed.
- Avoid deep recursive function calls. Individual recursive function calls do not always add a lot of stack usage each time they are called, but if each function includes large stack-"
"based variables then the overhead can get quite high.

To reduce the total number of tasks, users can consider the following method:

- Combine tasks. If a particular task is never created, the task's stack is never allocated, thus reducing RAM usage significantly. Unnecessary tasks can typically be removed if those tasks can be combined with another task. In an application, tasks can typically be combined or removed if:

   - The work done by the tasks can be structured into multiple functions "
"that are called sequentially.
   - The work done by the tasks can be structured into smaller jobs that are serialized (via a FreeRTOS queue or similar) for execution by a worker task.

Internal Task Stack Sizes


ESP-IDF allocates a number of internal tasks for housekeeping purposes or operating system functions. Some are created during the startup process, and some are created at runtime when particular features are initialized.

The default stack sizes for these tasks are usually set conservat"
"ively high to allow all common usage patterns. Many of the stack sizes are configurable, and it may be possible to reduce them to match the real runtime stack usage of the task.

.. important::

   If internal task stack sizes are set too small, ESP-IDF will crash unpredictably. Even if the root cause is task stack overflow, this is not always clear when debugging. It is recommended that internal stack sizes are only reduced carefully (if at all), with close attention to high water mark free spa"
"ce under load. If reporting an issue that occurs when internal task stack sizes have been reduced, please always include the following information and the specific configuration that is being used.

.. list::

   - :ref:`app-main-task` has stack size :ref:`CONFIG_ESP_MAIN_TASK_STACK_SIZE`.
   - :doc:`/api-reference/system/esp_timer` system task which executes callbacks has stack size :ref:`CONFIG_ESP_TIMER_TASK_STACK_SIZE`.
   - FreeRTOS Timer Task to handle FreeRTOS timer callbacks has stack si"
"ze :ref:`CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH`.
   - :doc:`/api-reference/system/esp_event` system task to execute callbacks for the default system event loop has stack size :ref:`CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE`.
   - :doc:`/api-guides/lwip` TCP/IP task has stack size :ref:`CONFIG_LWIP_TCPIP_TASK_STACK_SIZE`.
   :SOC_BT_SUPPORTED: - :doc:`/api-reference/bluetooth/index` have task stack sizes :ref:`CONFIG_BT_BTC_TASK_STACK_SIZE`, :ref:`CONFIG_BT_BTU_TASK_STACK_SIZE`.
   :SOC_BT_SUPPORT"
"ED: - :doc:`/api-reference/bluetooth/nimble/index` has task stack size :ref:`CONFIG_BT_NIMBLE_HOST_TASK_STACK_SIZE`.
   - The Ethernet driver creates a task for the MAC to receive Ethernet frames. If using the default config ``ETH_MAC_DEFAULT_CONFIG`` then the task stack size is 4 KB. This setting can be changed by passing a custom :cpp:class:`eth_mac_config_t` struct when initializing the Ethernet MAC.
   - FreeRTOS idle task stack size is configured by :ref:`CONFIG_FREERTOS_IDLE_TASK_STACKSIZE"
"`.
   - If using the :doc:`/api-reference/protocols/mqtt` component, it creates a task with stack size configured by :ref:`CONFIG_MQTT_TASK_STACK_SIZE`. MQTT stack size can also be configured using ``task_stack`` field of :cpp:class:`esp_mqtt_client_config_t`.
   - To see how to optimize RAM usage when using ``mDNS``, please check `Minimizing RAM Usage `__.

.. note::

   Aside from built-in system features such as ESP-timer, if an ESP-IDF feature is not initialized by the firmware, then no asso"
"ciated task is created. In those cases, the stack usage is zero, and the stack-size configuration for the task is not relevant.

Reducing Heap Usage


For functions that assist in analyzing heap usage at runtime, see :doc:`/api-reference/system/heap_debug`.

Normally, optimizing heap usage consists of analyzing the usage and removing calls to ``malloc()`` that are not being used, reducing the corresponding sizes, or freeing previously allocated buffers earlier.

There are some ESP-IDF configurat"
"ion options that can reduce heap usage at runtime:

.. list::

   - lwIP documentation has a section to configure :ref:`lwip-ram-usage`.
   :SOC_WIFI_SUPPORTED: - :ref:`wifi-buffer-usage` describes options to either reduce the number of static buffers or reduce the maximum number of dynamic buffers in use, so as to minimize memory usage at a possible cost of performance. Note that static Wi-Fi buffers are still allocated from the heap when Wi-Fi is initialized, and will be freed if Wi-Fi is dein"
"itialized.
   :esp32: - The Ethernet driver allocates DMA buffers for the internal Ethernet MAC when it is initialized - configuration options are :ref:`CONFIG_ETH_DMA_BUFFER_SIZE`, :ref:`CONFIG_ETH_DMA_RX_BUFFER_NUM`, :ref:`CONFIG_ETH_DMA_TX_BUFFER_NUM`.
   - Several Mbed TLS configuration options can be used to reduce heap memory usage. See the :ref:`reducing_ram_usage_mbedtls` docs for details.
   :esp32: - In single-core mode only, it is possible to use IRAM as byte-accessible memory added t"
"o the regular heap by enabling :ref:`CONFIG_ESP32_IRAM_AS_8BIT_ACCESSIBLE_MEMORY`. Note that this option carries a performance penalty, and the risk of security issues caused by executable data. If this option is enabled, then it is possible to set other options to prefer certain buffers allocated from this memory: :ref:`CONFIG_MBEDTLS_MEM_ALLOC_MODE`, :ref:`NimBLE `.
   :esp32: - Reduce :ref:`CONFIG_BTDM_CTRL_BLE_MAX_CONN` if using Bluetooth LE.
   :esp32: - Reduce :ref:`CONFIG_BTDM_CTRL_BR_EDR"
"_MAX_ACL_CONN` if using Bluetooth Classic.

.. note::

   There are other configuration options that increases heap usage at runtime if changed from the defaults. These options are not listed above, but the help text for the configuration item will mention if there is some memory impact.

.. _optimize-iram-usage:

Optimizing IRAM Usage


.. only:: not esp32

   The available DRAM at runtime for heap usage is also reduced by the static IRAM usage. Therefore, one way to increase available DRAM is "
"to reduce IRAM usage.

If the app allocates more static IRAM than available, then the app will fail to build, and linker errors such as ``section '.iram0.text' will not fit in region 'iram0_0_seg'``, ``IRAM0 segment data does not fit``, and ``region 'iram0_0_seg' overflowed by 84-bytes`` will be seen. If this happens, it is necessary to find ways to reduce static IRAM usage in order to link the application.

To analyze the IRAM usage in the firmware binary, use :ref:`idf.py-size`. If the firmwar"
"e failed to link, steps to analyze are shown at :ref:`idf-size-linker-failed`.

The following options will reduce IRAM usage of some ESP-IDF features:

.. list::

    - Enable :ref:`CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH`. Provided these functions are not incorrectly used from ISRs, this option is safe to enable in all configurations.
    - Enable :ref:`CONFIG_RINGBUF_PLACE_FUNCTIONS_INTO_FLASH`. Provided these functions are not incorrectly used from ISRs, this option is safe to enable in al"
"l configurations.
    - Enable :ref:`CONFIG_RINGBUF_PLACE_ISR_FUNCTIONS_INTO_FLASH`. This option is not safe to use if the ISR ringbuf functions are used from an IRAM interrupt context, e.g., if :ref:`CONFIG_UART_ISR_IN_IRAM` is enabled. For the ESP-IDF drivers where this is the case, you can get an error at run-time when installing the driver in question.
    :SOC_WIFI_SUPPORTED: - Disabling Wi-Fi options :ref:`CONFIG_ESP_WIFI_IRAM_OPT` and/or :ref:`CONFIG_ESP_WIFI_RX_IRAM_OPT` options frees av"
"ailable IRAM at the cost of Wi-Fi performance.
    :CONFIG_ESP_ROM_HAS_SPI_FLASH: - Enabling :ref:`CONFIG_SPI_FLASH_ROM_IMPL` frees some IRAM but means that esp_flash bugfixes and new flash chip support are not available, see :doc:`/api-reference/peripherals/spi_flash/spi_flash_idf_vs_rom` for details.
    :esp32: - Disabling :ref:`CONFIG_SPI_FLASH_ROM_DRIVER_PATCH` frees some IRAM but is only available in some flash configurations, see the configuration item help text.
    :esp32: - If the appl"
"ication uses PSRAM and is based on ESP32 rev. 3 (ECO3), setting :ref:`CONFIG_ESP32_REV_MIN` to ``3`` disables PSRAM bug workarounds, saving 10 KB or more of IRAM.
    - Disabling :ref:`CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR` prevents posting ``esp_event`` events from :ref:`iram-safe-interrupt-handlers` but saves some IRAM.
    - Disabling :ref:`CONFIG_SPI_MASTER_ISR_IN_IRAM` prevents spi_master interrupts from being serviced while writing to flash, and may otherwise reduce spi_master performance, b"
"ut saves some IRAM.
    - Disabling :ref:`CONFIG_SPI_SLAVE_ISR_IN_IRAM` prevents spi_slave interrupts from being serviced while writing to flash, which saves some IRAM.
    - Setting :ref:`CONFIG_HAL_DEFAULT_ASSERTION_LEVEL` to disable assertion for HAL component saves some IRAM, especially for HAL code who calls ``HAL_ASSERT`` a lot and resides in IRAM.
    - Refer to the sdkconfig menu ``Auto-detect Flash chips``, and you can disable flash drivers which you do not need to save some IRAM.
    -"
" Enable :ref:`CONFIG_HEAP_PLACE_FUNCTION_INTO_FLASH`. Provided that :ref:`CONFIG_SPI_MASTER_ISR_IN_IRAM` is not enabled and the heap functions are not incorrectly used from ISRs, this option is safe to enable in all configurations.
    :esp32c2: - Enable :ref:`CONFIG_BT_RELEASE_IRAM`. Release BT text section and merge BT data, bss & text into a large free heap region when ``esp_bt_mem_release`` is called. This makes Bluetooth unavailable until the next restart, but saving ~22 KB or more of IRAM."
"

.. only:: esp32

   Using SRAM1 for IRAM
   

   The SRAM1 memory area is normally used for DRAM, but it is possible to use parts of it for IRAM with :ref:`CONFIG_ESP_SYSTEM_ESP32_SRAM1_REGION_AS_IRAM`. This memory would previously be reserved for DRAM data usage (e.g., ``.bss``) by the software bootloader and later added to the heap. After this option was introduced, the bootloader DRAM size was reduced to a value closer to what it normally actually needs.

   To use this option, ESP-IDF shou"
"ld be able to recognize that the new SRAM1 area is also a valid load address for an image segment. If the software bootloader was compiled before this option existed, then the bootloader will not be able to load the app that has code placed in this new extended IRAM area. This would typically happen if you are doing an OTA update, where only the app would be updated.

   If the IRAM section were to be placed in an invalid area, then this would be detected during the bootup process, and result in"
" a failed boot:

   .. code-block:: text

      E (204) esp_image: Segment 5 0x400845f8-0x400a126c invalid: bad load address range

   .. warning::

      Apps compiled with :ref:`CONFIG_ESP_SYSTEM_ESP32_SRAM1_REGION_AS_IRAM` may fail to boot, if used together with a software bootloader that was compiled before this config option was introduced. If you are using an older bootloader and updating over OTA, please test carefully before pushing any updates.

   Any memory that ends up unused for sta"
"tic IRAM will be added to the heap.

.. only:: esp32c3

    Flash Suspend Feature
    

    When using SPI flash driver API and other APIs based on the former (NVS, Partition APIs, etc.), the Cache will be disabled. During this period, any code executed must reside in internal RAM, see :ref:`concurrency-constraints-flash`. Hence, interrupt handlers that are not in internal RAM will not be executed.

    To achieve this, ESP-IDF drivers usually have the following two options:

    - Place the dri"
"ver's internal ISR handler in the internal RAM.
    - Place some control functions in the internal RAM.

    User ISR callbacks and involved variables have to be in internal RAM if they are also used in interrupt contexts.

    Placing additional code into IRAM will exacerbate IRAM usage. For this reason, there is :ref:`CONFIG_SPI_FLASH_AUTO_SUSPEND`, which can alleviate the aforementioned kinds of IRAM usage. By enabling this feature, the Cache will not be disabled when SPI flash driver APIs an"
"d SPI flash driver-based APIs are used. Therefore, code and data in flash can be executed or accessed normally, but with some minor delay. See :ref:`auto-suspend` for more details about this feature.

    Regarding the flash suspend feature usage, and corresponding response time delay, please also see this example :example:`system/flash_suspend`.


.. only:: esp32

    Putting C Library in Flash
    

    When compiling for ESP32 revisions older than ECO3 (:ref:`CONFIG_ESP32_REV_MIN`), the PSRAM"
" Cache bug workaround (:ref:`CONFIG_SPIRAM_CACHE_WORKAROUND`) option is enabled, and the C library functions normally located in ROM are recompiled with the workaround and placed into IRAM instead. For most applications, it is safe to move many of the C library functions into flash, reclaiming some IRAM. Corresponding options include:

    .. list::

        - :ref:`CONFIG_SPIRAM_CACHE_LIBJMP_IN_IRAM`: affects the functions ``longjmp`` and ``setjump``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBMATH"
"_IN_IRAM`: affects the functions ``abs``, ``div``, ``labs``, ``ldiv``, ``quorem``, ``fpclassify`` and ``nan``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBNUMPARSER_IN_IRAM`: affects the functions ``utoa``, ``itoa``, ``atoi``, ``atol``, ``strtol``, and ``strtoul``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBIO_IN_IRAM`: affects the functions ``wcrtomb``, ``fvwrite``, ``wbuf``, ``wsetup``, ``fputwc``, ``wctomb_r``, ``ungetc``, ``makebuf``, ``fflush``, ``refill``, and ``sccl``.
        - :ref:`CONFIG_SPIRA"
"M_CACHE_LIBTIME_IN_IRAM`: affects the functions ``asctime``, ``asctime_r``, ``ctime``, ``ctime_r``, ``lcltime``, ``lcltime_r``, ``gmtime``, ``gmtime_r``, ``strftime``, ``mktime``, ``tzset_r``, ``tzset``, ``time``, ``gettzinfo``, ``systimes``, ``month_lengths``, ``timelocal``, ``tzvars``, ``tzlock``, ``tzcalc_limits``, and ``strptime``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBCHAR_IN_IRAM`: affects the functions ``ctype_``, ``toupper``, ``tolower``, ``toascii``, ``strupr``, ``bzero``, ``isalnum``,"
" ``isalpha``, ``isascii``, ``isblank``, ``iscntrl``, ``isdigit``, ``isgraph``, ``islower``, ``isprint``, ``ispunct``, ``isspace``, and ``isupper``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBMEM_IN_IRAM`: affects the functions ``memccpy``, ``memchr``, ``memmove``, and ``memrchr``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBSTR_IN_IRAM`: affects the functions ``strcasecmp``, ``strcasestr``, ``strchr``, ``strcoll``, ``strcpy``, ``strcspn``, ``strdup``, ``strdup_r``, ``strlcat``, ``strlcpy``, ``strlen``, `"
"`strlwr``, ``strncasecmp``, ``strncat``, ``strncmp``, ``strncpy``, ``strndup``, ``strndup_r``, ``strrchr``, ``strsep``, ``strspn``, ``strstr``, ``strtok_r, and ``strupr``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBRAND_IN_IRAM`: affects the functions ``srand``, ``rand``, and ``rand_r``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBENV_IN_IRAM`: affects the functions ``environ``, ``envlock``, and ``getenv_r``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBFILE_IN_IRAM`: affects the functions ``lock``, ``isatty``"
", ``fclose``, ``open``, ``close``, ``creat``, ``read``, ``rshift``, ``sbrk``, ``stdio``, ``syssbrk``, ``sysclose``, ``sysopen``, ``creat``, ``sysread``, ``syswrite``, ``impure``, ``fwalk``, and ``findfp``.
        - :ref:`CONFIG_SPIRAM_CACHE_LIBMISC_IN_IRAM`: affects the functions ``raise`` and ``system``.

    The exact amount of IRAM saved will depend on how much C library code is actually used by the application. In addition, the following options may be used to move more of the C library cod"
"e into flash, however note that this may result in reduced performance. Be careful not to use the C library function allocated with :c:macro:`ESP_INTR_FLAG_IRAM` flag from interrupts when cache is disabled, refer to :ref:`iram-safe-interrupt-handlers` for more details. For these reasons, the functions ``itoa``, ``memcmp``, ``memcpy``, ``memset``, ``strcat``, ``strcmp``, and ``strlen`` are always put in IRAM.

.. note::

    Moving frequently-called functions from IRAM to flash may increase their"
" execution time.

.. note::

    Other configuration options exist that will increase IRAM usage by moving some functionality into IRAM, usually for performance, but the default option is not to do this. These are not listed here. The IRAM size impact of enabling these options is usually noted in the configuration item help text.
"
"Libraries and Frameworks



.. toctree::
   :maxdepth: 1

   cloud-frameworks
   libs-frameworks
"
"Espressif's Frameworks



Here you will find a collection of the official Espressif libraries and frameworks.

Espressif Audio Development Framework


The ESP-ADF is a comprehensive framework for audio applications including:

This framework is available on GitHub: `ESP-ADF `_.

ESP-CSI


ESP-CSI is an experimental implementation that uses the Wi-Fi Channel State Information to detect the presence of a human body.

See the `ESP-CSI `_ project for more information.

Espressif DSP Library


The li"
"brary provides algorithms optimized specifically for digital signal processing applications. This library supports:

This library is available on Github: `ESP-DSP library `_.

ESP-WIFI-MESH Development Framework


This framework is based on the ESP-WIFI-MESH protocol with the following features:

This framework is available on Github: `ESP-MDF `_.

ESP-WHO


The ESP-WHO is a face detection and recognition framework using the ESP32 and camera.

This framework is available on Github: `ESP-WHO `_.
"
"
ESP RainMaker


`ESP RainMaker `_ is a complete solution for accelerated AIoT development. Using ESP RainMaker, you can create AIoT devices from the firmware to the integration with voice-assistant, phone apps and cloud backend.

This project is available on Github: `ESP RainMaker on GitHub `_.

ESP-IoT-Solution


`ESP-IoT-Solution `_ contains commonly used device drivers and code frameworks when developing IoT systems. The device drivers and code frameworks within the ESP-IoT-Solution are orga"
"nized as separate components, allowing them to be easily integrated into an ESP-IDF project.

ESP-IoT-Solution includes:

This solution is available on Github: `ESP-IoT-Solution on GitHub `_.


ESP-Protocols


The `ESP-Protocols `_ repository contains a collection of protocol components for ESP-IDF. The code within ESP-Protocols is organized into separate components, allowing them to be easily integrated into an ESP-IDF project. Additionally, each component is available in `IDF Component Registr"
"y `_.

ESP-Protocols components:

ESP-BSP


The `ESP-BSP `_ repository contains Board Support Packages (BSPs) for various Espressif's and third-party development boards. BSPs help to quickly get started with a supported board. Usually they contain pinout definition and helper functions that will initialize peripherals for the specific board. Additionally, the BSPs contain drivers for external chips populated on the development board, such as sensors, displays, audio codecs, etc.

ESP-IDF-CXX


`"
"ESP-IDF-CXX `_ contains C++ wrappers for part of ESP-IDF. The focuses are on ease of use, safety, automatic resource management. They also move error checking from runtime to compile time to prevent running failure. There are C++ classes for ESP-Timer, I2C, SPI, GPIO and other peripherals or features of ESP-IDF. ESP-IDF-CXX is `available as a component `_ from the component registry. Please check the project's `README.md `_ for more information.
"
"Cloud Frameworks


{IDF_TARGET_NAME} supports multiple cloud frameworks using agents built on top of ESP-IDF. Here are the pointers to various supported cloud frameworks' agents and examples:


ESP RainMaker


`ESP RainMaker `_ is a complete solution for accelerated AIoT development. `ESP RainMaker on GitHub `_.

AWS IoT


`https://github.com/espressif/esp-aws-iot `_ is an open source repository for {IDF_TARGET_NAME} based on Amazon Web Services' `aws-iot-device-sdk-embedded-C `_.

Azure IoT


`"
"https://github.com/espressif/esp-azure `_ is an open source repository for {IDF_TARGET_NAME} based on Microsoft Azure's `azure-iot-sdk-c SDK `_.

Google IoT Core


`https://github.com/espressif/esp-google-iot `_ is an open source repository for {IDF_TARGET_NAME} based on Google's `iot-device-sdk-embedded-c SDK `_.

Aliyun IoT


`https://github.com/espressif/esp-aliyun `_ is an open source repository for {IDF_TARGET_NAME} based on Aliyun's `iotkit-embedded SDK `_.

Joylink IoT


`https://github.c"
"om/espressif/esp-joylink `_ is an open source repository for {IDF_TARGET_NAME} based on Joylink's `joylink_dev_sdk SDK `_.

Tencent IoT


`https://github.com/espressif/esp-welink `_ is an open source repository for {IDF_TARGET_NAME} based on Tencent's `welink SDK `_.

Tencentyun IoT


`https://github.com/espressif/esp-qcloud `_ is an open source repository for {IDF_TARGET_NAME} based on Tencentyun's `qcloud-iot-sdk-embedded-c SDK `_.

Baidu IoT


`https://github.com/espressif/esp-baidu-iot `_ is"
" an open source repository for {IDF_TARGET_NAME} based on Baidu's `iot-sdk-c SDK `_.
"
"
Get Started




.. Please keep README.md in sync with these instructions.

This document is intended to help you set up the software development environment for the hardware based on the {IDF_TARGET_NAME} chip by Espressif. After that, a simple example will show you how to use ESP-IDF (Espressif IoT Development Framework) for menu configuration, then for building and flashing firmware onto an {IDF_TARGET_NAME} board.

.. include-build-file:: inc/version-note.inc

Introduction


{IDF_TARGET_NAME"
"} is a system on a chip that integrates the following features:

.. only:: esp32

.. only:: esp32s2

.. only:: esp32s3

.. only:: esp32c3

.. only:: esp32c2

.. only:: esp32c6

.. only:: esp32h2

Powered by 40 nm technology, {IDF_TARGET_NAME} provides a robust, highly integrated platform, which helps meet the continuous demands for efficient power usage, compact design, security, high performance, and reliability.

Espressif provides basic hardware and software resources to help application deve"
"lopers realize their ideas using the {IDF_TARGET_NAME} series hardware. The software development framework by Espressif is intended for development of Internet-of-Things (IoT) applications with Wi-Fi, Bluetooth, power management and several other system features.

What You Need


Hardware
~~~~~~~~

.. note:: Currently, some of the development boards are using USB Type C connectors. Be sure you have the correct cable to connect your board!

If you have one of {IDF_TARGET_NAME} official developmen"
"t boards listed below, you can click on the link to learn more about the hardware.

.. only:: esp32

    .. toctree::
        :maxdepth: 1

        ESP32-DevKitC 
        ESP-WROVER-KIT 
        ESP32-PICO-KIT 
        ESP32-Ethernet-Kit 
        ESP32-DevKit-S(-R) 
        ESP32-PICO-KIT-1 
        ESP32-PICO-DevKitM-2 
        ESP32-DevKitM-1 

.. only:: esp32s2

    .. toctree::
        :maxdepth: 1

        ESP32-S2-Saola-1 
        ESP32-S2-DevKitM-1 
        ESP32-S2-DevKitC-1 
        ESP"
"32-S2-Kaluga-Kit 

.. only:: esp32c3

    .. toctree::
        :maxdepth: 1

        ESP32-C3-DevKitM-1 
        ESP32-C3-DevKitC-02 


.. only:: esp32s3

    .. toctree::
        :maxdepth: 1

        ESP32-S3-DevKitC-1 
        ESP32-S3-DevKitM-1 

.. only:: esp32c2

    .. toctree::
        :maxdepth: 1

        ESP8684-DevKitM-1 

.. only:: esp32c6

    .. toctree::
        :maxdepth: 1

        ESP32-C6-DevKitC-1 
        ESP32-C6-DevKitM-1 

.. _get-started-get-prerequisites:

Software
~~~"
"~~~~~

To start using ESP-IDF on **{IDF_TARGET_NAME}**, install the following software:

.. figure:: ../../_static/what-you-need.png
    :align: center
    :alt: Development of applications for {IDF_TARGET_NAME}
    :figclass: align-center

.. _get-started-step-by-step:
.. _get-started-how-to-get-esp-idf:

Installation


To install all the required software, we offer some different ways to facilitate this task. Choose from one of the available options.

IDE
~~~

.. note:: We highly recommend ins"
"talling the ESP-IDF through your favorite IDE.

Manual Installation
~~~~~~~~~~~~~~~~~~~

For the manual procedure, please select according to your operating system.

.. toctree::
    :maxdepth: 1

    Windows Installer 
    Linux and macOS 

Build Your First Project


If you already have the ESP-IDF installed and are not using an IDE, you can build your first project from the command line following the :ref:`Start a Project on Windows ` or :ref:`Start a Project on Linux and macOS `.

.. _Stable "
"version: https://docs.espressif.com/projects/esp-idf/en/stable/

Uninstall ESP-IDF


If you want to remove ESP-IDF, please follow :ref:`idf-tools-uninstall`.
"
"
Standard Setup of Toolchain for Windows




Introduction


ESP-IDF requires some prerequisite tools to be installed so you can build firmware for supported chips. The prerequisite tools include Python, Git, cross-compilers, CMake and Ninja build tools.

For this Getting Started we are going to use the Command Prompt, but after ESP-IDF is installed you can use `Eclipse Plugin `_ or another graphical IDE with CMake support instead.

.. note::
    Limitations:
    - The installation path of ESP-ID"
"F and ESP-IDF Tools must not be longer than 90 characters. Too long installation paths might result in a failed build.
    - The installation path of Python or ESP-IDF must not contain white spaces or parentheses.
    - The installation path of Python or ESP-IDF should not contain special characters (non-ASCII) unless the operating system is configured with ""Unicode UTF-8"" support.

    System Administrator can enable the support via ``Control Panel`` > Change ``date``, ``time``, or ``number`` f"
"ormats > ``Administrative tab`` > Change ``system locale`` > check the option ``Beta: Use Unicode UTF-8 for worldwide language support`` > ``Ok`` > reboot the computer.

.. _get-started-windows-tools-installer:

ESP-IDF Tools Installer


The easiest way to install ESP-IDF's prerequisites is to download one of ESP-IDF Tools Installers.

+++
| |download-logo|   | `Windows Installer Download`_  |
+++

.. |download-logo| image:: ../../_static/logo_windows_install.png
    :target: https://dl.espressi"
"f.com/dl/esp-idf/?idf=4.4

.. _Windows Installer Download: https://dl.espressif.com/dl/esp-idf/?idf=4.4


What Is the Usecase for Online and Offline Installer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Online Installer is very small and allows the installation of all available releases of ESP-IDF. The installer downloads only necessary dependencies including `Git For Windows`_  during the installation process. The installer stores downloaded files in the cache directory ``%userprofile"
"%\.espressif``

Offline Installer does not require any network connection. The installer contains all required dependencies including `Git For Windows`_ .

Components of the Installation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The installer deploys the following components:

- Embedded Python
- Cross-compilers
- OpenOCD
- CMake_ and Ninja_ build tools
- ESP-IDF

The installer also allows reusing the existing directory with ESP-IDF. The recommended directory is ``%userprofile%\Desktop\esp-idf`` where ``%"
"userprofile%`` is your home directory.

Launching ESP-IDF Environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At the end of the installation process you can check out option ``Run ESP-IDF PowerShell Environment`` or ``Run ESP-IDF Command Prompt (cmd.exe)``. The installer launches ESP-IDF environment in selected prompt.

``Run ESP-IDF PowerShell Environment``:

.. figure:: ../../_static/esp-idf-installer-screenshot-powershell.png
    :align: center
    :alt: Completing the ESP-IDF Tools Setup Wizard with "
"Run ESP-IDF PowerShell Environment
    :figclass: align-center

    Completing the ESP-IDF Tools Setup Wizard with Run ESP-IDF PowerShell Environment

.. figure:: ../../_static/esp-idf-installer-powershell.png
    :align: center
    :alt: ESP-IDF PowerShell
    :figclass: align-center

    ESP-IDF PowerShell

``Run ESP-IDF Command Prompt (cmd.exe)``:

.. figure:: ../../_static/esp-idf-installer-screenshot.png
    :align: center
    :alt: Completing the ESP-IDF Tools Setup Wizard with Run ESP-IDF"
" Command Prompt (cmd.exe)
    :figclass: align-center

    Completing the ESP-IDF Tools Setup Wizard with Run ESP-IDF Command Prompt (cmd.exe)

.. figure:: ../../_static/esp-idf-installer-command-prompt.png
    :align: center
    :alt: ESP-IDF Command Prompt
    :figclass: align-center

    ESP-IDF Command Prompt

Using the Command Prompt


For the remaining Getting Started steps, we are going to use the Windows Command Prompt.

ESP-IDF Tools Installer also creates a shortcut in the Start menu t"
"o launch the ESP-IDF Command Prompt. This shortcut launches the Command Prompt (cmd.exe) and runs ``export.bat`` script to set up the environment variables (``PATH``, ``IDF_PATH`` and others). Inside this command prompt, all the installed tools are available.

Note that this shortcut is specific to the ESP-IDF directory selected in the ESP-IDF Tools Installer. If you have multiple ESP-IDF directories on the computer (for example, to work with different versions of ESP-IDF), you have two options "
"to use them:

First Steps on ESP-IDF


.. _get-started-windows-first-steps:

.. include:: windows-start-project.rst
.. include:: start-project.rst

Related Documents


For advanced users who want to customize the install process:

.. toctree::
    :hidden:
    :maxdepth: 1

    windows-setup-update
    establish-serial-connection
    flashing-troubleshooting

.. _CMake: https://cmake.org/download/
.. _Ninja: https://ninja-build.org/
.. _Python: https://www.python.org/downloads/windows/
.. _Git f"
"or Windows: https://gitforwindows.org/
.. _Github Desktop: https://desktop.github.com/
"
"
Standard Toolchain Setup for Linux and macOS




Installation Step by Step


This is a detailed roadmap to walk you through the installation process.

Setting up Development Environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These are the steps for setting up the ESP-IDF for your {IDF_TARGET_NAME}.

.. _get-started-prerequisites:

Step 1. Install Prerequisites


In order to use ESP-IDF with the {IDF_TARGET_NAME}, you need to install some software packages based on your Operating System. This setup"
" guide helps you on getting everything installed on Linux and macOS based systems.

For Linux Users
~~~~~~~~~~~~~~~

To compile using ESP-IDF, you need to get the following packages. The command to run depends on which distribution of Linux you are using:

- Ubuntu and Debian::

    sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0

- CentOS 7 & 8::

    sudo yum -y update && sudo yum install git w"
"get flex bison gperf python3 cmake ninja-build ccache dfu-util libusbx

CentOS 7 is still supported but CentOS version 8 is recommended for a better user experience.

- Arch::

    sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb

.. note::
    - CMake version 3.16 or newer is required for use with ESP-IDF. Run ""tools/idf_tools.py install cmake"" to install a suitable version if your OS versions does not have one.
    - If you do not see your Linux d"
"istribution in the above list then please check its documentation to find out which command to use for package installation.

For macOS Users
~~~~~~~~~~~~~~~

ESP-IDF uses the version of Python installed by default on macOS.

- Install CMake & Ninja build:

  - If you have HomeBrew_, you can run::

      brew install cmake ninja dfu-util

  - If you have MacPorts_, you can run::

      sudo port install cmake ninja dfu-util

  - Otherwise, consult the CMake_ and Ninja_ home pages for macOS insta"
"llation downloads.

- It is strongly recommended to also install ccache_ for faster builds. If you have HomeBrew_, this can be done via ``brew install ccache`` or ``sudo port install ccache`` on MacPorts_.

.. note::
   If an error like this is shown during any step::

     xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun

   Then you need to install the XCode command line tools to continue. You"
" can install these by running ``xcode-select --install``.

Apple M1 Users
~~~~~~~~~~~~~~

If you use Apple M1 platform and see an error like this::

      WARNING: directory for tool xtensa-esp32-elf version esp-2021r2-patch3-8.4.0 is present, but tool was not found
      ERROR: tool xtensa-esp32-elf has no installed versions. Please run 'install.sh' to install it.

or::

      zsh: bad CPU type in executable: ~/.espressif/tools/xtensa-esp32-elf/esp-2021r2-patch3-8.4.0/xtensa-esp32-elf/bin/xtens"
"a-esp32-elf-gcc

Then you need to install Apple Rosetta 2 by running

.. code-block:: bash

    /usr/sbin/softwareupdate --install-rosetta --agree-to-license


Installing Python 3
~~~~~~~~~~~~~~~~~~~

Based on macOS `Catalina 10.15 release notes`_, use of Python 2.7 is not recommended and Python 2.7 is not included by default in future versions of macOS. Check what Python you currently have::

  python --version

If the output is like ``Python 2.7.17``, your default interpreter is Python 2.7. If"
" so, also check if Python 3 is not already installed on your computer::

  python3 --version

If the above command returns an error, it means Python 3 is not installed.

Below is an overview of the steps to install Python 3.

  - Installing with HomeBrew_ can be done as follows::

      brew install python3

  - If you have MacPorts_, you can run::

      sudo port install python38

.. _get-started-get-esp-idf:

Step 2. Get ESP-IDF


To build applications for the {IDF_TARGET_NAME}, you need the "
"software libraries provided by Espressif in `ESP-IDF repository `_.

To get ESP-IDF, navigate to your installation directory and clone the repository with ``git clone``, following instructions below specific to your operating system.

Open Terminal, and run the following commands:

.. include-build-file:: inc/git-clone-bash.inc

ESP-IDF is downloaded into ``~/esp/esp-idf``.

Consult :doc:`/versions` for information about which ESP-IDF version to use in a given situation.

.. _get-started-set-up-"
"tools:

Step 3. Set up the Tools


Aside from the ESP-IDF, you also need to install the tools used by ESP-IDF, such as the compiler, debugger, Python packages, etc, for projects supporting {IDF_TARGET_NAME}.

.. code-block:: bash

    cd ~/esp/esp-idf
    ./install.sh {IDF_TARGET_PATH_NAME}

or with Fish shell

.. code-block:: fish

    cd ~/esp/esp-idf
    ./install.fish {IDF_TARGET_PATH_NAME}

The above commands install tools for {IDF_TARGET_NAME} only. If you intend to develop projects for mo"
"re chip targets then you should list all of them and run for example:

.. code-block:: bash

    cd ~/esp/esp-idf
    ./install.sh esp32,esp32s2

or with Fish shell

.. code-block:: fish

    cd ~/esp/esp-idf
    ./install.fish esp32,esp32s2

In order to install tools for all supported targets please run the following command:

.. code-block:: bash

    cd ~/esp/esp-idf
    ./install.sh all

or with Fish shell

.. code-block:: fish

    cd ~/esp/esp-idf
    ./install.fish all

.. note::
   For m"
"acOS users, if an error like this is shown during any step::

     `_.

Alternative File Downloads
~~~~~~~~~~~~~~~~~~~~~~~~~~

The tools installer downloads a number of files attached to GitHub Releases. If accessing GitHub is slow then it is possible to set an environment variable to prefer Espressif's download server for GitHub asset downloads.

.. note:: This setting only controls individual tools downloaded from GitHub releases, it does not change the URLs used to access any Git repositories"
".

To prefer the Espressif download server when installing tools, use the following sequence of commands when running ``install.sh``:

.. code-block:: bash

    cd ~/esp/esp-idf
    export IDF_GITHUB_ASSETS=""dl.espressif.com/github_assets""
    ./install.sh

.. note::
    For users in China, we recommend using our download server located in China for faster download speed.

    .. code-block:: bash

        cd ~/esp/esp-idf
        export IDF_GITHUB_ASSETS=""dl.espressif.cn/github_assets""
        "
"./install.sh

Customizing the Tools Installation Path
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The scripts introduced in this step install compilation tools required by ESP-IDF inside the user home directory: ``$HOME/.espressif`` on Linux. If you wish to install the tools into a different directory, **export the environment variable IDF_TOOLS_PATH before running the installation scripts**. Make sure that your user account has sufficient permissions to read and write this path.

.. code-block:: b"
"ash

    export IDF_TOOLS_PATH=""$HOME/required_idf_tools_path""
    ./install.sh

    . ./export.sh

If changing the ``IDF_TOOLS_PATH``, make sure it is exported in the environment before running any ESP-IDF tools or scripts.

.. note::
    Using ``IDF_TOOLS_PATH`` in variable assignement, e.g., ``IDF_TOOLS_PATH=""$HOME/required_idf_tools_path"" ./install.sh``, without prior exporting, will not work in most shells because the variable assignment will not affect the current execution environment, ev"
"en if it's exported/changed in the sourced script.

.. _get-started-set-up-env:

Step 4. Set up the Environment Variables


The installed tools are not yet added to the PATH environment variable. To make the tools usable from the command line, some environment variables must be set. ESP-IDF provides another script which does that.

In the terminal where you are going to use ESP-IDF, run:

.. code-block:: bash

    . $HOME/esp/esp-idf/export.sh

or for fish (supported only since fish version 3.0."
"0):

.. code-block:: bash

    . $HOME/esp/esp-idf/export.fish

Note the space between the leading dot and the path!

If you plan to use esp-idf frequently, you can create an alias for executing ``export.sh``:

    .. code-block:: bash

        alias get_idf='. $HOME/esp/esp-idf/export.sh'

Now you can run ``get_idf`` to set up or refresh the esp-idf environment in any terminal session.

Technically, you can add ``export.sh`` to your shell's profile directly; however, it is not recommended. Doin"
"g so activates IDF virtual environment in every terminal session (including those where IDF is not needed), defeating the purpose of the virtual environment and likely affecting other software.

.. _get-started-start-a-project:
.. _get-started-build:
.. _get-started-configure:
.. _get-started-connect:
.. _get-started-linux-macos-first-steps:

Step 5. First Steps on ESP-IDF


.. include:: linux-macos-start-project.rst
.. include:: start-project.rst

Tip: Updating ESP-IDF


It is recommended to up"
"date ESP-IDF from time to time, as newer versions fix bugs and/or provide new features. Please note that each ESP-IDF major and minor release version has an associated support period, and when one release branch is approaching end of life (EOL), all users are encouraged to upgrade their projects to more recent ESP-IDF releases, to find out more about support periods, see :doc:`ESP-IDF Versions `.

The simplest way to do the update is to delete the existing ``esp-idf`` folder and clone it again, "
"as if performing the initial installation described in :ref:`get-started-get-esp-idf`.

Another solution is to update only what has changed. :ref:`The update procedure depends on the version of ESP-IDF you are using `.

After updating ESP-IDF, execute the Install script again, in case the new ESP-IDF version requires different versions of tools. See instructions at :ref:`get-started-set-up-tools`.

Once the new tools are installed, update the environment using the Export script. See instructions"
" at :ref:`get-started-set-up-env`.

Related Documents


.. toctree::
    :hidden:
    :maxdepth: 1

    establish-serial-connection
    flashing-troubleshooting

.. _AUR: https://wiki.archlinux.org/index.php/Arch_User_Repository
.. _First Steps on ESP-IDF: ../get-started/first-steps.html
.. _cmake: https://cmake.org/
.. _ninja: https://ninja-build.org/
.. _ccache: https://ccache.dev/
.. _homebrew: https://brew.sh/
.. _MacPorts: https://www.macports.org/install.php
.. _Catalina 10.15 release note"
"s: https://developer.apple.com/documentation/macos-release-notes/macos-catalina-10_15-release-notes
"
"{IDF_TARGET_FEATURES:default=""[NEEDS TO BE UPDATED]"", esp32=""WiFi/BT/BLE, silicon revision 1, 2 MB external flash"", esp32s2=""WiFi, silicon revision 0, 2 MB external flash"", esp32s3=""This is esp32s3 chip with 2 CPU core(s), WiFi/BLE, silicon revision 0, 2 MB external flash"", esp32c2=""WiFi/BLE, silicon revision 0, 2 MB embedded flash"", esp32c3=""WiFi/BLE, silicon revision 0, 2 MB external flash"", esp32c6=""WiFi/BLE, 802.15.4 (Zigbee/Thread), silicon revision v0.0, 2 MB external flash"", esp32h2=""BLE,"
" 802.15.4 (Zigbee/Thread), silicon revision v0.1, 2 MB external flash""}

{IDF_TARGET_HEAP_SIZE:default=""[NEEDS TO BE UPDATED]"", esp32=""298968"", esp32s2=""253900"", esp32s3=""390684"", esp32c2=""203888"", esp32c3=""337332"", esp32c6=""473816"", esp32h2=""268256""}

Build the Project


Build the project by running:

.. code-block:: batch

    idf.py build

This command compiles the application and all ESP-IDF components, then it generates the bootloader, partition table, and application binaries.

.. code-blo"
"ck:: none

    $ idf.py build
    Running cmake in directory /path/to/hello_world/build
    Executing ""cmake -G Ninja --warn-uninitialized /path/to/hello_world""...
    Warn about uninitialized values.
    -- Found Git: /usr/bin/git (found version ""2.17.0"")
    -- Building empty aws_iot component due to configuration
    -- Component names: ...
    -- Component paths: ...

    ... (more lines of build system output)

    [527/527] Generating hello_world.bin
    esptool.py v2.3.1

    Project buil"
"d complete. To flash, run this command:
    ../../../components/esptool_py/esptool/esptool.py -p (PORT) -b 921600 write_flash --flash_mode dio --flash_size detect --flash_freq 40m 0x10000 build/hello_world.bin  build 0x1000 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin
    or run 'idf.py -p PORT flash'

If there are no errors, the build finishes by generating the firmware binary .bin files.


Flash onto the Device


To flash the binaries that you just built for"
" the {IDF_TARGET_NAME} in the previous step, you need to run the following command:

.. code-block:: bash

    idf.py -p PORT flash

Replace ``PORT`` with your {IDF_TARGET_NAME} board's USB port name. If the ``PORT`` is not defined, the :ref:`idf.py` will try to connect automatically using the available USB ports.

For more information on ``idf.py`` arguments, see :ref:`idf.py`.

.. note::

    The option ``flash`` automatically builds and flashes the project, so running ``idf.py build`` is not "
"necessary.

Encountered Issues While Flashing? See the ""Additional Tips"" below. You can also refer to :doc:`flashing-troubleshooting` page or :doc:`establish-serial-connection` for more detailed information.

Normal Operation
~~~~~~~~~~~~~~~~

When flashing, you will see the output log similar to the following:

.. include:: {IDF_TARGET_PATH_NAME}_output_log.inc
   :start-after: output_log

If there are no issues by the end of the flash process, the board will reboot and start up the ""hello_worl"
"d"" application.

If you would like to use the Eclipse or VS Code IDE instead of running ``idf.py``, check out `Eclipse Plugin `_, `VSCode Extension `_.

Monitor the Output


To check if ""hello_world"" is indeed running, type ``idf.py -p PORT monitor`` (Do not forget to replace PORT with your serial port name).

This command launches the :doc:`IDF Monitor ` application::

    $ idf.py -p  monitor
    Running idf_monitor in directory [...]/esp/hello_world/build
    Executing ""python [...]/esp-idf/t"
"ools/idf_monitor.py -b 115200 [...]/esp/hello_world/build/hello_world.elf""...
    --- idf_monitor on  115200 ---
    --- Quit: Ctrl+] | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
    ets Jun  8 2016 00:22:57

    rst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
    ets Jun  8 2016 00:22:57
    ...

After startup and diagnostic logs scroll up, you should see ""Hello world!"" printed out by the application.

.. code-block:: none

        ...
        Hello world!
        Restarting in "
"10 seconds...
        This is {IDF_TARGET_PATH_NAME} chip with {IDF_TARGET_SOC_CPU_CORES_NUM} CPU core(s), {IDF_TARGET_FEATURES}
    Minimum free heap size: {IDF_TARGET_HEAP_SIZE} bytes
        Restarting in 9 seconds...
        Restarting in 8 seconds...
        Restarting in 7 seconds...

To exit IDF monitor use the shortcut ``Ctrl+]``.

.. only:: esp32 or esp32c2

    If IDF monitor fails shortly after the upload, or, if instead of the messages above, you see random garbage similar to what is"
" given below, your board is likely using a 26 MHz crystal. Most development board designs use 40 MHz, so ESP-IDF uses this frequency as a default value.

    .. figure:: ../../_static/get-started-garbled-output.png
        :align: center
        :alt: Garbled output
        :figclass: align-center

    If you have such a problem, do the following:

    In the current version of ESP-IDF, main XTAL frequencies supported by {IDF_TARGET_NAME} are as follows:

    .. list::

        :SOC_XTAL_SUPPORT"
"_24M: - 24 MHz
        :SOC_XTAL_SUPPORT_26M: - 26 MHz
        :SOC_XTAL_SUPPORT_32M: - 32 MHz
        :SOC_XTAL_SUPPORT_40M: - 40 MHz

.. note::

    You can combine building, flashing and monitoring into one step by running::

        idf.py -p PORT flash monitor

See also:

- :doc:`IDF Monitor ` for handy shortcuts and more details on using IDF monitor.
- :ref:`idf.py` for a full reference of ``idf.py`` commands and options.

**That is all that you need to get started with {IDF_TARGET_NAME}!*"
"*

Now you are ready to try some other :idf:`examples`, or go straight to developing your own applications.

.. important::

    Some of examples do not support {IDF_TARGET_NAME} because required hardware is not included in {IDF_TARGET_NAME} so it cannot be supported.

    If building an example, please check the README file for the ``Supported Targets`` table. If this is present including {IDF_TARGET_NAME} target, or the table does not exist at all, the example will work on {IDF_TARGET_NAME}.

"
"

Additional Tips


Permission Denied Issue
~~~~~~~~~~~~~~~~~~~~~~~~

With some Linux distributions, you may get the error message similar to ``Could not open port : Permission denied: ''`` when flashing the {IDF_TARGET_NAME}. :ref:`This can be solved by adding the current user to the specific group `, such as ``dialout`` or ``uucp`` group.

Python Compatibility
~~~~~~~~~~~~~~~~~~~~

ESP-IDF supports Python 3.8 or newer. It is recommended to upgrade your operating system to a recent version sati"
"sfying this requirement. Other options include the installation of Python from `sources `_ or the use of a Python version management system such as `pyenv `_.

.. only:: esp32 or esp32s2 or esp32s3

    ..
        When adding new targets to the line above, please update this list in windows-start-project.rst and linux-macos-start-project.rst


    Start with Board Support Package
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    To speed up prototyping on some development boards, you can use `Board Supp"
"ort Packages (BSPs) `_, which makes initialization of a particular board as easy as few function calls.

    A BSP typically supports all of the hardware components provided on development board. Apart from the pinout definition and initialization functions, a BSP ships with drivers for the external components such as sensors, displays, audio codecs etc.

    The BSPs are distributed via :doc:`IDF Component Manager `, so they can be found in `IDF Component Registry `_.

    .. only:: esp32

    "
"    **Here is an example of how to add ESP-WROVER-KIT BSP to your project:**

        .. code-block:: bash

            idf.py add-dependency esp_wrover_kit

    .. only:: esp32s2

        **Here is an example of how to add ESP32-S2-Kaluga-Kit BSP to your project:**

        .. code-block:: bash

            idf.py add-dependency esp32_s2_kaluga_kit

    .. only:: esp32s3

        **Here is an example of how to add ESP-BOX BSP to your project:**

        .. code-block:: bash

            idf.py "
"add-dependency esp-box

    More examples of BSP usage can be found in `BSP examples folder `_.

Flash Erase
~~~~~~~~~~~

Erasing the flash is also possible. To erase the entire flash memory you can run the following command:

.. code-block:: bash

    idf.py -p PORT erase-flash

For erasing the OTA data, if present, you can run this command:

.. code-block:: bash

    idf.py -p PORT erase-otadata

The flash erase command can take a while to be done. Do not disconnect your device while the flash"
" erasing is in progress.
"
"
Updating ESP-IDF Tools on Windows




.. _get-started-install_bat-windows:

Install ESP-IDF Tools Using a Script


From the Windows Command Prompt, change to the directory where ESP-IDF is installed. Then run::

    install.bat

For Powershell, change to the directory where ESP-IDF is installed. Then run::

    install.ps1

This downloads and installs the tools necessary to use ESP-IDF. If the specific version of the tool is already installed, no action will be taken. The tools are downloaded a"
"nd installed into a directory specified during ESP-IDF Tools Installer process. By default, this is ``C:\Users\username\.espressif``.

.. _get-started-export_bat-windows:

Add ESP-IDF Tools to PATH Using an Export Script


ESP-IDF tools installer creates a Start menu shortcut for ""ESP-IDF Command Prompt"". This shortcut opens a Command Prompt window where all the tools are already available.

In some cases, you may want to work with ESP-IDF in a Command Prompt window which was not started using t"
"hat shortcut. If this is the case, follow the instructions below to add ESP-IDF tools to PATH.

In the command prompt where you need to use ESP-IDF, change to the directory where ESP-IDF is installed, then execute ``export.bat``::

    cd %userprofile%\esp\esp-idf
    export.bat

Alternatively in the Powershell where you need to use ESP-IDF, change to the directory where ESP-IDF is installed, then execute ``export.ps1``::

    cd ~/esp/esp-idf
    export.ps1

When this is done, the tools will be"
" available in this command prompt.
"
"Now since all requirements are met, the next topic guides you on how to start your first project.

This guide helps you on the first steps using ESP-IDF. Follow this guide to start a new project on the {IDF_TARGET_NAME} and build, flash, and monitor the device output.

.. note::

    If you have not yet installed ESP-IDF, please go to :ref:`get-started-step-by-step` and follow the instruction in order to get all the software needed to use this guide.

Start a Project


Now you are ready to prepa"
"re your application for {IDF_TARGET_NAME}. You can start with :example:`get-started/hello_world` project from :idf:`examples` directory in ESP-IDF.

.. important::

    The ESP-IDF build system does not support spaces in the paths to either ESP-IDF or to projects.

Copy the project :example:`get-started/hello_world` to ``~/esp`` directory:

.. code-block:: batch

    cd %userprofile%\esp
    xcopy /e /i %IDF_PATH%\examples\get-started\hello_world hello_world

.. note:: There is a range of exampl"
"e projects in the :idf:`examples` directory in ESP-IDF. You can copy any project in the same way as presented above and run it. It is also possible to build examples in-place without copying them first.

Connect Your Device


Now connect your {IDF_TARGET_NAME} board to the computer and check under which serial port the board is visible.

Serial port names start with ``COM`` in Windows.

If you are not sure how to check the serial port name, please refer to :doc:`establish-serial-connection` for "
"full details.

.. note::

    Keep the port name handy as it is needed in the next steps.

Configure Your Project


Navigate to your ``hello_world`` directory, set {IDF_TARGET_NAME} as the target, and run the project configuration utility ``menuconfig``.

Windows
~~~~~~~

.. code-block:: batch

    cd %userprofile%\esp\hello_world
    idf.py set-target {IDF_TARGET_PATH_NAME}
    idf.py menuconfig

After opening a new project, you should first set the target with ``idf.py set-target {IDF_TARGET_P"
"ATH_NAME}``. Note that existing builds and configurations in the project, if any, are cleared and initialized in this process. The target may be saved in the environment variable to skip this step at all. See :ref:`selecting-idf-target` for additional information.

If the previous steps have been done correctly, the following menu appears:

.. figure:: ../../_static/project-configuration.png
    :align: center
    :alt: Project configuration - Home window

    Project configuration - Home window"
"

You are using this menu to set up project specific variables, e.g., Wi-Fi network name and password, the processor speed, etc. Setting up the project with menuconfig may be skipped for ""hello_word"", since this example runs with default configuration.

.. only:: esp32

    .. attention::

        If you use ESP32-DevKitC board with the **ESP32-SOLO-1** module, or ESP32-DevKitM-1 board with the **ESP32-MIN1-1/1U** module, please enable single core mode (:ref:`CONFIG_FREERTOS_UNICORE`) in menucon"
"fig before flashing examples.

.. note::

    The colors of the menu could be different in your terminal. You can change the appearance with the option ``--style``. Please run ``idf.py menuconfig --help`` for further information.

.. only:: esp32 or esp32s2 or esp32s3

    If you are using one of the supported development boards, you can speed up your development by using Board Support Package. See `Additional Tips `__ for more information.

.. only:: esp32s2

    To use the USB for flashing the"
" {IDF_TARGET_NAME}, you need to change the channel for the console output to USB. For the {IDF_TARGET_NAME}, the default console output channel is the UART.

        ``Component config  --->  ESP System Settings  ---> Channel for console output``

        ``USB CDC``
"
"Establish Serial Connection with {IDF_TARGET_NAME}




.. only:: not SOC_USB_OTG_SUPPORTED and not SOC_USB_SERIAL_JTAG_SUPPORTED

    Establishing a serial connection with the {IDF_TARGET_NAME} target device could be done using a USB-to-UART bridge.

.. only:: SOC_USB_OTG_SUPPORTED or SOC_USB_SERIAL_JTAG_SUPPORTED

    Establishing a serial connection with the {IDF_TARGET_NAME} target device could be done using USB-to-UART bridge or USB peripheral supported in {IDF_TARGET_NAME}.

Some developmen"
"t boards have the USB-to-UART bridge installed. If a board does not have a bridge then an external bridge may be used.

.. only:: SOC_USB_OTG_SUPPORTED or SOC_USB_SERIAL_JTAG_SUPPORTED

    Supported USB Peripheral
    

    The {IDF_TARGET_NAME} supports the USB peripheral. In this case, the USB-to-UART bridge is not needed and the device can be flashed directly.

    .. blockdiag::
        :scale: 70%
        :caption: SoC with Supported USB
        :align: center

        blockdiag usb_capabl"
"e_esp {

            node_height = 80;
            span_width = 160;
            span_height = 140;
            default_fontsize = 16

            # labels of diagram nodes
            PC [label=""Personal\n Computer""];
            CHIP [label=""{IDF_TARGET_NAME}"", width=120];
            DUMMY [shape=none, width=1]


                # node connections
                PC   CHIP [fontsize=14];

                group {
                    shape = line;
                    style = dotted;
           "
"         color = ""#FF0000"";
                    label = ""Development Board\n\n\n"";
                    CHIP; DUMMY;
                }

        }

    Apart from the USB peripheral, some development boards also include the USB-to-UART bridge.

USB-to-UART Bridge on Development Board


For boards with an installed USB-to-UART bridge, the connection between the personal computer and the bridge is USB and between the bridge and {IDF_TARGET_NAME} is UART.

.. blockdiag::
    :caption: Development Boa"
"rd with USB-to-UART Bridge
    :align: center

    blockdiag esp_dev_board_with_usb_to_uart_bridge {

        node_height = 80;
        span_width = 160;
        span_height = 140;
        default_fontsize = 16

        # labels of diagram nodes
        PC [label=""Personal\nComputer""];
        BRIDGE [label=""USB-to-UART\n Bridge""];
        CHIP [label=""{IDF_TARGET_NAME}"", width=120];

            # node connections
            PC  BRIDGE [label = ""USB"", fontsize=14];
            BRIDGE  CHIP [la"
"bel = ""UART"", fontsize=14];

            group {
                shape = line;
                style = dotted;
                color = ""#FF0000"";
                label = ""Development Board\n\n\n"";
                BRIDGE; CHIP;
            }
    }


External USB-to-UART Bridge


Sometimes the USB-to-UART bridge is external. This is often used in small development boards or finished products when space and costs are crucial.

.. blockdiag::
    :caption: External USB-to-UART Bridge
    :align: cen"
"ter

    blockdiag external_usb_to_uart_bridge_to_esp {

        node_height = 80;
        span_width = 160;
        span_height = 140;
        default_fontsize = 16

        # labels of diagram nodes
        PC [label=""Personal\n Computer""];
        BRIDGE [label=""USB-to-UART\n Bridge"", width=180];
        CHIP [label=""{IDF_TARGET_NAME}"", width=120];
        DUMMY [shape=none, width=1]


            # node connections
            PC  BRIDGE [label = ""USB"", fontsize=14];
            BRIDGE  CHIP"
" [fontsize=14];

            group {
                shape = line;
                style = dotted;
                color = ""#FF0000"";
                label = ""Programmer Board\n\n\n"";
                BRIDGE
            }
            group {
                shape = line;
                style = dotted;
                color = ""#FF0000"";
                label = ""Development Board\n\n\n"";
                CHIP; DUMMY;
            }
    }


.. only:: SOC_USB_OTG_SUPPORTED or SOC_USB_SERIAL_JTAG_SUPPO"
"RTED

    Flash Using USB
    

    For the {IDF_TARGET_NAME}, the USB peripheral is available, allowing you to flash the binaries without the need for an external USB-to-UART bridge.

    {IDF_TARGET_USB_PIN_DM:default=""Not Updated!"", esp32c3=""GPIO18"", esp32s3=""GPIO19"", esp32s2=""GPIO19"", esp32c6=""GPIO12"", esp32h2=""GPIO26""}
    {IDF_TARGET_USB_PIN_DP:default=""Not Updated!"", esp32c3=""GPIO19"", esp32s3=""GPIO20"", esp32s2=""GPIO20"", esp32c6=""GPIO13"", esp32h2=""GPIO27""}

    The USB on the {IDF_TARGET_N"
"AME} uses the **{IDF_TARGET_USB_PIN_DP}** for **D+** and **{IDF_TARGET_USB_PIN_DM}** for **D-**.

    .. only:: SOC_USB_SERIAL_JTAG_SUPPORTED and not esp32s3

        .. note:: The {IDF_TARGET_NAME} supports only *USB CDC and JTAG*.

        If you are flashing for the first time, you need to get the {IDF_TARGET_NAME} into the download mode manually. To do so, press and hold the ``BOOT`` button and then press the ``RESET`` button once. After that release the ``BOOT`` button.

    .. only:: esp32"
"s3

        If you are flashing for the first time, you need to get the {IDF_TARGET_NAME} into the download mode manually. To do so, press and hold the ``BOOT`` button and then press the ``RESET`` button once. After that release the ``BOOT`` button.

    .. only:: esp32s2

        After flashing the binaries, a manual reset is needed.

Flash Using UART


This section provides guidance on how to establish a serial connection between {IDF_TARGET_NAME} and PC using USB-to-UART Bridge, either instal"
"led on the development board or external.

Connect {IDF_TARGET_NAME} to PC


Connect the {IDF_TARGET_NAME} board to the PC using the USB cable. If device driver does not install automatically, identify USB-to-UART bridge on your {IDF_TARGET_NAME} board (or external converter dongle), search for drivers in internet and install them.

Below is the list of USB to serial converter chips installed on most of the {IDF_TARGET_NAME} boards produced by Espressif together with links to the drivers:

Pleas"
"e check the board user guide for specific USB-to-UART bridge chip used. The drivers above are primarily for reference. Under normal circumstances, the drivers should be bundled with an operating system and automatically installed upon connecting the board to the PC.

For devices downloaded using a USB-to-UART bridge, you can run the following command including the optional argument to define the baud rate.

.. code-block:: bash

    idf.py -p PORT [-b BAUD] flash

Replace ``PORT`` with the devic"
"e name for the serial port of your {IDF_TARGET_NAME} board. Please note that ``-b`` is an optional argument. If you do not specify the baud rate, the default baud rate is ``460800``. If you need to specify the baud rate, replace ``BAUD`` with the baud rate you need.

To check the port name on Windows, please refer to `check-port-on-windows`_. For Linux and macOS users, please see `check-port-on-linux-and-macos`_.

For example, if the port name is ``COM3`` on Windows and your desired baud rate is"
" ``115200``, you can run the following command to flash the device:

.. code-block:: bash

    idf.py -p COM3 -b 115200 flash

For Linux users, if the port name is ``/dev/ttyUSB0`` and the desired baud rate is ``115200``, you can run the following command to flash the device:

.. code-block:: bash

    idf.py -p /dev/ttyUSB0 -b 115200 flash

For macOS users, if the port name is ``/dev/cu.usbserial-1401`` and the desired baud rate is ``115200``, you can run the following command to flash the devi"
"ce:

.. code-block:: bash

    idf.py -p /dev/cu.usbserial-1401 -b 115200 flash

.. note::

    If the device does not support the auto download mode, you need to get into the download mode manually. To do so, press and hold the ``BOOT`` button and then press the ``RESET`` button once. After that release the ``BOOT`` button.

.. _check-port-on-windows:

Check Port on Windows


Check the list of identified COM ports in the Windows Device Manager. Disconnect {IDF_TARGET_NAME} and connect it back, "
"to verify which port disappears from the list and then shows back again.

Figures below show serial port for ESP32 DevKitC and ESP32 WROVER KIT

.. figure:: ../../_static/esp32-devkitc-in-device-manager.png
    :align: center
    :alt: USB to UART bridge of ESP32-DevKitC in Windows Device Manager
    :figclass: align-center

    USB to UART bridge of ESP32-DevKitC in Windows Device Manager

.. figure:: ../../_static/esp32-wrover-kit-in-device-manager.png
    :align: center
    :alt: Two USB Seri"
"al Ports of ESP-WROVER-KIT in Windows Device Manager
    :figclass: align-center

    Two USB Serial Ports of ESP-WROVER-KIT in Windows Device Manager

.. _check-port-on-linux-and-macos:

Check Port on Linux and macOS


To check the device name for the serial port of your {IDF_TARGET_NAME} board (or external converter dongle), run this command two times, first with the board/dongle unplugged, then with plugged in. The port which appears the second time is the one you need:

Linux ::

    ls /dev"
"/tty*

macOS ::

    ls /dev/cu.*

.. note::

    macOS users: if you do not see the serial port then check you have the USB/serial drivers installed. See Section `Connect {IDF_TARGET_NAME} to PC`_ for links to drivers. For macOS High Sierra (10.13), you may also have to explicitly allow the drivers to load. Open System Preferences -> Security & Privacy -> General and check if there is a message shown here about ""System Software from developer ..."" where the developer name is Silicon Labs or FTD"
"I.

.. _linux-dialout-group:

Adding User to ``dialout`` or ``uucp`` on Linux


The currently logged user should have read and write access the serial port over USB. On most Linux distributions, this is done by adding the user to ``dialout`` group with the following command::

    sudo usermod -a -G dialout $USER

on Arch Linux this is done by adding the user to ``uucp`` group with the following command::

    sudo usermod -a -G uucp $USER

Make sure you re-login to enable read and write permiss"
"ions for the serial port.

Verify Serial Connection


Now verify that the serial connection is operational. You can do this using a serial terminal program by checking if you get any output on the terminal after resetting {IDF_TARGET_NAME}.

.. only:: esp32c2

    The default console baud rate on ESP32-C2 is 115200 when a 40 MHz XTAL is used, or 74880 when a 26 MHz XTAL is used.

.. only:: not esp32c2

    The default console baud rate on {IDF_TARGET_NAME} is 115200.

Windows and Linux


In this"
" example, we use `PuTTY SSH Client `_ that is available for both Windows and Linux. You can use other serial programs and set communication parameters like below.

Run terminal and set identified serial port. Baud rate = 115200 (if needed, change this to the default baud rate of the chip in use), data bits = 8, stop bits = 1, and parity = N. Below are example screenshots of setting the port and such transmission parameters (in short described as 115200-8-1-N) on Windows and Linux. Remember to se"
"lect exactly the same serial port you have identified in steps above.

.. figure:: ../../_static/putty-settings-windows.png
    :align: center
    :alt: Setting Serial Communication in PuTTY on Windows
    :figclass: align-center

    Setting Serial Communication in PuTTY on Windows

.. figure:: ../../_static/putty-settings-linux.png
    :align: center
    :alt: Setting Serial Communication in PuTTY on Linux
    :figclass: align-center

    Setting Serial Communication in PuTTY on Linux

Then op"
"en serial port in terminal and check, if you see any log printed out by {IDF_TARGET_NAME}. The log contents depend on application loaded to {IDF_TARGET_NAME}, see `Example Output`_. Reset the board if no log has been printed out.

.. note::

   Close the serial terminal after verification that communication is working. If you keep the terminal session open, the serial port will be inaccessible for uploading firmware later.

.. note::

   If there is no log output, check

   - if the required pow"
"er is supplied to {IDF_TARGET_NAME}
   - if the board was reset after starting the terminal program
   - if the selected serial port is the correct one by using the method stated in `Check Port on Windows`_ and `Check Port on Linux and macOS`_
   - if the serial port is not being used by another program
   - if the identified port has been selected in serial terminal programs you are using, as stated in `Windows and Linux`_
   - if settings of the serial port in serial terminal programs are appl"
"icable to corresponding applications
   - if the correct USB connector (UART) is used on the development board
   - if your application is expected to output some log
   - if the log output has not been disabled (use :example:`hello world application ` to test)

macOS


To spare you the trouble of installing a serial terminal program, macOS offers the **screen** command.

- As discussed in `Check port on Linux and macOS`_, run::

    ls /dev/cu.*

- You should see similar output::

    /dev/cu.B"
"luetooth-Incoming-Port /dev/cu.SLAB_USBtoUART      /dev/cu.SLAB_USBtoUART7

- The output varies depending on the type and the number of boards connected to your PC. Then pick the device name of your board and run (if needed, change ""115200"" to the default baud rate of the chip in use)::

    screen /dev/cu.device_name 115200

  Replace ``device_name`` with the name found running ``ls /dev/cu.*``.

- What you are looking for is some log displayed by the **screen**. The log contents depend on appl"
"ication loaded to {IDF_TARGET_NAME}, see `Example Output`_. To exit the current **screen** session, type ``Ctrl-A + K``.

.. note::

   Do not forget to **exit the current screen session** after verifying that the communication is working. If you fail to do it and just close the terminal window, the serial port will be inaccessible for uploading firmware later.

Example Output


An example log is shown below. Reset the board if you do not see anything.

.. highlight:: none

::

    ets Jun  8 20"
"16 00:22:57

    rst:0x5 (DEEPSLEEP_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
    ets Jun  8 2016 00:22:57

    rst:0x7 (TG0WDT_SYS_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
    configsip: 0, SPIWP:0x00
    clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
    mode:DIO, clock div:2
    load:0x3fff0008,len:8
    load:0x3fff0010,len:3464
    load:0x40078000,len:7828
    load:0x40080000,len:252
    entry 0x40080034
    I (44) boot: ESP-IDF v2.0-rc1-401-gf9fba35 2nd stage bootloader
"
"    I (45) boot: compile time 18:48:10
    ...

If you can see readable log output, it means serial connection is working and you are ready to proceed with installation and finally upload an application to {IDF_TARGET_NAME}.

.. note::

   For some serial port wiring configurations, the serial RTS & DTR pins need to be disabled in the terminal program before the {IDF_TARGET_NAME} booting and producing serial output. This depends on the hardware itself, most development boards (including all Espr"
"essif boards) *do not* have this issue. The issue is present if RTS & DTR are wired directly to the EN & GPIO0 pins. See the `esptool documentation`_ for more details.

If you got here from :ref:`get-started-connect` when installing s/w for {IDF_TARGET_NAME} development, then you can continue with :ref:`get-started-configure`.

.. _esptool documentation: https://docs.espressif.com/projects/esptool/en/latest/advanced-topics/boot-mode-selection.html#automatic-bootloader
"
"Now since all requirements are met, the next topic will guide you on how to start your first project.

This guide helps you on the first steps using ESP-IDF. Follow this guide to start a new project on the {IDF_TARGET_NAME} and build, flash, and monitor the device output.

.. note::

    If you have not yet installed ESP-IDF, please go to :ref:`get-started-step-by-step` and follow the instruction in order to get all the software needed to use this guide.

Start a Project


Now you are ready to p"
"repare your application for {IDF_TARGET_NAME}. You can start with :example:`get-started/hello_world` project from :idf:`examples` directory in ESP-IDF.

.. important::

    The ESP-IDF build system does not support spaces in the paths to either ESP-IDF or to projects.

Copy the project :example:`get-started/hello_world` to ``~/esp`` directory:

.. code-block:: bash

    cd ~/esp
    cp -r $IDF_PATH/examples/get-started/hello_world .

.. note:: There is a range of example projects in the :idf:`ex"
"amples` directory in ESP-IDF. You can copy any project in the same way as presented above and run it. It is also possible to build examples in-place without copying them first.

Connect Your Device


Now connect your {IDF_TARGET_NAME} board to the computer and check under which serial port the board is visible.

Serial ports have the following naming patterns:

- **Linux**: starting with ``/dev/tty``
- **macOS**: starting with ``/dev/cu.``

If you are not sure how to check the serial port name, "
"please refer to :doc:`establish-serial-connection` for full details.

.. note::

    Keep the port name handy as it is needed in the next steps.

Configure Your Project


Navigate to your ``hello_world`` directory, set {IDF_TARGET_NAME} as the target, and run the project configuration utility ``menuconfig``.

.. code-block:: bash

    cd ~/esp/hello_world
    idf.py set-target {IDF_TARGET_PATH_NAME}
    idf.py menuconfig

After opening a new project, you should first set the target with ``idf.py"
" set-target {IDF_TARGET_PATH_NAME}``. Note that existing builds and configurations in the project, if any, are cleared and initialized in this process. The target may be saved in the environment variable to skip this step at all. See :ref:`selecting-idf-target` for additional information.

If the previous steps have been done correctly, the following menu appears:

.. figure:: ../../_static/project-configuration.png
    :align: center
    :alt: Project configuration - Home window

    Project co"
"nfiguration - Home window

You are using this menu to set up project specific variables, e.g., Wi-Fi network name and password, the processor speed, etc. Setting up the project with menuconfig may be skipped for ""hello_world"", since this example runs with default configuration.

.. only:: esp32

    .. attention::

        If you use ESP32-DevKitC board with the **ESP32-SOLO-1** module, or ESP32-DevKitM-1 board with the **ESP32-MIN1-1/1U** module, please enable single core mode (:ref:`CONFIG_FRE"
"ERTOS_UNICORE`) in menuconfig before flashing examples.

.. note::

    The colors of the menu could be different in your terminal. You can change the appearance with the option ``--style``. Please run ``idf.py menuconfig --help`` for further information.

.. only:: esp32 or esp32s2 or esp32s3

    If you are using one of the supported development boards, you can speed up your development by using Board Support Package. See `Additional Tips `__ for more information.

.. only:: esp32s2

    Conso"
"le Output Configuration
    

    If you are using the USB for flashing the {IDF_TARGET_NAME}, you need to change the channel for the console output from UART (default) to USB.

        ``Component config`` > ``ESP System Settings`` > ``Channel for console output``

        ``USB CDC``
"
"Flashing Troubleshooting




Failed to Connect


{IDF_TARGET_STRAP_GPIO:default=""[NEEDS TO BE UPDATED]"", esp32=""GPIO0"", esp32s2=""GPIO0"", esp32s3=""GPIO0"", esp32c2=""GPIO9"", esp32c3=""GPIO9"", esp32c6=""GPIO9"", esp32h2=""GPIO9""}

If you run the given command and see errors such as ""Failed to connect"", there might be several reasons for this. One of the reasons might be issues encountered by ``esptool.py``, the utility that is called by the build system to reset the chip, interact with the ROM bootloade"
"r, and flash firmware. One simple solution to try is to manually reset as described below. If it does not help, you can find more details about possible issues in the `esptool troubleshooting `_ page.

``esptool.py`` resets {IDF_TARGET_NAME} automatically by asserting DTR and RTS control lines of the USB-to-UART bridge, i.e., FTDI or CP210x (for more information, see :doc:`establish-serial-connection`). The DTR and RTS control lines are in turn connected to ``{IDF_TARGET_STRAP_GPIO}`` and ``CHIP"
"_PU`` (EN) pins of {IDF_TARGET_NAME}, thus changes in the voltage levels of DTR and RTS will boot {IDF_TARGET_NAME} into Firmware Download mode. As an example, check the `schematic `_ for the ESP32 DevKitC development board.

In general, you should have no problems with the `official esp-idf development boards `_. However, ``esptool.py`` is not able to reset your hardware automatically in the following cases:

- Your hardware does not have the DTR and RTS lines connected to ``{IDF_TARGET_STRAP_G"
"PIO}`` and ``CHIP_PU``.
- The DTR and RTS lines are configured differently.
- There are no such serial control lines at all.

Depending on the kind of hardware you have, it may also be possible to manually put your {IDF_TARGET_NAME} board into Firmware Download mode (reset).

- For development boards produced by Espressif, this information can be found in the respective getting started guides or user guides. For example, to manually reset an ESP-IDF development board, hold down the ``Boot`` butt"
"on (``{IDF_TARGET_STRAP_GPIO}``) and press the ``EN`` button (``CHIP_PU``).
- For other types of hardware, try pulling ``{IDF_TARGET_STRAP_GPIO}`` down.
"
"
Hardware Reference




.. toctree::
    :maxdepth: 1

    Technical Reference Manual (PDF) 
    :esp32:   Chip Datasheet (PDF) 
    :esp32s2: Chip Datasheet (PDF) 
    :esp32s3: Chip Datasheet (PDF) 
    :esp32c2: Chip Datasheet (PDF) 
    :esp32c3: Chip Datasheet (PDF) 
    :esp32c6: Chip Datasheet (PDF) 
    :esp32h2: Chip Datasheet (PDF) 
    :esp32:   Hardware Design Guidelines (PDF) 
    :esp32s2: Hardware Design Guidelines (PDF) 
    :esp32s3: Hardware Design Guidelines (PDF) 
    :esp32c"
"2: Hardware Design Guidelines (PDF) 
    :esp32c3: Hardware Design Guidelines (PDF) 
    :esp32c6: Hardware Design Guidelines (PDF) 
    :esp32h2: Hardware Design Guidelines (PDF) 
    :esp32: Silicon Errata (PDF) 
    :esp32s2: Silicon Errata (PDF) 
    :esp32s3: Silicon Errata (PDF) 
    :esp32c3: Silicon Errata (PDF) 
    :esp32c2: Silicon Errata (PDF) 
    Chip Variants 
    Modules 
    Development Boards 
    Espressif KiCad Library 
    ESP Product Selector 
    Regulatory Certificates 
 "
"   Chip Series Comparison 
    User Forum (Hardware) 
"
"


This user guide will help you get started with ESP32-C3-DevKitM-1 and will also provide more in-depth information.

ESP32-C3-DevKitM-1 is an entry-level development board based on `ESP32-C3-MINI-1 `_, a module named for its small size. This board integrates complete Wi-Fi and Bluetooth® Low Energy functions.

Most of the I/O pins on the ESP32-C3-MINI-1 module are broken out to the pin headers on both sides of this board for easy interfacing. Developers can either connect peripherals with jump"
"er wires or mount ESP32-C3-DevKitM-1 on a breadboard.

.. figure:: ../../../_static/esp32-c3-devkitm-1-v1-isometric.png
    :align: center
    :alt: ESP32-C3-DevKitM-1
    :figclass: align-center

    ESP32-C3-DevKitM-1

The document consists of the following major sections:

- `Getting Started`_: Overview of ESP32-C3-DevKitM-1 and hardware/software setup instructions to get started.
- `Hardware Reference`_: More detailed information about the ESP32-C3-DevKitM-1's hardware.
- `Hardware Revision "
"Details`_: Revision history, known issues, and links to user guides for previous versions (if any) of ESP32-C3-DevKitM-1.
- `Related Documents`_: Links to related documentation.


Getting Started


This section provides a brief introduction of ESP32-C3-DevKitM-1, instructions on how to do the initial hardware setup and how to flash firmware onto it.


Description of Components


.. _user-guide-c3-devkitm-1-v1-board-front:

.. figure:: ../../../_static/esp32-c3-devkitm-1-v1-annotated-photo.png
  "
"  :align: center
    :alt: ESP32-C3-DevKitM-1 - front
    :figclass: align-center

    ESP32-C3-DevKitM-1 - front

The key components of the board are described in a counter-clockwise direction.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - ESP32-C3-MINI-1 is a general-purpose Wi-Fi and Bluetooth Low Energy combo module that comes with a PCB antenna. At the core of this module is `ESP32-C3FN4 `_, a chip that has an embedded flash of 4 MB. Since flash is packaged"
" in the ESP32-C3FN4 chip, rather than integrated into the module, ESP32-C3-MINI-1 has a smaller package size.
     - Power regulator that converts a 5 V supply into a 3.3 V output.
     - Turns on when the USB power is connected to the board.
     - All available GPIO pins (except for the SPI bus for flash) are broken out to the pin headers on the board. For details, please see :ref:`user-guide-c3-devkitm-1-v1-header-blocks`.
     - Download button. Holding down **Boot** and then pressing **Rese"
"t** initiates Firmware Download mode for downloading firmware through the serial port.
     - USB interface. Power supply for the board as well as the communication interface between a computer and the ESP32-C3FN4 chip.
     - Press this button to restart the system.
     - Single USB-UART bridge chip provides transfer rates up to 3 Mbps.
     - Addressable RGB LED, driven by GPIO8.


Start Application Development


Before powering up your ESP32-C3-DevKitM-1, please make sure that it is in good "
"condition with no obvious signs of damage.


Required Hardware


- ESP32-C3-DevKitM-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. note::

  Be sure to use an appropriate USB cable. Some cables are for charging only and do not provide the needed data lines nor work for programming the boards.


Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development env"
"ironment and then flash an application example onto your ESP32-C3-DevKitM-1.


Contents and Packaging


Retail Orders


If you order one or several samples, each ESP32-C3-DevKitM-1 comes in an individual package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www"
".espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the components of ESP32-C3-DevKitM-1 and their interconnections.

.. figure:: ../../../_static/esp32-c3-devkitm-1-v1-block-diagram.png
    :align: center
    :scale: 70%
    :alt: ESP32-C3-DevKitM-1 (click to enlarge)
    :figclass: align-center

    ESP32-C3-DevKitM-1 (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:
"
"
- Micro-USB Port, default power supply
- 5V and GND pin headers
- 3V3 and GND pin headers

It is recommended to use the first option: Micro-USB Port.


.. _user-guide-c3-devkitm-1-v1-header-blocks:

Header Block


The two tables below provide the **Name** and **Function** of the pin headers on both sides of the board (J1 and J3). The pin header names are shown in :ref:`user-guide-c3-devkitm-1-v1-board-front`. The numbering is the same as in the `ESP32-C3-DevKitM-1 Schematic`_ (PDF).


J1
^^^

="
"==      
No.  Name  Type [1]_   Function
===      
1    GND   G           Ground
2    3V3   P           3.3 V power supply
3    3V3   P           3.3 V power supply
4    IO2   I/O/T       GPIO2 [2]_, ADC1_CH2, FSPIQ
5    IO3   I/O/T       GPIO3, ADC1_CH3
6    GND   G           Ground
7    RST   I           CHIP_PU
8    GND   G           Ground
9    IO0   I/O/T       GPIO0, ADC1_CH0, XTAL_32K_P
10   IO1   I/O/T       GPIO1, ADC1_CH1, XTAL_32K_N
11   IO10  I/O/T       GPIO10, FSPICS0
12   GND   G "
"          Ground
13   5V    P           5 V power supply
14   5V    P           5 V power supply
15   GND   G           Ground
===      


J3
^^^

===      
No.  Name  Type [1]_   Function
===      
1    GND   G           Ground
2    TX    I/O/T       GPIO21, U0TXD
3    RX    I/O/T       GPIO20, U0RXD
4    GND   G           Ground
5    IO9   I/O/T       GPIO9 [2]_
6    IO8   I/O/T       GPIO8 [2]_, RGB LED
7    GND   G           Ground
8    IO7   I/O/T       GPIO7, FSPID, MTDO
9    IO6   I/O/T  "
"     GPIO6, FSPICLK, MTCK
10   IO5   I/O/T       GPIO5, ADC2_CH0, FSPIWP, MTDI
11   IO4   I/O/T       GPIO4, ADC1_CH4, FSPIHD, MTMS
12   GND   G           Ground
13   IO18  I/O/T       GPIO18, USB_D-
14   IO19  I/O/T       GPIO19, USB_D+
15   GND   G           Ground
===      

.. [1] P: Power supply; I: Input; O: Output; T: High impedance.
.. [2] GPIO2, GPIO8, and GPIO9 are strapping pins of the ESP32-C3FN4 chip. These pins are used to control several chip functions depending on binary voltage "
"values applied to the pins during chip power-up or system reset. For description and application of the strapping pins, please refer to Section Strapping Pins in `ESP32-C3 Datasheet`_.


Pin Layout


.. figure:: ../../../_static/esp32-c3-devkitm-1-v1-pinout.png
    :align: center
    :scale: 45%
    :alt: ESP32-C3-DevKitM-1 (click to enlarge)

    ESP32-C3-DevKitM-1 Pin Layout (click to enlarge)


Hardware Revision Details


No previous versions available.


Related Documents


For further desig"
"n documentation for the board, please contact us at `sales@espressif.com `_.

.. _ESP32-C3 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-c3_datasheet_en.pdf
.. _ESP32-C3-MINI-1 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-c3-mini-1_datasheet_en.pdf
.. _ESP32-C3-DevKitM-1 Schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-C3-DEVKITM-1_V1_20200915A.pdf
.. _ESP32-C3-DevKitM-1 PCB Layout: https://dl.espressif.com/dl/schematics/P"
"CB_ESP32-C3-DEVKITM-1_V1_20200915AA.pdf
.. _ESP32-C3-DevKitM-1 Dimensions: https://dl.espressif.com/dl/schematics/DIMENSION_ESP32-C3-DEVKITM-1_V1_20200915AA.pdf
.. _ESP32-C3-DevKitM-1 Dimensions source file: https://dl.espressif.com/dl/schematics/DIMENSION_ESP32-C3-DEVKITM-1_V1_20200915AA.dxf
"
"


This user guide will help you get started with ESP32-C3-DevKitC-02 and will also provide more in-depth information.

ESP32-C3-DevKitC-02 is an entry-level development board based on `ESP32-C3-WROOM-02 `_, a general-purpose module with 4 MB SPI flash. This board integrates complete Wi-Fi and Bluetooth® Low Energy functions.

Most of the I/O pins are broken out to the pin headers on both sides for easy interfacing. Developers can either connect peripherals with jumper wires or mount ESP32-C3-De"
"vKitC-02 on a breadboard.

.. figure:: ../../../_static/esp32-c3-devkitc-02-v1-isometric.png
    :align: center
    :alt: ESP32-C3-DevKitC-02
    :figclass: align-center

    ESP32-C3-DevKitC-02

The document consists of the following major sections:

- `Getting Started`_: Overview of ESP32-C3-DevKitC-02 and hardware/software setup instructions to get started.
- `Hardware Reference`_: More detailed information about the ESP32-C3-DevKitC-02's hardware.
- `Hardware Revision Details`_: Revision his"
"tory, known issues, and links to user guides for previous versions (if any) of ESP32-C3-DevKitC-02.
- `Related Documents`_: Links to related documentation.


Getting Started


This section provides a brief introduction of ESP32-C3-DevKitC-02, instructions on how to do the initial hardware setup and how to flash firmware onto it.


Description of Components


.. _user-guide-c3-devkitc-02-v1-board-front:

.. figure:: ../../../_static/esp32-c3-devkitc-02-v1-annotated-photo.png
    :align: center
  "
"  :alt: ESP32-C3-DevKitC-02 - front
    :figclass: align-center

    ESP32-C3-DevKitC-02 - front

The key components of the board are described in a counter-clockwise direction.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - ESP32-C3-WROOM-02 from Espressif is a powerful and general-purpose module that offers Wi-Fi and Bluetooth Low Energy coexistence. It has a PCB antenna and a 4 MB SPI flash.
     - Power regulator that converts a 5 V supply into a 3.3 V output"
".
     - Turns on when the USB power is connected to the board.
     - All available GPIO pins (except for the SPI bus for flash) are broken out to the pin headers on the board. For details, please see :ref:`user-guide-c3-devkitc-02-v1-header-blocks`.
     - Download button. Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - USB interface. Power supply for the board as well as the communication interface bet"
"ween a computer and the ESP32-C3 chip.
     - Press this button to restart the system.
     - Single USB-to-UART bridge chip provides transfer rates up to 3 Mbps.
     - Addressable RGB LED, driven by GPIO8.


Start Application Development


Before powering up your ESP32-C3-DevKitC-02, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-C3-DevKitC-02
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. no"
"te::

  Be sure to use an appropriate USB cable. Some cables are for charging only and do not provide the needed data lines nor work for programming the boards.


Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an application example into your ESP32-C3-DevKitC-02.


Contents and Packaging


Retail Orders


If you order a few samples, each ESP32-C3-DevKitC-02 co"
"mes in an individual package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the components of ESP32-C3-DevKitC-02 and their interconnections.

."
". figure:: ../../../_static/esp32-c3-devkitc-02-v1-block-diags.png
    :align: center
    :scale: 70%
    :alt: ESP32-C3-DevKitC-02 (click to enlarge)
    :figclass: align-center

    ESP32-C3-DevKitC-02 (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

- Micro-USB Port, default power supply
- 5V and GND pin headers
- 3V3 and GND pin headers

It is recommended to use the first option: Micro-USB Port.


.. _user-guide-c3-devkitc-02"
"-v1-header-blocks:

Header Block


The two tables below provide the **Name** and **Function** of the pin headers on both sides of the board (J1 and J3). The pin header names are shown in :ref:`user-guide-c3-devkitc-02-v1-board-front`. The numbering is the same as in the `ESP32-C3-DevKitC-02 Schematic`_ (PDF).


J1
^^^

===      
No.  Name  Type [1]_    Function
===      
1    G     G           Ground
2    3V3   P           3.3 V power supply
3    3V3   P           3.3 V power supply
4    RST   I"
"           CHIP_PU
5    G     G           Ground
6    4     I/O/T       GPIO4, ADC1_CH4, FSPIHD, MTMS
7    5     I/O/T       GPIO5, ADC2_CH0, FSPIWP, MTDI
8    6     I/O/T       GPIO6, FSPICLK, MTCK
9    7     I/O/T       GPIO7, FSPID, MTDO
10   G     G           Ground
11   8     I/O/T       GPIO8 [2]_, RGB LED
12   9     I/O/T       GPIO9 [2]_
13   5V    P           5 V power supply
14   5V    P           5 V power supply
15   G     G           Ground
===      


J3
^^^

===      
No.  Name  T"
"ype [1]_   Function
===      
1    G     G           Ground
2    0     I/O/T       GPIO0, ADC1_CH0, XTAL_32K_P
3    1     I/O/T       GPIO1, ADC1_CH1, XTAL_32K_N
4    2     I/O/T       GPIO2 [2]_, ADC1_CH2, FSPIQ
5    3     I/O/T       GPIO3, ADC1_CH3
6    G     G           Ground
7    10    I/O/T       GPIO10, FSPICS0
8    G     G           Ground
9    RX    I/O/T       GPIO20, U0RXD
10   TX    I/O/T       GPIO21, U0TXD
11   G     G           Ground
12   18    I/O/T       GPIO18
13   19    I/O/"
"T       GPIO19
14   G     G           Ground
15   G     G           Ground
===      

.. [1] P: Power supply; I: Input; O: Output; T: High impedance.
.. [2] GPIO2, GPIO8, and GPIO9 are strapping pins of the ESP32-C3 chip. These pins are used to control several chip functions depending on binary voltage values applied to the pins during chip power-up or system reset. For description and application of the strapping pins, please refer to Section Strapping Pins in `ESP32-C3 Datasheet`_.


Pin Layou"
"t


.. figure:: ../../../_static/esp32-c3-devkitc-02-v1-pinout.png
    :align: center
    :scale: 50%
    :alt: ESP32-C3-DevKitC-02 (click to enlarge)
    :figclass: align-center

    ESP32-C3-DevKitC-02 Pin Layout (click to enlarge)


Hardware Revision Details


No previous versions available.


Related Documents


For further design documentation for the board, please contact us at `sales@espressif.com `_.


.. _ESP32-C3 Datasheet: https://www.espressif.com/sites/default/files/documentation/es"
"p32-c3_datasheet_en.pdf
.. _ESP32-C3-WROOM-02 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-c3-wroom-02_datasheet_en.pdf
.. _ESP32-C3-DevKitC-02 Schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-C3-DEVKITC-02_V1_1_20210126A.pdf
"
"ESP32-Ethernet-Kit V1.0 Getting Started Guide




This guide shows how to get started with the ESP32-Ethernet-Kit development board and also provides information about its functionality and configuration options.

The :ref:`ESP32-Ethernet-Kit ` is an Ethernet-to-Wi-Fi development board that enables Ethernet devices to be interconnected over Wi-Fi. At the same time, to provide more flexible power supply options, the ESP32-Ethernet-Kit also supports power over Ethernet (PoE).


What You Need


You"
" can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP32-Ethernet-Kit is an ESP32-based development board produced by `Espressif `_.

It consists of two development boards, the Ethernet board A and the PoE board B. The :ref:`Ethernet board (A) ` contains Bluetooth®/Wi-Fi dual-mode ESP32-WROVER-B module and IP101GRI, a Single Port 10/100 Fast Ethernet Transceiver (PHY). The :ref:`PoE board (B) ` provides power over Ethernet functionality."
" The A board can work independently, without the board B installed.

.. _get-started-esp32-ethernet-kit-b-v1.0:

.. figure:: ../../../_static/esp32-ethernet-kit-v1.0.png
    :align: center
    :alt: ESP32-Ethernet-Kit V1.0
    :figclass: align-center

    ESP32-Ethernet-Kit V1.0

For the application loading and monitoring the Ethernet board (A) also features FTDI FT2232H chip - an advanced multi-interface USB bridge. This chip enables to use JTAG for direct debugging of ESP32 through the USB int"
"erface without a separate JTAG debugger.


Functionality Overview


The block diagram below shows the main components of ESP32-Ethernet-Kit and their interconnections.

.. figure:: ../../../_static/esp32-ethernet-kit-block-diagram.png
    :align: center
    :scale: 50%
    :alt: ESP32-Ethernet-Kit block diagram (click to enlarge)
    :figclass: align-center

    ESP32-Ethernet-Kit block diagram (click to enlarge)


Functional Description


The following two figures and tables describe the key co"
"mponents, interfaces, and controls of the ESP32-Ethernet-Kit.


.. _get-started-esp32-ethernet-kit-a-v1.0-layout:

Ethernet Board (A)


.. figure:: ../../../_static/esp32-ethernet-kit-a-v1.0-layout.png
    :align: center
    :scale: 80%
    :alt: ESP32-Ethernet-Kit - Ethernet board (A) layout
    :figclass: align-center

    ESP32-Ethernet-Kit - Ethernet board (A) layout (click to enlarge)

The table below provides description starting from the picture's top right corner and going clockwise.

  "
"
Key Component       Description
  
ESP32-WROVER-B      This ESP32 module features 64-Mbit PSRAM for flexible extended storage and data processing capabilities.

GPIO Header 2       Five unpopulated through-hole solder pads to provide access to selected GPIOs of ESP32. For details, see `GPIO Header 2`_.

Flow Control        A jumper header with access to the board signals. For details, see `Flow Control`_.

Function Switch     A DIP switch used to configure the functionality of selected GPIOs of"
" ESP32. For details, see `Function Switch`_.

Tx/Rx LEDs          Two LEDs to show the status of UART transmission.

GPIO Header 3       Provides access to some GPIOs of ESP32 that can be used depending on the position of the `Function Switch`_.

FT2232H              The FT2232H chip serves as a multi-protocol USB-to-serial bridge which can be programmed and controlled via USB to provide communication with ESP32. FT2232H also features USB-to-JTAG interface which is available on channel A of the "
"chip, while USB-to-serial is on channel B. The FT2232H chip enhances user-friendliness in terms of application development and debugging. See `ESP32-Ethernet-Kit V1.0 Ethernet board (A) schematic`_.

USB Port            USB interface. Power supply for the board as well as the communication interface between a computer and the board.

Power Switch        Power On/Off Switch. Toggling toward the **Boot** button powers the board on, toggling away from **Boot** powers the board off.

5V Input       "
"     The 5V power supply interface can be more convenient when the board is operating autonomously (not connected to a computer).

5V Power On LED     This red LED turns on when power is supplied to the board, either from USB or 5 V Input.

DC/DC Converter     Provided DC 5 V to 3.3 V conversion, output current up to 2 A.

Board B Connectors  A pair male header pins for mounting the :ref:`PoE board (B) `.

IP101GRI (PHY)      The physical layer (PHY) connection to the Ethernet cable is implement"
"ed using the `IP101GRI `_ chip. The connection between PHY and ESP32 is done through the reduced media-independent interface (RMII), a variant of the media-independent interface `(MII) `_ standard. The PHY supports the IEEE 802.3/802.3u standard of 10/100 Mbps.

RJ45 Port           Ethernet network data transmission port.

Magnetics Module    The Magnetics are part of the Ethernet specification to protect against faults and transients, including rejection of common mode signals between the trans"
"ceiver IC and the cable. The magnetics also provide galvanic isolation between the transceiver and the Ethernet device.

Link/Activity LEDs  Two LEDs (green and red) that respectively indicate the ""Link"" and ""Activity"" statuses of the PHY.

BOOT Button         Download button. Holding down **BOOT** and then pressing **CH_PU** initiates Firmware Download mode for downloading firmware through the serial port.

CH_PU Button        Reset button.

GPIO Header 1       This header provides six unpopula"
"ted through-hole solder pads connected to spare GPIOs of ESP32. For details, see `GPIO Header 1`_.

  


.. _get-started-esp32-ethernet-kit-b-v1.0-layout:

PoE Board (B)


This board coverts power delivered over the Ethernet cable (PoE) to provide a power supply for the Ethernet board (A). The main components of the PoE board (B) are shown on the block diagram under `Functionality Overview`_.

The PoE board (B) has the following features:

To take advantage of the PoE functionality the **RJ45 Po"
"rt** of the Ethernet board (A) should be connected with an Ethernet cable to a switch that supports PoE. When the Ethernet board (A) detects 5 V power output from the PoE board (B), the USB power will be automatically cut off.

.. figure:: ../../../_static/esp32-ethernet-kit-b-v1.0-layout.png
    :align: center
    :scale: 80%
    :alt: ESP32-Ethernet-Kit - PoE board (B)
    :figclass: align-center

    ESP32-Ethernet-Kit - PoE board (B) layout (click to enlarge)

  
Key Component               "
"Description
  
Board A Connector           Four female header pins for mounting this board onto :ref:`Ethernet board (A) `.

External Power Terminals    Optional power supply to the PoE board (B).

  


.. _get-started-esp32-ethernet-kit-b-v1.0-setup-options:

Setup Options


This section describes options to configure the ESP32-Ethernet-Kit hardware.


Function Switch


The functions for specific GPIO pins can be selected with the **Function Switch**.

    
DIP SW   GPIO Pin          Pin Functi"
"onality if DIP SW is ON
    
 1       GPIO14            Connected to FT2232H to provide JTAG functionality
 2       GPIO12            Connected to FT2232H to provide JTAG functionality
 3       GPIO13            Connected to FT2232H to provide JTAG functionality
 4       GPIO15            Connected to FT2232H to provide JTAG functionality
 5       GPIO4             Connected to FT2232H to provide JTAG functionality
 6       GPIO2             Connected to on-board 25 MHz oscillator
 7       GPIO5"
"             Connected to RESET_N input of IP101GRI
 8       n/a
    

You can make a certain GPIO pin available for other purposes by putting its DIP SW to the Off position.


Flow Control


This is a 2 x 2 jumper pin header intended for the UART flow control.

    
.     Signal   Comment
    
 1    MTDO     GPIO13, see also `Function Switch`_
 2    MTCK     GPIO15, see also `Function Switch`_
 3    RTS      RTS signal of FT2232H
 4    CTS      CTS signal of FT2232H
    


GPIO Allocation


Thi"
"s section describes allocation of ESP32 GPIOs to specific interfaces or functions of the ESP32-Ethernet-Kit.


IP101GRI (PHY) Interface


The allocation of the ESP32 (MAC) pins to IP101GRI (PHY) is shown in the table below. Implementation of ESP32-Ethernet-Kit defaults to Reduced Media-Independent Interface (RMII).

    
.     ESP32 Pin (MAC)   IP101GRI (PHY)
    
*RMII Interface*

 1    GPIO21            TX_EN
 2    GPIO19            TXD[0]
 3    GPIO22            TXD[1]
 4    GPIO25           "
" RXD[0]
 5    GPIO26            RXD[1]
 6    GPIO27            CRS_DV
 7    GPIO0             REF_CLK
    
*Serial Management Interface*

 8    GPIO23            MDC
 9    GPIO18            MDIO
    
*PHY Reset*

10    GPIO5             Reset_N
    

.. note::

    Except for REF_CLK, the allocation of all pins under the *RMII Interface* is fixed and cannot be changed either through IOMUX or GPIO Matrix.


GPIO Header 1


This header exposes some GPIOs that are not used elsewhere on the ESP32-Et"
"hernet-Kit.

  
.     ESP32 Pin
  
 1    GPIO32
 2    GPIO33
 3    GPIO34
 4    GPIO35
 5    GPIO36
 6    GPIO39
  


GPIO Header 2


This header contains the GPIOs with specific MII functionality (except GPIO2), as opposed to Reduced Media-Independent Interface (RMII) functionality implemented on ESP32-Ethernet-Kit board by default, see `IP101GRI (PHY) Interface`_. Depending on the situation, if MMI is used, specific Ethernet applications might require this functionality.

      
.     ESP32 Pi"
"n   MII Function       Comments
      
 1    GPIO17      EMAC_CLK_180       See note 1
 2    GPIO16      EMAC_CLK_OUT       See note 1
 3    GPIO4       EMAC_TX_ER
 4    GPIO2       n/a                See note 2
 5    GPIO5       EMAC_RX_CLK        See note 2
      

.. note::


GPIO Header 3


The functionality of GPIOs connected to this header depends on the settings of the `Function Switch`_.

  
.     ESP32 Pin
  
 1     GPIO15
 2     GPIO13
 3     GPIO12
 4     GPIO14
 5     GND
 6     3V3
"
"  


GPIO Allocation Summary


.. csv-table::
    :header: ESP32-WROVER-B,IP101GRI,UART,JTAG,GPIO, Comments

    S_VP,,,,IO36,
    S_VN,,,,IO39,
    IO34,,,,IO34,
    IO35,,,,IO35,
    IO32,,,,IO32,
    IO33,,,,IO33,
    IO25,RXD[0],,,,
    IO26,RXD[1],,,,
    IO27,CRS_DV,,,,
    IO14,,,TMS,IO14,
    IO12,,,TDI,IO12,
    IO13,,RTS,TCK,IO13,
    IO15,,CTS,TDO,IO15,
    IO2,,,,IO2,See notes 1 and 3 below
    IO0,REF_CLK,,,,See notes 2 and 3 below
    IO4,,,nTRST,IO4,
    IO16,,,,IO16 (NC),See note"
" 4 below
    IO17,,,,IO17 (NC),See note 4 below
    IO5,Reset_N,,,IO5,
    IO18,MDIO,,,,
    IO19,TXD[0],,,,
    IO21,TX_EN,,,,
    RXD0,,RXD,,,
    TXD0,,TXD,,,
    IO22,TXD[1],,,,
    IO23,MDC,,,,


.. note::


Start Application Development


Before powering up your ESP32-Ethernet-Kit, please make sure that the board is in good condition with no obvious signs of damage.


Initial Setup



Now to Development


Proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-st"
"ep` will quickly help you set up the development environment and then flash an example project onto your board.

To use the older GNU Make compilation system, please refer to :ref:`get-started-step-by-step` section.

Move on to the next section only if you have successfully completed all the above steps.


Configure and Load the Ethernet Example


After setting up the development environment and testing the board, you can configure and flash the :example:`ethernet/basic` example. This example ha"
"s been created for testing Ethernet functionality. It supports different PHY, including **IP101GRI** installed on :ref:`ESP32-Ethernet-Kit V1.0 board `.


Related Documents


For other design documentation for the board, please contact us at sales@espressif.com.

.. _ESP32-Ethernet-Kit V1.0 Ethernet board (A) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-ETHERNET-KIT_A_V1.0_20190517.pdf
.. _ESP32-Ethernet-Kit V1.0 PoE board (B) schematic: https://dl.espressif.com/dl/schematics/SCH_"
"ESP32-ETHERNET-KIT_B_V1.0_20190517.pdf
.. _IP101GRI: http://www.bdtic.com/DataSheet/ICplus/IP101G_DS_R01_20121224.pdf
.. _MII: https://en.wikipedia.org/wiki/Media-independent_interface
"
"ESP32-Ethernet-Kit V1.1 Getting Started Guide




This guide shows how to get started with the ESP32-Ethernet-Kit development board and also provides information about its functionality and configuration options.

The :ref:`ESP32-Ethernet-Kit ` is an Ethernet-to-Wi-Fi development board that enables Ethernet devices to be interconnected over Wi-Fi. At the same time, to provide more flexible power supply options, the ESP32-Ethernet-Kit also supports power over Ethernet (PoE).


What You Need


You"
" can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP32-Ethernet-Kit is an ESP32-based development board produced by `Espressif `_.

It consists of two development boards, the Ethernet board A and the PoE board B. The :ref:`Ethernet board (A) ` contains Bluetooth®/Wi-Fi dual-mode ESP32-WROVER-B module and IP101GRI, a Single Port 10/100 Fast Ethernet Transceiver (PHY). The `PoE board (B)`_ provides power over Ethernet functionality. The "
"A board can work independently, without the board B installed.

.. _get-started-esp32-ethernet-kit-v1.1:

.. figure:: ../../../_static/esp32-ethernet-kit-v1.1.png
    :align: center
    :alt: ESP32-Ethernet-Kit V1.1
    :figclass: align-center

    ESP32-Ethernet-Kit V1.1

For the application loading and monitoring, the Ethernet board (A) also features FTDI FT2232H chip - an advanced multi-interface USB bridge. This chip enables to use JTAG for direct debugging of ESP32 through the USB interface"
" without a separate JTAG debugger.


Functionality Overview


The block diagram below shows the main components of ESP32-Ethernet-Kit and their interconnections.

.. figure:: ../../../_static/esp32-ethernet-kit-v1.1-block-diagram.png
    :align: center
    :scale: 60%
    :alt: ESP32-Ethernet-Kit block diagram (click to enlarge)
    :figclass: align-center

    ESP32-Ethernet-Kit block diagram (click to enlarge)


Functional Description


The following figures and tables describe the key compone"
"nts, interfaces, and controls of the ESP32-Ethernet-Kit.

.. _get-started-esp32-ethernet-kit-a-v1.1-layout:


Ethernet Board (A)


.. figure:: ../../../_static/esp32-ethernet-kit-a-v1.1-layout.png
    :align: center
    :scale: 80%
    :alt: ESP32-Ethernet-Kit - Ethernet board (A) layout
    :figclass: align-center

    ESP32-Ethernet-Kit - Ethernet board (A) layout (click to enlarge)

The table below provides description starting from the picture's top right corner and going clockwise.

.. list"
"-table:: Table 1  Component Description
  :widths: 40 150
  :header-rows: 1
    - Description
    - This ESP32 module features 64-Mbit PSRAM for flexible extended storage and data processing capabilities.
    - Five unpopulated through-hole solder pads to provide access to selected GPIOs of ESP32. For details, see `GPIO Header 2`_.
    - A 4-bit DIP switch used to configure the functionality of selected GPIOs of ESP32. Please note that placement of GPIO pin number marking on the board's silkscre"
"en besides the DIP switch is incorrect. For details and correct pin allocation see `Function Switch`_.
    - Two LEDs to show the status of UART transmission.
    - The FT2232H chip serves as a multi-protocol USB-to-serial bridge which can be programmed and controlled via USB to provide communication with ESP32. FT2232H also features USB-to-JTAG interface which is available on channel A of the chip, while USB-to-serial is on channel B. The FT2232H chip enhances user-friendliness in terms of appl"
"ication development and debugging. See `ESP32-Ethernet-Kit V1.1 Ethernet board (A) schematic`_.
    - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
    - Power On/Off Switch. Toggling the switch to **5V0** position powers the board on, toggling to **GND** position powers the board off.
    - The 5 V power supply interface can be more convenient when the board is operating autonomously (not connected to a computer).
    - This r"
"ed LED turns on when power is supplied to the board, either from USB or 5 V Input.
    - Provided DC 5 V to 3.3 V conversion, output current up to 2 A.
    - A pair male and female header pins for mounting the `PoE board (B)`_.
    - The physical layer (PHY) connection to the Ethernet cable is implemented using the `IP101GRI `_ chip. The connection between PHY and ESP32 is done through the reduced media-independent interface (RMII), a variant of the media-independent interface `(MII) `_ standard"
". The PHY supports the IEEE 802.3/802.3u standard of 10/100 Mbps.
    - Ethernet network data transmission port.
    - The Magnetics are part of the Ethernet specification to protect against faults and transients, including rejection of common mode signals between the transceiver IC and the cable. The magnetics also provide galvanic isolation between the transceiver and the Ethernet device.
    - Two LEDs (green and red) that respectively indicate the ""Link"" and ""Activity"" statuses of the PHY.
 "
"   - Download button. Holding down **BOOT** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
    - Reset button.
    - This header provides six unpopulated through-hole solder pads connected to spare GPIOs of ESP32. For details, see `GPIO Header 1`_.


PoE Board (B)


This board coverts power delivered over the Ethernet cable (PoE) to provide a power supply for the Ethernet board (A). The main components of the PoE board (B) are shown on"
" the block diagram under `Functionality Overview`_.

The PoE board (B) has the following features:

To take advantage of the PoE functionality the **RJ45 Port** of the Ethernet board (A) should be connected with an Ethernet cable to a switch that supports PoE. When the Ethernet board (A) detects 5 V power output from the PoE board (B), the USB power will be automatically cut off.

.. figure:: ../../../_static/esp32-ethernet-kit-b-v1.0-layout.png
    :align: center
    :scale: 80%
    :alt: ESP32"
"-Ethernet-Kit - PoE board (B)
    :figclass: align-center

    ESP32-Ethernet-Kit - PoE board (B) layout (click to enlarge)

.. list-table:: Table  PoE board (B)
  :widths: 40 150
  :header-rows: 1
    - Description
    - Four female (left) and four male (right) header pins for connecting the PoE board (B) to :ref:`Ethernet board (A) `. The pins on the left accept power coming from a PoE switch. The pins on the right deliver 5 V power supply to the  Ethernet board (A).
    - Optional power suppl"
"y (26.6 ~ 54 V) to the PoE board (B).

.. _get-started-esp32-ethernet-kit-v1.1-setup-options:


Setup Options


This section describes options to configure the ESP32-Ethernet-Kit hardware.


Function Switch


When in On position, this DIP switch is routing listed GPIOs to FT2232H to provide JTAG functionality. When in Off position, the GPIOs may be used for other purposes.

  
DIP SW   GPIO Pin
  
 1       GPIO13
 2       GPIO12
 3       GPIO15
 4       GPIO14
  

.. note::

    Placement of GPI"
"O pin number marking on the board's silkscreen besides the DIP switch is incorrect. Please use instead the pin order as in the table above.


RMII Clock Selection


The ethernet MAC and PHY under RMII working mode need a common 50 MHz reference clock (i.e., RMII clock) that can be provided either externally, or generated from internal ESP32 APLL.

.. note::

    For additional information on the RMII clock selection, please refer to `ESP32-Ethernet-Kit V1.1 Ethernet board (A) schematic`_, sheet "
"2, location D2.


RMII Clock Sourced Externally by PHY
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

By default, the ESP32-Ethernet-Kit is configured to provide RMII clock for the IP101GRI PHY's 50M_CLKO output. The clock signal is generated by the frequency multiplication of 25 MHz crystal connected to the PHY. For details, please see the figure below.

.. figure:: ../../../_static/esp32-ethernet-kit-rmii-clk-from-phy.png
    :align: center
    :scale: 80%
    :alt: RMII Clock from IP101GRI PHY
    :fi"
"gclass: align-center

    RMII Clock from IP101GRI PHY

Please note that the PHY is reset on power up by pulling the RESET_N signal down with a resistor. ESP32 should assert RESET_N high with GPIO5 to enable PHY. Only this can ensure the power-up of system. Otherwise ESP32 may enter download mode (when the clock signal of REF_CLK_50M is at a high logic level during the GPIO0 power-up sampling phase).


RMII Clock Sourced Internally from ESP32's APLL
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""

Another option is to source the RMII Clock from internal ESP32 APLL, see figure below. The clock signal coming from GPIO0 is first inverted, to account for transmission line delay, and then supplied to the PHY.

.. figure:: ../../../_static/esp32-ethernet-kit-rmii-clk-to-phy.png
    :align: center
    :scale: 80%
    :alt: RMII Clock from ESP Internal APLL
    :figclass: align-center

    RMII Clock from ESP Internal APLL

To implement this option, users need to remove or add some RC componen"
"ts on the board. For details please refer to `ESP32-Ethernet-Kit V1.1 Ethernet board (A) schematic`_, sheet 2, location D2. Please note that if the APLL is already used for other purposes (e.g., I2S peripheral), then you have no choice but use an external RMII clock.


GPIO Allocation


This section describes allocation of ESP32 GPIOs to specific interfaces or functions of the ESP32-Ethernet-Kit.


IP101GRI (PHY) Interface


The allocation of the ESP32 (MAC) pins to IP101GRI (PHY) is shown in th"
"e table below. Implementation of ESP32-Ethernet-Kit defaults to Reduced Media-Independent Interface (RMII).

    
.     ESP32 Pin (MAC)   IP101GRI (PHY)
    
*RMII Interface*

 1    GPIO21            TX_EN
 2    GPIO19            TXD[0]
 3    GPIO22            TXD[1]
 4    GPIO25            RXD[0]
 5    GPIO26            RXD[1]
 6    GPIO27            CRS_DV
 7    GPIO0             REF_CLK
    
*Serial Management Interface*

 8    GPIO23            MDC
 9    GPIO18            MDIO
    
*PHY Rese"
"t*

10    GPIO5             Reset_N
    

.. note::

    Except for REF_CLK, the allocation of all pins under the ESP32's *RMII Interface* is fixed and cannot be changed either through IOMUX or GPIO Matrix.


GPIO Header 1


This header exposes some GPIOs that are not used elsewhere on the ESP32-Ethernet-Kit.

  
.     ESP32 Pin
  
 1    GPIO32
 2    GPIO33
 3    GPIO34
 4    GPIO35
 5    GPIO36
 6    GPIO39
  


GPIO Header 2


This header contains GPIOs that may be used for other purposes depe"
"nding on scenarios described in column ""Comments"".

    
.     ESP32 Pin   Comments
    
 1    GPIO17      See note 1
 2    GPIO16      See note 1
 3    GPIO4
 4    GPIO2
 5    GPIO13      See note 2
 6    GPIO12      See note 2
 7    GPIO15      See note 2
 8    GPIO14      See note 2
 9    GND         Ground
10    3V3         3.3 V power supply
    

.. note::


GPIO Allocation Summary


.. csv-table::
    :header: ESP32-WROVER-B,IP101GRI,UART,JTAG,GPIO,Comments

    S_VP,,,,IO36,
    S_VN,,,,"
"IO39,
    IO34,,,,IO34,
    IO35,,,,IO35,
    IO32,,,,IO32,
    IO33,,,,IO33,
    IO25,RXD[0],,,,
    IO26,RXD[1],,,,
    IO27,CRS_DV,,,,
    IO14,,,TMS,IO14,
    IO12,,,TDI,IO12,
    IO13,,RTS,TCK,IO13,
    IO15,,CTS,TDO,IO15,
    IO2,,,,IO2,
    IO0,REF_CLK,,,,See note 1
    IO4,,,,IO4,
    IO16,,,,IO16 (NC),See note 2
    IO17,,,,IO17 (NC),See note 2
    IO5,Reset_N,,,,See note 1
    IO18,MDIO,,,,
    IO19,TXD[0],,,,
    IO21,TX_EN,,,,
    RXD0,,RXD,,,
    TXD0,,TXD,,,
    IO22,TXD[1],,,,
   "
" IO23,MDC,,,,

.. note::


Start Application Development


Before powering up your ESP32-Ethernet-Kit, please make sure that the board is in good condition with no obvious signs of damage.


Initial Setup



Now to Development


Proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.

Move on to the next section only if you have successfully completed all t"
"he above steps.


Configure and Load the Ethernet Example


After setting up the development environment and testing the board, you can configure and flash the :example:`ethernet/basic` example. This example has been created for testing Ethernet functionality. It supports different PHY, including **IP101GRI** installed on :ref:`get-started-esp32-ethernet-kit-v1.1`.


Summary of Changes from ESP32-Ethernet-Kit V1.0



Other Versions of ESP32-Ethernet-Kit



Related Documents


For other design do"
"cumentation for the board, please contact us at sales@espressif.com.

.. _ESP32-Ethernet-Kit V1.1 Ethernet board (A) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-ETHERNET-KIT_A_V1.1_20190711.pdf
.. _ESP32-Ethernet-Kit V1.0 PoE board (B) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-ETHERNET-KIT_B_V1.0_20190517.pdf
.. _ESP32-Ethernet-Kit V1.0 Ethernet board (A) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-ETHERNET-KIT_A_V1.0_20190517.pdf

.. toctree::
 "
"   :hidden:

    get-started-ethernet-kit-v1.0.rst
"
"


This user guide provides information on ESP32-DevKitS(-R), an ESP32-based flashing board produced by Espressif.

ESP32-DevKitS(-R) is a combination of two board names: ESP32-DevKitS and ESP32-DevKitS-R. S stands for springs, and R stands for WROVER.

+++
| |ESP32-DevKitS| | |ESP32-DevKitS-R| |
+++
|  ESP32-DevKitS  |  ESP32-DevKitS-R  |
+++

.. |ESP32-DevKitS| image:: ../../../_static/esp32-devkits-v1.1-layout-isometric-raw.png

.. |ESP32-DevKitS-R| image:: ../../../_static/esp32-devkits-r-v1"
".1-layout-isometric-raw.png

The document consists of the following major sections:

- `Getting Started`_: Provides an overview of ESP32-DevKitS(-R) and hardware/software setup instructions to get started.
- `Hardware Reference`_: Provides more detailed information about ESP32-DevKitS(-R)'s hardware.
- `Related Documents`_: Gives links to related documentation.


Getting Started


This section describes how to get started with ESP32-DevKitS(-R). It begins with a few introductory sections about E"
"SP32-DevKitS(-R), then Section `How to Flash a Board`_ provides instructions on how to mount a module onto ESP32-DevKitS(-R), get it ready, and flash firmware onto it.


Overview


ESP32-DevKitS(-R) is Espressif's flashing board designed specifically for ESP32. It can be used to flash an ESP32 module without soldering the module to the power supply and signal lines. With a module mounted, ESP32-DevKitS(-R) can also be used as a mini development board like ESP32-DevKitC.

ESP32-DevKitS and ESP32-"
"DevKitS-R boards vary only in layout of spring pins to fit the following ESP32 modules.

- ESP32-DevKitS:
   - ESP32-WROOM-32
   - ESP32-WROOM-32D
   - ESP32-WROOM-32U
   - ESP32-SOLO-1
   - ESP32-WROOM-32E
   - ESP32-WROOM-32UE
- ESP32-DevKitS-R:
   - ESP32-WROVER (PCB & IPEX)
   - ESP32-WROVER-B (PCB & IPEX)
   - ESP32-WROVER-E
   - ESP32-WROVER-IE

For information about above modules, please refer to `ESP32 Series Modules `_.


Description of Components


.. figure:: ../../../_static/esp32-de"
"vkits-v1.1-layout-front.png
    :align: center
    :alt: ESP32-DevKitS - front
    :figclass: align-center

    ESP32-DevKitS - front

.. figure:: ../../../_static/esp32-devkits-r-v1.1-layout-front.png
    :align: center
    :alt: ESP32-DevKitS-R - front
    :figclass: align-center

    ESP32-DevKitS-R - front


.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Click the module in. The pins will fit into the module's castellated holes.
     - These female headers are"
" connected to pins of the module mounted on this board. For description of female headers, please refer to `Header Blocks`_.
     - Single-chip USB to UART bridge provides transfer rates of up to 3 Mbps.
     - 5V-to-3.3V low-dropout voltage regulator (LDO).
     - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
     - Reset button.
     - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download"
" mode for downloading firmware through the serial port.
     - Turns on when the USB or power supply is connected to the board.


How to Flash a Board


Before powering up your ESP32-DevKitS(-R), please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- An ESP32 module of your choice
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS


Hardware Setup


Please mount a module of your choice onto your ESP32-DevKitS(-R) ac"
"cording to the following steps:

- Gently put your module on the ESP32-DevKitS(-R) board. Make sure that castellated holes on your module are aligned with spring pins on the board.
- Press your module down into the board until it clicks.
- Check whether all spring pins are inserted into castellated holes. If there are some misaligned spring pins, place them into castellated holes with tweezers.


Software Setup


Preferred Method
++++++++++++++++
The ESP-IDF development framework provides a pref"
"erred way of flashing binaries onto ESP32-DevKitS(-R). Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an application example onto your ESP32-DevKitS(-R).


Alternative Method
++++++++++++++++++

As an alternative, Windows users can flash binaries using the `Flash Download Tool `_. Just download it, unzip it, and follow the instructions inside the *doc* folder.

    .. note::

"
"
Board Dimensions


.. figure:: ../../../_static/esp32-devkits-v1.1-dimensions-back.png
    :align: center
    :alt: ESP32-DevKitS
    :figclass: align-center

    ESP32-DevKitS board dimensions - back

.. figure:: ../../../_static/esp32-devkits-r-v1.1-dimensions-back.png
    :align: center
    :alt: ESP32-DevKitS-R
    :figclass: align-center

    ESP32-DevKitS-R board dimensions - back


Contents and Packaging


Retail Orders


If you order a few samples, each ESP32-DevKitS(-R) comes in an ind"
"ividual package in either antistatic bag or any packaging depending on a retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


A block diagram below shows the components of ESP32-DevKitS(-R) and their interconnections.

.. figure:: ../../../"
"_static/esp32-devkits-r-v1.1-block_diagram.png
    :align: center
    :scale: 70%
    :alt: ESP32-DevKitS(-R) - block diagram (click to enlarge)
    :figclass: align-center

    ESP32-DevKitS(-R) (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

- Micro USB port, default power supply
- 5V and GND header pins
- 3V3 and GND header pins

It is advised to use the first option: micro USB port.


Header Blocks


    
.        Label     "
"        Signal
    
L1       3V3               VDD 3V3
L2       EN                CHIP_PU
L3       VP                SENSOR_VP
L4       VN                SENSOR_VN
L5       34                GPIO34
L6       35                GPIO35
L7       32                GPIO32
L8       33                GPIO33
L9       25                GPIO25
L10      26                GPIO26
L11      27                GPIO27
L12      14                GPIO14
L13      12                GPIO12
L14      GND               GND"
"
L15      13                GPIO13
L16      D2                SD_DATA2
L17      D3                SD_DATA3
L18      CMD               SD_CMD
L19      5V                External 5V
R1       GND               GND
R2       23                GPIO23
R3       22                GPIO22
R4       TX                U0TXD
R5       RX                U0RXD
R6       21                GPIO21
R7       GND               GND
R8       19                GPIO19
R9       18                GPIO18
R10      5            "
"     GPIO5
R11      17                GPIO17
R12      16                GPIO16
R13      4                 GPIO4
R14      0                 GPIO0
R15      2                 GPIO2
R16      15                GPIO15
R17      D1                SD_DATA1
R18      D0                SD_DATA0
R19      CLK               SD_CLK
    

For the image of header blocks, please refer to `Description of Components`_.


Related Documents

- `ESP32-DevKitS(-R) Schematics `_ (PDF)
- `ESP32 Datasheet `_ (PDF)
- `ESP32"
"-WROOM-32 Datasheet `_ (PDF)
- `ESP32-WROOM-32D & ESP32-WROOM-32U Datasheet `_ (PDF)
- `ESP32-SOLO-1 Datasheet `_ (PDF)
- `ESP32-WROVER Datasheet `_ (PDF)
- `ESP32-WROVER-B Datasheet `_ (PDF)
- `ESP Product Selector `_
"
"ESP32-PICO-DevKitM-2




Overview


ESP32-PICO-DevKitM-2 is an ESP32-based development board produced by `Espressif `_.

The core of this board is `ESP32-PICO-MINI-02/02U `_ module with complete Wi-Fi and Bluetooth® functionalities. The development board features a USB-to-UART Bridge circuit which allows developers to connect the board to a computer's USB port for flashing and debugging.

All the IO signals and system power on ESP32-PICO-MINI-02/02U are led out to two rows of 18 x 0.1"" header pa"
"ds on both sides of the development board for easy access. For compatibility with Dupont wires, all header pads are populated with two rows of male pin headers.

.. note::

    ESP32-PICO-DevKitM-2 comes with male headers by default.

ESP32-PICO-DevKitM-2 provides the users with hardware for development of applications based on the ESP32, making it easier for users to explore ESP32 functionalities.

.. figure:: ../../../_static/esp32-pico-devkitm-2-overview.png
    :align: center
    :scale: 70%"
"
    :alt: ESP32-PICO-DevKitM-2 (click to enlarge)
    :figclass: align-center

    ESP32-PICO-DevKitM-2 Overview (click to enlarge)

This guide covers:

- `Getting Started`_: Provides an overview of the ESP32-PICO-DevKitM-2 and software setup instructions to get started.
- `Contents and Packaging`_: Provides information about packaging and contents for retail and wholesale orders.
- `Hardware Reference`_: Provides more detailed information about the ESP32-PICO-DevKitM-2's hardware.
- `Hardware "
"Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions (if any) of the ESP32-PICO-DevKitM-2.
- `Related Documents`_: Gives links to related documentation.


Getting Started


This section describes how to get started with the ESP32-PICO-DevKitM-2. It begins with a few introductory sections about the ESP32-PICO-DevKitM-2, then Section `Start Application Development`_ provides instructions on how to flash firmware onto the ESP32-PICO-DevKitM-2.


"
".. _get-started-pico-devkitm-2-board-front:

Description of Components


The following figure and the table below describe the key components, interfaces, and controls of the ESP32-PICO-DevKitM-2 board. We take the board with a ESP32-PICO-MINI-02 module as an example in the following sections.

.. figure:: ../../../_static/esp32-pico-devkitm-2-layout-front.png
    :align: center
    :scale: 90%
    :alt: ESP32-PICO-DevKitM-2 (click to enlarge)
    :figclass: align-center

    ESP32-PICO-DevKitM-"
"2 board layout - front (click to enlarge)

Below is the description of the items identified in the figure starting from the top left corner and going clockwise.

.. list-table::
   :widths: 10 25
   :header-rows: 1
     - Description
     - Standard ESP32-PICO-MINI-02 module soldered to the ESP32-PICO-DevKitM-2 board. The complete ESP32 system on a chip (ESP32 SoC) has been integrated into the module. Users can also select the board with ESP32-PICO-MINI-02U soldered.
     - V-to-3.3V Low dropout"
" voltage regulator (LDO).
     - CP2102N, single-chip USB-UART bridge that offers up to 3 Mbps transfers rates.
     - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
     - This red LED turns on when power is supplied to the board. For details, see the schematic in `Related Documents`_.
     - All the pins on ESP32-PICO-MINI-02 are broken out to pin headers. You can program ESP32 to enable multiple functions, such as PWM, ADC, D"
"AC, I2C, I2S, SPI, etc. For details, please see Section `Pin Descriptions`_.
     - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
     - Reset button.


Start Application Development


Before powering up your ESP32-PICO-DevKitM-2, please make sure that the board is in good condition with no obvious signs of damage.


Required Hardware
""""""""""""""""""""""""""""""""""

- 1 x ESP32-PICO-DevKitM-2
- 1 x USB 2.0 A "
"to Micro B cable
- 1 x Computer running Windows, Linux, or macOS


.. _user-guide-pico-devkitm-2-software-setup:

Software Setup
""""""""""""""""""""""""""""

Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment.


Contents and Packaging


Retail Orders


If you order one or several samples of the board, each ESP32-PICO-DevKitM-2 development board comes in an individual package.

For retail orders, please go to"
" https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the main components of ESP32-PICO-DevKitM-2 and their interconnections.

.. figure:: ../../../_static/esp32-pico-devkitm-2-block.png
    :align: center
    :scale: 70%
    :alt: ESP32-PICO-DevKitM-2 "
"(click to enlarge)
    :figclass: align-center

    ESP32-PICO-DevKitM-2 Block Diagram (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

.. warning::

    The power supply must be provided using **one and only one of the options above**, otherwise the board and/or the power supply source can be damaged.


Pin Descriptions


The two tables below provide the **Name** and **Function** of I/O header pins on both sides of the board, se"
"e :ref:`get-started-pico-devkitm-2-board-front`. The pin numbering and header names are the same as in the schematic given in `Related Documents`_.


Header J2
""""""""""""""""""

.. list-table::
   :widths: 5 5 5 35
   :header-rows: 1
     - Name
     - Type
     - Function
     - IO20
     - I/O
     - GPIO20
     - IO21
     - I/O
     - GPIO21, VSPIHD, EMAC_TX_EN
     - IO22
     - I/O
     - GPIO22, VSPIWP, U0RTS, EMAC_TXD1
     - IO19
     - I/O
     - GPIO19, VSPIQ, U0CTS, EMAC_TXD0
     - IO8
   "
"  - I/O
     - GPIO8, SD_DATA1, HS1_DATA1, U2CTS
     - IO7
     - I/O
     - GPIO7, SD_DATA0, HS1_DATA0, U2RTS
     - IO5
     - I/O
     - GPIO5, VSPICS0, HS1_DATA6, EMAC_RX_CLK
     - NC
     - \-
     - NC
     - NC
     - \-
     - NC
     - RXD0
     - I/O
     - GPIO3, U0RXD :ref:`(See 1) `, CLK_OUT2
     - TXD0
     - I/O
     - GPIO1, U0TXD :ref:`(See 1) `, CLK_OUT3, EMAC_RXD2
     - IO35
     - I
     - ADC1_CH7, RTC_GPIO5
     - IO34
     - I
     - ADC1_CH6, RTC_GPIO4
     - IO38
   "
"  - I
     - GPIO38, ADC1_CH2, RTC_GPIO2
     - IO37
     - I
     - GPIO37, ADC1_CH1, RTC_GPIO1
     - EN
     - I
     - CHIP_PU
     - GND
     - P
     - Ground
     - VDD33 (3V3)
     - P
     - 3.3 V power supply


Header J3
""""""""""""""""""

.. list-table::
   :widths: 5 5 5 35
   :header-rows: 1
     - Name
     - Type
     - Function
     - GND
     - P
     - Ground
     - SENSOR_VP (FSVP)
     - I
     - GPIO36, ADC1_CH0, RTC_GPIO0
     - SENSOR_VN (FSVN)
     - I
     - GPIO39, ADC1_CH3, RT"
"C_GPIO3
     - IO25
     - I/O
     - GPIO25, DAC_1, ADC2_CH8, RTC_GPIO6, EMAC_RXD0
     - IO26
     - I/O
     - GPIO26, DAC_2, ADC2_CH9, RTC_GPIO7, EMAC_RXD1
     - IO32
     - I/O
     - 32K_XP :ref:`(See 2a) `, ADC1_CH4, TOUCH9, RTC_GPIO9
     - IO33
     - I/O
     - 32K_XN :ref:`(See 2b) `, ADC1_CH5, TOUCH8, RTC_GPIO8
     - IO27
     - I/O
     - GPIO27, ADC2_CH7, TOUCH7, RTC_GPIO17, EMAC_RX_DV
     - IO14
     - I/O
     - ADC2_CH6, TOUCH6, RTC_GPIO16, MTMS, HSPICLK, HS2_CLK, SD_CLK, EMA"
"C_TXD2
     - IO12
     - I/O
     - ADC2_CH5, TOUCH5, RTC_GPIO15, MTDI :ref:`(See 3) `, HSPIQ, HS2_DATA2, SD_DATA2, EMAC_TXD3
     - IO13
     - I/O
     - ADC2_CH4, TOUCH4, RTC_GPIO14, MTCK, HSPID, HS2_DATA3, SD_DATA3, EMAC_RX_ER
     - IO15
     - I/O
     - ADC2_CH3, TOUCH3, RTC_GPIO13, MTDO, HSPICS0, HS2_CMD, SD_CMD, EMAC_RXD3
     - IO2
     - I/O
     - ADC2_CH2, TOUCH2, RTC_GPIO12, HSPIWP, HS2_DATA0, SD_DATA0
     - IO4
     - I/O
     - ADC2_CH0, TOUCH0, RTC_GPIO10, HSPIHD, HS2_DATA1, S"
"D_DATA1, EMAC_TX_ER
     - IO0
     - I/O
     - ADC2_CH1, TOUCH1, RTC_GPIO11, CLK_OUT1, EMAC_TX_CLK
     - VDD33 (3V3)
     - P
     - 3.3V power supply
     - GND
     - P
     - Ground
     - EXT_5V (5V)
     - P
     - 5V power supply


.. _get-started-pico-devkitm-2-pin-notes:

.. note::
       a) input
       b) output


Pin Layout
""""""""""""""""""""
.. figure:: ../../../_static/esp32-pico-devkitm-2-pinout.png
    :align: center
    :scale: 50%
    :alt: ESP32-PICO-DevKitM-2 (click to enlarge)
   "
" :figclass: align-center

    ESP32-PICO-DevKitM-2 Pin Layout (click to enlarge)


Hardware Revision Details


No previous versions available.


Related Documents


For other design documentation for the board, please contact us at sales@espressif.com.
"
"ESP32-DevKitC V4 Getting Started Guide




This guide shows how to start using the ESP32-DevKitC V4 development board.


What You Need


You can skip the introduction sections and go directly to Section `Start Application Development`_.


.. _DevKitC-Overview:

Overview


ESP32-DevKitC V4 is a small-sized ESP32-based development board produced by `Espressif `_. Most of the I/O pins are broken out to the pin headers on both sides for easy interfacing. Developers can either connect peripherals wit"
"h jumper wires or mount ESP32-DevKitC V4 on a breadboard.

To cover a wide range of user requirements, the following versions of ESP32-DevKitC V4 are available:

- different ESP32 modules

   - `ESP32-WROOM-DA `_
   - `ESP32-WROOM-32E `_
   - `ESP32-WROOM-32UE `_
   - `ESP32-WROOM-32D `_
   - `ESP32-WROOM-32U `_
   - `ESP32-SOLO-1 `_
   - `ESP32-WROVER-E `_
   - `ESP32-WROVER-IE `_

- male or female pin headers.

For details please refer to `ESP Product Selector `_.


Functional Description


Th"
"e following figure and the table below describe the key components, interfaces and controls of the ESP32-DevKitC V4 board.

.. _get-started-esp32-devkitc-board-front:

.. figure:: ../../../_static/esp32-devkitc-functional-overview.jpg
    :align: center
    :alt: ESP32-DevKitC V4 with ESP-WROOM-32 module soldered

    ESP32-DevKitC V4 with ESP32-WROOM-32 module soldered


.. list-table::
    :widths: 25 75
    :header-rows: 1
      - Description
      - A module with ESP32 at its core. For more "
"information, see `ESP32-WROOM-32 Datasheet`_.
      - Reset button.
      - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
      - Single USB-UART bridge chip provides transfer rates of up to 3 Mbps.
      - USB interface. Power supply for the board as well as the communication interface between a computer and the ESP32-WROOM-32 module.
      - Turns on when the USB or an external 5V power supply "
"is connected to the board. For details see the schematics in `Related Documents`_.
      - Most of the pins on the ESP module are broken out to the pin headers on the board. You can program ESP32 to enable multiple functions such as PWM, ADC, DAC, I2C, I2S, SPI, etc.


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

.. warning::

    The power supply must be provided using **one and only one of the options above**, otherwise the board and/or the pow"
"er supply source can be damaged.


Header Block


The two tables below provide the **Name** and **Function** of I/O header pins on both sides of the board, as shown in :ref:`get-started-esp32-devkitc-board-front`.


J2
^^^
===      
No.  Name  Type [1]_   Function
===      
1    3V3   P           3.3 V power supply
2    EN    I           CHIP_PU, Reset
3    VP    I           GPIO36, ADC1_CH0, S_VP
4    VN    I           GPIO39, ADC1_CH3, S_VN
5    IO34  I           GPIO34, ADC1_CH6, VDET_1
6    "
"IO35  I           GPIO35, ADC1_CH7, VDET_2
7    IO32  I/O         GPIO32, ADC1_CH4, TOUCH_CH9, XTAL_32K_P
8    IO33  I/O         GPIO33, ADC1_CH5, TOUCH_CH8, XTAL_32K_N
9    IO25  I/O         GPIO25, ADC1_CH8, DAC_1
10   IO26  I/O         GPIO26, ADC2_CH9, DAC_2
11   IO27  I/O         GPIO27, ADC2_CH7, TOUCH_CH7
12   IO14  I/O         GPIO14, ADC2_CH6, TOUCH_CH6, MTMS
13   IO12  I/O         GPIO12, ADC2_CH5, TOUCH_CH5, MTDI
14   GND   G           Ground
15   IO13  I/O         GPIO13, ADC2_CH4, T"
"OUCH_CH4, MTCK
16   D2    I/O         GPIO9, D2 [2]_
17   D3    I/O         GPIO10, D3 [2]_
18   CMD   I/O         GPIO11, CMD [2]_
19   5V    P           5 V power supply
===      


J3
^^^
===      
No.  Name  Type [1]_   Function
===      
1    GND   G           Ground
2    IO23  I/O         GPIO23
3    IO22  I/O         GPIO22
4    TX    I/O         GPIO1, U0TXD
5    RX    I/O         GPIO3, U0RXD
6    IO21  I/O         GPIO21
7    GND   G           Ground
8    IO19  I/O         GPIO19
9    "
"IO18  I/O         GPIO18
10   IO5   I/O         GPIO5
11   IO17  I/O         GPIO17 [3]_
12   IO16  I/O         GPIO16 [3]_
13   IO4   I/O         GPIO4, ADC2_CH0, TOUCH_CH0
14   IO0   I/O         GPIO0, ADC2_CH1, TOUCH_CH1, Boot
15   IO2   I/O         GPIO2, ADC2_CH2, TOUCH_CH2
16   IO15  I/O         GPIO15, ADC2_CH3, TOUCH_CH3, MTDO
17   D1    I/O         GPIO8, D1 [2]_
18   D0    I/O         GPIO7, D0 [2]_
19   CLK   I/O         GPIO6, CLK [2]_
===      

.. [1] P: Power supply; I: Input; O: "
"Output.
.. [2] The pins D0, D1, D2, D3, CMD and CLK are used internally for communication between ESP32 and SPI flash memory. They are grouped on both sides near the USB connector. Avoid using these pins, as it may disrupt access to the SPI flash memory/SPI RAM.
.. [3] The pins GPIO16 and GPIO17 are available for use only on the boards with the modules ESP32-WROOM and ESP32-SOLO-1. The boards with ESP32-WROVER modules have the pins reserved for internal use.


Pin Layout

.. figure:: ../../../_s"
"tatic/esp32-devkitC-v4-pinout.png
    :align: center
    :scale: 45%
    :alt: ESP32-DevKitC (click to enlarge)

    ESP32-DevKitC Pin Layout (click to enlarge)


Note on C15


The component C15 may cause the following issues on earlier ESP32-DevKitC V4 boards:

In case these issues occur, please remove the component. The figure below shows the location of C15 highlighted in yellow.


.. figure:: ../../../_static/esp32-devkitc-c15-location.png
    :align: center
    :alt: Location of C15 (colore"
"d yellow) on ESP32-DevKitC V4 board
    :width: 30%

    Location of C15 (yellow) on ESP32-DevKitC V4 board


Start Application Development


Before powering up your ESP32-DevKitC V4, please make sure that the board is in good condition with no obvious signs of damage.

After that, proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.


Board Dimensions

"
"
.. figure:: ../../../_static/esp32-devkitc-dimensions-back.jpg
    :align: center
    :scale: 80%
    :alt: Dimensions of ESP32-DevKitC board with ESP32-WROOM-32 module soldered - back (click to enlarge)

    Dimensions of ESP32-DevKitC board with ESP32-WROOM-32 module soldered - back (click to enlarge)


Related Documents


For further design documentation for the board, please contact us at `sales@espressif.com `_.


.. toctree::
    :hidden:

    get-started-devkitc-v2
"
"ESP32-Ethernet-Kit V1.2 Getting Started Guide




This guide shows how to get started with the ESP32-Ethernet-Kit development board and also provides information about its functionality and configuration options.

The :ref:`ESP32-Ethernet-Kit ` is an Ethernet-to-Wi-Fi development board that enables Ethernet devices to be interconnected over Wi-Fi. At the same time, to provide more flexible power supply options, the ESP32-Ethernet-Kit also supports power over Ethernet (PoE).

.. _get-started-esp3"
"2-ethernet-kit-v1.2-overview:

.. figure:: ../../../_static/esp32-ethernet-kit-v1.2-overview.png
    :align: center
    :scale: 80%
    :alt: ESP32-Ethernet-Kit V1.2
    :figclass: align-center

    ESP32-Ethernet-Kit V1.2 Overview (click to enlarge)


What You Need


You can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP32-Ethernet-Kit is an ESP32-based development board produced by `Espressif `_.

It consists of two development boar"
"ds, the Ethernet board A and the PoE board B. The :ref:`Ethernet board (A) ` contains Bluetooth®/Wi-Fi dual-mode ESP32-WROVER-E module and IP101GRI, a Single Port 10/100 Fast Ethernet Transceiver (PHY). The `PoE board (B)`_ provides power over Ethernet functionality. The A board can work independently, without the board B installed.

.. _get-started-esp32-ethernet-kit-v1.2:

.. figure:: ../../../_static/esp32-ethernet-kit-v1.2.jpg
    :align: center
    :scale: 80%
    :alt: ESP32-Ethernet-Kit V"
"1.2
    :figclass: align-center

    ESP32-Ethernet-Kit V1.2 (click to enlarge)

For the application loading and monitoring, the Ethernet board (A) also features FTDI FT2232H chip - an advanced multi-interface USB bridge. This chip enables to use JTAG for direct debugging of ESP32 through the USB interface without a separate JTAG debugger.


Functionality Overview


The block diagram below shows the main components of ESP32-Ethernet-Kit and their interconnections.

.. figure:: ../../../_static/e"
"sp32-ethernet-kit-v1.1-block-diagram.png
    :align: center
    :scale: 60%
    :alt: ESP32-Ethernet-Kit block diagram (click to enlarge)
    :figclass: align-center

    ESP32-Ethernet-Kit block diagram (click to enlarge)


Functional Description


The following figures and tables describe the key components, interfaces, and controls of the ESP32-Ethernet-Kit.

.. _get-started-esp32-ethernet-kit-a-v1.2-layout:


Ethernet Board (A)


.. figure:: ../../../_static/esp32-ethernet-kit-a-v1.2-layout."
"jpg
    :align: center
    :scale: 80%
    :alt: ESP32-Ethernet-Kit V1.2 (click to enlarge)
    :figclass: align-center

    ESP32-Ethernet-Kit - Ethernet board (A) layout (click to enlarge)

The table below provides description starting from the picture's top right corner and going clockwise.

.. list-table:: Table 1  Component Description
  :widths: 40 150
  :header-rows: 1
    - Description
    - This ESP32 module features 64-Mbit PSRAM for flexible extended storage and data processing capabi"
"lities.
    - Five unpopulated through-hole solder pads to provide access to selected GPIOs of ESP32. For details, see `GPIO Header 2`_.
    - A 4-bit DIP switch used to configure the functionality of selected GPIOs of ESP32. For details see `Function Switch`_.
    - Two LEDs to show the status of UART transmission.
    - The FT2232H chip serves as a multi-protocol USB-to-serial bridge which can be programmed and controlled via USB to provide communication with ESP32. FT2232H also features USB-t"
"o-JTAG interface which is available on channel A of the chip, while USB-to-serial is on channel B. The FT2232H chip enhances user-friendliness in terms of application development and debugging. See `ESP32-Ethernet-Kit V1.2 Ethernet board (A) schematic`_.
    - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
    - Power On/Off Switch. Toggling the switch to **5V0** position powers the board on, toggling to **GND** position powers "
"the board off.
    - The 5 V power supply interface can be more convenient when the board is operating autonomously (not connected to a computer).
    - This red LED turns on when power is supplied to the board, either from USB or 5 V Input.
    - Provided DC 5 V to 3.3 V conversion, output current up to 2 A.
    - A pair male and female header pins for mounting the `PoE board (B)`_
    -  The physical layer (PHY) connection to the Ethernet cable is implemented using the `IP101GRI `_ chip. The c"
"onnection between PHY and ESP32 is done through the reduced media-independent interface (RMII), a variant of the media-independent interface `(MII) `_ standard. The PHY supports the IEEE 802.3/802.3u standard of 10/100 Mbps.
    - Ethernet network data transmission port.
    - The Magnetics are part of the Ethernet specification to protect against faults and transients, including rejection of common mode signals between the transceiver IC and the cable. The magnetics also provide galvanic isolat"
"ion between the transceiver and the Ethernet device.
    - Two LEDs (green and red) that respectively indicate the ""Link"" and ""Activity"" statuses of the PHY.
    - Download button. Holding down **BOOT** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
    - Reset button.
    - This header provides six unpopulated through-hole solder pads connected to spare GPIOs of ESP32. For details, see `GPIO Header 1`_.

.. note::

    Automatic firmw"
"are download is supported. If following steps and using software described in Section `Start Application Development`_, users do not need to do any operation with BOOT button or EN button.


PoE Board (B)


This board coverts power delivered over the Ethernet cable (PoE) to provide a power supply for the Ethernet board (A). The main components of the PoE board (B) are shown on the block diagram under `Functionality Overview`_.

The PoE board (B) has the following features:

To take advantage of "
"the PoE functionality the **RJ45 Port** of the Ethernet board (A) should be connected with an Ethernet cable to a switch that supports PoE. When the Ethernet board (A) detects 5 V power output from the PoE board (B), the USB power will be automatically cut off.

.. figure:: ../../../_static/esp32-ethernet-kit-b-v1.0-layout.png
    :align: center
    :scale: 80%
    :alt: ESP32-Ethernet-Kit - PoE board (B)
    :figclass: align-center

    ESP32-Ethernet-Kit - PoE board (B) layout (click to enlarg"
"e)

.. list-table:: Table  PoE board (B)
  :widths: 40 150
  :header-rows: 1
    - Description
    - Four female (left) and four male (right) header pins for connecting the PoE board (B) to :ref:`Ethernet board (A) `. The pins on the left accept power coming from a PoE switch. The pins on the right deliver 5 V power supply to the Ethernet board (A).
    - Optional power supply (26.6 ~ 54 V) to the PoE board (B).


.. _get-started-esp32-ethernet-kit-v1.2-setup-options:

Setup Options


This secti"
"on describes options to configure the ESP32-Ethernet-Kit hardware.


Function Switch


When in On position, this DIP switch is routing listed GPIOs to FT2232H to provide JTAG functionality. When in Off position, the GPIOs may be used for other purposes.

  
DIP SW   GPIO Pin
  
 1       GPIO13
 2       GPIO12
 3       GPIO15
 4       GPIO14
  


RMII Clock Selection


The ethernet MAC and PHY under RMII working mode need a common 50 MHz reference clock (i.e., RMII clock) that can be provided eit"
"her externally, or generated from internal ESP32 APLL (not recommended).

.. note::

    For additional information on the RMII clock selection, please refer to `ESP32-Ethernet-Kit V1.2 Ethernet board (A) schematic`_, sheet 2, location D2.


RMII Clock Sourced Externally by PHY
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

By default, the ESP32-Ethernet-Kit is configured to provide RMII clock for the IP101GRI PHY's 50M_CLKO output. The clock signal is generated by the frequency multiplication of 25 MHz "
"crystal connected to the PHY. For details, please see the figure below.

.. figure:: ../../../_static/esp32-ethernet-kit-rmii-clk-from-phy.png
    :align: center
    :scale: 80%
    :alt: RMII Clock from IP101GRI PHY
    :figclass: align-center

    RMII Clock from IP101GRI PHY

Please note that the PHY is reset on power up by pulling the RESET_N signal down with a resistor. ESP32 should assert RESET_N high with GPIO5 to enable PHY. Only this can ensure the power-up of system. Otherwise ESP32 ma"
"y enter download mode (when the clock signal of REF_CLK_50M is at a high logic level during the GPIO0 power-up sampling phase).


RMII Clock Sourced Internally from ESP32's APLL
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Another option is to source the RMII Clock from internal ESP32 APLL, see figure below. The clock signal coming from GPIO0 is first inverted, to account for transmission line delay, and then supplied to the PHY.

.. figure:: ../../../_static/esp32-ethernet-kit-rmii-clk-to-p"
"hy.png
    :align: center
    :scale: 80%
    :alt: RMII Clock from ESP Internal APLL
    :figclass: align-center

    RMII Clock from ESP Internal APLL

To implement this option, users need to remove or add some RC components on the board. For details please refer to `ESP32-Ethernet-Kit V1.2 Ethernet board (A) schematic`_, sheet 2, location D2. Please note that if the APLL is already used for other purposes (e.g., I2S peripheral), then you have no choice but use an external RMII clock.


GPIO A"
"llocation


This section describes allocation of ESP32 GPIOs to specific interfaces or functions of the ESP32-Ethernet-Kit.


IP101GRI (PHY) Interface


The allocation of the ESP32 (MAC) pins to IP101GRI (PHY) is shown in the table below. Implementation of ESP32-Ethernet-Kit defaults to Reduced Media-Independent Interface (RMII).

    
No.   ESP32 Pin (MAC)   IP101GRI (PHY)
    
*RMII Interface*

 1    GPIO21            TX_EN
 2    GPIO19            TXD[0]
 3    GPIO22            TXD[1]
 4    GP"
"IO25            RXD[0]
 5    GPIO26            RXD[1]
 6    GPIO27            CRS_DV
 7    GPIO0             REF_CLK
    
*Serial Management Interface*

 8    GPIO23            MDC
 9    GPIO18            MDIO
    
*PHY Reset*

10    GPIO5             Reset_N
    

.. note::

    The allocation of all pins under the ESP32's *RMII Interface* is fixed and cannot be changed either through IO MUX or GPIO Matrix. REF_CLK can only be selected from GPIO0, GPIO16 or GPIO17 and it can not be changed thro"
"ugh GPIO Matrix.


GPIO Header 1


This header exposes some GPIOs that are not used elsewhere on the ESP32-Ethernet-Kit.

  
No.   ESP32 Pin
  
 1    GPIO32
 2    GPIO33
 3    GPIO34
 4    GPIO35
 5    GPIO36
 6    GPIO39
  


GPIO Header 2


This header contains GPIOs that may be used for other purposes depending on scenarios described in column ""Comments"".

    
No.   ESP32 Pin   Comments
    
 1    GPIO17      See note 1
 2    GPIO16      See note 1
 3    GPIO4
 4    GPIO2
 5    GPIO13      S"
"ee note 2
 6    GPIO12      See note 2
 7    GPIO15      See note 2
 8    GPIO14      See note 2
 9    GND         Ground
10    3V3         3.3 V power supply
    

.. note::


GPIO Allocation Summary


.. csv-table::
    :header: ESP32-WROVER-E,IP101GRI,UART,JTAG,GPIO,Comments

    S_VP,,,,IO36,
    S_VN,,,,IO39,
    IO34,,,,IO34,
    IO35,,,,IO35,
    IO32,,,,IO32,
    IO33,,,,IO33,
    IO25,RXD[0],,,,
    IO26,RXD[1],,,,
    IO27,CRS_DV,,,,
    IO14,,,TMS,IO14,
    IO12,,,TDI,IO12,
    IO13,,"
",TCK,IO13,
    IO15,,,TDO,IO15,
    IO2,,,,IO2,
    IO0,REF_CLK,,,,See note 1
    IO4,,,,IO4,
    IO16,,,,IO16 (NC),See note 2
    IO17,,,,IO17 (NC),See note 2
    IO5,Reset_N,,,,See note 1
    IO18,MDIO,,,,
    IO19,TXD[0],,,,
    IO21,TX_EN,,,,
    RXD0,,RXD,,,
    TXD0,,TXD,,,
    IO22,TXD[1],,,,
    IO23,MDC,,,,

.. note::


Start Application Development


Before powering up your ESP32-Ethernet-Kit, please make sure that the board is in good condition with no obvious signs of damage.


Initi"
"al Setup



Now to Development


Proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.

Move on to the next section only if you have successfully completed all the above steps.


Configure and Load the Ethernet Example


After setting up the development environment and testing the board, you can configure and flash the :example:`ethernet/basic` example. T"
"his example has been created for testing Ethernet functionality. It supports different PHY, including **IP101GRI** installed on :ref:`get-started-esp32-ethernet-kit-v1.2`.


Summary of Changes from ESP32-Ethernet-Kit V1.1



Other Versions of ESP32-Ethernet-Kit



Related Documents


For other design documentation for the board, please contact us at sales@espressif.com.

.. _ESP32-Ethernet-Kit V1.1 Ethernet board (A) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-ETHERNET-KIT_A_V1.1"
"_20190711.pdf
.. _ESP32-Ethernet-Kit PoE board (B) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-ETHERNET-KIT_B_V1.0_20190517.pdf
.. _ESP32-Ethernet-Kit V1.0 Ethernet board (A) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-ETHERNET-KIT_A_V1.0_20190517.pdf
.. _ESP32-Ethernet-Kit V1.2 Ethernet board (A) schematic: https://dl.espressif.com/dl/schematics/SCH_ESP32-Ethernet-Kit_A_V1.2_20200528.pdf

.. toctree::
    :hidden:

    get-started-ethernet-kit-v1.0.rst
    get-st"
"arted-ethernet-kit-v1.1.rst

"
"ESP-WROVER-KIT V3 Getting Started Guide




This guide shows how to get started with the ESP-WROVER-KIT V3 development board and also provides information about its functionality and configuration options. For the description of other ESP-WROVER-KIT versions, please check :doc:`../../hw-reference/index`.


What You Need


You can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP-WROVER-KIT is an ESP32-based development board produced by "
"`Espressif `_. This board features an integrated LCD screen and microSD card slot.

ESP-WROVER-KIT comes with the following ESP32 modules:

- ESP32-WROOM-32
- ESP32-WROVER series

Its another distinguishing feature is the embedded FTDI FT2232HL chip - an advanced multi-interface USB bridge. This chip enables to use JTAG for direct debugging of ESP32 through the USB interface without a separate JTAG debugger. ESP-WROVER-KIT makes development convenient, easy, and cost-effective.

Most of the ESP3"
"2 I/O pins are broken out to the board's pin headers for easy access.

    .. note::

        The version with the ESP32-WROVER module uses ESP32's GPIO16 and GPIO17 as chip select and clock signals for PSRAM. By default, the two GPIOs are not broken out to the board's pin headers in order to ensure reliable performance.


Functionality Overview


The block diagram below shows the main components of ESP-WROVER-KIT and their interconnections.

.. figure:: ../../../_static/esp-wrover-kit-block-dia"
"gram.png
    :align: center
    :alt: ESP-WROVER-KIT block diagram
    :figclass: align-center

    ESP-WROVER-KIT block diagram


Functional Description


The following two figures and the table below describe the key components, interfaces, and controls of the ESP-WROVER-KIT board.

.. _get-started-esp-wrover-kit-v3-board-front:

.. figure:: ../../../_static/esp-wrover-kit-v3-layout-front.jpg
    :align: center
    :alt: ESP-WROVER-KIT board layout - front
    :figclass: align-center

    ESP-"
"WROVER-KIT board layout - front

.. _get-started-esp-wrover-kit-v3-board-back:

.. figure:: ../../../_static/esp-wrover-kit-v3-layout-back.jpg
    :align: center
    :alt: ESP-WROVER-KIT board layout - back
    :figclass: align-center

    ESP-WROVER-KIT board layout - back


The table below provides description in the following manner:

- Starting from the first picture's top right corner and going clockwise
- Then moving on to the second picture

.. list-table::
    :widths: 25 75
    :header-"
"rows: 1
      - Description
      - External precision 32.768 kHz crystal oscillator serves as a clock with low-power consumption while the chip is in Deep-sleep mode.
      - Zero-ohm resistor intended as a placeholder for a current shunt, can be desoldered or replaced with a current shunt to facilitate the measurement of ESP32's current consumption in different modes.
      - Either ESP32-WROOM-32 or ESP32-WROVER with an integrated ESP32. The ESP32-WROVER module features all the functions of E"
"SP32-WROOM-32 and integrates an external 32-MBit PSRAM for flexible extended storage and data processing capabilities.
      - The FT2232 chip serves as a multi-protocol USB-to-serial bridge which can be programmed and controlled via USB to provide communication with ESP32. FT2232 also features USB-to-JTAG interface which is available on channel A of the chip, while USB-to-serial is on channel B. The FT2232 chip enhances user-friendliness in terms of application development and debugging. See `E"
"SP-WROVER-KIT V3 schematic`_.
      - Serial port. The serial TX/RX signals of FT2232 and ESP32 are broken out to the inward and outward sides of JP11 respectively. By default, these pairs of pins are connected with jumpers. To use ESP32's serial interface, remove the jumpers and connect another external serial device to the respective pins.
      - By default, ESP32 uses its SPI interface to access flash and PSRAM memory inside the module. Use these pins to connect ESP32 to another SPI device. "
"In this case, an extra chip select (CS) signal is needed. Please note that the interface voltage for the version with ESP32-WROVER is 1.8V, while that for the version with ESP32-WROOM-32 is 3.3V.
      - Serial port flow control signals: the pins are not connected to the circuitry by default. To enable them, short the respective pins of JP14 with jumpers.
      - JTAG interface. JTAG signals of FT2232 and ESP32 are broken out to the inward and outward sides of JP8 respectively. By default, these"
" pairs of pins are disconnected. To enable JTAG, short the respective pins with jumpers as shown in Section `Setup Options`_.
      - Reset button.
      - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
      - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
      - Power On/Off Switch. Toggling toward **USB** powers the board on, "
"toggling away from **USB** powers the board off.
      - Power supply selector interface. The board can be powered either via USB or via the 5V Input interface. Select the power source with a jumper. For more details, see Section `Setup Options`_, jumper header JP7.
      - The 5 V power supply interface can be more convenient when the board is operating autonomously (not connected to a computer).
      - NCP1117(1A). 5V-to-3.3V LDO. NCP1117 can provide a maximum current of 1A. The LDO on the bo"
"ard has a fixed output voltage. Although, the user can install an LDO with adjustable output voltage. For details, please refer to `ESP-WROVER-KIT V3 schematic`_.
      - Camera interface, a standard OV7670 camera module.
      - Red, green and blue (RGB) light emitting diodes (LEDs), can be controlled by pulse width modulation (PWM).
      - All the pins on the ESP32 module are broken out to pin headers. You can program ESP32 to enable multiple functions, such as PWM, ADC, DAC, I2C, I2S, SPI, e"
"tc.
      - Useful for developing applications that access microSD card for data storage and retrieval.
      - Support for mounting and interfacing a 3.2” SPI (standard 4-wire Serial Peripheral Interface) LCD, as shown on figure :ref:`get-started-esp-wrover-kit-v3-board-back`.


.. _get-started-esp-wrover-kit-v3-setup-options:

Setup Options


There are five jumper blocks available to set up the board functionality. The most frequently required options are listed in the table below.

    
Heade"
"r   Jumper Setting    Description of Functionality
    
JP7      |jp7-ext_5v|      Power ESP-WROVER-KIT via an external power supply
JP7      |jp7-usb_5v|      Power ESP-WROVER-KIT via USB
JP8      |jp8|             Enable JTAG functionality
JP11     |jp11-tx-rx|      Enable UART communication
JP14     |jp14|            Enable RTS/CTS flow control for serial communication
    


Allocation of ESP32 Pins


Some pins/terminals of ESP32 are allocated for use with the onboard or external hardware. I"
"f that hardware is not used, e.g., nothing is plugged into the Camera (JP4) header, then these GPIOs can be used for other purposes.

Some of the pins, such as GPIO0 or GPIO2, have multiple functions and some of them are shared among onboard and external peripheral devices. Certain combinations of peripherals cannot work together. For example, it is not possible to do JTAG debugging of an application that is using SD card, because several pins are shared by JTAG and the SD card slot.

In other c"
"ases, peripherals can coexist under certain conditions. This is applicable to, for example, LCD screen and SD card that share only a single pin GPIO21. This pin is used to provide D/C (Data/Control) signal for the LCD as well as the CD (Card Detect) signal read from the SD card slot. If the card detect functionality is not essential, then it may be disabled by removing R167, so both LCD and SD may operate together.

For more details on which pins are shared among which peripherals, please refer "
"to the table in the next section.


Main I/O Connector/JP1


The JP1 connector consists of 14x2 male pins whose functions are shown in the middle two ""I/O"" columns of the table below. The two ""Shared With"" columns on both sides describe where else on the board a certain GPIO is used.

      
Shared With            I/O    I/O    Shared With
      
n/a                    3.3V   GND    n/a
NC/XTAL                IO32   IO33   NC/XTAL
JTAG, microSD          IO12   IO13   JTAG, microSD
JTAG, microSD "
"         IO14   IO27   Camera
Camera                 IO26   IO25   Camera, LCD
Camera                 IO35   IO34   Camera
Camera                 IO39   IO36   Camera
JTAG                   EN     IO23   Camera, LCD
Camera, LCD            IO22   IO21   Camera, LCD, microSD
Camera, LCD            IO19   IO18   Camera, LCD
Camera, LCD            IO5    IO17   PSRAM
PSRAM                  IO16   IO4    LED, Camera, microSD
Camera, LED, Boot      IO0    IO2    LED, microSD
JTAG, microSD          IO1"
"5   5V
      

Legend:


.. _get-started-esp-wrover-kit-v3-xtal:

32.768 kHz Oscillator


  
.     ESP32 Pin
  
1     GPIO32
2     GPIO33
  

.. note::

    Since GPIO32 and GPIO33 are connected to the oscillator by default, they are not connected to the JP1 I/O connector to maintain signal integrity. This allocation may be changed from the oscillator to JP1 by desoldering the zero-ohm resistors from positions R11/R23 and re-soldering them to positions R12/R24.


.. _get-started-esp-wrover-kit-v"
"3-spi-flash-header:

SPI Flash/JP13


  
.     ESP32 Pin
  
1     CLK/GPIO6
2     SD0/GPIO7
3     SD1/GPIO8
4     SD2/GPIO9
5     SD3/GPIO10
6     CMD/GPIO11
  

.. important::

    The module's flash bus is connected to the jumper block JP13 through zero-ohm resistors R140 ~ R145. If the flash memory needs to operate at the frequency of 80 MHz, for reasons such as improving the integrity of bus signals, you can desolder these resistors to disconnect the module's flash bus from the pin header JP"
"13.


.. _get-started-esp-wrover-kit-v3-jtag-header:

JTAG/JP8


    
.     ESP32 Pin       JTAG Signal
    
1     EN              TRST_N
2     MTMS/GPIO14     TMS
3     MTDO/GPIO15     TDO
4     MTDI/GPIO12     TDI
5     MTCK/GPIO13     TCK
    


.. _get-started-esp-wrover-kit-v3-camera-header:

Camera/JP4


    
.     ESP32 Pin   Camera Signal
    
 1    n/a         3.3V
 2    n/a         Ground
 3    GPIO27      SIO_C/SCCB Clock
 4    GPIO26      SIO_D/SCCB Data
 5    GPIO25      VSYNC/Verti"
"cal Sync
 6    GPIO23      HREF/Horizontal Reference
 7    GPIO22      PCLK/Pixel Clock
 8    GPIO21      XCLK/System Clock
 9    GPIO35      D7/Pixel Data Bit 7
10    GPIO34      D6/Pixel Data Bit 6
11    GPIO39      D5/Pixel Data Bit 5
12    GPIO36      D4/Pixel Data Bit 4
13    GPIO19      D3/Pixel Data Bit 3
14    GPIO18      D2/Pixel Data Bit 2
15    GPIO5       D1/Pixel Data Bit 1
16    GPIO4       D0/Pixel Data Bit 0
17    GPIO0       RESET/Camera Reset
18    n/a         PWDN/Camera Power"
" Down
    


.. _get-started-esp-wrover-kit-v3-rgb-led-connections:

RGB LED


    
.     ESP32 Pin   RGB LED
    
1     GPIO0       Red
2     GPIO2       Green
3     GPIO4       Blue
    


.. _get-started-esp-wrover-kit-v3-microsd-card-slot:

microSD Card


    
.     ESP32 Pin       microSD Signal
    
1     MTDI/GPIO12     DATA2
2     MTCK/GPIO13     CD/DATA3
3     MTDO/GPIO15     CMD
4     MTMS/GPIO14     CLK
5     GPIO2           DATA0
6     GPIO4           DATA1
7     GPIO21          CD
 "
"   


.. _get-started-esp-wrover-kit-v3-lcd-connector:

LCD/U5


    
.     ESP32 Pin       LCD Signal
    
1     GPIO18          RESET
2     GPIO19          SCL
3     GPIO21          D/C
4     GPIO22          CS
5     GPIO23          SDA
6     GPIO25          SDO
7     GPIO5           Backlight
    


.. _get-started-esp-wrover-kit-v3-start-development:

Start Application Development


Before powering up your ESP-WROVER-KIT, please make sure that the board is in good condition with no obvious s"
"igns of damage.


Initial Setup


Please set only the following jumpers shown in the pictures below:

- Select USB as the power source using the jumper block JP7.

- Enable UART communication using the jumper block JP11.

  
Power up from USB port    Enable UART communication
  
|jp7-usb_5v|              |jp11-tx-rx|
  

Do not install any other jumpers.

Turn the **Power Switch** to ON, the **5V Power On LED** should light up.


Now to Development


Please proceed to :doc:`../../get-started/ind"
"ex`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.


Related Documents


.. |jp7-ext_5v| image:: ../../../_static/esp-wrover-kit-v3-jp7-ext_5v.png
.. |jp7-usb_5v| image:: ../../../_static/esp-wrover-kit-v3-jp7-usb_5v.png
.. |jp8| image:: ../../../_static/esp-wrover-kit-v3-jp8.png
.. |jp11-tx-rx| image:: ../../../_static/esp-wrover-kit-v3-jp11-tx-rx.png
.. |jp14| image:: ../../../_static/es"
"p-wrover-kit-v3-jp14.png

.. _ESP-WROVER-KIT V3 schematic: https://dl.espressif.com/dl/schematics/ESP-WROVER-KIT_SCH-3.pdf

.. toctree::
    :hidden:

    get-started-wrover-kit-v2.rst
"
"ESP-WROVER-KIT V2 Getting Started Guide




This guide shows how to get started with the ESP-WROVER-KIT V2 development board and also provides information about its functionality and configuration options. For the description of other ESP-WROVER-KIT versions, please check :doc:`../../hw-reference/index`.


What You Need


You can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP-WROVER-KIT is an ESP32-based development board produced by "
"`Espressif `_. This board features an integrated LCD screen and microSD card slot.

ESP-WROVER-KIT comes with the following ESP32 modules:

- ESP32-WROOM-32
- ESP32-WROVER series

Its another distinguishing feature is the embedded FTDI FT2232HL chip - an advanced multi-interface USB bridge. This chip enables to use JTAG for direct debugging of ESP32 through the USB interface without a separate JTAG debugger. ESP-WROVER-KIT makes development convenient, easy, and cost-effective.

Most of the ESP3"
"2 I/O pins are broken out to the board's pin headers for easy access.

    .. note::

        The version with the ESP32-WROVER module uses ESP32's GPIO16 and GPIO17 as chip select and clock signals for PSRAM. By default, the two GPIOs are not broken out to the board's pin headers in order to ensure reliable performance.


Functionality Overview


The block diagram below shows the main components of ESP-WROVER-KIT and their interconnections.

.. figure:: ../../../_static/esp-wrover-kit-block-dia"
"gram.png
    :align: center
    :alt: ESP-WROVER-KIT block diagram
    :figclass: align-center

    ESP-WROVER-KIT block diagram


Functional Description


The following two figures and the table below describe the key components, interfaces, and controls of the ESP-WROVER-KIT board.

.. _get-started-esp-wrover-kit-v2-board-front:

.. figure:: ../../../_static/esp-wrover-kit-v2-layout-front.png
    :align: center
    :alt: ESP-WROVER-KIT board layout - front
    :figclass: align-center

    ESP-"
"WROVER-KIT board layout - front

.. _get-started-esp-wrover-kit-v2-board-back:

.. figure:: ../../../_static/esp-wrover-kit-v2-layout-back.png
    :align: center
    :alt: ESP-WROVER-KIT board layout - back
    :figclass: align-center

    ESP-WROVER-KIT board layout - back


The table below provides description in the following manner:

- Starting from the first picture's top right corner and going clockwise
- Then moving on to the second picture

.. list-table::
    :widths: 25 75
    :header-"
"rows: 1
      - Description
      - External precision 32.768 kHz crystal oscillator serves as a clock with low-power consumption while the chip is in Deep-sleep mode.
      - Either ESP32-WROOM-32 or ESP32-WROVER with an integrated ESP32. The ESP32-WROVER module features all the functions of ESP32-WROOM-32 and integrates an external 32-MBit PSRAM for flexible extended storage and data processing capabilities.
      - Serial port flow control signals: the pins are not connected to the circuitry "
"by default. To enable them, short the respective pins of JP14 with jumpers.
      - Serial port. The serial TX/RX signals of FT2232 and ESP32 are broken out to the inward and outward sides of JP11 respectively. By default, these pairs of pins are connected with jumpers. To use ESP32's serial interface, remove the jumpers and connect another external serial device to the respective pins.
      - By default, ESP32 uses its SPI interface to access flash and PSRAM memory inside the module. Use these"
" pins to connect ESP32 to another SPI device. In this case, an extra chip select (CS) signal is needed. Please note that the interface voltage for the version with ESP32-WROVER is 1.8V, while that for the version with ESP32-WROOM-32 is 3.3 V.
      - JTAG interface. JTAG signals of FT2232 and ESP32 are broken out to the inward and outward sides of JP8 respectively. By default, these pairs of pins are disconnected. To enable JTAG, short the respective pins with jumpers as shown in Section `Setup "
"Options`_.
      - The FT2232 chip serves as a multi-protocol USB-to-serial bridge which can be programmed and controlled via USB to provide communication with ESP32. FT2232 features USB-to-UART and USB-to-JTAG functionalities.
      - Reset button.
      - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
      - USB interface. Power supply for the board as well as the communication interface betwee"
"n a computer and the board.
      - Power supply selector interface. The board can be powered either via USB or via the 5 V Input interface. Select the power source with a jumper. For more details, see Section `Setup Options`_, jumper header JP7.
      - Power On/Off Switch. Toggling toward **USB** powers the board on, toggling away from **USB** powers the board off.
      - The 5 V power supply interface can be more convenient when the board is operating autonomously (not connected to a compute"
"r).
      - NCP1117(1 A). 5V-to-3.3V LDO. NCP1117 can provide a maximum current of 1 A. The LDO on the board has a fixed output voltage. Although, the user can install an LDO with adjustable output voltage. For details, please refer to `ESP-WROVER-KIT V2 schematic`_.
      - Camera interface, a standard OV7670 camera module.
      - Red, green and blue (RGB) light emitting diodes (LEDs), can be controlled by pulse width modulation (PWM).
      - All the pins on the ESP32 module are broken out to"
" pin headers. You can program ESP32 to enable multiple functions, such as PWM, ADC, DAC, I2C, I2S, SPI, etc.
      - microSD card slot for data storage: when ESP32 enters the download mode, GPIO2 cannot be held high. However, a pull-up resistor is required on GPIO2 to enable the microSD Card. By default, GPIO2 and the pull-up resistor R153 are disconnected. To enable the SD Card, use jumpers on JP1 as shown in Section `Setup Options`_.
      - Support for mounting and interfacing a 3.2” SPI (sta"
"ndard 4-wire Serial Peripheral Interface) LCD, as shown on figure :ref:`get-started-esp-wrover-kit-v2-board-back`.


.. _get-started-esp-wrover-kit-v2-setup-options:

Setup Options


There are five jumper blocks available to set up the board functionality. The most frequently required options are listed in the table below.

    
Header   Jumper Setting    Description of Functionality
    
JP1      |jp1-sd_io2|      Enable pull up for the microSD Card
JP1      |jp1-both|        Assert GPIO2 low d"
"uring each download (by jumping it to GPIO0)
JP7      |jp7-ext_5v|      Power ESP-WROVER-KIT via an external power supply
JP7      |jp7-usb_5v|      Power ESP-WROVER-KIT via USB
JP8      |jp8|             Enable JTAG functionality
JP11     |jp11-tx-rx|      Enable UART communication
JP14     |jp14|            Enable RTS/CTS flow control for serial communication
    


.. _get-started-esp-wrover-kit-v2-start-development:

Start Application Development


Before powering up your ESP-WROVER-KIT, ple"
"ase make sure that the board is in good condition with no obvious signs of damage.


Initial Setup


Please set only the following jumpers shown in the pictures below:

- Select USB as the power source using the jumper block JP7.

- Enable UART communication using the jumper block JP11.

  
Power up from USB port    Enable UART communication
  
|jp7-usb_5v|              |jp11-tx-rx|
  

Do not install any other jumpers.

Turn the **Power Switch** to ON, the **5V Power On LED** should light up.

"
"
Now to Development


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.


Related Documents



.. |jp1-sd_io2| image:: ../../../_static/wrover-jp1-sd_io2.png
.. |jp1-both| image:: ../../../_static/wrover-jp1-both.png
.. |jp7-ext_5v| image:: ../../../_static/wrover-jp7-ext_5v.png
.. |jp7-usb_5v| image:: ../../../_static/wrover-jp7-usb_5v.png
.. "
"|jp8| image:: ../../../_static/wrover-jp8.png
.. |jp11-tx-rx| image:: ../../../_static/wrover-jp11-tx-rx.png
.. |jp14| image:: ../../../_static/wrover-jp14.png

.. _ESP-WROVER-KIT V2 schematic: https://dl.espressif.com/dl/schematics/ESP-WROVER-KIT_SCH-2.pdf
"
"ESP32-DevKitC V2 Getting Started Guide




This guide shows how to start using the ESP32-DevKitC V2 development board.


What You Need


You can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP32-DevKitC V2 is a small-sized ESP32-based development board produced by `Espressif `_. Most of the I/O pins are broken out to the pin headers on both sides for easy interfacing. Developers can either connect peripherals with jumper wires or mount"
" ESP32-DevKitC V4 on a breadboard.


Functional Description


The following figure and the table below describe the key components, interfaces and controls of the ESP32-DevKitC V2 board.

.. _get-started-esp32-devkitc-v2-board-front-make:

.. figure:: ../../../_static/esp32-devkitc-v2-functional-overview.png
    :align: center
    :alt: ESP32-DevKitC V2 board layout
    :figclass: align-center

    ESP32-DevKitC V2 board layout


.. list-table::
    :widths: 25 75
    :header-rows: 1
      - Des"
"cription
      - Standard module with ESP32 at its core. For more information, see `ESP32-WROOM-32 Datasheet `_
      - Reset button.
      - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
      - USB interface. Power supply for the board as well as the communication interface between a computer and ESP32-WROOM-32.
      - Most of the pins on the ESP module are broken out to the pin headers on the"
" board. You can program ESP32 to enable multiple functions such as PWM, ADC, DAC, I2C, I2S, SPI, etc.


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

.. warning::

    The power supply must be provided using **one and only one of the options above**, otherwise the board and/or the power supply source can be damaged.


Start Application Development


Before powering up your ESP32-DevKitC V2, please make sure that the board is in good condition with"
" no obvious signs of damage.

After that, proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.


Related Documents

"
"


This user guide will help you get started with ESP32-DevKitM-1 and will also provide more in-depth information.

ESP32-DevKitM-1 is an ESP32-MINI-1/1U-based development board produced by Espressif. Most of the I/O pins are broken out to the pin headers on both sides for easy interfacing. Users can either connect peripherals with jumper wires or mount ESP32-DevKitM-1 on a breadboard.


+++
| |ESP32-DevKitM-1 - front| | |ESP32-DevKitM-1 - isometric| |
+++
|  ESP32-DevKitM-1 - front  |  ESP32-De"
"vKitM-1 - isometric  |
+++

.. |ESP32-DevKitM-1 - front| image:: ../../../_static/esp32-DevKitM-1-front.png

.. |ESP32-DevKitM-1 - isometric| image:: ../../../_static/esp32-DevKitM-1-isometric.png


The document consists of the following major sections:

- `Getting started`_: Provides an overview of the ESP32-DevKitM-1 and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information about the ESP32-DevKitM-1's hardware.
- `Related Documents`_: "
"Gives links to related documentaiton.


Getting Started


This section describes how to get started with ESP32-DevKitM-1. It begins with a few introductory sections about the ESP32-DevKitM-1, then Section `Start Application Development`_ provides instructions on how to do the initial hardware setup and then how to flash firmware onto the ESP32-DevKitM-1.


Overview


This is a small and convenient development board that features:

- `ESP32-MINI-1, or ESP32-MINI-1U module `_
- USB-to-serial progr"
"amming interface that also provides power supply for the board
- pin headers
- pushbuttons for reset and activation of Firmware Download mode
- a few other components


Contents and Packaging


Retail Orders


If you order a few samples, each ESP32-DevKitM-1 comes in an individual package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards "
"come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Description of Components


The following figure and the table below describe the key components, interfaces and controls of the ESP32-DevKitM-1 board. We take the board with a ESP32-MINI-1 module as an example in the following sections.


.. figure:: ../../../_static/esp32-devkitm-1-v1-annotated-photo.png
    :align: center
    :alt: ESP32-DevKitM-1 - front
    :figclass"
": align-center

    ESP32-DevKitM-1 - front


.. list-table::
    :widths: 25 75
    :header-rows: 1
      - Description
      - ESP32-MINI-1 module or ESP32-MINI-1U module. ESP32-MINI-1 comes with an on-board PCB antenna. ESP32-MINI-1U comes with an external antenna connector. The two modules both have a 4 MB flash in chip package. For details, please see `ESP32-MINI-1 & ESP32-MINI-1U Datasheet `_.
      - Power regulator converts 5 V to 3.3 V.
      - Download button. Holding down **Boot** and"
" then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
      - Reset Button
      - USB interface. Power supply for the board as well as the communication interface between a computer and the ESP32 chip.
      - Single USB-UART bridge chip provides transfer rates up to 3 Mbps.
      - Turns on when the USB is connected to the board. For details, please see the schematics in `Related Documents`_.
      - All available GPIO pins (except for the "
"SPI bus for flash) are broken out to the pin headers on the board. Users can program ESP32 chip to enable multiple functions.


Start Application Development


Before powering up your ESP32-DevKitM-1, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-DevKitM-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS


Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-sta"
"rted-step-by-step` will quickly help you set up the development environment and then flash an application example onto your ESP32-DevKitM-1.

.. attention::

    ESP32-DevKitM-1 boards manufactured before December 2, 2021 have a single core module installed. To verify what module you have, please check module marking information in `PCN-2021-021 `_ . If your board has a single core module installed, please enable single core mode (:ref:`CONFIG_FREERTOS_UNICORE`) in :ref:`menuconfig ` before flas"
"hing your applications.


Hardware Reference


Block Diagram


A block diagram below shows the components of ESP32-DevKitM-1 and their interconnections.

.. figure:: ../../../_static/esp32-DevKitM-1_v1_SystemBlock.png
    :align: center
    :alt: ESP32-DevKitM-1
    :figclass: align-center

    ESP32-DevKitM-1


Power Source Select


There are three mutually exclusive ways to provide power to the board:

.. warning::

    - The power supply must be provided using **one and only one of the option"
"s above**, otherwise the board and/or the power supply source can be damaged.
    - Power supply by micro USB port is recommended.


Pin Descriptions


The table below provides the Name and Function of pins on both sides of the board. For peripheral pin configurations, please refer to `ESP32 Datasheet`_.

.. list-table::
   :header-rows: 1
   :widths: 10 12 12 66
     - Name
     - Type [1]_
     - Function
     - GND
     - P
     - Ground
     - 3V3
     - P
     - 3.3 V power supply
     - I3"
"6
     - I
     - GPIO36, ADC1_CH0, RTC_GPIO0
     - I37
     - I
     - GPIO37, ADC1_CH1, RTC_GPIO1
     - I38
     - I
     - GPIO38, ADC1_CH2, RTC_GPIO2
     - I39
     - I
     - GPIO39, ADC1_CH3, RTC_GPIO3
     - RST
     - I
     - Reset; High: enable; Low: powers off
     - I34
     - I
     - GPIO34, ADC1_CH6, RTC_GPIO4
     - I35
     - I
     - GPIO35, ADC1_CH7, RTC_GPIO5
     - IO32
     - I/O
     - GPIO32, XTAL_32K_P (32.768 kHz crystal oscillator input), ADC1_CH4, TOUCH9, RTC_GPIO9"
"
     - IO33
     - I/O
     - GPIO33, XTAL_32K_N (32.768 kHz crystal oscillator output), ADC1_CH5, TOUCH8, RTC_GPIO8
     - IO25
     - I/O
     - GPIO25, DAC_1, ADC2_CH8, RTC_GPIO6, EMAC_RXD0
     - IO26
     - I/O
     - GPIO26, DAC_2, ADC2_CH9, RTC_GPIO7, EMAC_RXD1
     - IO27
     - I/O
     - GPIO27, ADC2_CH7, TOUCH7, RTC_GPIO17, EMAC_RX_DV
     - IO14
     - I/O
     - GPIO14, ADC2_CH6, TOUCH6, RTC_GPIO16, MTMS, HSPICLK, HS2_CLK, SD_CLK, EMAC_TXD2
     - 5V
     - P
     - 5 V power suppl"
"y
     - IO12
     - I/O
     - GPIO12, ADC2_CH5, TOUCH5, RTC_GPIO15, MTDI [2]_, HSPIQ, HS2_DATA2, SD_DATA2, EMAC_TXD3
     - IO13
     - I/O
     - GPIO13, ADC2_CH4, TOUCH4, RTC_GPIO14, MTCK, HSPID, HS2_DATA3, SD_DATA3, EMAC_RX_ER
     - IO15
     - I/O
     - GPIO15, ADC2_CH3, TOUCH3, RTC_GPIO13, MTDO [2]_, HSPICS0, HS2_CMD, SD_CMD, EMAC_RXD3
     - IO2
     - I/O
     - GPIO2 [2]_, ADC2_CH2, TOUCH2, RTC_GPIO12, HSPIWP, HS2_DATA0, SD_DATA0
     - IO0
     - I/O
     - GPIO0 [2]_, ADC2_CH1, TOU"
"CH1, RTC_GPIO11, CLK_OUT1, EMAC_TX_CLK
     - IO4
     - I/O
     - GPIO4, ADC2_CH0, TOUCH0, RTC_GPIO10, HSPIHD, HS2_DATA1, SD_DATA1, EMAC_TX_ER
     - IO9
     - I/O
     - GPIO9, HS1_DATA2, U1RXD, SD_DATA2
     - IO10
     - I/O
     - GPIO10, HS1_DATA3, U1TXD, SD_DATA3
     - IO5
     - I/O
     - GPIO5 [2]_, HS1_DATA6, VSPICS0, EMAC_RX_CLK
     - IO18
     - I/O
     - GPIO18, HS1_DATA7, VSPICLK
     - IO23
     - I/O
     - GPIO23, HS1_STROBE, VSPID
     - IO19
     - I/O
     - GPIO19, VSP"
"IQ, U0CTS, EMAC_TXD0
     - IO22
     - I/O
     - GPIO22, VSPIWP, U0RTS, EMAC_TXD1
     - IO21
     - I/O
     - GPIO21, VSPIHD, EMAC_TX_EN
     - TXD0
     - I/O
     - GPIO1, U0TXD, CLK_OUT3, EMAC_RXD2
     - RXD0
     - I/O
     - GPIO3, U0RXD, CLK_OUT2

.. [1] P: Power supply; I: Input; O: Output.
.. [2] MTDI, GPIO0, GPIO2, MTDO, and GPIO5 are strapping pins. These pins are used to control several chip functions depending on binary voltage values applied to the pins during chip power-up or "
"system reset. For description and application of the strapping pins, please refer to `ESP32 Datasheet`_ > Section *Strapping Pins*.


Pin Layout


.. figure:: ../../../_static/ESP32_DevKitM-1_pinlayout.png
    :align: center
    :scale: 43%
    :alt: ESP32-DevKitM-1 (click to enlarge)
    :figclass: align-center

    ESP32-DevKitM-1 (click to enlarge)


Hardware Revision Details


No previous versions available.


Related Documents


For other design documentation for the board, please contact u"
"s at sales@espressif.com.
"
"ESP32-PICO-KIT-1




Overview


ESP32-PICO-KIT-1 is an ESP32-based development board produced by `Espressif `_.

The core of this board is `ESP32-PICO-V3 `_ - a System-in-Package (SiP) module with complete Wi-Fi and Bluetooth® functionalities. Compared to other ESP32 modules, ESP32-PICO-V3 integrates the following peripheral components in one single package, which otherwise would need to be installed separately:

- 40 MHz crystal oscillator
- 4 MB flash
- Filter capacitors
- RF matching network
"
"
This setup reduces the costs of additional external components as well as the cost of assembly and testing and also increases the overall usability of the product.

The development board features a USB-to-UART Bridge circuit which allows developers to connect the board to a computer's USB port for flashing and debugging.

All the IO signals and system power on ESP32-PICO-V3 are led out to two rows of 18 x 0.1"" header pads on both sides of the development board for easy access. For compatibility"
" with Dupont wires, all header pads are populated with two rows of male pin headers.

.. note::

    ESP32-PICO-KIT-1 comes with male headers by default.

ESP32-PICO-KIT-1 provides the users with hardware for development of applications based on the ESP32, making it easier for users to explore ESP32 functionalities.

.. figure:: ../../../_static/esp32-pico-kit-1-overview.png
    :align: center
    :scale: 70%
    :alt: ESP32-PICO-KIT-1 (click to enlarge)
    :figclass: align-center

    ESP32-PI"
"CO-KIT-1 Overview (click to enlarge)

This guide covers:

- `Getting Started`_: Provides an overview of the ESP32-PICO-KIT-1 and software setup instructions to get started.
- `Contents and Packaging`_: Provides information about packaging and contents for retail and wholesale orders.
- `Hardware Reference`_: Provides more detailed information about the ESP32-PICO-KIT-1's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous version"
"s of the ESP32-PICO-KIT-1.
- `Related Documents`_: Gives links to related documentation.


Getting Started


This section describes how to get started with the ESP32-PICO-KIT-1. It begins with a few introductory sections about the ESP32-PICO-KIT-1, then Section `Start Application Development`_ provides instructions on how to flash firmware onto the ESP32-PICO-KIT-1.


.. _get-started-pico-kit-1-board-front:

Description of Components


The following figure and the table below describe the key co"
"mponents, interfaces, and controls of the ESP32-PICO-KIT-1 board.

.. figure:: ../../../_static/esp32-pico-kit-1-layout-front.png
    :align: center
    :scale: 90%
    :alt: ESP32-PICO-KIT-1 (click to enlarge)
    :figclass: align-center

    ESP32-PICO-KIT-1 board layout - front (click to enlarge)


Below is the description of the items identified in the figure starting from the top left corner and going clockwise.

.. list-table::
   :widths: 10 25
   :header-rows: 1
     - Description
     -"
" Standard ESP32-PICO-V3 module soldered to the ESP32-PICO-KIT-1 board. The complete ESP32 system on a chip (ESP32 SoC) has been integrated into the SiP module, requiring only an external antenna with LC matching network, decoupling capacitors, and a pull-up resistor for EN signals to function properly.
     - 5V-to-3.3V Low dropout voltage regulator (LDO).
     - CP2102N, single-chip USB-to-UART bridge that offers up to 3 Mbps transfers rates.
     - USB interface. Power supply for the board as "
"well as the communication interface between a computer and the board.
     - This red LED turns on when power is supplied to the board. For details, see the schematic in `Related Documents`_.
     - All the pins on ESP32-PICO-V3 are broken out to pin headers. You can program ESP32 to enable multiple functions, such as PWM, ADC, DAC, I2C, I2S, SPI, etc. For details, please see Section `Pin Descriptions`_.
     - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Do"
"wnload mode for downloading firmware through the serial port.
     - Reset button.


Start Application Development


Before powering up your ESP32-PICO-KIT-1, please make sure that the board is in good condition with no obvious signs of damage.


Required Hardware
""""""""""""""""""""""""""""""""""

- 1 x ESP32-PICO-KIT-1
- 1 x USB 2.0 A to Micro B cable
- 1 x Computer running Windows, Linux, or macOS


.. _user-guide-pico-kit-1-software-setup:

Software Setup
""""""""""""""""""""""""""""

Please proceed to :doc:`../../get-st"
"arted/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment.


Contents and Packaging


Retail Orders


If you order one or several samples of the board, each ESP32-PICO-KIT-1 development board comes in an individual package.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://ww"
"w.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the main components of ESP32-PICO-KIT-1 and their interconnections.

.. figure:: ../../../_static/esp32-pico-kit-1-block.png
    :align: center
    :scale: 70%
    :alt: ESP32-PICO-KIT-1 (click to enlarge)
    :figclass: align-center

    ESP32-PICO-KIT-1 Block Diagram (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:"
"

.. warning::

    The power supply must be provided using **one and only one of the options above**, otherwise the board and/or the power supply source can be damaged.


Pin Descriptions


The two tables below provide the **Name** and **Function** of I/O header pins on both sides of the board, see :ref:`get-started-pico-kit-1-board-front`. The pin numbering and header names are the same as in the schematic given in `Related Documents`_.


Header J2
""""""""""""""""""

.. list-table::
   :widths: 5 5 5 "
"35
   :header-rows: 1
     - Name
     - Type
     - Function
     - IO20
     - I/O
     - GPIO20
     - IO21
     - I/O
     - GPIO21, VSPIHD, EMAC_TX_EN
     - IO22
     - I/O
     - GPIO22, VSPIWP, U0RTS, EMAC_TXD1
     - IO19
     - I/O
     - GPIO19, VSPIQ, U0CTS, EMAC_TXD0
     - IO8
     - I/O
     - GPIO8, SD_DATA1, HS1_DATA1, U2CTS
     - IO7
     - I/O
     - GPIO7, SD_DATA0, HS1_DATA0, U2RTS
     - IO5
     - I/O
     - GPIO5, VSPICS0, HS1_DATA6, EMAC_RX_CLK
     - IO10
     - I/O
  "
"   - GPIO10, SD_DATA3, SPIWP, HS1_DATA3, U1TXD
     - IO9
     - I/O
     - GPIO9, SD_DATA2, SPIHD, HS1_DATA2, U1RXD
     - RXD0
     - I/O
     - GPIO3, U0RXD :ref:`(See 1) `, CLK_OUT2
     - TXD0
     - I/O
     - GPIO1, U0TXD :ref:`(See 1) `, CLK_OUT3, EMAC_RXD2
     - IO35
     - I
     - ADC1_CH7, RTC_GPIO5
     - IO34
     - I
     - ADC1_CH6, RTC_GPIO4
     - IO38
     - I
     - GPIO38, ADC1_CH2, RTC_GPIO2
     - IO37
     - I
     - GPIO37, ADC1_CH1, RTC_GPIO1
     - EN
     - I
     - "
"CHIP_PU
     - GND
     - P
     - Ground
     - VDD33 (3V3)
     - P
     - 3.3 V power supply


Header J3
""""""""""""""""""

.. list-table::
   :widths: 5 5 5 35
   :header-rows: 1
     - Name
     - Type
     - Function
     - GND
     - P
     - Ground
     - SENSOR_VP (FSVP)
     - I
     - GPIO36, ADC1_CH0, RTC_GPIO0
     - SENSOR_VN (FSVN)
     - I
     - GPIO39, ADC1_CH3, RTC_GPIO3
     - IO25
     - I/O
     - GPIO25, DAC_1, ADC2_CH8, RTC_GPIO6, EMAC_RXD0
     - IO26
     - I/O
     - GPIO26, D"
"AC_2, ADC2_CH9, RTC_GPIO7, EMAC_RXD1
     - IO32
     - I/O
     - 32K_XP :ref:`(See 2a) `, ADC1_CH4, TOUCH9, RTC_GPIO9
     - IO33
     - I/O
     - 32K_XN :ref:`(See 2b) `, ADC1_CH5, TOUCH8, RTC_GPIO8
     - IO27
     - I/O
     - GPIO27, ADC2_CH7, TOUCH7, RTC_GPIO17, EMAC_RX_DV
     - IO14
     - I/O
     - ADC2_CH6, TOUCH6, RTC_GPIO16, MTMS, HSPICLK, HS2_CLK, SD_CLK, EMAC_TXD2
     - IO12
     - I/O
     - ADC2_CH5, TOUCH5, RTC_GPIO15, MTDI :ref:`(See 3) `, HSPIQ, HS2_DATA2, SD_DATA2, EMAC_T"
"XD3
     - IO13
     - I/O
     - ADC2_CH4, TOUCH4, RTC_GPIO14, MTCK, HSPID, HS2_DATA3, SD_DATA3, EMAC_RX_ER
     - IO15
     - I/O
     - ADC2_CH3, TOUCH3, RTC_GPIO13, MTDO, HSPICS0, HS2_CMD, SD_CMD, EMAC_RXD3
     - IO2
     - I/O
     - ADC2_CH2, TOUCH2, RTC_GPIO12, HSPIWP, HS2_DATA0, SD_DATA0
     - IO4
     - I/O
     - ADC2_CH0, TOUCH0, RTC_GPIO10, HSPIHD, HS2_DATA1, SD_DATA1, EMAC_TX_ER
     - IO0
     - I/O
     - ADC2_CH1, TOUCH1, RTC_GPIO11, CLK_OUT1, EMAC_TX_CLK
     - VDD33 (3V3)
   "
"  - P
     - 3.3V power supply
     - GND
     - P
     - Ground
     - EXT_5V (5V)
     - P
     - 5V power supply


.. _get-started-pico-kit-1-pin-notes:

.. note::
       a) input
       b) output


Pin Layout
""""""""""""""""""""
.. figure:: ../../../_static/esp32-pico-kit-1-pinout.png
    :align: center
    :scale: 50%
    :alt: ESP32-PICO-KIT-1 (click to enlarge)
    :figclass: align-center

    ESP32-PICO-KIT-1 Pin Layout(click to enlarge)


Hardware Revision Details


No previous versions availabl"
"e.


Related Documents


For other design documentation for the board, please contact us at sales@espressif.com.
"
"ESP32-PICO-KIT V4/V4.1 Getting Started Guide




This guide shows how to get started with the ESP32-PICO-KIT V4/V4.1 mini development board. For the description of other ESP32-PICO-KIT versions, please check :doc:`../../hw-reference/index`.

This particular description covers ESP32-PICO-KIT V4 and V4.1. The difference is the upgraded USB-UART bridge from CP2102 in V4 with up to 1 Mbps transfer rates to CP2102N in V4.1 with up to 3 Mbps transfer rates.


What You Need


You can skip the introduct"
"ion sections and go directly to Section `Start Application Development`_.


Overview


ESP32-PICO-KIT is an ESP32-based mini development board produced by `Espressif `_.

The core of this board is ESP32-PICO-D4 - a System-in-Package (SiP) module with complete Wi-Fi and Bluetooth® functionalities. Compared to other ESP32 modules, ESP32-PICO-D4 integrates the following peripheral components in one single package, which otherwise would need to be installed separately:

- 40 MHz crystal oscillator
-"
" 4 MB flash
- Filter capacitors
- RF matching links

This setup reduces the costs of additional external components as well as the cost of assembly and testing and also increases the overall usability of the product.

The development board features a USB-UART Bridge circuit which allows developers to connect the board to a computer's USB port for flashing and debugging.

All the IO signals and system power on ESP32-PICO-D4 are led out to two rows of 20 x 0.1"" header pads on both sides of the dev"
"elopment board for easy access. For compatibility with Dupont wires, 2 x 17 header pads are populated with two rows of male pin headers. The remaining 2 x 3 header pads beside the antenna are not populated. These pads may be populated later by the user if required.

.. note::


Functionality Overview


The block diagram below shows the main components of ESP32-PICO-KIT and their interconnections.

.. figure:: ../../../_static/esp32-pico-kit-v4-functional-block-diagram.png
    :align: center
    "
":alt: ESP32-PICO-KIT functional block diagram
    :figclass: align-center

    ESP32-PICO-KIT block diagram


Functional Description


The following figure and the table below describe the key components, interfaces, and controls of the ESP32-PICO-KIT board.

.. _get-started-pico-kit-v4-board-front:

.. figure:: ../../../_static/esp32-pico-kit-v4.1-f-layout.jpeg
    :align: center
    :alt: ESP32-PICO-KIT board layout (with female headers)
    :figclass: align-center

    ESP32-PICO-KIT board la"
"yout (with female headers)

Below is the description of the items identified in the figure starting from the top left corner and going clockwise.

.. list-table::
    :widths: 25 75
    :header-rows: 1
      - Description
      - Standard ESP32-PICO-D4 module soldered to the ESP32-PICO-KIT board. The complete ESP32 system on a chip (ESP32 SoC) has been integrated into the SiP module, requiring only an external antenna with LC matching network, decoupling capacitors, and a pull-up resistor for EN"
" signals to function properly.
      - 5V-to-3.3V Low dropout voltage regulator (LDO).
      - Single-chip USB-UART bridge: CP2102 in V4 provides up to 1 Mbps transfer rates and CP2102N in V4.1 offers up to 3 Mbps transfers rates.
      - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
      - This red LED turns on when power is supplied to the board. For details, see the schematics in `Related Documents`_.
      - All the pins o"
"n ESP32-PICO-D4 are broken out to pin headers. You can program ESP32 to enable multiple functions, such as PWM, ADC, DAC, I2C, I2S, SPI, etc. For details, please see Section `Pin Descriptions`_.
      - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
      - Reset button.


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

.. warning::

    The power sup"
"ply must be provided using **one and only one of the options above**, otherwise the board and/or the power supply source can be damaged.


Pin Descriptions


The two tables below provide the **Name** and **Function** of I/O header pins on both sides of the board, see :ref:`get-started-pico-kit-v4-board-front`. The pin numbering and header names are the same as in the schematic given in `Related Documents`_.


Header J2
""""""""""""""""""

      
No.     Name               Type    Function
      
1       "
"FLASH_SD1 (FSD1)   I/O     | GPIO8, SD_DATA1, SPID, HS1_DATA1 :ref:`(See 1) ` , U2CTS
2       FLASH_SD3 (FSD3)   I/O     | GPIO7, SD_DATA0, SPIQ, HS1_DATA0 :ref:`(See 1) ` , U2RTS
3       FLASH_CLK (FCLK)   I/O     | GPIO6, SD_CLK, SPICLK, HS1_CLK :ref:`(See 1) ` , U1CTS
4       IO21               I/O     | GPIO21, VSPIHD, EMAC_TX_EN
5       IO22               I/O     | GPIO22, VSPIWP, U0RTS, EMAC_TXD1
6       IO19               I/O     | GPIO19, VSPIQ, U0CTS, EMAC_TXD0
7       IO23             "
"  I/O     | GPIO23, VSPID, HS1_STROBE
8       IO18               I/O     | GPIO18, VSPICLK, HS1_DATA7
9       IO5                I/O     | GPIO5, VSPICS0, HS1_DATA6, EMAC_RX_CLK
10      IO10               I/O     | GPIO10, SD_DATA3, SPIWP, HS1_DATA3, U1TXD
11      IO9                I/O     | GPIO9, SD_DATA2, SPIHD, HS1_DATA2, U1RXD
12      RXD0               I/O     | GPIO3, U0RXD :ref:`(See 3) ` , CLK_OUT2
13      TXD0               I/O     | GPIO1, U0TXD :ref:`(See 3) ` , CLK_OUT3, EMAC_RXD2
"
"14      IO35               I       | ADC1_CH7, RTC_GPIO5
15      IO34               I       | ADC1_CH6, RTC_GPIO4
16      IO38               I       | GPIO38, ADC1_CH2, RTC_GPIO2
17      IO37               I       | GPIO37, ADC1_CH1, RTC_GPIO1
18      EN                 I       | CHIP_PU
19      GND                P       | Ground
20      VDD33 (3V3)        P       | 3.3V power supply
      


Header J3
""""""""""""""""""

      
No.     Name               Type    Function
      
1       FLASH_CS (FCS)  "
"   I/O     | GPIO16, HS1_DATA4 :ref:`(See 1) ` , U2RXD, EMAC_CLK_OUT
2       FLASH_SD0 (FSD0)   I/O     | GPIO17, HS1_DATA5 :ref:`(See 1) ` , U2TXD, EMAC_CLK_OUT_180
3       FLASH_SD2 (FSD2)   I/O     | GPIO11, SD_CMD, SPICS0, HS1_CMD :ref:`(See 1) ` , U1RTS
4       SENSOR_VP (FSVP)   I       | GPIO36, ADC1_CH0, RTC_GPIO0
5       SENSOR_VN (FSVN)   I       | GPIO39, ADC1_CH3, RTC_GPIO3
6       IO25               I/O     | GPIO25, DAC_1, ADC2_CH8, RTC_GPIO6, EMAC_RXD0
7       IO26               I"
"/O     | GPIO26, DAC_2, ADC2_CH9, RTC_GPIO7, EMAC_RXD1
8       IO32               I/O     | 32K_XP :ref:`(See 2a) ` , ADC1_CH4, TOUCH9, RTC_GPIO9
9       IO33               I/O     | 32K_XN :ref:`(See 2b) ` , ADC1_CH5, TOUCH8, RTC_GPIO8
10      IO27               I/O     | GPIO27, ADC2_CH7, TOUCH7, RTC_GPIO17
                                   | EMAC_RX_DV
11      IO14               I/O     | ADC2_CH6, TOUCH6, RTC_GPIO16, MTMS, HSPICLK,
                                   | HS2_CLK, SD_CLK, EMAC_"
"TXD2
12      IO12               I/O     | ADC2_CH5, TOUCH5, RTC_GPIO15, MTDI :ref:`(See 4) ` , HSPIQ,
                                   | HS2_DATA2, SD_DATA2, EMAC_TXD3
13      IO13               I/O     | ADC2_CH4, TOUCH4, RTC_GPIO14, MTCK, HSPID,
                                   | HS2_DATA3, SD_DATA3, EMAC_RX_ER
14      IO15               I/O     | ADC2_CH3, TOUCH3, RTC_GPIO13, MTDO, HSPICS0
                                   | HS2_CMD, SD_CMD, EMAC_RXD3
15      IO2                I/O     |"
" ADC2_CH2, TOUCH2, RTC_GPIO12, HSPIWP,
                                   | HS2_DATA0, SD_DATA0
16      IO4                I/O     | ADC2_CH0, TOUCH0, RTC_GPIO10, HSPIHD,
                                   | HS2_DATA1, SD_DATA1, EMAC_TX_ER
17      IO0                I/O     | ADC2_CH1, TOUCH1, RTC_GPIO11, CLK_OUT1
                                   | EMAC_TX_CLK
18      VDD33 (3V3)        P       | 3.3V power supply
19      GND                P       | Ground
20      EXT_5V (5V)        P       |"
" 5V power supply
      


.. _get-started-pico-kit-v4-pin-notes:

.. note::


Pin Layout

.. figure:: ../../../_static/esp32-pico-kit-v4-pinout.png
    :align: center
    :scale: 43%
    :alt: ESP32-PICO-KIT (click to enlarge)

    ESP32-PICO-KIT Pin Layout (click to enlarge)


Start Application Development


Before powering up your ESP32-PICO-KIT, please make sure that the board is in good condition with no obvious signs of damage.

After that, proceed to :doc:`../../get-started/index`, where S"
"ection :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.


Board Dimensions


The dimensions are 52 x 20.3 x 10 mm (2.1"" x 0.8"" x 0.4"").

.. figure:: ../../../_static/esp32-pico-kit-v4.1-dimensions-back.jpg
    :align: center
    :alt: ESP32-PICO-KIT dimensions - back (with male headers)
    :figclass: align-center

    ESP32-PICO-KIT dimensions - back (with male headers)

.. figure:: ../../../_static/esp32"
"-pico-kit-v4-dimensions-side.jpg
    :align: center
    :alt: ESP32-PICO-KIT V4 dimensions - side (with male headers)
    :figclass: align-center

    ESP32-PICO-KIT dimensions - side (with male headers)

For the board physical construction details, please refer to its Reference Design listed below.


Related Documents



.. toctree::
    :hidden:

    get-started-pico-kit-v3
"
"ESP-WROVER-KIT V4.1 Getting Started Guide




This guide shows how to get started with the ESP-WROVER-KIT V4.1 development board and also provides information about its functionality and configuration options.


What You Need


You can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP-WROVER-KIT is an ESP32-based development board produced by `Espressif `_.

ESP-WROVER-KIT features the following integrated components:

- ESP32-WROVER-E m"
"odule
- LCD screen
- microSD card slot

Another distinguishing feature is the embedded FTDI FT2232HL chip, an advanced multi-interface USB bridge. This chip enables to use JTAG for direct debugging of ESP32 through the USB interface without a separate JTAG debugger. ESP-WROVER-KIT makes development convenient, easy, and cost-effective.

Most of the ESP32 I/O pins are broken out to the board's pin headers for easy access.

.. note::

    ESP32's GPIO16 and GPIO17 are used as chip select and clock"
" signals for PSRAM. By default, the two GPIOs are not broken out to the board's pin headers in order to ensure reliable performance.


Functionality Overview


The block diagram below shows the main components of ESP-WROVER-KIT and their interconnections.

.. figure:: ../../../_static/esp-wrover-kit-block-diagram.png
    :align: center
    :alt: ESP-WROVER-KIT block diagram
    :figclass: align-center

    ESP-WROVER-KIT block diagram


Functional Description


The following two figures and the "
"table below describe the key components, interfaces, and controls of the ESP-WROVER-KIT board.

.. _get-started-esp-wrover-kit-v4.1-board-front:

.. figure:: ../../../_static/esp-wrover-kit-v4.1-layout-front.png
    :align: center
    :alt: ESP-WROVER-KIT board layout - front
    :figclass: align-center

    ESP-WROVER-KIT board layout - front

.. _get-started-esp-wrover-kit-v4.1-board-back:

.. figure:: ../../../_static/esp-wrover-kit-v4.1-layout-back.png
    :align: center
    :alt: ESP-WROVER"
"-KIT board layout - back
    :figclass: align-center

    ESP-WROVER-KIT board layout - back


The table below provides description in the following manner:

- Starting from the first picture's top right corner and going clockwise
- Then moving on to the second picture

.. list-table::
    :widths: 25 75
    :header-rows: 1
      - Description
      - The FT2232HL chip serves as a multi-protocol USB-to-serial bridge which can be programmed and controlled via USB to provide communication with ESP"
"32. FT2232HL also features USB-to-JTAG interface which is available on channel A of the chip, while USB-to-serial is on channel B. The FT2232HL chip enhances user-friendliness in terms of application development and debugging. See `ESP-WROVER-KIT V4.1 schematic`_.
      - External precision 32.768 kHz crystal oscillator serves as a clock with low-power consumption while the chip is in Deep-sleep mode.
      - Zero-ohm resistor intended as a placeholder for a current shunt, can be desoldered or r"
"eplaced with a current shunt to facilitate the measurement of ESP32's current consumption in different modes.
      - This ESP32 module features 64-Mbit PSRAM for flexible extended storage and data processing capabilities.
      - Four red LEDs connected to the GPIO pins of FT2232HL. Intended for future use.
      - Serial port. The serial TX/RX signals of FT2232HL and ESP32 are broken out to the inward and outward sides of JP2 respectively. By default, these pairs of pins are connected with jum"
"pers. To use ESP32's serial interface, remove the jumpers and connect another external serial device to the respective pins.
      - By default, ESP32 uses its SPI interface to access flash and PSRAM memory inside the module. Use these pins to connect ESP32 to another SPI device. In this case, an extra chip select (CS) signal is needed. Please note that the voltage of this interface is 3.3 V.
      - Serial port flow control signals: the pins are not connected to the circuitry by default. To ena"
"ble them, short the respective pins of JP14 with jumpers.
      - JTAG interface. JTAG signals of FT2232HL and ESP32 are broken out to the inward and outward sides of JP2 respectively. By default, these pairs of pins are disconnected. To enable JTAG, short the respective pins with jumpers as shown in Section `Setup Options`_.
      - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
      - Reset button.
      - Download button. Ho"
"lding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
      - Power On/Off Switch. Toggling toward the **Boot** button powers the board on, toggling away from **Boot** powers the board off.
      - Power supply selector interface. The board can be powered either via USB or via the 5V Input interface. Select the power source with a jumper. For more details, see Section `Setup Options`_, jumper header JP7.
      - 5V power s"
"upply interface for a standard coaxial power connector, 5.5 x 2.1 mm, center positive. This interface can be more convenient when the board is operating autonomously (not connected to a computer).
      - This red LED turns on when power is supplied to the board, either from **USB** or **5V Input**.
      - NCP1117(1A). 5V-to-3.3V LDO. NCP1117 can provide a maximum current of 1A. The LDO on the board has a fixed output voltage, but the user can install an LDO with adjustable output voltage. For "
"details, please refer to `ESP-WROVER-KIT V4.1 schematic`_.
      - Camera interface, a standard OV7670 camera module.
      - Red, green and blue (RGB) light emitting diodes (LEDs), can be controlled by pulse width modulation (PWM).
      - All the pins on the ESP32 module are broken out to pin headers. You can program ESP32 to enable multiple functions, such as PWM, ADC, DAC, I2C, I2S, SPI, etc.
      - Useful for developing applications that access microSD card for data storage and retrieval.
"
"      - Support for mounting and interfacing a 3.2” SPI (standard 4-wire Serial Peripheral Interface) LCD, as shown in figure :ref:`get-started-esp-wrover-kit-v4.1-board-back`.


.. _get-started-esp-wrover-kit-v4.1-setup-options:

Setup Options


There are three jumper blocks available to set up the board functionality. The most frequently required options are listed in the table below.

.. list-table::
    :widths: 25 35 40
    :header-rows: 1
      - Jumper Setting
      - Description of Funct"
"ionality
      - |jp7-ext_5v|
      - Power ESP-WROVER-KIT via an external power supply
      - |jp7-usb_5v|
      - Power ESP-WROVER-KIT via USB
      - |jp2-jtag|
      - Enable JTAG functionality
      - |jp2-tx-rx|
      - Enable UART communication
      - |jp14|
      - Enable RTS/CTS flow control for serial communication


Allocation of ESP32 Pins


Some pins or terminals of ESP32 are allocated for use with the onboard or external hardware. If that hardware is not used, e.g., nothing is pl"
"ugged into the Camera (JP4) header, then these GPIOs can be used for other purposes.

Some of the pins, such as GPIO0 or GPIO2, have multiple functions and some of them are shared among onboard and external peripheral devices. Certain combinations of peripherals cannot work together. For example, it is not possible to do JTAG debugging of an application that is using SD card, because several pins are shared by JTAG and the SD card slot.

In other cases, peripherals can coexist under certain cond"
"itions. This is applicable to, for example, LCD screen and SD card that share only a single pin GPIO21. This pin is used to provide D/C (Data/Control) signal for the LCD as well as the Card Detect signal read from the SD card slot. If the card detect functionality is not essential, then it may be disabled by removing R167, so both LCD and SD may operate together.

For more details on which pins are shared among which peripherals, please refer to the table in the next section.


Main I/O Connecto"
"r/JP1


The JP1 connector consists of 14x2 male pins whose functions are shown in the middle two ""I/O"" columns of the table below. The two ""Shared With"" columns on both sides describe where else on the board a certain GPIO is used.

.. list-table::
    :widths: 30 20 20 30
    :header-rows: 1
      - I/O
      - I/O
      - Shared With
      - 3.3V
      - GND
      - n/a
      - IO32
      - IO33
      - NC/XTAL
      - IO12
      - IO13
      - JTAG，microSD
      - IO14
      - IO27
      - Ca"
"mera
      - IO26
      - IO25
      - Camera, LCD
      - IO35
      - IO34
      - Camera
      - IO39
      - IO36
      - Camera
      - EN
      - IO23
      - Camera, LCD
      - IO22
      - IO21
      - Camera, LCD, microSD
      - IO19
      - IO18
      - Camera, LCD
      - IO5
      - IO17
      - PSRAM
      - IO16
      - IO4
      - LED, Camera, microSD
      - IO0
      - IO2
      - LED, microSD
      - IO15
      - 5V
      -

Legend:


.. _get-started-esp-wrover-kit-v4.1-xtal:"
"

32.768 kHz Oscillator


  
.     ESP32 Pin
  
1     GPIO32
2     GPIO33
  

.. note::

    Since GPIO32 and GPIO33 are connected to the oscillator by default, they are not connected to the JP1 I/O connector to maintain signal integrity. This allocation may be changed from the oscillator to JP1 by desoldering the zero-ohm resistors from positions R11 or R23 and re-soldering them to positions R12 or R24.


.. _get-started-esp-wrover-kit-v4.1-spi-flash-header:

SPI Flash/JP2


  
.     ESP32 Pin
"
"  
1     CLK/GPIO6
2     SD0/GPIO7
3     SD1/GPIO8
4     SD2/GPIO9
5     SD3/GPIO10
6     CMD/GPIO11
  

.. note::

    SPI Flash pins are used to access the internal flash memory. Therefore, they are not available to connect external SPI devices. Those pins are exposed for monitoring or for advanced usage only.

.. important::

    The module's flash bus is connected to the jumper block JP2 through zero-ohm resistors R140 ~ R145. If the flash memory needs to operate at the frequency of 80 MHz, "
"for reasons such as improving the integrity of bus signals, you can desolder these resistors to disconnect the module's flash bus from the pin header JP2.


.. _get-started-esp-wrover-kit-v4.1-jtag-header:

JTAG/JP2


    
.     ESP32 Pin       JTAG Signal
    
1     EN              TRST_N
2     MTMS/GPIO14     TMS
3     MTDO/GPIO15     TDO
4     MTDI/GPIO12     TDI
5     MTCK/GPIO13     TCK
    


.. _get-started-esp-wrover-kit-v4.1-camera-header:

Camera/JP4


    
.     ESP32 Pin   Camera Sig"
"nal
    
 1    n/a         3.3V
 2    n/a         Ground
 3    GPIO27      SIO_C/SCCB Clock
 4    GPIO26      SIO_D/SCCB Data
 5    GPIO25      VSYNC/Vertical Sync
 6    GPIO23      HREF/Horizontal Reference
 7    GPIO22      PCLK/Pixel Clock
 8    GPIO21      XCLK/System Clock
 9    GPIO35      D7/Pixel Data Bit 7
10    GPIO34      D6/Pixel Data Bit 6
11    GPIO39      D5/Pixel Data Bit 5
12    GPIO36      D4/Pixel Data Bit 4
13    GPIO19      D3/Pixel Data Bit 3
14    GPIO18      D2/Pixel Data"
" Bit 2
15    GPIO5       D1/Pixel Data Bit 1
16    GPIO4       D0/Pixel Data Bit 0
17    GPIO0       RESET/Camera Reset
18    n/a         PWDN/Camera Power Down
    


.. _get-started-esp-wrover-kit-v4.1-rgb-led-connections:

RGB LED


    
.     ESP32 Pin   RGB LED
    
1     GPIO0       Red
2     GPIO2       Green
3     GPIO4       Blue
    


.. _get-started-esp-wrover-kit-v4.1-microsd-card-slot:

microSD Card


    
.     ESP32 Pin       microSD Signal
    
1     MTDI/GPIO12     DATA2
2     "
"MTCK/GPIO13     CD/DATA3
3     MTDO/GPIO15     CMD
4     MTMS/GPIO14     CLK
5     GPIO2           DATA0
6     GPIO4           DATA1
7     GPIO21          Card Detect
    


.. _get-started-esp-wrover-kit-v4.1-lcd-connector:

LCD/U5


    
.     ESP32 Pin       LCD Signal
    
1     GPIO18          RESET
2     GPIO19          SCL
3     GPIO21          D/C
4     GPIO22          CS
5     GPIO23          SDA
6     GPIO25          SDO
7     GPIO5           Backlight
    


.. _get-started-esp-wrover"
"-kit-start-development:

Start Application Development


Before powering up your ESP-WROVER-KIT, please make sure that the board is in good condition with no obvious signs of damage.


Initial Setup


Please set only the following jumpers shown in the pictures below:

- Select USB as the power source using the jumper block JP7.

- Enable UART communication using the jumper block JP2.

  
Power up from USB port    Enable UART communication
  
|jp7-usb_5v|              |jp2-tx-rx|
  

Do not insta"
"ll any other jumpers.

Turn the **Power Switch** to ON, and the **5 V Power On LED** should light up.


Now to Development


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.

A Board Support Package can be found in `IDF Component Registry `_.

The application examples that use some hardware specific to your ESP-WROVER-KIT can be found below.

"
"
Related Documents


.. |jp7-ext_5v| image:: ../../../_static/esp-wrover-kit-v4.1-jp7-ext_5v.jpg
.. |jp7-usb_5v| image:: ../../../_static/esp-wrover-kit-v4.1-jp7-usb_5v.jpg
.. |jp2-jtag| image:: ../../../_static/esp-wrover-kit-v4.1-jp2-jtag.jpg
.. |jp2-tx-rx| image:: ../../../_static/esp-wrover-kit-v4.1-jp2-tx-rx.jpg
.. |jp14| image:: ../../../_static/esp-wrover-kit-v4.1-jp14.jpg

.. _ESP-WROVER-KIT V4.1 schematic: https://dl.espressif.com/dl/schematics/ESP-WROVER-KIT_V4_1.pdf

.. toctree::
    "
":hidden:

    get-started-wrover-kit-v3.rst
    get-started-wrover-kit-v2.rst
"
"ESP32-PICO-KIT V3 Getting Started Guide




This guide shows how to get started with the ESP32-PICO-KIT V3 mini development board. For the description of other ESP32-PICO-KIT versions, please check :doc:`../../hw-reference/index`.


What You Need


You can skip the introduction sections and go directly to Section `Start Application Development`_.


Overview


ESP32-PICO-KIT V3 is an ESP32-based mini development board produced by `Espressif `_. The core of this board is ESP32-PICO-D4 - a System-i"
"n-Package (SiP) module.

The development board features a USB-UART Bridge circuit, which allows developers to connect the board to a computer's USB port for flashing and debugging.

All the IO signals and system power on ESP32-PICO-D4 are led out to two rows of 20 x 0.1"" header pads on both sides of the development board for easy access.


Functional Description


The following figure and the table below describe the key components, interfaces, and controls of the ESP32-PICO-KIT V3 board.

.. fi"
"gure:: ../../../_static/esp32-pico-kit-v3-layout.jpg
    :align: center
    :alt: ESP32-PICO-KIT V3 board layout
    :figclass: align-center

    ESP32-PICO-KIT V3 board layout

Below is the description of the items identified in the figure starting from the top left corner and going clockwise.

.. list-table::
    :widths: 25 75
    :header-rows: 1
      - Description
      - Standard ESP32-PICO-D4 module soldered to the ESP32-PICO-KIT V3 board. The complete ESP32 system on a chip (ESP32 SoC) h"
"as been integrated into the SiP module, requiring only an external antenna with LC matching network, decoupling capacitors, and a pull-up resistor for EN signals to function properly.
      - 5V-to-3.3V Low dropout voltage regulator (LDO).
      - Single-chip USB-UART bridge provides up to 1 Mbps transfers rates.
      - USB interface. Power supply for the board as well as the communication interface between a computer and the board.
      - This red LED turns on when power is supplied to the bo"
"ard.
      - All the pins on ESP32-PICO-D4 are broken out to pin headers. You can program ESP32 to enable multiple functions, such as PWM, ADC, DAC, I2C, I2S, SPI, etc.
      - Download button. Holding down **Boot** and then pressing **EN** initiates Firmware Download mode for downloading firmware through the serial port.
      - Reset button.


Start Application Development


Before powering up your ESP32-PICO-KIT V3, please make sure that the board is in good condition with no obvious signs of"
" damage.

After that, proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an example project onto your board.


Related Documents

"
"


This user guide will help you get started with ESP32-S3-DevKitM-1 and will also provide more in-depth information.

The ESP32-S3-DevKitM-1 is an entry-level development board equipped with either ESP32-S3-MINI-1 or ESP32-S3-MINI-1U, a module named for its small size. This board integrates complete Wi-Fi and Bluetooth® Low Energy functions.

Most of the I/O pins on the module are broken out to the pin headers on both sides of this board for easy interfacing. Developers can either connect perip"
"herals with jumper wires or mount ESP32-S3-DevKitM-1 on a breadboard.

.. figure:: ../../../_static/esp32-s3-devkitm-1-v1-isometric.png
    :align: center
    :scale: 70%
    :alt: ESP32-S3-DevKitM-1 with ESP32-S3-MINI-1 Module
    :figclass: align-center

    ESP32-S3-DevKitM-1 with ESP32-S3-MINI-1 Module


The document consists of the following major sections:

- `Getting Started`_: Overview of the board and hardware/software setup instructions to get started.
- `Hardware Reference`_: More det"
"ailed information about the board's hardware.
- `Related Documents`_: Links to related documentation.


Getting Started


This section provides a brief introduction of ESP32-S3-DevKitM-1, instructions on how to do the initial hardware setup and how to flash firmware onto it.


Description of Components


.. _user-guide-s3-devkitm-1-v1-board-front:

.. figure:: ../../../_static/ESP32-S3-DevKitM-1_v1-annotated-photo.png
    :align: center
    :alt: ESP32-S3-DevKitM-1 - front
    :figclass: align-c"
"enter

    ESP32-S3-DevKitM-1 - front

The key components of the board are described in a counter-clockwise direction, starting from the ESP32-S3-MINI-1/1U module.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - ESP32-S3-MINI-1 and ESP32-S3-MINI-1U are two general-purpose Wi-Fi and Bluetooth Low Energy combo modules that have a rich set of peripherals. ESP32-S3-MINI-1 comes with a PCB antenna. ESP32-S3-MINI-1U comes with an external antenna connector. At the core "
"of the modules is ESP32-S3FN8, a chip equipped with an 8 MB flash. Since flash is packaged in the chip, rather than integrated into the module, ESP32-S3-MINI-1/1U has a smaller package size.
     - Power regulator that converts a 5 V supply into a 3.3 V output.
     - All available GPIO pins (except for the SPI bus for flash) are broken out to the pin headers on the board for easy interfacing and programming. For details, please see :ref:`user-guide-s3-devkitm-1-v1-header-blocks`.
     - A Micro"
"-USB port used for power supply to the board, for flashing applications to the chip, as well as for communication with the chip via the on-board USB-to-UART bridge.
     - Download button. Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - Press this button to restart ESP32-S3.
     - ESP32-S3 full-speed USB OTG interface, compliant with the USB 1.1 specification. The interface is used for power supply to th"
"e board, for flashing applications to the chip, for communication with the chip using USB 1.1 protocols, as well as for JTAG debugging.
     - Single USB-to-UART bridge chip provides transfer rates up to 3 Mbps.
     - Addressable RGB LED, driven by GPIO48.
     - Turns on when the USB power is connected to the board.


Start Application Development


Before powering up your board, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-S3-Dev"
"KitM-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. note::

  Be sure to use an appropriate USB cable. Some cables are for charging only and do not provide the needed data lines nor work for programming the boards.


Hardware Setup


Connect the board with the computer using **USB-to-UART Port** or **ESP32-S3 USB Port**. In subsequent steps, **USB-to-UART Port** will be used by default.


Software Setup


Please proceed to :doc:`../../get-started/index`"
", where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an application example onto your board.


Contents and Packaging


Retail Orders


If you order a few samples, each board comes in an individual package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large car"
"dboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the components of ESP32-S3-DevKitM-1 and their interconnections.

.. figure:: ../../../_static/ESP32-S3-DevKitM-1_v1_SystemBlock.png
    :align: center
    :scale: 70%
    :alt: ESP32-S3-DevKitM-1 (click to enlarge)
    :figclass: align-center

    ESP32-S3-DevKitM-1 (click to enlarge)


Power Supply Options


There are th"
"ree mutually exclusive ways to provide power to the board:

- USB-to-UART Port and ESP32-S3 USB Port (either one or both), default power supply (recommended)
- 5V and G (GND) pins
- 3V3 and G (GND) pins


.. _user-guide-s3-devkitm-1-v1-header-blocks:

Header Block


The two tables below provide the **Name** and **Function** of the pins on both sides of the board (J1 and J3). The pin names are shown in :ref:`user-guide-s3-devkitm-1-v1-board-front`. The numbering is the same as in the `Board Schem"
"atic `_ (PDF).


J1
^^^

===      
No.  Name  Type [#]_    Function
===      
1    3V3   P           3.3 V power supply
2    0     I/O/T       RTC_GPIO0, GPIO0
3    1     I/O/T       RTC_GPIO1, GPIO1, TOUCH1, ADC1_CH0
4    2     I/O/T       RTC_GPIO2, GPIO2, TOUCH2, ADC1_CH1
5    3     I/O/T       RTC_GPIO3, GPIO3, TOUCH3, ADC1_CH2
6    4     I/O/T       RTC_GPIO4, GPIO4, TOUCH4, ADC1_CH3
7    5     I/O/T       RTC_GPIO5, GPIO5, TOUCH5, ADC1_CH4
8    6     I/O/T       RTC_GPIO6, GPIO6, TOUCH6, A"
"DC1_CH5
9    7     I/O/T       RTC_GPIO7, GPIO7, TOUCH7, ADC1_CH6
10   8     I/O/T       RTC_GPIO8, GPIO8, TOUCH8, ADC1_CH7, SUBSPICS1
11   9     I/O/T       RTC_GPIO9, GPIO9, TOUCH9, ADC1_CH8, FSPIHD, SUBSPIHD
12   10    I/O/T       RTC_GPIO10, GPIO10, TOUCH10, ADC1_CH9, FSPICS0, FSPIIO4, SUBSPICS0
13   11    I/O/T       RTC_GPIO11, GPIO11, TOUCH11, ADC2_CH0, FSPID, FSPIIO5, SUBSPID
14   12    I/O/T       RTC_GPIO12, GPIO12, TOUCH12, ADC2_CH1, FSPICLK, FSPIIO6, SUBSPICLK
15   13    I/O/T       "
"RTC_GPIO13, GPIO13, TOUCH13, ADC2_CH2, FSPIQ, FSPIIO7, SUBSPIQ
16   14    I/O/T       RTC_GPIO14, GPIO14, TOUCH14, ADC2_CH3, FSPIWP, FSPIDQS, SUBSPIWP
17   15    I/O/T       RTC_GPIO15, GPIO15, U0RTS, ADC2_CH4, XTAL_32K_P
18   16    I/O/T       RTC_GPIO16, GPIO16, U0CTS, ADC2_CH5, XTAL_32K_N
19   17    I/O/T       RTC_GPIO17, GPIO17, U1TXD, ADC2_CH6
20   18    I/O/T       RTC_GPIO18, GPIO18, U1RXD, ADC2_CH7, CLK_OUT3
21   5V    P           5 V power supply
22   G     G           Ground
===      "
"


J3
^^^

===      
No.  Name  Type   Function
===      
1    G     G      Ground
2    RST   I      EN
3    46    I/O/T  GPIO46
4    45    I/O/T  GPIO45
5    RX    I/O/T  U0RXD, GPIO44, CLK_OUT2
6    TX    I/O/T  U0TXD, GPIO43, CLK_OUT1
7    42    I/O/T  MTMS, GPIO42
8    41    I/O/T  MTDI, GPIO41, CLK_OUT1
9    40    I/O/T  MTDO, GPIO40, CLK_OUT2
10   39    I/O/T  MTCK, GPIO39, CLK_OUT3, SUBSPICS1
11   38    I/O/T  GPIO38, FSPIWP, SUBSPIWP
12   37    I/O/T  SPIDQS, GPIO37, FSPIQ, SUBSPIQ
13   "
"36    I/O/T  SPIIO7, GPIO36, FSPICLK, SUBSPICLK
14   35    I/O/T  SPIIO6, GPIO35, FSPID, SUBSPID
15   34    I/O/T  SPIIO5, GPIO34, FSPICS0, SUBSPICS0
16   33    I/O/T  SPIIO4, GPIO33, FSPIHD, SUBSPIHD
17   26    I/O/T  SPICS1, GPIO26
18   21    I/O/T  RTC_GPIO21, GPIO21
19   20    I/O/T  RTC_GPIO20, GPIO20, U1CTS, ADC2_CH9, CLK_OUT1, USB_D+
20   19    I/O/T  RTC_GPIO19, GPIO19, U1RTS, ADC2_CH8, CLK_OUT2, USB_D-
21   48    I/O/T  SPICLK_N, GPIO48, SUBSPICLK_N_DIFF, RGB LED
22   47    I/O/T  SPICL"
"K_P, GPIO47, SUBSPICLK_P_DIFF
===      


.. [#] P: Power supply; I: Input; O: Output; T: High impedance.



For description of function names, please refer to `ESP32-S3 Datasheet `_ (PDF).


Pin Layout


.. figure:: ../../../_static/ESP32-S3_DevKitM-1_pinlayout.jpg
    :align: center
    :scale: 50%
    :alt: ESP32-S3-DevKitM-1 (click to enlarge)
    :figclass: align-center

    ESP32-S3-DevKitM-1 Pin Layout (click to enlarge)


Hardware Revision Details


This is the first revision of this boa"
"rd released.


Related Documents


- `ESP32-S3 Datasheet `_ (PDF)
- `ESP32-S3-MINI-1 & ESP32-S3-MINI-1U Datasheet `_ (PDF)
- `ESP32-S3-DevKitM-1 Schematic `_ (PDF)
- `ESP32-S3-DevKitM-1 PCB layout `_ (PDF)
- `ESP32-S3-DevKitM-1 Dimensions `_ (PDF)
- `ESP32-S3-DevKitM-1 Dimensions source file `_ (DXF) - You can view it with `Autodesk Viewer `_ online

For further design documentation for the board, please contact us at `sales@espressif.com `_.
"
"


The latest version: :doc:`user-guide-devkitc-1`

This user guide will help you get started with ESP32-S3-DevKitC-1 and will also provide more in-depth information.

The ESP32-S3-DevKitC-1 is an entry-level development board equipped with ESP32-S3-WROOM-1, ESP32-S3-WROOM-1U, or ESP32-S3-WROOM-2, a general-purpose Wi-Fi + Bluetooth® Low Energy MCU module that integrates complete Wi-Fi and Bluetooth Low Energy functions.

Most of the I/O pins on the module are broken out to the pin headers on bo"
"th sides of this board for easy interfacing. Developers can either connect peripherals with jumper wires or mount ESP32-S3-DevKitC-1 on a breadboard.

.. figure:: ../../../_static/esp32-s3-devkitc-1-v1-isometric.png
    :align: center
    :alt: ESP32-S3-DevKitC-1 with ESP32-S3-WROOM-1 Module

    ESP32-S3-DevKitC-1 with ESP32-S3-WROOM-1 Module


The document consists of the following major sections:

- `Getting started`_: Overview of the board and hardware/software setup instructions to get star"
"ted.
- `Hardware Reference`_: More detailed information about the board's hardware.
- `Hardware Revision Details`_: Revision history, known issues, and links to user guides for previous versions (if any) of the board.
- `Related Documents`_: Links to related documentation.


Getting Started


This section provides a brief introduction of ESP32-S3-DevKitC-1, instructions on how to do the initial hardware setup and how to flash firmware onto it.


Description of Components


.. _user-guide-s3-devk"
"itc-1-v1-board-front:

.. figure:: ../../../_static/ESP32-S3-DevKitC-1_v2-annotated-photo.png
    :align: center
    :alt: ESP32-S3-DevKitC-1 - front

    ESP32-S3-DevKitC-1 - front

The key components of the board are described in a counter-clockwise direction.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - ESP32-S3-WROOM-1, ESP32-S3-WROOM-1U, and ESP32-S3-WROOM-2 are powerful, generic Wi-Fi + Bluetooth Low Energy MCU modules that have a rich set of peripherals."
" They provide acceleration for neural network computing and signal processing workloads. ESP32-S3-WROOM-1 and ESP32-S3-WROOM-2 comes with a PCB antenna. ESP32-S3-WROOM-1U comes with an external antenna connector.
     - Power regulator that converts a 5 V supply into a 3.3 V output.
     - All available GPIO pins (except for the SPI bus for flash) are broken out to the pin headers on the board for easy interfacing and programming. For details, please see :ref:`user-guide-s3-devkitc-1-v1-header-b"
"locks`.
     - A Micro-USB port used for power supply to the board, for flashing applications to the chip, as well as for communication with the chip via the on-board USB-to-UART bridge.
     - Download button. Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - Press this button to restart the system.
     - ESP32-S3 full-speed USB OTG interface, compliant with the USB 1.1 specification. The interface is use"
"d for power supply to the board, for flashing applications to the chip, for communication with the chip using USB 1.1 protocols, as well as for JTAG debugging.
     - Single USB-to-UART bridge chip provides transfer rates up to 3 Mbps.
     - Addressable RGB LED, driven by GPIO48.
     - Turns on when the USB power is connected to the board.

.. note::

    For boards with Octal SPI flash/PSRAM memory embedded ESP32-S3-WROOM-1/1U modules, and boards with ESP32-S3-WROOM-2 modules, the pins GPIO35"
", GPIO36 and GPIO37 are used for the internal communication between ESP32-S3 and SPI flash/PSRAM memory, thus not available for external use.


Start Application Development


Before powering up your board, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-S3-DevKitC-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. note::

  Be sure to use an appropriate USB cable. Some cables are for charging onl"
"y and do not provide the needed data lines nor work for programming the boards.


Hardware Setup


Connect the board with the computer using **USB-to-UART Port**. Connection using **ESP32-S3 USB Port** is not fully implemented in software. In subsequent steps, **USB-to-UART Port** will be used by default.


Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an app"
"lication example onto your board.


Contents and Packaging


Ordering Information


The development board has a variety of variants to choose from, as shown in the table below.

.. list-table::
   :widths: 28 29 19 17 15
   :header-rows: 1
     - Module Integrated
     - Flash
     - PSRAM
     - SPI Voltage
     - ESP32-S3-WROOM-1-N8
     - 8 MB QD
     - —
     - 3.3 V
     - ESP32-S3-WROOM-1-N8R2
     - 8 MB QD
     - 2 MB QD
     - 3.3 V
     - ESP32-S3-WROOM-1-N8R8
     - 8 MB QD
     - 8 M"
"B OT
     - 3.3 V
     - ESP32-S3-WROOM-2-N16R8V
     - 16 MB OT
     - 8 MB OT
     - 1.8 V
     - ESP32-S3-WROOM-2-N32R8V
     - 32 MB OT
     - 8 MB OT
     - 1.8 V
     - ESP32-S3-WROOM-1U-N8
     - 8 MB QD
     - —
     - 3.3 V
     - ESP32-S3-WROOM-1U-N8R2
     - 8 MB QD
     - 2 MB QD
     - 3.3 V
     - ESP32-S3-WROOM-1U-N8R8
     - 8 MB QD
     - 8 MB OT
     - 3.3 V

.. note::

  In the table above, QD stands for Quad SPI and OT stands for Octal SPI.


Retail Orders


If you order a fe"
"w samples, each board comes in an individual package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/company/contact/buy-a-sample.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the components of ESP32-S3-DevKitC-1 a"
"nd their interconnections.

.. figure:: ../../../_static/ESP32-S3-DevKitC-1_v2-SystemBlock.png
    :align: center
    :scale: 70%
    :alt: ESP32-S3-DevKitC-1 (click to enlarge)

    ESP32-S3-DevKitC-1 (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

- USB-to-UART Port and ESP32-S3 USB Port (either one or both), default power supply (recommended)
- 5V and G (GND) pins
- 3V3 and G (GND) pins


.. _user-guide-s3-devkitc-1-v1-header"
"-blocks:

Header Block


The two tables below provide the **Name** and **Function** of the pins on both sides of the board (J1 and J3). The pin names are shown in :ref:`user-guide-s3-devkitc-1-v1-board-front`. The numbering is the same as in the `Board Schematic `_ (PDF).


J1
^^^

===      
No.  Name  Type [#]_    Function
===      
1    3V3   P           3.3 V power supply
2    3V3   P           3.3 V power supply
3    RST   I           EN
4    4     I/O/T       RTC_GPIO4, GPIO4, TOUCH4, ADC1_"
"CH3
5    5     I/O/T       RTC_GPIO5, GPIO5, TOUCH5, ADC1_CH4
6    6     I/O/T       RTC_GPIO6, GPIO6, TOUCH6, ADC1_CH5
7    7     I/O/T       RTC_GPIO7, GPIO7, TOUCH7, ADC1_CH6
8    15    I/O/T       RTC_GPIO15, GPIO15, U0RTS, ADC2_CH4, XTAL_32K_P
9    16    I/O/T       RTC_GPIO16, GPIO16, U0CTS, ADC2_CH5, XTAL_32K_N
10   17    I/O/T       RTC_GPIO17, GPIO17, U1TXD, ADC2_CH6
11   18    I/O/T       RTC_GPIO18, GPIO18, U1RXD, ADC2_CH7, CLK_OUT3
12   8     I/O/T       RTC_GPIO8, GPIO8, TOUCH8, ADC"
"1_CH7, SUBSPICS1
13   3     I/O/T       RTC_GPIO3, GPIO3, TOUCH3, ADC1_CH2
14   46    I/O/T       GPIO46
15   9     I/O/T       RTC_GPIO9, GPIO9, TOUCH9, ADC1_CH8, FSPIHD, SUBSPIHD
16   10    I/O/T       RTC_GPIO10, GPIO10, TOUCH10, ADC1_CH9, FSPICS0, FSPIIO4, SUBSPICS0
17   11    I/O/T       RTC_GPIO11, GPIO11, TOUCH11, ADC2_CH0, FSPID, FSPIIO5, SUBSPID
18   12    I/O/T       RTC_GPIO12, GPIO12, TOUCH12, ADC2_CH1, FSPICLK, FSPIIO6, SUBSPICLK
19   13    I/O/T       RTC_GPIO13, GPIO13, TOUCH13, A"
"DC2_CH2, FSPIQ, FSPIIO7, SUBSPIQ
20   14    I/O/T       RTC_GPIO14, GPIO14, TOUCH14, ADC2_CH3, FSPIWP, FSPIDQS, SUBSPIWP
21   5V    P           5 V power supply
22   G     G           Ground
===      


J3
^^^

===      
No.  Name  Type   Function
===      
1    G     G      Ground
2    TX    I/O/T  U0TXD, GPIO43, CLK_OUT1
3    RX    I/O/T  U0RXD, GPIO44, CLK_OUT2
4    1     I/O/T  RTC_GPIO1, GPIO1, TOUCH1, ADC1_CH0
5    2     I/O/T  RTC_GPIO2, GPIO2, TOUCH2, ADC1_CH1
6    42    I/O/T  MTMS, GPI"
"O42
7    41    I/O/T  MTDI, GPIO41, CLK_OUT1
8    40    I/O/T  MTDO, GPIO40, CLK_OUT2
9    39    I/O/T  MTCK, GPIO39, CLK_OUT3, SUBSPICS1
10   38    I/O/T  GPIO38, FSPIWP, SUBSPIWP
11   37    I/O/T  SPIDQS, GPIO37, FSPIQ, SUBSPIQ
12   36    I/O/T  SPIIO7, GPIO36, FSPICLK, SUBSPICLK
13   35    I/O/T  SPIIO6, GPIO35, FSPID, SUBSPID
14   0     I/O/T  RTC_GPIO0, GPIO0
15   45    I/O/T  GPIO45
16   48    I/O/T  GPIO48, SPICLK_N, SUBSPICLK_N_DIFF, RGB LED
17   47    I/O/T  GPIO47, SPICLK_P, SUBSPICLK_"
"P_DIFF
18   21    I/O/T  RTC_GPIO21, GPIO21
19   20    I/O/T  RTC_GPIO20, GPIO20, U1CTS, ADC2_CH9, CLK_OUT1, USB_D+
20   19    I/O/T  RTC_GPIO19, GPIO19, U1RTS, ADC2_CH8, CLK_OUT2, USB_D-
21   G     G      Ground
22   G     G      Ground
===      


.. [#] P: Power supply; I: Input; O: Output; T: High impedance.


For description of function names, please refer to `Chip Datasheet `_ (PDF).


Pin Layout


.. figure:: ../../../_static/ESP32-S3_DevKitC-1_pinlayout.jpg
    :align: center
    :scale:"
" 50%
    :alt: ESP32-S3-DevKitC-1 (click to enlarge)

    ESP32-S3-DevKitC-1 Pin Layout (click to enlarge)


Hardware Revision Details


This is the first revision of this board released.


Related Documents


- `ESP32-S3 Datasheet `_ (PDF)
- `ESP32-S3-WROOM-1 & ESP32-S3-WROOM-1U Datasheet `_ (PDF)
- `ESP32-S3-WROOM-2 Datasheet `_ (PDF)
- `ESP32-S3-DevKitC-1 Schematic `_ (PDF)
- `ESP32-S3-DevKitC-1 PCB layout `_ (PDF)
- `ESP32-S3-DevKitC-1 Dimensions `_ (PDF)
- `ESP32-S3-DevKitC-1 Dimensions sou"
"rce file `_ (DXF) - You can view it with `Autodesk Viewer `_ online

For further design documentation for the board, please contact us at `sales@espressif.com `_.
"
"


The older version: :doc:`user-guide-devkitc-1-v1.0`

This user guide will help you get started with ESP32-S3-DevKitC-1 and will also provide more in-depth information.

The ESP32-S3-DevKitC-1 is an entry-level development board equipped with ESP32-S3-WROOM-1, ESP32-S3-WROOM-1U, or ESP32-S3-WROOM-2, a general-purpose Wi-Fi + Bluetooth® Low Energy MCU module that integrates complete Wi-Fi and Bluetooth Low Energy functions.

Most of the I/O pins on the module are broken out to the pin headers o"
"n both sides of this board for easy interfacing. Developers can either connect peripherals with jumper wires or mount ESP32-S3-DevKitC-1 on a breadboard.

.. figure:: ../../../_static/esp32-s3-devkitc-1-v1.1-isometric.png
    :align: center
    :alt: ESP32-S3-DevKitC-1 with ESP32-S3-WROOM-1 Module

    ESP32-S3-DevKitC-1 with ESP32-S3-WROOM-1 Module


The document consists of the following major sections:

- `Getting started`_: Overview of the board and hardware/software setup instructions to ge"
"t started.
- `Hardware Reference`_: More detailed information about the board's hardware.
- `Hardware Revision Details`_: Revision history, known issues, and links to user guides for previous versions (if any) of the board.
- `Related Documents`_: Links to related documentation.


Getting Started


This section provides a brief introduction of ESP32-S3-DevKitC-1, instructions on how to do the initial hardware setup and how to flash firmware onto it.


Description of Components


.. _user-guide-s"
"3-devkitc-1-v1.1-board-front:

.. figure:: ../../../_static/ESP32-S3-DevKitC-1_v2-annotated-photo.png
    :align: center
    :alt: ESP32-S3-DevKitC-1 - front

    ESP32-S3-DevKitC-1 - front

The key components of the board are described in a counter-clockwise direction.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - ESP32-S3-WROOM-1, ESP32-S3-WROOM-1U, and ESP32-S3-WROOM-2 are powerful, generic Wi-Fi + Bluetooth Low Energy MCU modules that have a rich set of peri"
"pherals. They provide acceleration for neural network computing and signal processing workloads. ESP32-S3-WROOM-1 and ESP32-S3-WROOM-2 comes with a PCB antenna. ESP32-S3-WROOM-1U comes with an external antenna connector.
     - Power regulator that converts a 5 V supply into a 3.3 V output.
     - All available GPIO pins (except for the SPI bus for flash) are broken out to the pin headers on the board for easy interfacing and programming. For details, please see :ref:`user-guide-s3-devkitc-1-v1."
"1-header-blocks`.
     - A Micro-USB port used for power supply to the board, for flashing applications to the chip, as well as for communication with the chip via the on-board USB-to-UART bridge.
     - Download button. Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - Press this button to restart the system.
     - ESP32-S3 full-speed USB OTG interface, compliant with the USB 1.1 specification. The interf"
"ace is used for power supply to the board, for flashing applications to the chip, for communication with the chip using USB 1.1 protocols, as well as for JTAG debugging.
     - Single USB-to-UART bridge chip provides transfer rates up to 3 Mbps.
     - Addressable RGB LED, driven by GPIO38.
     - Turns on when the USB power is connected to the board.

.. note::

    For boards with Octal SPI flash/PSRAM memory embedded ESP32-S3-WROOM-1/1U modules, and boards with ESP32-S3-WROOM-2 modules, the p"
"ins GPIO35, GPIO36 and GPIO37 are used for the internal communication between ESP32-S3 and SPI flash/PSRAM memory, thus not available for external use.


Start Application Development


Before powering up your board, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-S3-DevKitC-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. note::

  Be sure to use an appropriate USB cable. Some cables are for ch"
"arging only and do not provide the needed data lines nor work for programming the boards.


Hardware Setup


Connect the board with the computer using **USB-to-UART Port** or **ESP32-S3 USB Port**. In subsequent steps, **USB-to-UART Port** will be used by default.


Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an application example onto your board.


Conten"
"ts and Packaging


Ordering Information


The development board has a variety of variants to choose from, as shown in the table below.

.. list-table::
   :widths: 28 29 19 17 15
   :header-rows: 1
     - Module Integrated
     - Flash
     - PSRAM
     - SPI Voltage
     - ESP32-S3-WROOM-1-N8
     - 8 MB QD
     - —
     - 3.3 V
     - ESP32-S3-WROOM-1-N8R2
     - 8 MB QD
     - 2 MB QD
     - 3.3 V
     - ESP32-S3-WROOM-1-N8R8
     - 8 MB QD
     - 8 MB OT
     - 3.3 V
     - ESP32-S3-WROOM-2-"
"N16R8V
     - 16 MB OT
     - 8 MB OT
     - 1.8 V
     - ESP32-S3-WROOM-2-N32R8V
     - 32 MB OT
     - 8 MB OT
     - 1.8 V
     - ESP32-S3-WROOM-1U-N8
     - 8 MB QD
     - —
     - 3.3 V
     - ESP32-S3-WROOM-1U-N8R2
     - 8 MB QD
     - 2 MB QD
     - 3.3 V
     - ESP32-S3-WROOM-1U-N8R8
     - 8 MB QD
     - 8 MB OT
     - 3.3 V

.. note::

  In the table above, QD stands for Quad SPI and OT stands for Octal SPI.


Retail Orders


If you order a few samples, each board comes in an individu"
"al package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the components of ESP32-S3-DevKitC-1 and their interconnections.

.. figure:: ../../.."
"/_static/ESP32-S3-DevKitC-1_v2-SystemBlock.png
    :align: center
    :scale: 70%
    :alt: ESP32-S3-DevKitC-1 (click to enlarge)

    ESP32-S3-DevKitC-1 (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

- USB-to-UART Port and ESP32-S3 USB Port (either one or both), default power supply (recommended)
- 5V and G (GND) pins
- 3V3 and G (GND) pins


.. _user-guide-s3-devkitc-1-v1.1-header-blocks:

Header Block


The two tables below "
"provide the **Name** and **Function** of the pins on both sides of the board (J1 and J3). The pin names are shown in :ref:`user-guide-s3-devkitc-1-v1.1-board-front`. The numbering is the same as in the `Board Schematic `_ (PDF).


J1
^^^

===      
No.  Name  Type [#]_    Function
===      
1    3V3   P           3.3 V power supply
2    3V3   P           3.3 V power supply
3    RST   I           EN
4    4     I/O/T       RTC_GPIO4, GPIO4, TOUCH4, ADC1_CH3
5    5     I/O/T       RTC_GPIO5, GPIO5,"
" TOUCH5, ADC1_CH4
6    6     I/O/T       RTC_GPIO6, GPIO6, TOUCH6, ADC1_CH5
7    7     I/O/T       RTC_GPIO7, GPIO7, TOUCH7, ADC1_CH6
8    15    I/O/T       RTC_GPIO15, GPIO15, U0RTS, ADC2_CH4, XTAL_32K_P
9    16    I/O/T       RTC_GPIO16, GPIO16, U0CTS, ADC2_CH5, XTAL_32K_N
10   17    I/O/T       RTC_GPIO17, GPIO17, U1TXD, ADC2_CH6
11   18    I/O/T       RTC_GPIO18, GPIO18, U1RXD, ADC2_CH7, CLK_OUT3
12   8     I/O/T       RTC_GPIO8, GPIO8, TOUCH8, ADC1_CH7, SUBSPICS1
13   3     I/O/T       RTC_"
"GPIO3, GPIO3, TOUCH3, ADC1_CH2
14   46    I/O/T       GPIO46
15   9     I/O/T       RTC_GPIO9, GPIO9, TOUCH9, ADC1_CH8, FSPIHD, SUBSPIHD
16   10    I/O/T       RTC_GPIO10, GPIO10, TOUCH10, ADC1_CH9, FSPICS0, FSPIIO4, SUBSPICS0
17   11    I/O/T       RTC_GPIO11, GPIO11, TOUCH11, ADC2_CH0, FSPID, FSPIIO5, SUBSPID
18   12    I/O/T       RTC_GPIO12, GPIO12, TOUCH12, ADC2_CH1, FSPICLK, FSPIIO6, SUBSPICLK
19   13    I/O/T       RTC_GPIO13, GPIO13, TOUCH13, ADC2_CH2, FSPIQ, FSPIIO7, SUBSPIQ
20   14    "
"I/O/T       RTC_GPIO14, GPIO14, TOUCH14, ADC2_CH3, FSPIWP, FSPIDQS, SUBSPIWP
21   5V    P           5 V power supply
22   G     G           Ground
===      


J3
^^^

===      
No.  Name  Type   Function
===      
1    G     G      Ground
2    TX    I/O/T  U0TXD, GPIO43, CLK_OUT1
3    RX    I/O/T  U0RXD, GPIO44, CLK_OUT2
4    1     I/O/T  RTC_GPIO1, GPIO1, TOUCH1, ADC1_CH0
5    2     I/O/T  RTC_GPIO2, GPIO2, TOUCH2, ADC1_CH1
6    42    I/O/T  MTMS, GPIO42
7    41    I/O/T  MTDI, GPIO41, CLK_OUT1"
"
8    40    I/O/T  MTDO, GPIO40, CLK_OUT2
9    39    I/O/T  MTCK, GPIO39, CLK_OUT3, SUBSPICS1
10   38    I/O/T  GPIO38, FSPIWP, SUBSPIWP, RGB LED
11   37    I/O/T  SPIDQS, GPIO37, FSPIQ, SUBSPIQ
12   36    I/O/T  SPIIO7, GPIO36, FSPICLK, SUBSPICLK
13   35    I/O/T  SPIIO6, GPIO35, FSPID, SUBSPID
14   0     I/O/T  RTC_GPIO0, GPIO0
15   45    I/O/T  GPIO45
16   48    I/O/T  GPIO48, SPICLK_N, SUBSPICLK_N_DIFF
17   47    I/O/T  GPIO47, SPICLK_P, SUBSPICLK_P_DIFF
18   21    I/O/T  RTC_GPIO21, GPIO21
"
"19   20    I/O/T  RTC_GPIO20, GPIO20, U1CTS, ADC2_CH9, CLK_OUT1, USB_D+
20   19    I/O/T  RTC_GPIO19, GPIO19, U1RTS, ADC2_CH8, CLK_OUT2, USB_D-
21   G     G      Ground
22   G     G      Ground
===      


.. [#] P: Power supply; I: Input; O: Output; T: High impedance.


For description of function names, please refer to `ESP32-S3 Series Datasheet `_ (PDF).


Pin Layout


.. figure:: ../../../_static/ESP32-S3_DevKitC-1_pinlayout_v1.1.jpg
    :align: center
    :scale: 50%
    :alt: ESP32-S3-DevK"
"itC-1 (click to enlarge)

    ESP32-S3-DevKitC-1 Pin Layout (click to enlarge)


Hardware Revision Details


:doc:`Initial release `

.. note::

    Both the initial and v1.1 versions of ESP32-S3-DevKitC-1 are available on the market. The main difference lies in the GPIO assignment for the RGB LED: the initial version uses GPIO48, whereas v1.1 uses GPIO38.


Related Documents


- `ESP32-S3 Datasheet `_ (PDF)
- `ESP32-S3-WROOM-1 & ESP32-S3-WROOM-1U Datasheet `_ (PDF)
- `ESP32-S3-WROOM-2 Datasheet"
" `_ (PDF)
- `ESP32-S3-DevKitC-1 Schematic `_ (PDF)
- `ESP32-S3-DevKitC-1 PCB layout `_ (PDF)
- `ESP32-S3-DevKitC-1 Dimensions `_ (PDF)
- `ESP32-S3-DevKitC-1 Dimensions source file `_ (DXF) - You can view it with `Autodesk Viewer `_ online

For further design documentation for the board, please contact us at `sales@espressif.com `_.

.. toctree::
    :hidden:

    user-guide-devkitc-1-v1.0
"
"


This user guide provides information on the ESP-LyraT-8311A extension board.

This board cannot be bought separately and is usually sold together with other Espressif development boards (e.g., ESP32-S2-Kaluga-1), which will be referred to as *main boards* below.

Currently, ESP-LyraT-8311A v1.3 is sold as part of the :doc:`user-guide-esp32-s2-kaluga-1-kit`.

The ESP-LyraT-8311A extends the functionality of your main board by adding sound processing functionality:

- Audio playback/recording
-"
" Processing of audio signals
- Programmable buttons for easy control

This extension board can be used in many ways. The applications might include voice user interface, voice control, voice authorization, recording and playback of sound, etc.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrat-8311a-v1.3-3d.png
    :align: center
    :width: 1934px
    :height: 1473px
    :scale: 30%
    :alt: ESP-LyraT-8311A
    :figclass: align-center

    ESP-LyraT-8311A (click to enlarge)"
"

The document consists of the following major sections:

- `Overview`_: Provides an overview and hardware setup instructions.
- `Hardware reference`_: Provides more detailed information about the ESP-LyraT-8311A's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions of the ESP-LyraT-8311A.
- `Related Documents`_: Gives links to related documentation.


Overview


The ESP-LyraT-8311A is mainly designed for audio applicati"
"ons. However, you can use your creativity to come up with any other use cases.


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrat-8311a-v1.3-layout-front.png
    :align: center
    :width: 934px
    :height: 565px
    :scale: 70%
    :alt: ESP-LyraT-8311A - front
    :figclass: align-center

    ESP-LyraT-8311A - front (click to enlarge)

The description of components starts from the top right corner and then goes clockwise.

**Reserved** means th"
"at the functionality is available, but the current version of the kit does not use it.


.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Male Extension Header on the flip side is for mounting onto main board's Extension Header; Female Extension Header is for mounting other boards that have a Male Extension Header
     - This board has six programmable buttons
     - Supports Electret and MEMS microphones; this extension board is supplied with an electret microphone"
"
     - 6.3 mm (1/8"") stereo headphone connector
     - Connect an external speaker to the 2-pin connector
     - 3 W Audio signal amplifier for the external speaker
     - (Reserved) FPC connector for external Mic-Matrix (microphone boards)
     - (Reserved) high-performance ADC/ES7243: 1 channel for microphone, 1 channel for acoustic echo cancellation (AEC) function
     - ES8311 audio ADC and DAC; it can convert the analog signal picked up by the microphone or convert digital signal to play i"
"t back through a speaker or headphones


Start Application Development


Before powering up your ESP-LyraT-8311A, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- Board with a female Extension Header (e.g., ESP32-S2-Kaluga-1)
- ESP-LyraT-8311A extension board
- Four mounting bolts (for stable mounting)
- Computer running Windows, Linux, or macOS


Hardware Setup


To mount your ESP-LyraT-8311A onto the board with a female Extension Header:


"
"Software Setup


Depending on your application, see:


Hardware Reference


Block Diagram


A block diagram below shows the components of ESP-LyraT-8311A and their interconnections.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrat-8311a-v1.3-block-diagram.png
    :align: center
    :alt: ESP-LyraT-8311A block diagram
    :figclass: align-center

    ESP-LyraT-8311A block diagram


Hardware Revision Details


ESP-LyraT-8311A v1.3



ESP-LyraT-8311A v1.2


:doc:`Initial relea"
"se `


Related Documents


- `ESP-LyraT-8311A Schematic `_ (PDF)
- `ESP-LyraT-8311A PCB Layout `_ (PDF)

For other design documentation for the board, please contact us at sales@espressif.com.
"
"


This user guide provides information on the ESP-LyraT-8311A extension board.

This board cannot be bought separately and is usually sold together with other Espressif development boards (e.g., ESP32-S2-Kaluga-1), which will be referred to as *main boards* below.

Currently, ESP-LyraT-8311A v1.2 is sold as part of the :doc:`user-guide-esp32-s2-kaluga-1-kit-v1.2`.

The ESP-LyraT-8311A extends the functionality of your main board by adding sound processing functionality:

- Audio playback/record"
"ing
- Processing of audio signals
- Programmable buttons for easy control

This extension board can be used in many ways. The applications might include voice user interface, voice control, voice authorization, recording and playback of sound, etc.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrat-8311a-v1.2-3d.png
    :align: center
    :width: 2545px
    :height: 1786px
    :scale: 30%
    :alt: ESP-LyraT-8311A
    :figclass: align-center

    ESP-LyraT-8311A (click to enl"
"arge)

The document consists of the following major sections:

- `Overview`_: Provides an overview and hardware setup instructions.
- `Hardware reference`_: Provides more detailed information about the ESP-LyraT-8311A's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions of the ESP-LyraT-8311A.
- `Related Documents`_: Gives links to related documentation.


Overview


The ESP-LyraT-8311A is mainly designed for audio appl"
"ications. However, you can use your creativity to come up with any other use cases.


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrat-8311a-v1.2-layout-front.png
    :align: center
    :width: 934px
    :height: 565px
    :scale: 70%
    :alt: ESP-LyraT-8311A - front
    :figclass: align-center

    ESP-LyraT-8311A - front (click to enlarge)

The description of components starts from the top right corner and then goes clockwise.

**Reserved** mea"
"ns that the functionality is available, but the current version of the kit does not use it.


.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Male Extension Header on the flip side is for mounting onto main board's Extension Header; Female Extension Header is for mounting other boards that have a Male Extension Header
     - This board has six programmable buttons
     - Supports Electret and MEMS microphones; this extension board is supplied with an electret micro"
"phone
     - 6.3 mm (1/8"") stereo headphone connector
     - Connect an external speaker to the 2-pin connector
     - 3 W Audio signal amplifier for the external speaker
     - (Reserved) FPC connector for external Mic-Matrix (microphone boards)
     - (Reserved) high-performance ADC/ES7243: 1 channel for microphone, 1 channel for acoustic echo cancellation (AEC) function
     - ES8311 audio ADC and DAC; it can convert the analog signal picked up by the microphone or convert digital signal to p"
"lay it back through a speaker or headphones


Start Application Development


Before powering up your ESP-LyraT-8311A, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- Board with a female Extension Header (e.g., ESP32-S2-Kaluga-1)
- ESP-LyraT-8311A extension board
- Four mounting bolts (for stable mounting)
- Computer running Windows, Linux, or macOS


Hardware Setup


To mount your ESP-LyraT-8311A onto the board with a female Extension Heade"
"r:


Software Setup


Depending on your application, see:


Hardware Reference


Block Diagram


A block diagram below shows the components of ESP-LyraT-8311A and their interconnections.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrat-8311a-v1.2-block-diagram.png
    :align: center
    :alt: ESP-LyraT-8311A block diagram
    :figclass: align-center

    ESP-LyraT-8311A block diagram


Hardware Revision Details


No previous versions available.


Related Documents


- `ESP-"
"LyraT-8311A Schematic `_ (PDF)
- `ESP-LyraT-8311A PCB Layout `_ (PDF)

For other design documentation for the board, please contact us at sales@espressif.com.
"
"


Older version: :doc:`user-guide-esp32-s2-kaluga-1-kit-v1.2`

The ESP32-S2-Kaluga-1 kit v1.3 is a development kit by Espressif that is mainly created to:

- Demonstrate the ESP32-S2's human-computer interaction functionalities
- Provide the users with the tools for development of human-computer interaction applications based on the ESP32-S2

There are many ways of how the ESP32-S2's abundant functionalities can be used. For starters, the possible use cases may include:

- **Smart home**: From "
"simplest smart lighting, smart door locks, smart sockets, to video streaming devices, security cameras, OTT devices, and home appliances
- **Battery-powered equipment**: Wi-Fi mesh sensor networks, Wi-Fi-networked toys, wearable devices, health management equipment
- **Industrial automation equipment**: Wireless control and robot technology, intelligent lighting, HVAC control equipment, etc.
- **Retail and catering industry**: POS machines and service robots

.. Image of v1.2 is used as there ar"
"e no visual changes

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32-s2-kaluga-1-kit-v1.0-3d.png
    :align: center
    :width: 3452px
    :height: 1590px
    :scale: 20%
    :alt: ESP32-S2-Kaluga-1-Kit-Assembly
    :figclass: align-center

    ESP32-S2-Kaluga-1-Kit Overview (click to enlarge)


The ESP32-S2-Kaluga-1 kit consists of the following boards:

- Main board: *ESP32-S2-Kaluga-1*
- Extension boards:

  - :doc:`user-guide-esp-lyrat-8311a_v1.3` - audio player
  - :doc:`u"
"ser-guide-esp-lyrap-toucha-v1.1` - touch panel
  - :doc:`user-guide-esp-lyrap-lcd32-v1.2` - 3.2"" LCD screen
  - :doc:`user-guide-esp-lyrap-cam-v1.1` - camera board

Due to the presence of multiplexed pins on ESP32-S2, certain extension board combinations have limited compatibility. For more details, please see :ref:`user-guide-esp32-s2-kaluga-1-kit-ext-board-compatibility`.

This document is **mostly dedicated to the main board** and its interaction with the extension boards. For more detailed i"
"nformation on each extension board, click their respective links.

This guide covers:

- `Getting Started`_: Provides an overview of the ESP32-S2-Kaluga-1 and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information about the ESP32-S2-Kaluga-1's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions of the ESP32-S2-Kaluga-1.
- `Related Documents`_: Gives links to relat"
"ed documentation.


Getting Started


This section describes how to get started with the ESP32-S2-Kaluga-1. It begins with a few introductory sections about the ESP32-S2-Kaluga-1, then Section `Start Application Development`_ provides instructions on how to do the initial hardware setup and then how to flash firmware onto the ESP32-S2-Kaluga-1.


Overview


The ESP32-S2-Kaluga-1 main board is the heart of the kit. It integrates the ESP32-S2-WROVER module and all the connectors for extension boar"
"ds. This board is the key tool in prototyping human-computer interaction interfaces.

The ESP32-S2-Kaluga-1 board has connectors for boards with:

- Extension header (ESP-LyraT-8311A, ESP-LyraP-LCD32)
- Camera header (ESP-LyraP-CAM)
- Touch FPC coneector (ESP-LyraP-TouchA)
- LCD FPC connector (no official extension boards yet)
- I2C FPC connector (no official extension boards yet)

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32s2-kaluga-1-v1.3-3d.png
    :align: center
    :wi"
"dth: 3089px
    :height: 2335px
    :scale: 25%
    :alt: ESP32-S2-Kaluga-1
    :figclass: align-center

    ESP32-S2-Kaluga-1 (click to enlarge)

All the four extension boards are specially desgined to support the following features:


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32-s2-kaluga-1-v1.3-layout-front.png
    :align: center
    :width: 934px
    :height: 645px
    :scale: 70%
    :alt: ESP32-S2-Kaluga-1 - front
    :figclass: align-center"
"

    ESP32-S2-Kaluga-1 - front (click to enlarge)

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32-s2-kaluga-1-v1.3-layout-back.png
    :align: center
    :width: 934px
    :height: 600px
    :scale: 70%
    :alt: ESP32-S2-Kaluga-1 - back
    :figclass: align-center

    ESP32-S2-Kaluga-1 - back (click to enlarge)


The description of components starts from the ESP32-S2 module on the left side and then goes clockwise.

**Reserved** means that the functionality is available, bu"
"t the current version of the kit does not use it.


.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Module integrating the ESP32-S2 chip that provides Wi-Fi connectivity, data processing power, and flexible data storage.
     - (Reserved) Connect to a 4.3"" LCD extension board using the FPC cable.
     - (Reserved) Connection for Espressif's download device (ESP-Prog) to flash ESP32-S2 system.
     - Switch to ON to enable connection between ESP32-S2 and FT2232; JTA"
"G debugging will then be possible using USB-UART/JTAG Port. See also :doc:`../../api-guides/jtag-debugging/index`.
     - Some GPIO pins of the ESP32-S2-WROVER module are broken out to this header, see labels on the board.
     - FT2232 adapter board allowing for communication over USB port using UART/JTAG protocols.
     - Mount a camera extension board here (e.g., ESP-LyraP-CAM).
     - Mount the extension boards having such connectors here.
     - Press this button to restart the system
     "
"- Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - Communication interface (UART or JTAG) between a PC and the ESP32-S2 module.
     - Power supply for the board.
     - Connect an external battery to the 2-pin battery connector.
     - Turns on when the USB or an external power supply is connected to the board.
     - Switch to ON to power the system.
     - To have access to the RGB LED, place a jumper o"
"nto the pins.
     - Programmable RGB LED and controlled by GPIO45. Before using it, you need to put RGB Jumper ON.
     - Regulator converts 5 V to 3.3 V.
     - (Reserved) Connect to other I2C extension boards using the FPC cable.
     - Some GPIO pins of the ESP32-S2-WROVER module are broken out to this header, see labels on the board.
     - Connect the ESP-LyraP-TouchA extension board using the FPC cable.
     - In OFF position, GPIO1 to GPIO14 are used for connection to touch sensors; swit"
"ch to ON if you want to use them for other purposes.
     - Connect a 3.2"" LCD extension board (e.g., ESP-LyraP-LCD32) using the FPC cable.


Start Application Development


Before powering up your ESP32-S2-Kaluga-1, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-S2-Kaluga-1
- Two USB 2.0 cables (Standard-A to Micro-B)

  - For power supply
  - For UART/JTAG communication

- Computer running Windows, Linux, or macOS
- Any extension bo"
"ards of your choice


Hardware Setup



.. _user-guide-esp32-s2-kaluga-1-kit-software-setup:

Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment.

The programming guide and application examples for your ESP32-S2-Kaluga-1 kit can be found in `esp-dev-kits `_ repository on GitHub.

A Board Support Package can be found in `IDF Component Registry `_.


Contents and Packaging


Retai"
"l Orders


If you order one or several samples of the kit, each ESP32-S2-Kaluga-1 development kit comes in an individual package.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32s2-kaluga-1-kit-v1.3-package-3d.png
    :align: center
    :alt: ESP32-S2-Kaluga-1 - package
    :figclass: align-center

    ESP32-S2-Kaluga-1 - package


The contents are as follows:

- Main Board
    - ESP32-S2-Kaluga-1
- Extension Boards:
    - ESP-LyraT-8311A
    - ESP-LyraP-CAM
    - ESP-LyraP-Tou"
"chA
    - ESP-LyraP-LCD32
- Connectors
    - 20-pin FPC cable (to connect ESP32-S2-Kaluga-1 to ESP-LyraP-TouchA)
- Fasteners
    - Mounting bolts (x8)
    - Screws (x4)
    - Nuts (x4)

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


.. Image of "
"v1.2 is used as there are no visual changes

A block diagram below shows the components of the ESP32-S2-Kaluga-1 and their interconnections.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32-s2-kaluga-1-v1.2-block-diagram.png
    :align: center
    :alt: ESP32-S2-Kaluga-1 block diagram
    :figclass: align-center

    ESP32-S2-Kaluga-1 block diagram


Power Supply Options


There are four ways to provide power to the board:

- Micro USB port, default power supply
- External batt"
"ery via the 2-pin battery connector
- 5V and GND header pins
- 3V3 and GND header pins


.. _user-guide-esp32-s2-kaluga-1-kit-ext-board-compatibility:

Compatibility of Extension Boards


If you want to use more than one extension board at the same time, please check the table given below.

.. list-table::
   :widths: 20 15 33 32
   :header-rows: 1
     - HW Conflict
     - Limitations
     - Solution
     - I2S Controller
     - ESP32-S2 has only one I2S interface. But both extension boards req"
"uire connection via the ESP32-S2's I2S interface (LyraT-8311A in Standard mode, ESP-LyraP-CAM in Camera mode).
     - Utilize time division multiple access, or use a different audio module that can be connected via other GPIOs or DAC.
     - IO11, IO6
     - Touch actions cannot be triggered because of the multiplexed pin IO11. ESP-LyraP-LCD32 will not be affected because its BLCT pin will be disconnected from IO6.
     - Do not initialize IO11 (NETWORK) for your ESP-LyraP-TouchA, or configure t"
"he BLCT pin to `-1` (= do not use BLCT) for your ESP-LyraP-LCD32.
     - IO6
     - BLCT pin of ESP32-S2-Kaluga-1 will be disconnected from IO6.
     - Configure the BK pin to `-1` (= do not use BLCT) for your ESP-LyraP-LCD32.
     - Pin BT_ADC on ESP-LyraT-8311A
     - This pin is required for initialization of the six button on ESP-LyraT-8311A. At the same time, ESP-LyraP-TouchA needs this pin for its touch actions.
     - If you plan to use buttons on ESP-LyraT-8311A, do not initialize pin IO"
"6 (PHOTO) for your ESP-LyraP-TouchA.
     - IO1, IO2, IO3
     - Cannot be used simultaneously because of the mentioned multiplexed pins.
     - For ESP-LyraP-TouchA, do not initialize IO1 (VOL_UP), IO2 (PLAY), and IO3 (VOL_DOWN).
     - IO1, IO2, IO3, IO11
     - Conflicts on the mentioned multiplexed pins.
     - For ESP-LyraP-TouchA, do not initialize IO1 (VOL_UP), IO2 (PLAY), IO3 (VOL_DOWN), and IO11 (NETWORK).
     - IO6, IO11
     - If ESP-LyraT-8311A's pin BT_ADC is used to initialize the"
" board's six buttons, IO6 and IO11 will not be available for the other boards.
     - Do not initialize IO11 (NETWORK) for your ESP-LyraP-TouchA. Also, if you need to use BT_ADC, do not initialize IO6 (PHOTO).

Also, all extension boards and the :ref:`JTAG interface ` share the same pins IO39, IO40, IO41 and IO42. For this reason, the following may disturb the JTAG operation:


Hardware Revision Details


ESP32-S2-Kaluga-1 Kit v1.3



ESP32-S2-Kaluga-1 Kit v1.2


:doc:`Initial release `


Relate"
"d Documents


.. toctree::
    :hidden:

    user-guide-esp32-s2-kaluga-1-kit-v1.2.rst
    user-guide-esp-lyrap-cam-v1.1
    user-guide-esp-lyrap-lcd32-v1.2
    user-guide-esp-lyrat-8311a_v1.3

- `ESP32-S2-WROVER Datasheet `_ (PDF)
- `ESP Product Selector `_
- :doc:`../../api-guides/jtag-debugging/index`

- `ESP32-S2-Kaluga-1 Schematic `_ (PDF)
- `ESP32-S2-Kaluga-1 PCB Layout `_ (PDF)
- `ESP32-S2-Kaluga-1 Pin Mapping `_ (Excel)

For other design documentation for the board, please contact us at "
"sales@espressif.com.


"
"


This user guide provides information on the ESP-LyraP-TouchA extension board.

This board cannot be bought separately and is usually sold together with other Espressif development boards (e.g., ESP32-S2-Kaluga-1), which will be referred to as *main boards* below.

Currently, ESP-LyraP-TouchA v1.1 is sold as part of the following kits:

The ESP-LyraP-TouchA extends the functionality of your main board by adding touch buttons.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyr"
"ap-toucha-v1.1-3d.png
    :align: center
    :alt: ESP-LyraP-TouchA
    :figclass: align-center

    ESP-LyraP-TouchA

The document consists of the following major sections:

- `Overview`_: Provides an overview and hardware setup instructions.
- `Hardware reference`_: Provides more detailed information about the ESP-LyraP-TouchA's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions of the ESP-LyraP-TouchA.
- `Related Doc"
"uments`_: Gives links to related documentation.


Overview


The ESP-LyraP-TouchA has six touch buttons and is mainly designed for audio applications. However, the touch buttons can also be used for any other purposes.


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-toucha-v1.1-layout-front.png
    :align: center
    :alt: ESP-LyraP-TouchA
    :figclass: align-center

    ESP-LyraP-TouchA

.. list-table::
   :widths: 30 70
   :header-rows: 1
  "
"   - Description
     - Connect to main board's Touch FPC Connector.
     - Capacitive touch electrode.
     - Connected to a touch sensor, the guard ring triggers an interrupt if wet (Water rejection). It indicates that the sensor array is also wet and most (if not all) touchpads are unusable due to the false detection of touches. After receiving this interrupt, the user might consider disabling all the touch sensors via software.


Start Application Development


Before powering up your ESP-Ly"
"raP-TouchA, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- Board with a Touch FPC connector  (e.g., ESP32-S2-Kaluga-1)
- ESP-LyraP-TouchA extension board
- FPC cable
- Computer running Windows, Linux, or macOS


Hardware Setup


Connect the two FPC connectors with the FPC cable.


Software Setup


See Section :ref:`user-guide-esp32-s2-kaluga-1-kit-software-setup` of the ESP32-S2-Kaluga-1 kit user guide.


Hardware Reference


Block Diagram
"
"

A block diagram below shows the components of ESP-LyraP-TouchA and their interconnections.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-toucha-v1.1-block-diagram.png
    :align: center
    :alt: ESP-LyraP-TouchA-v1.1 block diagram
    :figclass: align-center

    ESP-LyraP-TouchA-v1.1 block diagram


Hardware Revision Details


No previous versions available.


Related Documents


- `ESP-LyraP-TouchA Schematic `_ (PDF)
- `ESP-LyraP-TouchA PCB Layout `_ (PDF)

For othe"
"r design documentation for the board, please contact us at sales@espressif.com.
"
"


This user guide provides information on Espressif's small-sized development board ESP32-S2-DevKitM-1.

ESP32-S2-DevKitM-1 is entry-level development board. Most of the I/O pins on the module are broken out to the pin headers on both sides for easy interfacing. Developers can either connect peripherals with jumper wires or mount ESP32-S2-DevKitM-1 on a breadboard.

+++
| |ESP32-S2-DevKitM-1| | |ESP32-S2-DevKitM-1U| |
+++
|  ESP32-S2-DevKitM-1  |  ESP32-S2-DevKitM-1U  |
+++

.. |ESP32-S2-DevKit"
"M-1| image:: ../../../_static/esp32-s2-devkitm-1-v1-isometric.png

.. |ESP32-S2-DevKitM-1U| image:: ../../../_static/esp32-s2-devkitm-1u-v1-isometric.png

The document consists of the following major sections:

- `Getting started`_: Provides an overview of the ESP32-S2-DevKitM-1 and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information about the ESP32-S2-DevKitM-1's hardware.
- `Hardware Revision Details`_: Revision history, known issues"
", and links to user guides for previous versions (if any) of ESP32-S2-DevKitM-1.
- `Related Documents`_: Gives links to related documentation.


Getting Started


This section describes how to get started with ESP32-S2-DevKitM-1. It begins with a few introductory sections about the ESP32-S2-DevKitM-1, then Section `Start Application Development`_ provides instructions on how to get the ESP32-S2-DevKitM-1 ready and flash firmware into it.


Contents and Packaging



.. _user-guide-s2-devkitm-1-v1"
"-ordering-info:

Ordering Information


The development board has a variety of variants to choose from, as shown in the table below.

.. list-table::
   :header-rows: 1
   :widths: 41 24 9 8 18
     - On-board Module [#]_
     - Flash
     - PSRAM
     - Antenna
     - ESP32-S2-MINI-2

       (Recommended)
     - 4 MB
     - 2 MB
     - PCB on-board antenna
     - ESP32-S2-MINI-2U

       (Recommended)
     - 4 MB
     - 2 MB
     - External antenna connector
     - ESP32-S2-MINI-1
     - 4 MB
 "
"    - ---
     - PCB on-board antenna
     - ESP32-S2-MINI-1U
     - 4 MB
     - ---
     - External antenna connector
     - ESP32-S2-MINI-1
     - 4 MB
     - 2 MB
     - PCB on-board antenna
     - ESP32-S2-MINI-1U
     - 4 MB
     - 2 MB
     - External antenna connector


.. [#] The ESP32-S2-MINI-2 and ESP32-S2-MINI-2U modules use chip revision v1.0, and the rest use chip revision v0.0. For more information about chip revisions, please refer to `ESP32-S2 Series SoC Errata`_.


Retail Orders"
"


If you order a few samples, each ESP32-S2-DevKitM-1 comes in an individual package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Description of Components


.. _user-guide-devkitm-1-v1-board-front:

.. figur"
"e:: ../../../_static/esp32-s2-devkitm-1-v1-annotated-photo.png
    :align: center
    :alt: ESP32-S2-DevKitM-1 - front
    :figclass: align-center

    ESP32-S2-DevKitM-1 - front

.. figure:: ../../../_static/esp32-s2-devkitm-1u-v1-annotated-photo.png
    :align: center
    :alt: ESP32-S2-DevKitM-1U - front
    :figclass: align-center

    ESP32-S2-DevKitM-1U - front

The key components of the board are described in a clockwise direction.

.. list-table::
   :widths: 30 70
   :header-rows: 1
   "
"  - Description
     - ESP32-S2-MINI series modules with an on-board PCB antenna or a connector for an external antenna. This series of modules, known for its small size, have a flash and/or a PSRAM integrated in the chip package. For more information, please refer to :ref:`user-guide-s2-devkitm-1-v1-ordering-info`.
     - All available GPIO pins (except for the SPI bus for flash) are broken out to the pin headers on the board. Users can program ESP32-S2FH4 chip to enable multiple functions such"
" as SPI, I2S, UART, I2C, touch sensors, PWM etc. For details, please see :ref:`user-guide-devkitm-1-v1-header-blocks`.
     - Turns on when the USB power is connected to the board.
     - Single USB-UART bridge chip provides transfer rates up to 3 Mbps.
     - Reset button.
     - USB interface. Power supply for the board as well as the communication interface between a computer and the ESP32-S2FH4 chip.
     - Download button. Holding down **Boot** and then pressing **Reset** initiates Firmware"
" Download mode for downloading firmware through the serial port.
     - Addressable RGB LED, driven by GPIO18.
     - Power regulator that converts a 5 V supply into a 3.3 V output.
     - On **ESP32-S2-MINI-2U** and **ESP32-S2-MINI-1U** module only. For connector dimensions, please refer to Section External Antenna Connector Dimensions in module datasheet.


Start Application Development


Before powering up your ESP32-S2-DevKitM-1, please make sure that it is in good condition with no obvious "
"signs of damage.


Required Hardware


- ESP32-S2-DevKitM-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. note::

  Be sure to use an appropriate USB cable. Some cables are for charging only and do not provide the needed data lines nor work for programming the boards.


Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment and then flash an"
" application example into your ESP32-S2-DevKitM-1.

.. note::

    ESP32-S2 series of chips only is only supported in ESP-IDF master or version v4.2 and higher.


Hardware Reference


Block Diagram


A block diagram below shows the components of ESP32-S2-DevKitM-1 and their interconnections.

.. figure:: ../../../_static/esp32-s2-devkitm-1-v1-block-diagram.png
    :align: center
    :scale: 70%
    :alt: ESP32-S2-DevKitM-1 (click to enlarge)
    :figclass: align-center

    ESP32-S2-DevKitM-1 (c"
"lick to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

- Micro-USB Port, default power supply
- 5V and GND pin headers
- 3V3 and GND pin headers

It is recommended to use the first option: micro USB Port.


.. _user-guide-devkitm-1-v1-header-blocks:

Header Block


The two tables below provide the **Name** and **Function** of the pin headers on both sides of the board (J1 and J3). The pin header names are shown in :ref:`user-guide-devkit"
"m-1-v1-board-front`. The numbering is the same as in the `ESP32-S2-DevKitM-1 Schematics `_ (PDF).


J1
^^^

===      
No.  Name  Type [#]_    Function
===      
1    3V3    P           3.3 V power supply
2    0      I/O/T       RTC_GPIO0, GPIO0
3    1      I/O/T       RTC_GPIO1, GPIO1, TOUCH1, ADC1_CH0
4    2      I/O/T       RTC_GPIO2, GPIO2, TOUCH2, ADC1_CH1
5    3      I/O/T       RTC_GPIO3, GPIO3, TOUCH3, ADC1_CH2
6    4      I/O/T       RTC_GPIO4, GPIO4, TOUCH4, ADC1_CH3
7    5      I/O/T  "
"     RTC_GPIO5, GPIO5, TOUCH5, ADC1_CH4
8    6      I/O/T       RTC_GPIO6, GPIO6, TOUCH6, ADC1_CH5
9    7      I/O/T       RTC_GPIO7, GPIO7, TOUCH7, ADC1_CH6
10   8      I/O/T       RTC_GPIO8, GPIO8, TOUCH8, ADC1_CH7
11   9      I/O/T       RTC_GPIO9, GPIO9, TOUCH9, ADC1_CH8, FSPIHD
12   10     I/O/T       RTC_GPIO10, GPIO10, TOUCH10, ADC1_CH9, FSPICS0, FSPIIO4
13   11     I/O/T       RTC_GPIO11, GPIO11, TOUCH11, ADC2_CH0, FSPID, FSPIIO5
14   12     I/O/T       RTC_GPIO12, GPIO12, TOUCH12, ADC2_"
"CH1, FSPICLK, FSPIIO6
15   13     I/O/T       RTC_GPIO13, GPIO13, TOUCH13, ADC2_CH2, FSPIQ, FSPIIO7
16   14     I/O/T       RTC_GPIO14, GPIO14, TOUCH14, ADC2_CH3, FSPIWP, FSPIDQS
17   15     I/O/T       RTC_GPIO15, GPIO15, U0RTS, ADC2_CH4, XTAL_32K_P
18   16     I/O/T       RTC_GPIO16, GPIO16, U0CTS, ADC2_CH5, XTAL_32K_N
19   17     I/O/T       RTC_GPIO17,  GPIO17, U1TXD, ADC2_CH6, DAC_1
20   5V     P           5 V power supply
21   G      G           Ground
===      


J3
^^^

===      
No.  Na"
"me  Type   Function
===      
1    G     G      Ground
2    RST   I      CHIP_PU
3    46    I      GPIO46
4    45    I/O/T  GPIO45
5    RX    I/O/T  U0RXD, GPIO44, CLK_OUT2
6    TX    I/O/T  U0TXD, GPIO43, CLK_OUT1
7    42    I/O/T  MTMS, GPIO42
8    41    I/O/T  MTDI, GPIO41, CLK_OUT1
9    40    I/O/T  MTDO, GPIO40, CLK_OUT2
10   39    I/O/T  MTCK, GPIO39, CLK_OUT3
11   38    I/O/T  GPIO38, FSPIWP
12   37    I/O/T  SPIDQS, GPIO37, FSPIQ
13   36    I/O/T  SPIIO7, GPIO36, FSPICLK
14   35    I/O/T"
"  SPIIO6, GPIO35, FSPID
15   34    I/O/T  SPIIO5, GPIO34, FSPICS0
16   33    I/O/T  SPIIO4, GPIO33, FSPIHD
17   26    I/O/T  SPICS1, GPIO26
18   21    I/O/T  RTC_GPIO21, GPIO21
19   20    I/O/T  RTC_GPIO20, GPIO20, U1CTS, ADC2_CH9, CLK_OUT1, USB_D+
20   19    I/O/T  RTC_GPIO19, GPIO19, U1RTS, ADC2_CH8, CLK_OUT2, USB_D-
21   18    I/O/T  RTC_GPIO18, GPIO18, U1RXD, ADC2_CH7, DAC_2, CLK_OUT3, RGB LED
===      

.. [#] P: Power supply; I: Input; O: Output; T: High impedance.


Pin Layout


.. figure"
":: ../../../_static/esp32-s2-devkitm-1-v1-pin-layout.png
    :align: center
    :scale: 15%
    :alt: ESP32-S2-DevKitM-1 (click to enlarge)
    :figclass: align-center

    ESP32-S2-DevKitM-1 Pin Layout (click to enlarge)


Hardware Revision Details


This is the first revision of this board released.


Related Documents


For other design documentation for the board, please contact us at `sales@espressif.com `_.

.. _NRND: https://www.espressif.com/en/products/longevity-commitment?id=nrnd
.. _E"
"SP32-S2 Series Chip Revision v1.0 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-s2-v1.0_datasheet_en.pdf
.. _ESP32-S2 Series SoC Errata: https://espressif.com/sites/default/files/documentation/esp32-s2_errata_en.pdf
"
"


This user guide provides information on ESP32-S2-Saola-1, a small-sized `ESP32-S2 Datasheet`_ based development board produced by Espressif.

.. figure:: ../../../_static/esp32-s2-saola-1-v1.2-isometric.png
    :align: center
    :alt: ESP32-S2-Saola-1
    :figclass: align-center

    ESP32-S2-Saola-1

The document consists of the following major sections:

- `Getting started`_: Provides an overview of the ESP32-S2-Saola-1 and hardware/software setup instructions to get started.
- `Hardware r"
"eference`_: Provides more detailed information about the ESP32-S2-Saola-1's hardware.
- `Hardware Revision Details`_: Revision history, known issues, and links to user guides for previous versions (if any) of ESP32-S2-Saola-1.
- `Related Documents`_: Gives links to related documentation.


Getting Started


This section describes how to get started with ESP32-S2-Saola-1. It begins with a few introductory sections about the ESP32-S2-Saola-1, then Section `Start Application Development`_ provides "
"instructions on how to get the ESP32-S2-Saola-1 ready and flash firmware into it.


Overview


ESP32-S2-Saola-1 is a small-sized ESP32-S2 based development board produced by Espressif. Most of the I/O pins are broken out to the pin headers on both sides for easy interfacing. Developers can either connect peripherals with jumper wires or mount ESP32-S2-Saola-1 on a breadboard.

To cover a wide range of users' needs, ESP32-S2-Saola-1 supports:

- `ESP32-S2-WROVER `_
- `ESP32-S2-WROVER-I `_
- `ESP3"
"2-S2-WROOM `_
- `ESP32-S2-WROOM-I `_

In this guide, we take ESP32-S2-Saola-1 equipped with ESP32-S2-WROVER as an example.


Contents and Packaging


Retail Orders


If you order a few samples, each ESP32-S2-Saola-1 comes in an individual package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesa"
"le orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Description of Components


.. _user-guide-saola-1-v1.2-board-front:

.. figure:: ../../../_static/esp32-s2-saola-1-v1.2-annotated-photo.png
    :align: center
    :alt: ESP32-S2-Saola-1 - front/back
    :figclass: align-center

    ESP32-S2-Saola-1 - front

The key components of the board are described in a clockwise direction.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - ESP32-"
"S2-WROVER is a powerful, generic Wi-Fi MCU module that integrates ESP32-S2. It has a PCB antenna, a 4 MB external SPI flash and an additional 2 MB PSRAM.
     - All available GPIO pins (except for the SPI bus for flash and PSRAM) are broken out to the pin headers on the board. Users can program ESP32-S2 chip to enable multiple functions such as SPI, I2S, UART, I2C, touch sensors, PWM etc.
     - Turns on when the USB power is connected to the board.
     - Single USB-UART bridge chip provides tr"
"ansfer rates up to 3 Mbps.
     - Reset button.
     - USB interface. Power supply for the board as well as the communication interface between a computer and the ESP32-S2 chip.
     - Download button. Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - Addressable RGB LED (WS2812), driven by GPIO18.


Start Application Development


Before powering up your ESP32-S2-Saola-1, please make sure that it is in goo"
"d condition with no obvious signs of damage.


Required Hardware


- ESP32-S2-Saola-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. note::

  Be sure to use an appropriate USB cable. Some cables are for charging only and do not provide the needed data lines nor work for programming the boards.


Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development env"
"ironment and then flash an application example into your ESP32-S2-Saola-1.

.. note::

    ESP32-S2 series of chips only supports ESP-IDF master or version v4.2 and higher.


Hardware Reference


Block Diagram


A block diagram below shows the components of ESP32-S2-Saola-1 and their interconnections.

.. figure:: ../../../_static/esp32-s2-saola-1-v1.2-block-diags.png
    :align: center
    :scale: 70%
    :alt: ESP32-S2-Saola-1 (click to enlarge)
    :figclass: align-center

    ESP32-S2-Saola-"
"1 (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

- Micro-USB port, default power supply
- 5V and GND pin headers
- 3V3 and GND pin headers

It is recommended to use the first option: Micro-USB Port.


Header Block


The two tables below provide the **Name** and **Function** of the pin headers on both sides of the board (J2 and J3). The pin header names are shown in :ref:`user-guide-saola-1-v1.2-board-front`. The numbering is th"
"e same as in the `ESP32-S2-Saola-1 Schematics`_ (PDF).


J2
^^^

===      
No.  Name  Type [#]_    Function
===      
1    3V3    P           3.3 V power supply
2    IO0    I/O         GPIO0, Boot
3    IO1    I/O         GPIO1, ADC1_CH0, TOUCH_CH1
4    IO2    I/O         GPIO2, ADC1_CH1, TOUCH_CH2
5    IO3    I/O         GPIO3, ADC1_CH2, TOUCH_CH3
6    IO4    I/O         GPIO4, ADC1_CH3, TOUCH_CH4
7    IO5    I/O         GPIO5, ADC1_CH4, TOUCH_CH5
8    IO6    I/O         GPIO6, ADC1_CH5, TOUCH_C"
"H6
9    IO7    I/O         GPIO7, ADC1_CH6, TOUCH_CH7
10   IO8    I/O         GPIO8, ADC1_CH7, TOUCH_CH8
11   IO9    I/O         GPIO9, ADC1_CH8, TOUCH_CH9
12   IO10   I/O         GPIO10, ADC1_CH9, TOUCH_CH10
13   IO11   I/O         GPIO11, ADC2_CH0, TOUCH_CH11
14   IO12   I/O         GPIO12, ADC2_CH1, TOUCH_CH12
15   IO13   I/O         GPIO13, ADC2_CH2, TOUCH_CH13
16   IO14   I/O         GPIO14, ADC2_CH3, TOUCH_CH14
17   IO15   I/O         GPIO15, ADC2_CH4, XTAL_32K_P
18   IO16   I/O         GP"
"IO16, ADC2_CH5, XTAL_32K_N
19   IO17   I/O         GPIO17, ADC2_CH6, DAC_1
20   5V0    P           5 V power supply
21   GND    G           Ground
===      


J3
^^^

===      
No.  Name  Type   Function
===      
1    GND   G      Ground
2    RST   I      CHIP_PU, Reset
3    IO46  I      GPIO46
4    IO45  I/O    GPIO45
5    IO44  I/O    GPIO44, U0RXD
6    IO43  I/O    GPIO43, U0TXD
7    IO42  I/O    GPIO42, MTMS
8    IO41  I/O    GPIO41, MTDI
9    IO40  I/O    GPIO40, MTDO
10   IO39  I/O    GPI"
"O39, MTCK
11   IO38  I/O    GPIO38
12   IO37  I/O    GPIO37
13   IO36  I/O    GPIO36
14   IO35  I/O    GPIO35
16   IO34  I/O    GPIO34
17   IO33  I/O    GPIO33
17   IO26  I/O    GPIO26
18   IO21  I/O    GPIO21
19   IO20  I/O    GPIO20, ADC2_CH9, USB_D+
20   IO19  I/O    GPIO19, ADC2_CH8, USB_D-
21   IO18  I/O    GPIO18, ADC2_CH7, DAC_2, RGB LED
===      

.. [#] P: Power supply; I: Input; O: Output; T: High impedance.


Pin Layout


.. figure:: ../../../_static/esp32-s2_saola1-pinout.jpg
    :al"
"ign: center
    :scale: 45%
    :alt: ESP32-S2-Saola-1 (click to enlarge)
    :figclass: align-center

    ESP32-S2 Saola-1 Pin Layout (click to enlarge)


Hardware Revision Details


This is the first revision of this board released.


Related Documents


For other design documentation for the board, please contact us at `sales@espressif.com `_.

.. _ESP32-S2-Saola-1 Schematics: https://dl.espressif.com/dl/schematics/ESP32-S2-SAOLA-1_V1.1_schematics.pdf
.. _ESP32-S2-Saola-1 Dimensions: https://"
"dl.espressif.com/dl/schematics/ESP32-S2-Saola-1_V1.2_Dimensions.pdf
.. _ESP32-S2 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-s2_datasheet_en.pdf
.. _ESP32-S2-WROVER and ESP32-S2-WROVER-I Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-s2-wrover_esp32-s2-wrover-i_datasheet_en.pdf
.. _ESP32-S2-WROOM and ESP32-S2-WROOM-I Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-s2-wroom_esp32-s2-wroom-i_datasheet_en.pd"
"f
.. _ESP Product Selector: https://products.espressif.com/#/product-selector?names=
"
"


New version available: :doc:`user-guide-esp32-s2-kaluga-1-kit`

The ESP32-S2-Kaluga-1 kit v1.2 is a development kit by Espressif that is mainly created to:

- Demonstrate the ESP32-S2's human-computer interaction functionalities
- Provide the users with the tools for development of human-computer interaction applications based on the ESP32-S2

There are many ways of how the ESP32-S2's abundant functionalities can be used. For starters, the possible use cases may include:

- **Smart home**: Fr"
"om simplest smart lighting, smart door locks, smart sockets, to video streaming devices, security cameras, OTT devices, and home appliances
- **Battery-powered equipment**: Wi-Fi mesh sensor networks, Wi-Fi-networked toys, wearable devices, health management equipment
- **Industrial automation equipment**: Wireless control and robot technology, intelligent lighting, HVAC control equipment, etc.
- **Retail and catering industry**: POS machines and service robots


.. figure:: https://dl.espressif"
".com/dl/schematics/pictures/esp32-s2-kaluga-1-kit-v1.0-3d.png
    :align: center
    :width: 3452px
    :height: 1590px
    :scale: 20%
    :alt: ESP32-S2-Kaluga-1-Kit-Assembly
    :figclass: align-center

    ESP32-S2-Kaluga-1-Kit Overview (click to enlarge)


The ESP32-S2-Kaluga-1 kit consists of the following boards:

- Main board: *ESP32-S2-Kaluga-1*
- Extension boards:

  - :doc:`user-guide-esp-lyrat-8311a_v1.2` - audio player
  - :doc:`user-guide-esp-lyrap-toucha-v1.1` - touch panel
  - :d"
"oc:`user-guide-esp-lyrap-lcd32-v1.1` - 3.2"" LCD screen
  - :doc:`user-guide-esp-lyrap-cam-v1.0` - camera board

Due to the presence of multiplexed pins on ESP32-S2, certain extension board combinations have limited compatibility. For more details, please see :ref:`user-guide-esp32-s2-kaluga-1-kit-v1.2-ext-board-compatibility`.

This document is **mostly dedicated to the main board** and its interaction with the extension boards. For more detailed information on each extension board, click their "
"respective links.

This guide covers:

- `Getting Started`_: Provides an overview of the ESP32-S2-Kaluga-1 and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information about the ESP32-S2-Kaluga-1's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions of the ESP32-S2-Kaluga-1.
- `Related Documents`_: Gives links to related documentation.


Getting Started


This secti"
"on describes how to get started with the ESP32-S2-Kaluga-1. It begins with a few introductory sections about the ESP32-S2-Kaluga-1, then Section `Start Application Development`_ provides instructions on how to do the initial hardware setup and then how to flash firmware onto the ESP32-S2-Kaluga-1.


Overview


The ESP32-S2-Kaluga-1 main board is the heart of the kit. It integrates the ESP32-S2-WROVER module and all the connectors for extension boards. This board is the key tool in prototyping hu"
"man-computer interaction interfaces.

The ESP32-S2-Kaluga-1 board has connectors for boards with:

- Extension header (ESP-LyraT-8311A, ESP-LyraP-LCD32)
- Camera header (ESP-LyraP-CAM)
- Touch FPC connector (ESP-LyraP-TouchA)
- LCD FPC connector (no official extension boards yet)
- I2C FPC connector (no official extension boards yet)

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32-s2-kaluga-1-v1.2-3d.png
    :align: center
    :width: 2631px
    :height: 1966px
    :scale: 25%"
"
    :alt: ESP32-S2-Kaluga-1
    :figclass: align-center

    ESP32-S2-Kaluga-1 (click to enlarge)

All the four extension boards are specially desgined to support the following features:


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp32-s2-kaluga-1-v1.2-layout-front.png
    :align: center
    :width: 934px
    :height: 645px
    :scale: 70%
    :alt: ESP32-S2-Kaluga-1 - front
    :figclass: align-center

    ESP32-S2-Kaluga-1 - front (click to enlar"
"ge)


The description of components starts from the ESP32-S2 module on the left side and then goes clockwise.

**Reserved** means that the functionality is available, but the current version of the kit does not use it.


.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Module integrating the ESP32-S2 chip that provides Wi-Fi connectivity, data processing power, and flexible data storage.
     - (Reserved) Connect to a 4.3"" LCD extension board using the FPC cable.
  "
"   - (Reserved) Connection for Espressif's download device (ESP-Prog) to flash ESP32-S2 system.
     - Switch to ON to enable connection between ESP32-S2 and FT2232; JTAG debugging will then be possible using USB-UART/JTAG Port. See also :doc:`../../api-guides/jtag-debugging/index`.
     - Some GPIO pins of the ESP32-S2-WROVER module are broken out to this header, see labels on the board.
     - FT2232 adapter board allowing for communication over USB port using UART/JTAG protocols.
     - Mount"
" a camera extension board here (e.g., ESP-LyraP-CAM).
     - Mount the extension boards having such connectors here.
     - Press this button to restart the system.
     - Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - Communication interface (UART or JTAG) between a PC and the ESP32-S2 module.
     - Power supply for the board.
     - Connect an external battery to the 2-pin battery connector.
     - Tu"
"rns on when the USB or an external power supply is connected to the board.
     - Switch to ON to power the system.
     - To have access to the RGB LED, place a jumper onto the pins.
     - Programmable RGB LED and controlled by GPIO45. Before using it, you need to put RGB Jumper ON.
     - Regulator converts 5 V to 3.3 V.
     - (Reserved) Connect to other I2C extension boards using the FPC cable.
     - Some GPIO pins of the ESP32-S2-WROVER module are broken out to this header, see labels on "
"the board.
     - Connect the ESP-LyraP-TouchA extension board using the FPC cable.
     - In OFF position, GPIO1 to GPIO14 are used for connection to touch sensors; switch to ON if you want to use them for other purposes.
     - Connect a 3.2"" LCD extension board (e.g., ESP-LyraP-LCD32) using the FPC cable.


Start Application Development


Before powering up your ESP32-S2-Kaluga-1, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-S2-K"
"aluga-1
- Two USB 2.0 cables (Standard-A to Micro-B)

  - For power supply
  - For UART/JTAG communication

- Computer running Windows, Linux, or macOS
- Any extension boards of your choice


Hardware Setup



.. _user-guide-esp32-s2-kaluga-1-kit-v1.2-software-setup:

Software Setup


Please proceed to :doc:`../../get-started/index`, where Section :ref:`get-started-step-by-step` will quickly help you set up the development environment.

The programming guide and application examples for your ESP"
"32-S2-Kaluga-1 kit can be found in `esp-dev-kits `_ repository on GitHub.


Contents and Packaging


Retail Orders


If you order one or several samples of the kit, each ESP32-S2-Kaluga-1 development kit comes in an individual package containing:

- Main Board
    - ESP32-S2-Kaluga-1
- Extension Boards:
    - ESP-LyraT-8311A
    - ESP-LyraP-CAM
    - ESP-LyraP-TouchA
    - ESP-LyraP-LCD32
- Connectors
    - 20-pin FPC cable (to connect ESP32-S2-Kaluga-1 to ESP-LyraP-TouchA)
- Fasteners
    - Mou"
"nting bolts (x8)
    - Screws (x4)
    - Nuts (x4)

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


A block diagram below shows the components of the ESP32-S2-Kaluga-1 and their interconnections.

.. figure:: https://dl.espressif.com/dl/schematic"
"s/pictures/esp32-s2-kaluga-1-v1.2-block-diagram.png
    :align: center
    :alt: ESP32-S2-Kaluga-1 block diagram
    :figclass: align-center

    ESP32-S2-Kaluga-1 block diagram


Power Supply Options


There are four ways to provide power to the board:

- Micro USB port, default power supply
- External battery via the 2-pin battery connector
- 5V and GND header pins
- 3V3 and GND header pins


.. _user-guide-esp32-s2-kaluga-1-kit-v1.2-ext-board-compatibility:

Compatibility of Extension Boards
"
"

If you want to use more than one extension board at the same time, please check the table given below.

.. list-table::
   :widths: 20 10 30 40
   :header-rows: 1
     - HW Conflict
     - Limitations
     - Solution
     - I2S Controller, IO46
     - ESP32-S2 has only one I2S interface. But both extension boards require connection via the ESP32-S2's I2S interface (ESP-LyraT-8311A in Standard mode, ESP-LyraP-CAM in Camera mode). If IO46 is used by both extension boards at the same time, ESP-Ly"
"raP-CAM experiences interferences when used.
     - No ready solution for now.
     - IO11, IO6
     - Touch actions cannot be triggered because of the multiplexed pin IO11. ESP-LyraP-LCD32 is also affected because its BK (BLCT) pin is connected to pin IO6.
     - Do not initialize IO11 (NETWORK) and IO6 (PHOTO) for your ESP-LyraP-TouchA.
     - IO6
     - The two extension boards can be used at the same time. However, since the BK (BLCT) pin of ESP32-S2-Kaluga-1 is connected to IO6, ESP-LyraT-8"
"311A's pin BT_ADC cannot be used and the board's six buttons will not be available.
     - There is a solution that will allow you to use ESP-LyraT-8311A's pin BT_ADC, but will stop you from controlling the display background brightness with software: on your ESP-LyraP-LCD32 board, remove R39, change R41 to 100 Ohm, switch BLCT_L to on.
     - Pin BT_ADC on ESP-LyraT-8311A
     - The two extension boards can be used at the same time. However, ESP-LyraP-TouchA cannot be triggered if ESP-LyraT-831"
"1A's pin BT_ADC is used to initialize the board's six buttons.
     - If you plan to use ESP-LyraT-8311A's pin BT_ADC, do not initialize pin IO6 (PHOTO) for your ESP-LyraP-TouchA.
     - IO1, IO2, IO3
     - Cannot be used simultaneously because of the mentioned multiplexed pins.
     - For ESP-LyraP-TouchA, do not initialize IO1 (VOL_UP), IO2 (PLAY), and IO3 (VOL_DOWN).
     - IO1, IO2, IO3, IO6, IO11
     - Conflicts on the mentioned multiplexed pins.
     - **Solution 1**: For ESP-LyraP-Touch"
"A, do not initialize IO1 (VOL_UP), IO2 (PLAY), IO3 (VOL_DOWN), IO6 (PHOTO) and IO11 (NETWORK). **Solution 2**: It will allow you to initialize IO6 (PHOTO) properly, but will stop you from controlling the background brightness with software. On your ESP-LyraP-LCD32, remove R39, change R41 to 100 Ohm, switch BLCT_L to on.
     - IO6, IO11
     - IO11 is multiplexed; IO6 is also multiplexed stopping you from using ESP-LyraT-8311A's pin BT_ADC that is needed to initialize the board's six buttons.
  "
"   - **Solution 1**: For ESP-LyraP-TouchA, do not initialize IO6 (PHOTO) and IO11 (NETWORK). Please note that the six buttons on ESP-LyraT-8311A still cannot be used. **Solution 2**: On your ESP-LyraP-LCD32, remove R39, change R41 to 100 Ohm, switch BLCT_L to on. For your ESP-LyraP-TouchA, do not initialize IO11 (NETWORK). If you want to use the six buttons on your ESP-LyraT-8311A, also do not initialize IO6 (PHOTO).

Also, all extension boards and the :ref:`JTAG interface ` share the same pins "
"IO39, IO40, IO41 and IO42. For this reason, the following may disturb the JTAG operation:


Known Issues


.. list-table::
   :widths: 22 24 32 22
   :header-rows: 1
     - Description
     - Reason for Failure
     - Solution
     - Flashing firmware might be impossible with the extension board connected to the main board.
     - Incorrect timing sequence is fed to strapping pins IO45 and IO46 when the board is powered on. It stops the board from booting successfully.
     - While flashing the "
"main board, keep the extension board disconnected.
     - Rebooting the board by pressing Reset might not lead to desired results.
     - Incorrect timing sequence is fed to strapping pins IO45 and IO46 when the board is powered on. It stops the board from booting successfully.
     - No ready solution for v1.2. This bug is fixed in ESP32-S2-Kaluga-1 V1.3.
     - Flashing firmware might be impossible with the extension board connected to the main board.
     - Incorrect timing sequence is fed to"
" strapping pin IO46 when the board is powered on. It stops the board from booting successfully.
     - While flashing the main board, keep the extension board disconnected.
     - Rebooting the board by pressing Reset might not lead to desired results.
     - Incorrect timing sequence is fed to strapping pin IO46 when the board is powered on. It stops the board from booting successfully.
     - No ready solution for v1.2. This bug is fixed in ESP32-S2-Kaluga-1 V1.3.


Hardware Revision Details

"
"
No previous versions available.


Related Documents


.. toctree::
    :hidden:

    user-guide-esp-lyrap-cam-v1.0
    user-guide-esp-lyrap-lcd32-v1.1
    user-guide-esp-lyrap-toucha-v1.1
    user-guide-esp-lyrat-8311a_v1.2

- `ESP32-S2-WROVER Datasheet `_ (PDF)
- `ESP Product Selector `_
- :doc:`../../api-guides/jtag-debugging/index`

- `ESP32-S2-Kaluga-1 Schematic `_ (PDF)
- `ESP32-S2-Kaluga-1 PCB Layout `_ (PDF)
- `ESP32-S2-Kaluga-1 Pin Mapping `_ (Excel)

For other design documentation for "
"the board, please contact us at sales@espressif.com.
"
"


This user guide provides information on the ESP-LyraP-LCD32 extension board.

This extension board cannot be bought separately and is usually sold together with other Espressif development boards (e.g., ESP32-S2-Kaluga-1), which will be referred to as *main boards* below.

Currently, ESP-LyraP-LCD32 v1.1 is sold as part of the :doc:`user-guide-esp32-s2-kaluga-1-kit-v1.2`.

The ESP-LyraP-LCD32 extends the functionality of your main board by adding an LCD graphic display.

.. figure:: https://d"
"l.espressif.com/dl/schematics/pictures/esp-lyrap-lcd32-v1.1-3d.png
    :align: center
    :width: 2243px
    :height: 1534px
    :scale: 30%
    :alt: ESP-LyraP-LCD32
    :figclass: align-center

    ESP-LyraP-LCD32 (click to enlarge)

The document consists of the following major sections:

- `Overview`_: Provides an overview and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information about the ESP-LyraP-LCD32's hardware.
- `Hardware Revis"
"ion Details`_: Covers revision history, known issues, and links to user guides for previous versions of the ESP-LyraP-LCD32.
- `Related Documents`_: Gives links to related documentation.


Overview


This extension board adds a 3.2"" LCD graphic display with the resolution of 320x240. This display is connected to ESP32-S2 over the SPI bus.


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-lcd32-v1.1-layout-front.png
    :align: center
    :width: "
"934px
    :height: 600px
    :scale: 70%
    :alt: ESP-LyraP-LCD32 - front
    :figclass: align-center

    ESP-LyraP-LCD32 - front (click to enlarge)


In the description of components below, **Reserved** means that the functionality is available, but the current version of the kit does not use it.


.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Male Extension Header for mounting onto a female Extension Header
     - This version has a 3.2"" 320x240 SPI LCD displ"
"ay module; the display driver/controller is Sitronix ST7789V
     - No support for touch screens, keep the switches to OFF to make the pins available for other uses
     - (Reserved) Connect to main board's 3.2"" LCD FPC connector
     - Switch to ON to set Reset/Backlight_control/CS to default high or low; switch to OFF to make the pins available for other uses


Start Application Development


Before powering up your ESP-LyraP-LCD32, please make sure that it is in good condition with no obvious"
" signs of damage.


Required Hardware


- Board with a female Extension Header (e.g., ESP32-S2-Kaluga-1, ESP-LyraT-8311A)
- ESP-LyraP-LCD32 extension board
- Four mounting bolts (for stable mounting)
- Computer running Windows, Linux, or macOS


Hardware Setup


To mount your ESP-LyraP-LCD32 onto the board with a female Extension Header:


Software Setup


See Section :ref:`user-guide-esp32-s2-kaluga-1-kit-v1.2-software-setup` of the ESP32-S2-Kaluga-1 kit user guide.


Hardware Reference


Block"
" Diagram


A block diagram below shows the components of the ESP-LyraP-LCD32 and their interconnections.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-lcd32-v1.1-block-diagram.png
    :align: center
    :alt: ESP-LyraP-LCD32 block diagram
    :figclass: align-center

    ESP-LyraP-LCD32 block diagram


Hardware Revision Details


No previous versions available.


Related Documents


- `ESP-LyraP-LCD32 Schematic `_ (PDF)
- `ESP-LyraP-LCD32 PCB Layout `_ (PDF)

For other d"
"esign documentation for the board, please contact us at sales@espressif.com.
"
"


This user guide provides information on the ESP-LyraP-CAM extension board.

This extension board cannot be bought separately and is usually sold together with other Espressif development boards (e.g., ESP32-S2-Kaluga-1), which will be referred to as *main boards* below.

Currently, ESP-LyraP-CAM v1.1 is sold as part of the :doc:`user-guide-esp32-s2-kaluga-1-kit`.

The ESP-LyraP-CAM extends the functionality of your main board by adding a camera.

.. Image of v1.0 is used as there are no visua"
"l changes

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-cam-v1.0-3d.png
    :align: center
    :alt: ESP-LyraP-CAM
    :figclass: align-center

    ESP-LyraP-CAM

The document consists of the following major sections:

- `Overview`_: Provides an overview and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information about the ESP-LyraP-CAM's hardware.
- `Hardware Revision Details`_: Covers revision history, known issu"
"es, and links to user guides for previous versions of the ESP-LyraP-CAM.
- `Related Documents`_: Gives links to related documentation.


Overview


This extension board adds a camera to your main board.


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-cam-v1.1-layout-front.png
    :align: center
    :alt: ESP-LyraP-CAM - front and back
    :figclass: align-center

    ESP-LyraP-CAM - front and back

.. list-table::
   :widths: 30 70
   :header-r"
"ows: 1
     - Description
     - Mount onto main board's Camera Header
     - Red LED is on if the power supply voltage is correct
     - Supports OV2640 and OV3660 camera modules; this extension board is supplied with an OV2640 camera module
     - LDO Regulators converting 3.3 V to 2.8 V and 1.5 V


Start Application Development


Before powering up your ESP-LyraP-CAM, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- Board with a female Cam"
"era Header (e.g., ESP32-S2-Kaluga-1)
- ESP-LyraP-CAM extension board
- Computer running Windows, Linux, or macOS


Hardware Setup


Insert the ESP-LyraP-CAM extension board into your board's female Camera Header.


Software Setup


See Section :ref:`user-guide-esp32-s2-kaluga-1-kit-software-setup` of the ESP32-S2-Kaluga-1 kit user guide.


Hardware Reference


Block Diagram


A block diagram below shows the components of the ESP-LyraP-CAM and their interconnections.

.. Image of v1.0 is used as "
"there are no visual changes

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-cam-v1.0-block-diagram.png
    :align: center
    :alt: ESP-LyraP-CAM block diagram
    :figclass: align-center

    ESP-LyraP-CAM block diagram


Hardware Revision Details


ESP-LyraP-CAM v1.1



ESP-LyraP-CAM v1.0


:doc:`Initial release `


Related Documents


- `ESP-LyraP-CAM Schematic `_ (PDF)
- `ESP-LyraP-CAM PCB Layout `_ (PDF)

For other design documentation for the board, please contact us"
" at sales@espressif.com.
"
"


This user guide provides information on the ESP-LyraP-CAM extension board.

This extension board cannot be bought separately and is usually sold together with other Espressif development boards (e.g., ESP32-S2-Kaluga-1), which will be referred to as *main boards* below.

Currently, ESP-LyraP-CAM v1.0 is sold as part of the :doc:`user-guide-esp32-s2-kaluga-1-kit-v1.2`.

The ESP-LyraP-CAM extends the functionality of your main board by adding a camera.

.. figure:: https://dl.espressif.com/dl/s"
"chematics/pictures/esp-lyrap-cam-v1.0-3d.png
    :align: center
    :alt: ESP-LyraP-CAM
    :figclass: align-center

    ESP-LyraP-CAM

The document consists of the following major sections:

- `Overview`_: Provides an overview and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information about the ESP-LyraP-CAM's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions o"
"f the ESP-LyraP-CAM.
- `Related Documents`_: Gives links to related documentation.


Overview


This extension board adds a camera to your main board.


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-cam-v1.0-layout-front.png
    :align: center
    :alt: ESP-LyraP-CAM - front and back
    :figclass: align-center

    ESP-LyraP-CAM - front and back

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Mount onto main boa"
"rd's Camera Header
     - Red LED is on if the power supply voltage is applied
     - Supports OV2640 and OV3660 camera modules; this extension board is supplied with an OV2640 camera module
     - LDO Regulators converting 3.3 V to 2.8 V and 1.5 V


Start Application Development


Before powering up your ESP-LyraP-CAM, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- Board with a female Camera Header (e.g., ESP32-S2-Kaluga-1)
- ESP-LyraP-CAM"
" extension board
- Computer running Windows, Linux, or macOS


Hardware Setup


Insert the ESP-LyraP-CAM extension board into your board's female Camera Header.


Software Setup


See Section :ref:`user-guide-esp32-s2-kaluga-1-kit-v1.2-software-setup` of the ESP32-S2-Kaluga-1 kit user guide.


Hardware Reference


Block Diagram


A block diagram below shows the components of the ESP-LyraP-CAM and their interconnections.

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-cam-v"
"1.0-block-diagram.png
    :align: center
    :alt: ESP-LyraP-CAM block diagram
    :figclass: align-center

    ESP-LyraP-CAM block diagram


Hardware Revision Details


No previous versions available.


Related Documents


- `ESP-LyraP-CAM Schematic `_ (PDF)
- `ESP-LyraP-CAM PCB Layout `_ (PDF)

For other design documentation for the board, please contact us at sales@espressif.com.
"
"


This user guide provides information on the ESP-LyraP-LCD32 extension board.

This extension board cannot be bought separately and is usually sold together with other Espressif development boards (e.g., ESP32-S2-Kaluga-1), which will be referred to as *main boards* below.

Currently, ESP-LyraP-LCD32 v1.2 is sold as part of the :doc:`user-guide-esp32-s2-kaluga-1-kit`.

The ESP-LyraP-LCD32 extends the functionality of your main board by adding an LCD graphic display.

.. Image of v1.1 is used a"
"s there are no visual changes

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-lcd32-v1.1-3d.png
    :align: center
    :width: 2243px
    :height: 1534px
    :scale: 30%
    :alt: ESP-LyraP-LCD32
    :figclass: align-center

    ESP-LyraP-LCD32 (click to enlarge)

The document consists of the following major sections:

- `Overview`_: Provides an overview and hardware/software setup instructions to get started.
- `Hardware reference`_: Provides more detailed information abo"
"ut the ESP-LyraP-LCD32's hardware.
- `Hardware Revision Details`_: Covers revision history, known issues, and links to user guides for previous versions of the ESP-LyraP-LCD32.
- `Related Documents`_: Gives links to related documentation.


Overview


This extension board adds a 3.2"" LCD graphic display with the resolution of 320x240. This display is connected to ESP32-S2 over the SPI bus.


Description of Components


.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-lcd32-v"
"1.2-layout-front.png
    :align: center
    :width: 934px
    :height: 489px
    :scale: 70%
    :alt: ESP-LyraP-LCD32 - front
    :figclass: align-center

    ESP-LyraP-LCD32 - front (click to enlarge)

.. figure:: https://dl.espressif.com/dl/schematics/pictures/esp-lyrap-lcd32-v1.2-layout-back.png
    :align: center
    :width: 934px
    :height: 600px
    :scale: 70%
    :alt: ESP-LyraP-LCD32 - back
    :figclass: align-center

    ESP-LyraP-LCD32 - back (click to enlarge)


In the descriptio"
"n of components below, **Reserved** means that the functionality is available, but the current version of the kit does not use it.


.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - Male Extension Header for mounting onto a female Extension Header
     - This version has a 3.2"" 320x240 SPI LCD display module; the display driver/controller is either Sitronix ST7789V or Ilitek ILI9341
     - No support for touch screens, keep the switches to OFF to make the pins avail"
"able for other uses
     - (Reserved) Connect to main board's 3.2"" LCD FPC connector
     - Switch to ON to set Reset/Backlight_control/CS to default high or low; switch to OFF to make the pins available for other uses


Start Application Development


Before powering up your ESP-LyraP-LCD32, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- Board with a female Extension Header (e.g., ESP32-S2-Kaluga-1, ESP-LyraT-8311A)
- ESP-LyraP-LCD32 exten"
"sion board
- Four mounting bolts (for stable mounting)
- Computer running Windows, Linux, or macOS


Hardware Setup


To mount your ESP-LyraP-LCD32 onto the board with a female Extension Header:


Software Setup


See Section :ref:`user-guide-esp32-s2-kaluga-1-kit-software-setup` of the ESP32-S2-Kaluga-1 kit user guide.


Hardware Reference


Block Diagram


A block diagram below shows the components of the ESP-LyraP-LCD32 and their interconnections.

.. figure:: https://dl.espressif.com/dl/sche"
"matics/pictures/esp-lyrap-lcd32-v1.2-block-diagram.png
    :align: center
    :alt: ESP-LyraP-LCD32 block diagram
    :figclass: align-center

    ESP-LyraP-LCD32 block diagram


Hardware Revision Details


ESP-LyraP-LCD32 v1.2



ESP-LyraP-LCD32 v1.1


:doc:`Initial release `


Related Documents


- `ESP-LyraP-LCD32 Schematic `_ (PDF)
- `ESP-LyraP-LCD32 PCB Layout `_ (PDF)

For other design documentation for the board, please contact us at sales@espressif.com.
"
"


This user guide will help you get started with ESP32-S2-DevKitC-1 and will also provide more in-depth information.

ESP32-S2-DevKitC-1 is an entry-level development board. This board integrates complete Wi-Fi functions. Most of the I/O pins are broken out to the pin headers on both sides for easy interfacing. Developers can either connect peripherals with jumper wires or mount ESP32-S2-DevKitC-1 on a breadboard.

.. figure:: ../../../_static/esp32-s2-devkitc-1-v1-isometric.png
    :align: cen"
"ter
    :alt: ESP32-S2-DevKitC-1 with the ESP32-S2-SOLO Module
    :figclass: align-center

    ESP32-S2-DevKitC-1 with the ESP32-S2-SOLO Module

The document consists of the following major sections:

- `Getting Started`_: Overview of ESP32-S2-DevKitC-1 and hardware/software setup instructions to get started.
- `Hardware Reference`_: More detailed information about the ESP32-S2-DevKitC-1's hardware.
- `Hardware Revision Details`_: Revision history, known issues, and links to user guides for pre"
"vious versions (if any) of ESP32-S2-DevKitC-1.
- `Related Documents`_: Links to related documentation.


Getting Started


This section provides a brief introduction of ESP32-S2-DevKitC-1, instructions on how to do the initial hardware setup and how to flash firmware onto it.


Description of Components


.. _user-guide-s2-devkitc-1-v1-board-front:

.. figure:: ../../../_static/esp32-s2-devkitc-1-v1-annotated-photo.png
    :align: center
    :alt: ESP32-S2-DevKitC-1 - front
    :figclass: align-"
"center

    ESP32-S2-DevKitC-1 - front

The key components of the board are described in a clockwise direction.

.. list-table::
   :widths: 30 70
   :header-rows: 1
     - Description
     - ESP32-S2-SOLO series modules with an on-board PCB antenna or a connector for an external antenna. This series of modules have multiple options for flash and PSRAM size. For more information, please refer to :ref:`user-guide-s2-devkitc-1-v1-ordering-info`.
     - Turns on when the USB power is connected to t"
"he board.
     - Single USB-to-UART bridge chip provides transfer rates up to 3 Mbps.
     - All available GPIO pins (except for the SPI bus for flash) are broken out to the pin headers on the board. For details, please see :ref:`user-guide-s2-devkitc-1-v1-header-blocks`.
     - ESP32-S2 full-speed USB OTG interface, compliant with the USB 1.1 specifications. The interface is used for power supply to the board, for flashing applications to the chip, and for communication with the chip using USB "
"1.1 protocols.
     - Press this button to restart the system.
     - Download button. Holding down **Boot** and then pressing **Reset** initiates Firmware Download mode for downloading firmware through the serial port.
     - A Micro-USB port used for power supply to the board, for flashing applications to the chip, as well as the communication with the chip via the on-board USB-to-UART bridge.
     - Addressable RGB LED, driven by GPIO18.
     - Power regulator that converts a 5 V supply into "
"a 3.3 V output.


Start Application Development


Before powering up your ESP32-S2-DevKitC-1, please make sure that it is in good condition with no obvious signs of damage.


Required Hardware


- ESP32-S2-DevKitC-1
- USB 2.0 cable (Standard-A to Micro-B)
- Computer running Windows, Linux, or macOS

.. note::

  Be sure to use an appropriate USB cable. Some cables are for charging only and do not provide the needed data lines nor work for programming the boards.


Hardware Setup


Connect the bo"
"ard with the computer using **USB-to-UART Port** or **ESP32-S2 USB Port**. In subsequent steps, **USB-to-UART Port** will be used by default.


Software Setup


Please proceed to `ESP-IDF Get Started `_, where Section `Installation Step by Step `_ will quickly help you set up the development environment and then flash an application example into your ESP32-S2-DevKitC-1.


Contents and Packaging


.. _user-guide-s2-devkitc-1-v1-ordering-info:

Ordering Information


The development board has a va"
"riety of variants to choose from, as shown in the table below.

.. list-table::
   :header-rows: 1
   :widths: 41 24 9 8 18
     - On-board Module [#]_
     - Flash
     - PSRAM
     - Antenna
     - ESP32-S2-SOLO-2

       (Recommended)
     - 8 MB
     - 2 MB
     - PCB on-board antenna
     - ESP32-S2-SOLO-2U

       (Recommended)
     - 8 MB
     - 2 MB
     - External antenna connector
     - ESP32-S2-SOLO
     - 4 MB
     - ---
     - PCB on-board antenna
     - ESP32-S2-SOLO-U
     - 4 MB"
"
     - ---
     - External antenna connector
     - ESP32-S2-SOLO
     - 4 MB
     - 2 MB
     - PCB on-board antenna
     - ESP32-S2-SOLO-U
     - 4 MB
     - 2 MB
     - External antenna connector

.. [#] The ESP32-S2-SOLO-2 and ESP32-S2-SOLO-2U modules use chip revision v1.0, and the rest use chip revision v0.0. For more information about chip revisions, please refer to `ESP32-S2 Series SoC Errata`_.


Retail Orders


If you order a few samples, each ESP32-S2-DevKitC-1 comes in an individual"
" package in either antistatic bag or any packaging depending on your retailer.

For retail orders, please go to https://www.espressif.com/en/contact-us/get-samples.


Wholesale Orders


If you order in bulk, the boards come in large cardboard boxes.

For wholesale orders, please go to https://www.espressif.com/en/contact-us/sales-questions.


Hardware Reference


Block Diagram


The block diagram below shows the components of ESP32-S2-DevKitC-1 and their interconnections.

.. figure:: ../../../_"
"static/esp32-s2-devkitc-1-v1-block-diags.png
    :align: center
    :scale: 70%
    :alt: ESP32-S2-DevKitC-1 (click to enlarge)
    :figclass: align-center

    ESP32-S2-DevKitC-1 (click to enlarge)


Power Supply Options


There are three mutually exclusive ways to provide power to the board:

- USB-to-UART Port and ESP32-S2 USB Port (either one or both), default power supply (recommended)
- 5V and G (GND) pins
- 3V3 and G (GND) pins


.. _user-guide-s2-devkitc-1-v1-header-blocks:

Header Block"
"


The two tables below provide the **Name** and **Function** of the pin headers on both sides of the board (J1 and J3). The pin header names are shown in :ref:`user-guide-s2-devkitc-1-v1-board-front`. The numbering is the same as in the `ESP32-S2-DevKitC-1 Schematic`_ (PDF).


J1
^^^

===      
No.  Name       Type [#]_    Function
===      
1    3V3         P           3.3 V power supply
2    3V3         P           3.3 V power supply
3    RST         I           CHIP_PU
4    4           I/O/T"
"       RTC_GPIO4, GPIO4, TOUCH4, ADC1_CH3
5    5           I/O/T       RTC_GPIO5, GPIO5, TOUCH5, ADC1_CH4
6    6           I/O/T       RTC_GPIO6, GPIO6, TOUCH6, ADC1_CH5
7    7           I/O/T       RTC_GPIO7, GPIO7, TOUCH7, ADC1_CH6
8    15          I/O/T       RTC_GPIO15, GPIO15, U0RTS, ADC2_CH4, XTAL_32K_P
9    16          I/O/T       RTC_GPIO16, GPIO16, U0CTS, ADC2_CH5, XTAL_32K_N
10   17          I/O/T       RTC_GPIO17, GPIO17, U1TXD, ADC2_CH6, DAC_1
11   18 [#]_     I/O/T       RTC_GPIO18,"
" GPIO18, U1RXD, ADC2_CH7, DAC_2, CLK_OUT3, RGB LED
12   8           I/O/T       RTC_GPIO8, GPIO8, TOUCH8, ADC1_CH7
13   3           I/O/T       RTC_GPIO3, GPIO3, TOUCH3, ADC1_CH2
14   46          I           GPIO46
15   9           I/O/T       RTC_GPIO9, GPIO9, TOUCH9, ADC1_CH8, FSPIHD
16   10          I/O/T       RTC_GPIO10, GPIO10, TOUCH10, ADC1_CH9, FSPICS0, FSPIIO4
17   11          I/O/T       RTC_GPIO11, GPIO11, TOUCH11, ADC2_CH0, FSPID, FSPIIO5
18   12          I/O/T       RTC_GPIO12, GPIO"
"12, TOUCH12, ADC2_CH1, FSPICLK, FSPIIO6
19   13          I/O/T       RTC_GPIO13, GPIO13, TOUCH13, ADC2_CH2, FSPIQ, FSPIIO7
20   14          I/O/T       RTC_GPIO14, GPIO14, TOUCH14, ADC2_CH3, FSPIWP, FSPIDQS
21   5V          P           5 V power supply
22   G           G           Ground
===      


J3
^^^

===       
No.  Name  Type    Function
===       
1    G     G       Ground
2    TX    I/O/T   U0TXD, GPIO43, CLK_OUT1
3    RX    I/O/T   U0RXD, GPIO44, CLK_OUT2
4    1     I/O/T   RTC_GPIO1,"
" GPIO1, TOUCH1, ADC1_CH0
5    2     I/O/T   RTC_GPIO2, GPIO2, TOUCH2, ADC1_CH1
6    42    I/O/T   MTMS, GPIO42
7    41    I/O/T   MTDI, GPIO41, CLK_OUT1
8    40    I/O/T   MTDO, GPIO40, CLK_OUT2
9    39    I/O/T   MTCK, GPIO39, CLK_OUT3
10   38    I/O/T   GPIO38, FSPIWP
11   37    I/O/T   SPIDQS, GPIO37, FSPIQ
12   36    I/O/T   SPIIO7, GPIO36, FSPICLK
13   35    I/O/T   SPIIO6, GPIO35, FSPID
14   0     I/O/T   RTC_GPIO0, GPIO0
15   45    I/O/T   GPIO45
16   34    I/O/T   SPIIO5, GPIO34, FSPICS0"
"
17   33    I/O/T   SPIIO4, GPIO33, FSPIHD
18   21    I/O/T   RTC_GPIO21, GPIO21
19   20    I/O/T   RTC_GPIO20, GPIO20, U1CTS, ADC2_CH9, CLK_OUT1, USB_D+
20   19    I/O/T   RTC_GPIO19, GPIO19, U1RTS, ADC2_CH8, CLK_OUT2, USB_D-
21   G     G       Ground
22   G     G       Ground
===       

.. [#] P: Power supply; I: Input; O: Output; T: High impedance.
.. [#] GPIO18 is not pulled up on boards with an ESP32-S2-SOLO-2 or ESP32-S2-SOLO-2U module.


Pin Layout


.. figure:: ../../../_static/esp32-s2"
"-devkitc-1-v1-pinout.png
    :align: center
    :scale: 45%
    :alt: ESP32-S2-DevKitC-1 (click to enlarge)
    :figclass: align-center

    ESP32-S2-DevKitC-1 Pin Layout (click to enlarge)


Hardware Revision Details


This is the first revision of this board released.


Related Documents


For further design documentation for the board, please contact us at `sales@espressif.com `_.

.. _NRND: https://www.espressif.com/en/products/longevity-commitment?id=nrnd
.. _ESP32-S2 Series Chip Revision v"
"1.0 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-s2-v1.0_datasheet_en.pdf
.. _ESP32-S2 Series SoC Errata: https://espressif.com/sites/default/files/documentation/esp32-s2_errata_en.pdf
.. _ESP32-S2-DevKitC-1 Schematic: https://dl.espressif.com/dl/schematics/esp-idf/SCH_ESP32-S2-DEVKITC-1_V1_20220817.pdf
"
